{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\n", "theoremStatement": "lemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p])", "fileCreated": "623ad58 20231116", "theoremCreated": "6854e2a 20231120", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 72, "tokenPositionInFile": 2703, "theoremPositionInFile": 4}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 11, "proofLengthTokens": 615}}
{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p]) := by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\n", "theoremStatement": "lemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082]\n    {\u03bc\u2081 : Measure \u03a9\u2081} {\u03bc\u2082 : Measure \u03a9\u2082} {\u03bc'\u2081 : Measure \u03a9'\u2081} {\u03bc'\u2082 : Measure \u03a9'\u2082}\n    {X\u2081 : \u03a9\u2081 \u2192 G} {X\u2082 : \u03a9\u2082 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X'\u2081 \u03bc\u2081 \u03bc'\u2081) (h\u2082 : IdentDistrib X\u2082 X'\u2082 \u03bc\u2082 \u03bc'\u2082) :\n    \u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p] = \u03c4[X'\u2081 ; \u03bc'\u2081 # X'\u2082 ; \u03bc'\u2082 | p]", "fileCreated": "623ad58 20231116", "theoremCreated": "828bcd7 20231120", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 88, "tokenPositionInFile": 3629, "theoremPositionInFile": 5}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h\u2081,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h\u2082,\n      h\u2081.rdist_eq h\u2082]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 5, "proofLengthTokens": 164}}
{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p]) := by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082]\n    {\u03bc\u2081 : Measure \u03a9\u2081} {\u03bc\u2082 : Measure \u03a9\u2082} {\u03bc'\u2081 : Measure \u03a9'\u2081} {\u03bc'\u2082 : Measure \u03a9'\u2082}\n    {X\u2081 : \u03a9\u2081 \u2192 G} {X\u2082 : \u03a9\u2082 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X'\u2081 \u03bc\u2081 \u03bc'\u2081) (h\u2082 : IdentDistrib X\u2082 X'\u2082 \u03bc\u2082 \u03bc'\u2082) :\n    \u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p] = \u03c4[X'\u2081 ; \u03bc'\u2081 # X'\u2082 ; \u03bc'\u2082 | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h\u2081,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h\u2082,\n      h\u2081.rdist_eq h\u2082]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {\u03a9 : Type*} [MeasureSpace \u03a9] (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G) : Prop :=\n  \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\n", "theoremStatement": "lemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace \u03a9]\n    [MeasureSpace \u03a9']\n    {X\u2081 X\u2082 : \u03a9 \u2192 G} {X\u2081' X\u2082' : \u03a9' \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082') :\n    tau_minimizes p X\u2081 X\u2082 \u2194 tau_minimizes p X\u2081' X\u2082'", "fileCreated": "623ad58 20231116", "theoremCreated": "0b960b2 20231128", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 107, "tokenPositionInFile": 4793, "theoremPositionInFile": 7}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp_rw [_root_.tau_minimizes, h\u2081.tau_eq p h\u2082]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 51}}
{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p]) := by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082]\n    {\u03bc\u2081 : Measure \u03a9\u2081} {\u03bc\u2082 : Measure \u03a9\u2082} {\u03bc'\u2081 : Measure \u03a9'\u2081} {\u03bc'\u2082 : Measure \u03a9'\u2082}\n    {X\u2081 : \u03a9\u2081 \u2192 G} {X\u2082 : \u03a9\u2082 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X'\u2081 \u03bc\u2081 \u03bc'\u2081) (h\u2082 : IdentDistrib X\u2082 X'\u2082 \u03bc\u2082 \u03bc'\u2082) :\n    \u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p] = \u03c4[X'\u2081 ; \u03bc'\u2081 # X'\u2082 ; \u03bc'\u2082 | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h\u2081,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h\u2082,\n      h\u2081.rdist_eq h\u2082]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {\u03a9 : Type*} [MeasureSpace \u03a9] (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G) : Prop :=\n  \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace \u03a9]\n    [MeasureSpace \u03a9']\n    {X\u2081 X\u2082 : \u03a9 \u2192 G} {X\u2081' X\u2082' : \u03a9' \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082') :\n    tau_minimizes p X\u2081 X\u2082 \u2194 tau_minimizes p X\u2081' X\u2082' := by\n  simp_rw [_root_.tau_minimizes, h\u2081.tau_eq p h\u2082]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\n", "theoremStatement": "lemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    \u2203 (\u03bc : Measure G \u00d7 Measure G),\n    IsProbabilityMeasure \u03bc.1 \u2227 IsProbabilityMeasure \u03bc.2 \u2227\n    \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p]", "fileCreated": "623ad58 20231116", "theoremCreated": "3c88319 20231123", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 115, "tokenPositionInFile": 5142, "theoremPositionInFile": 8}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  let _i : TopologicalSpace G := (\u22a5 : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := \u27e8rfl\u27e9\n  have GG_cpt : CompactSpace (ProbabilityMeasure G \u00d7 ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G \u00d7 ProbabilityMeasure G \u2192 \u211d := -- restrict \u03c4 to the compact subspace\n    fun \u27e8\u03bc\u2081, \u03bc\u2082\u27e9 \u21a6 \u03c4[id ; \u03bc\u2081 # id ; \u03bc\u2082 | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := \u27e80\u27e9 -- Need to record this for Lean to know that proba measures exist.\n  obtain \u27e8\u03bc, _, h\u03bc\u27e9 := @IsCompact.exists_isMinOn \u211d (ProbabilityMeasure G \u00d7 ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ \u27e8default, trivial\u27e9 T T_cont.continuousOn\n  use \u27e8\u03bc.1.toMeasure, \u03bc.2.toMeasure\u27e9\n  refine \u27e8\u03bc.1.prop, \u03bc.2.prop, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 P\u03bd\u2081 P\u03bd\u2082\n  rw [isMinOn_univ_iff] at h\u03bc\n  let \u03bd : ProbabilityMeasure G \u00d7 ProbabilityMeasure G := \u27e8\u27e8\u03bd\u2081, P\u03bd\u2081\u27e9, \u03bd\u2082, P\u03bd\u2082\u27e9\n  exact h\u03bc \u03bd", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 16, "proofLengthTokens": 961}}
{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p]) := by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082]\n    {\u03bc\u2081 : Measure \u03a9\u2081} {\u03bc\u2082 : Measure \u03a9\u2082} {\u03bc'\u2081 : Measure \u03a9'\u2081} {\u03bc'\u2082 : Measure \u03a9'\u2082}\n    {X\u2081 : \u03a9\u2081 \u2192 G} {X\u2082 : \u03a9\u2082 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X'\u2081 \u03bc\u2081 \u03bc'\u2081) (h\u2082 : IdentDistrib X\u2082 X'\u2082 \u03bc\u2082 \u03bc'\u2082) :\n    \u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p] = \u03c4[X'\u2081 ; \u03bc'\u2081 # X'\u2082 ; \u03bc'\u2082 | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h\u2081,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h\u2082,\n      h\u2081.rdist_eq h\u2082]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {\u03a9 : Type*} [MeasureSpace \u03a9] (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G) : Prop :=\n  \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace \u03a9]\n    [MeasureSpace \u03a9']\n    {X\u2081 X\u2082 : \u03a9 \u2192 G} {X\u2081' X\u2082' : \u03a9' \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082') :\n    tau_minimizes p X\u2081 X\u2082 \u2194 tau_minimizes p X\u2081' X\u2082' := by\n  simp_rw [_root_.tau_minimizes, h\u2081.tau_eq p h\u2082]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    \u2203 (\u03bc : Measure G \u00d7 Measure G),\n    IsProbabilityMeasure \u03bc.1 \u2227 IsProbabilityMeasure \u03bc.2 \u2227\n    \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] := by\n  let _i : TopologicalSpace G := (\u22a5 : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := \u27e8rfl\u27e9\n  have GG_cpt : CompactSpace (ProbabilityMeasure G \u00d7 ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G \u00d7 ProbabilityMeasure G \u2192 \u211d := -- restrict \u03c4 to the compact subspace\n    fun \u27e8\u03bc\u2081, \u03bc\u2082\u27e9 \u21a6 \u03c4[id ; \u03bc\u2081 # id ; \u03bc\u2082 | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := \u27e80\u27e9 -- Need to record this for Lean to know that proba measures exist.\n  obtain \u27e8\u03bc, _, h\u03bc\u27e9 := @IsCompact.exists_isMinOn \u211d (ProbabilityMeasure G \u00d7 ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ \u27e8default, trivial\u27e9 T T_cont.continuousOn\n  use \u27e8\u03bc.1.toMeasure, \u03bc.2.toMeasure\u27e9\n  refine \u27e8\u03bc.1.prop, \u03bc.2.prop, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 P\u03bd\u2081 P\u03bd\u2082\n  rw [isMinOn_univ_iff] at h\u03bc\n  let \u03bd : ProbabilityMeasure G \u00d7 ProbabilityMeasure G := \u27e8\u27e8\u03bd\u2081, P\u03bd\u2081\u27e9, \u03bd\u2082, P\u03bd\u2082\u27e9\n  exact h\u03bc \u03bd\n\n/-- A pair of random variables minimizing $\u03c4$ exists. -/\n", "theoremStatement": "lemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    \u2203 (\u03a9 : Type uG) (m\u03a9 : MeasureSpace \u03a9) (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G),\n    Measurable X\u2081 \u2227 Measurable X\u2082 \u2227 IsProbabilityMeasure (\u2119 : Measure \u03a9) \u2227\n    tau_minimizes p X\u2081 X\u2082", "fileCreated": "623ad58 20231116", "theoremCreated": "3c88319 20231123", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 137, "tokenPositionInFile": 6471, "theoremPositionInFile": 9}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  let \u03bc := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure \u03bc.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure \u03bc.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (\u03bc.1.prod \u03bc.2) := by infer_instance\n  let M : MeasureSpace (G \u00d7 G) := \u27e8\u03bc.1.prod \u03bc.2\u27e9\n  refine \u27e8G \u00d7 G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n  have A : \u03c4[@Prod.fst G G # @Prod.snd G G | p] = \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 11, "proofLengthTokens": 650}}
{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p]) := by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082]\n    {\u03bc\u2081 : Measure \u03a9\u2081} {\u03bc\u2082 : Measure \u03a9\u2082} {\u03bc'\u2081 : Measure \u03a9'\u2081} {\u03bc'\u2082 : Measure \u03a9'\u2082}\n    {X\u2081 : \u03a9\u2081 \u2192 G} {X\u2082 : \u03a9\u2082 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X'\u2081 \u03bc\u2081 \u03bc'\u2081) (h\u2082 : IdentDistrib X\u2082 X'\u2082 \u03bc\u2082 \u03bc'\u2082) :\n    \u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p] = \u03c4[X'\u2081 ; \u03bc'\u2081 # X'\u2082 ; \u03bc'\u2082 | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h\u2081,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h\u2082,\n      h\u2081.rdist_eq h\u2082]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {\u03a9 : Type*} [MeasureSpace \u03a9] (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G) : Prop :=\n  \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace \u03a9]\n    [MeasureSpace \u03a9']\n    {X\u2081 X\u2082 : \u03a9 \u2192 G} {X\u2081' X\u2082' : \u03a9' \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082') :\n    tau_minimizes p X\u2081 X\u2082 \u2194 tau_minimizes p X\u2081' X\u2082' := by\n  simp_rw [_root_.tau_minimizes, h\u2081.tau_eq p h\u2082]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    \u2203 (\u03bc : Measure G \u00d7 Measure G),\n    IsProbabilityMeasure \u03bc.1 \u2227 IsProbabilityMeasure \u03bc.2 \u2227\n    \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] := by\n  let _i : TopologicalSpace G := (\u22a5 : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := \u27e8rfl\u27e9\n  have GG_cpt : CompactSpace (ProbabilityMeasure G \u00d7 ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G \u00d7 ProbabilityMeasure G \u2192 \u211d := -- restrict \u03c4 to the compact subspace\n    fun \u27e8\u03bc\u2081, \u03bc\u2082\u27e9 \u21a6 \u03c4[id ; \u03bc\u2081 # id ; \u03bc\u2082 | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := \u27e80\u27e9 -- Need to record this for Lean to know that proba measures exist.\n  obtain \u27e8\u03bc, _, h\u03bc\u27e9 := @IsCompact.exists_isMinOn \u211d (ProbabilityMeasure G \u00d7 ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ \u27e8default, trivial\u27e9 T T_cont.continuousOn\n  use \u27e8\u03bc.1.toMeasure, \u03bc.2.toMeasure\u27e9\n  refine \u27e8\u03bc.1.prop, \u03bc.2.prop, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 P\u03bd\u2081 P\u03bd\u2082\n  rw [isMinOn_univ_iff] at h\u03bc\n  let \u03bd : ProbabilityMeasure G \u00d7 ProbabilityMeasure G := \u27e8\u27e8\u03bd\u2081, P\u03bd\u2081\u27e9, \u03bd\u2082, P\u03bd\u2082\u27e9\n  exact h\u03bc \u03bd\n\n/-- A pair of random variables minimizing $\u03c4$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    \u2203 (\u03a9 : Type uG) (m\u03a9 : MeasureSpace \u03a9) (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G),\n    Measurable X\u2081 \u2227 Measurable X\u2082 \u2227 IsProbabilityMeasure (\u2119 : Measure \u03a9) \u2227\n    tau_minimizes p X\u2081 X\u2082 := by\n  let \u03bc := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure \u03bc.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure \u03bc.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (\u03bc.1.prod \u03bc.2) := by infer_instance\n  let M : MeasureSpace (G \u00d7 G) := \u27e8\u03bc.1.prod \u03bc.2\u27e9\n  refine \u27e8G \u00d7 G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n  have A : \u03c4[@Prod.fst G G # @Prod.snd G G | p] = \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n\n\nvariable [MeasureSpace \u03a9] [h\u03a9\u2081 : MeasureSpace \u03a9'\u2081] [h\u03a9\u2082 : MeasureSpace \u03a9'\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9'\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9'\u2082)]\n  {X\u2081 : \u03a9 \u2192 G} {X\u2082 : \u03a9 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n\n", "theoremStatement": "lemma is_tau_min (h : tau_minimizes p X\u2081 X\u2082) (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[X'\u2081 # X'\u2082 | p]", "fileCreated": "623ad58 20231116", "theoremCreated": "828bcd7 20231120", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 158, "tokenPositionInFile": 7617, "theoremPositionInFile": 10}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  let \u03bd\u2081 := (\u2119 : Measure \u03a9'\u2081).map X'\u2081\n  let \u03bd\u2082 := (\u2119 : Measure \u03a9'\u2082).map X'\u2082\n  have B : \u03c4[X'\u2081 # X'\u2082 | p] = \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] :=\n    (identDistrib_id_right h1.aemeasurable).tau_eq p (identDistrib_id_right h2.aemeasurable)\n  convert h \u03bd\u2081 \u03bd\u2082 (isProbabilityMeasure_map h1.aemeasurable)\n    (isProbabilityMeasure_map h2.aemeasurable)", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 7, "proofLengthTokens": 337}}
{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p]) := by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082]\n    {\u03bc\u2081 : Measure \u03a9\u2081} {\u03bc\u2082 : Measure \u03a9\u2082} {\u03bc'\u2081 : Measure \u03a9'\u2081} {\u03bc'\u2082 : Measure \u03a9'\u2082}\n    {X\u2081 : \u03a9\u2081 \u2192 G} {X\u2082 : \u03a9\u2082 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X'\u2081 \u03bc\u2081 \u03bc'\u2081) (h\u2082 : IdentDistrib X\u2082 X'\u2082 \u03bc\u2082 \u03bc'\u2082) :\n    \u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p] = \u03c4[X'\u2081 ; \u03bc'\u2081 # X'\u2082 ; \u03bc'\u2082 | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h\u2081,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h\u2082,\n      h\u2081.rdist_eq h\u2082]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {\u03a9 : Type*} [MeasureSpace \u03a9] (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G) : Prop :=\n  \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace \u03a9]\n    [MeasureSpace \u03a9']\n    {X\u2081 X\u2082 : \u03a9 \u2192 G} {X\u2081' X\u2082' : \u03a9' \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082') :\n    tau_minimizes p X\u2081 X\u2082 \u2194 tau_minimizes p X\u2081' X\u2082' := by\n  simp_rw [_root_.tau_minimizes, h\u2081.tau_eq p h\u2082]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    \u2203 (\u03bc : Measure G \u00d7 Measure G),\n    IsProbabilityMeasure \u03bc.1 \u2227 IsProbabilityMeasure \u03bc.2 \u2227\n    \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] := by\n  let _i : TopologicalSpace G := (\u22a5 : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := \u27e8rfl\u27e9\n  have GG_cpt : CompactSpace (ProbabilityMeasure G \u00d7 ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G \u00d7 ProbabilityMeasure G \u2192 \u211d := -- restrict \u03c4 to the compact subspace\n    fun \u27e8\u03bc\u2081, \u03bc\u2082\u27e9 \u21a6 \u03c4[id ; \u03bc\u2081 # id ; \u03bc\u2082 | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := \u27e80\u27e9 -- Need to record this for Lean to know that proba measures exist.\n  obtain \u27e8\u03bc, _, h\u03bc\u27e9 := @IsCompact.exists_isMinOn \u211d (ProbabilityMeasure G \u00d7 ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ \u27e8default, trivial\u27e9 T T_cont.continuousOn\n  use \u27e8\u03bc.1.toMeasure, \u03bc.2.toMeasure\u27e9\n  refine \u27e8\u03bc.1.prop, \u03bc.2.prop, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 P\u03bd\u2081 P\u03bd\u2082\n  rw [isMinOn_univ_iff] at h\u03bc\n  let \u03bd : ProbabilityMeasure G \u00d7 ProbabilityMeasure G := \u27e8\u27e8\u03bd\u2081, P\u03bd\u2081\u27e9, \u03bd\u2082, P\u03bd\u2082\u27e9\n  exact h\u03bc \u03bd\n\n/-- A pair of random variables minimizing $\u03c4$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    \u2203 (\u03a9 : Type uG) (m\u03a9 : MeasureSpace \u03a9) (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G),\n    Measurable X\u2081 \u2227 Measurable X\u2082 \u2227 IsProbabilityMeasure (\u2119 : Measure \u03a9) \u2227\n    tau_minimizes p X\u2081 X\u2082 := by\n  let \u03bc := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure \u03bc.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure \u03bc.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (\u03bc.1.prod \u03bc.2) := by infer_instance\n  let M : MeasureSpace (G \u00d7 G) := \u27e8\u03bc.1.prod \u03bc.2\u27e9\n  refine \u27e8G \u00d7 G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n  have A : \u03c4[@Prod.fst G G # @Prod.snd G G | p] = \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n\n\nvariable [MeasureSpace \u03a9] [h\u03a9\u2081 : MeasureSpace \u03a9'\u2081] [h\u03a9\u2082 : MeasureSpace \u03a9'\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9'\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9'\u2082)]\n  {X\u2081 : \u03a9 \u2192 G} {X\u2082 : \u03a9 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n\nlemma is_tau_min (h : tau_minimizes p X\u2081 X\u2082) (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[X'\u2081 # X'\u2082 | p] := by\n  let \u03bd\u2081 := (\u2119 : Measure \u03a9'\u2081).map X'\u2081\n  let \u03bd\u2082 := (\u2119 : Measure \u03a9'\u2082).map X'\u2082\n  have B : \u03c4[X'\u2081 # X'\u2082 | p] = \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] :=\n    (identDistrib_id_right h1.aemeasurable).tau_eq p (identDistrib_id_right h2.aemeasurable)\n  convert h \u03bd\u2081 \u03bd\u2082 (isProbabilityMeasure_map h1.aemeasurable)\n    (isProbabilityMeasure_map h2.aemeasurable)\n\n/-- Let `X\u2081` and `X\u2082` be tau-minimizers associated to `p`, with $d[X_1,X_2]=k$, then\n$$ d[X'_1;X'_2] \\geq\n    k - \\eta (d[X^0_1;X'_1] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2] - d[X^0_2;X_2] )$$\nfor any $G$-valued random variables $X'_1,X'_2$.\n-/\n", "theoremStatement": "lemma distance_ge_of_min (h : tau_minimizes p X\u2081 X\u2082) (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    d[X\u2081 # X\u2082] - p.\u03b7 * (d[p.X\u2080\u2081 # X'\u2081] - d[p.X\u2080\u2081 # X\u2081]) - p.\u03b7 * (d[p.X\u2080\u2082 # X'\u2082] - d[p.X\u2080\u2082 # X\u2082])\n      \u2264 d[X'\u2081 # X'\u2082]", "fileCreated": "623ad58 20231116", "theoremCreated": "828bcd7 20231120", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 172, "tokenPositionInFile": 8332, "theoremPositionInFile": 11}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have Z := is_tau_min p h h1 h2\n  simp [tau] at Z\n  linarith", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 4, "proofLengthTokens": 64}}
{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p]) := by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082]\n    {\u03bc\u2081 : Measure \u03a9\u2081} {\u03bc\u2082 : Measure \u03a9\u2082} {\u03bc'\u2081 : Measure \u03a9'\u2081} {\u03bc'\u2082 : Measure \u03a9'\u2082}\n    {X\u2081 : \u03a9\u2081 \u2192 G} {X\u2082 : \u03a9\u2082 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X'\u2081 \u03bc\u2081 \u03bc'\u2081) (h\u2082 : IdentDistrib X\u2082 X'\u2082 \u03bc\u2082 \u03bc'\u2082) :\n    \u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p] = \u03c4[X'\u2081 ; \u03bc'\u2081 # X'\u2082 ; \u03bc'\u2082 | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h\u2081,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h\u2082,\n      h\u2081.rdist_eq h\u2082]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {\u03a9 : Type*} [MeasureSpace \u03a9] (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G) : Prop :=\n  \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace \u03a9]\n    [MeasureSpace \u03a9']\n    {X\u2081 X\u2082 : \u03a9 \u2192 G} {X\u2081' X\u2082' : \u03a9' \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082') :\n    tau_minimizes p X\u2081 X\u2082 \u2194 tau_minimizes p X\u2081' X\u2082' := by\n  simp_rw [_root_.tau_minimizes, h\u2081.tau_eq p h\u2082]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    \u2203 (\u03bc : Measure G \u00d7 Measure G),\n    IsProbabilityMeasure \u03bc.1 \u2227 IsProbabilityMeasure \u03bc.2 \u2227\n    \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] := by\n  let _i : TopologicalSpace G := (\u22a5 : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := \u27e8rfl\u27e9\n  have GG_cpt : CompactSpace (ProbabilityMeasure G \u00d7 ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G \u00d7 ProbabilityMeasure G \u2192 \u211d := -- restrict \u03c4 to the compact subspace\n    fun \u27e8\u03bc\u2081, \u03bc\u2082\u27e9 \u21a6 \u03c4[id ; \u03bc\u2081 # id ; \u03bc\u2082 | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := \u27e80\u27e9 -- Need to record this for Lean to know that proba measures exist.\n  obtain \u27e8\u03bc, _, h\u03bc\u27e9 := @IsCompact.exists_isMinOn \u211d (ProbabilityMeasure G \u00d7 ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ \u27e8default, trivial\u27e9 T T_cont.continuousOn\n  use \u27e8\u03bc.1.toMeasure, \u03bc.2.toMeasure\u27e9\n  refine \u27e8\u03bc.1.prop, \u03bc.2.prop, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 P\u03bd\u2081 P\u03bd\u2082\n  rw [isMinOn_univ_iff] at h\u03bc\n  let \u03bd : ProbabilityMeasure G \u00d7 ProbabilityMeasure G := \u27e8\u27e8\u03bd\u2081, P\u03bd\u2081\u27e9, \u03bd\u2082, P\u03bd\u2082\u27e9\n  exact h\u03bc \u03bd\n\n/-- A pair of random variables minimizing $\u03c4$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    \u2203 (\u03a9 : Type uG) (m\u03a9 : MeasureSpace \u03a9) (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G),\n    Measurable X\u2081 \u2227 Measurable X\u2082 \u2227 IsProbabilityMeasure (\u2119 : Measure \u03a9) \u2227\n    tau_minimizes p X\u2081 X\u2082 := by\n  let \u03bc := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure \u03bc.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure \u03bc.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (\u03bc.1.prod \u03bc.2) := by infer_instance\n  let M : MeasureSpace (G \u00d7 G) := \u27e8\u03bc.1.prod \u03bc.2\u27e9\n  refine \u27e8G \u00d7 G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n  have A : \u03c4[@Prod.fst G G # @Prod.snd G G | p] = \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n\n\nvariable [MeasureSpace \u03a9] [h\u03a9\u2081 : MeasureSpace \u03a9'\u2081] [h\u03a9\u2082 : MeasureSpace \u03a9'\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9'\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9'\u2082)]\n  {X\u2081 : \u03a9 \u2192 G} {X\u2082 : \u03a9 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n\nlemma is_tau_min (h : tau_minimizes p X\u2081 X\u2082) (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[X'\u2081 # X'\u2082 | p] := by\n  let \u03bd\u2081 := (\u2119 : Measure \u03a9'\u2081).map X'\u2081\n  let \u03bd\u2082 := (\u2119 : Measure \u03a9'\u2082).map X'\u2082\n  have B : \u03c4[X'\u2081 # X'\u2082 | p] = \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] :=\n    (identDistrib_id_right h1.aemeasurable).tau_eq p (identDistrib_id_right h2.aemeasurable)\n  convert h \u03bd\u2081 \u03bd\u2082 (isProbabilityMeasure_map h1.aemeasurable)\n    (isProbabilityMeasure_map h2.aemeasurable)\n\n/-- Let `X\u2081` and `X\u2082` be tau-minimizers associated to `p`, with $d[X_1,X_2]=k$, then\n$$ d[X'_1;X'_2] \\geq\n    k - \\eta (d[X^0_1;X'_1] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2] - d[X^0_2;X_2] )$$\nfor any $G$-valued random variables $X'_1,X'_2$.\n-/\nlemma distance_ge_of_min (h : tau_minimizes p X\u2081 X\u2082) (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    d[X\u2081 # X\u2082] - p.\u03b7 * (d[p.X\u2080\u2081 # X'\u2081] - d[p.X\u2080\u2081 # X\u2081]) - p.\u03b7 * (d[p.X\u2080\u2082 # X'\u2082] - d[p.X\u2080\u2082 # X\u2082])\n      \u2264 d[X'\u2081 # X'\u2082] := by\n  have Z := is_tau_min p h h1 h2\n  simp [tau] at Z\n  linarith\n\n/-- Version of `distance_ge_of_min` with the measures made explicit. -/\n", "theoremStatement": "lemma distance_ge_of_min' {\u03a9'\u2081 \u03a9'\u2082 : Type*} (h : tau_minimizes p X\u2081 X\u2082)\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082] {\u03bc : Measure \u03a9'\u2081} {\u03bc' : Measure \u03a9'\u2082}\n    [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc'] {X'\u2081: \u03a9'\u2081 \u2192 G} {X'\u2082: \u03a9'\u2082 \u2192 G}\n    (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    d[X\u2081 # X\u2082] - p.\u03b7 * (d[p.X\u2080\u2081; \u2119 # X'\u2081; \u03bc] - d[p.X\u2080\u2081 # X\u2081])\n      - p.\u03b7 * (d[p.X\u2080\u2082; \u2119 # X'\u2082; \u03bc'] - d[p.X\u2080\u2082 # X\u2082]) \u2264 d[X'\u2081; \u03bc # X'\u2082; \u03bc']", "fileCreated": "623ad58 20231116", "theoremCreated": "ba82447 20231128", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 180, "tokenPositionInFile": 8690, "theoremPositionInFile": 12}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  set M1 : MeasureSpace \u03a9'\u2081 := { volume := \u03bc }\n  set M2 : MeasureSpace \u03a9'\u2082 := { volume := \u03bc' }\n  exact distance_ge_of_min p h h1 h2", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 4, "proofLengthTokens": 134}}
{"srcContext": "import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `\u03b7`: $1/9$\n* `\u03c4`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*) [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n[IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the \u03c4 functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe \u03b7 parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X\u2080\u2081 : \u03a9\u2080\u2081 \u2192 G\n  /-- The second variable in a package. -/\n  X\u2080\u2082 : \u03a9\u2080\u2082 \u2192 G\n  hmeas1 : Measurable X\u2080\u2081\n  hmeas2 : Measurable X\u2080\u2082\n  \u03b7 : \u211d\n  h\u03b7 : 0 < \u03b7\n  h\u03b7' : 8 * \u03b7 \u2264 1\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 G}\n\nvariable {\u03a9\u2081 \u03a9\u2082 \u03a9'\u2081 \u03a9'\u2082 : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `\u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `\u2119`, we\ncan use `\u03c4[X\u2081 # X\u2082 | p]`\n-/\n@[pp_dot] noncomputable def tau {\u03a9\u2081 \u03a9\u2082 : Type*} [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    (X\u2081 : \u03a9\u2081 \u2192 G) (X\u2082 : \u03a9\u2082 \u2192 G) (\u03bc\u2081 : Measure \u03a9\u2081) (\u03bc\u2082 : Measure \u03a9\u2082) : \u211d :=\n  d[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082] + p.\u03b7 * d[p.X\u2080\u2081 ; \u2119 # X\u2081 ; \u03bc\u2081] + p.\u03b7 * d[p.X\u2080\u2082 ; \u2119 # X\u2082 ; \u03bc\u2082]\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" ; \" \u03bc\u2081 \" # \" X\u2082 \" ; \" \u03bc\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 \u03bc\u2081 \u03bc\u2082\n\n@[inherit_doc tau]\nnotation3:max \"\u03c4[\" X\u2081 \" # \" X\u2082 \" | \" p\"]\" => tau p X\u2081 X\u2082 MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p]) := by\n  have obs\u2081 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2082 ; \u2119 # id ; \u03bc.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas2) continuous_snd\n  have obs\u2082 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[id ; \u03bc.1.toMeasure # id ; \u03bc.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs\u2083 : Continuous\n      (fun (\u03bc : ProbabilityMeasure G \u00d7 ProbabilityMeasure G) \u21a6 d[p.X\u2080\u2081 ; \u2119 # id ; \u03bc.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure\u2081' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace \u03a9\u2081] [MeasurableSpace \u03a9\u2082]\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082]\n    {\u03bc\u2081 : Measure \u03a9\u2081} {\u03bc\u2082 : Measure \u03a9\u2082} {\u03bc'\u2081 : Measure \u03a9'\u2081} {\u03bc'\u2082 : Measure \u03a9'\u2082}\n    {X\u2081 : \u03a9\u2081 \u2192 G} {X\u2082 : \u03a9\u2082 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X'\u2081 \u03bc\u2081 \u03bc'\u2081) (h\u2082 : IdentDistrib X\u2082 X'\u2082 \u03bc\u2082 \u03bc'\u2082) :\n    \u03c4[X\u2081 ; \u03bc\u2081 # X\u2082 ; \u03bc\u2082 | p] = \u03c4[X'\u2081 ; \u03bc'\u2081 # X'\u2082 ; \u03bc'\u2082 | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h\u2081,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h\u2082,\n      h\u2081.rdist_eq h\u2082]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {\u03a9 : Type*} [MeasureSpace \u03a9] (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G) : Prop :=\n  \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace \u03a9]\n    [MeasureSpace \u03a9']\n    {X\u2081 X\u2082 : \u03a9 \u2192 G} {X\u2081' X\u2082' : \u03a9' \u2192 G}\n    (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082') :\n    tau_minimizes p X\u2081 X\u2082 \u2194 tau_minimizes p X\u2081' X\u2082' := by\n  simp_rw [_root_.tau_minimizes, h\u2081.tau_eq p h\u2082]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    \u2203 (\u03bc : Measure G \u00d7 Measure G),\n    IsProbabilityMeasure \u03bc.1 \u2227 IsProbabilityMeasure \u03bc.2 \u2227\n    \u2200 (\u03bd\u2081 : Measure G) (\u03bd\u2082 : Measure G), IsProbabilityMeasure \u03bd\u2081 \u2192 IsProbabilityMeasure \u03bd\u2082 \u2192\n      \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] \u2264 \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] := by\n  let _i : TopologicalSpace G := (\u22a5 : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := \u27e8rfl\u27e9\n  have GG_cpt : CompactSpace (ProbabilityMeasure G \u00d7 ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G \u00d7 ProbabilityMeasure G \u2192 \u211d := -- restrict \u03c4 to the compact subspace\n    fun \u27e8\u03bc\u2081, \u03bc\u2082\u27e9 \u21a6 \u03c4[id ; \u03bc\u2081 # id ; \u03bc\u2082 | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := \u27e80\u27e9 -- Need to record this for Lean to know that proba measures exist.\n  obtain \u27e8\u03bc, _, h\u03bc\u27e9 := @IsCompact.exists_isMinOn \u211d (ProbabilityMeasure G \u00d7 ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ \u27e8default, trivial\u27e9 T T_cont.continuousOn\n  use \u27e8\u03bc.1.toMeasure, \u03bc.2.toMeasure\u27e9\n  refine \u27e8\u03bc.1.prop, \u03bc.2.prop, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 P\u03bd\u2081 P\u03bd\u2082\n  rw [isMinOn_univ_iff] at h\u03bc\n  let \u03bd : ProbabilityMeasure G \u00d7 ProbabilityMeasure G := \u27e8\u27e8\u03bd\u2081, P\u03bd\u2081\u27e9, \u03bd\u2082, P\u03bd\u2082\u27e9\n  exact h\u03bc \u03bd\n\n/-- A pair of random variables minimizing $\u03c4$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    \u2203 (\u03a9 : Type uG) (m\u03a9 : MeasureSpace \u03a9) (X\u2081 : \u03a9 \u2192 G) (X\u2082 : \u03a9 \u2192 G),\n    Measurable X\u2081 \u2227 Measurable X\u2082 \u2227 IsProbabilityMeasure (\u2119 : Measure \u03a9) \u2227\n    tau_minimizes p X\u2081 X\u2082 := by\n  let \u03bc := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure \u03bc.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure \u03bc.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (\u03bc.1.prod \u03bc.2) := by infer_instance\n  let M : MeasureSpace (G \u00d7 G) := \u27e8\u03bc.1.prod \u03bc.2\u27e9\n  refine \u27e8G \u00d7 G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_\u27e9\n  intro \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n  have A : \u03c4[@Prod.fst G G # @Prod.snd G G | p] = \u03c4[id ; \u03bc.1 # id ; \u03bc.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 \u03bd\u2081 \u03bd\u2082 h\u2081 h\u2082\n\n\nvariable [MeasureSpace \u03a9] [h\u03a9\u2081 : MeasureSpace \u03a9'\u2081] [h\u03a9\u2082 : MeasureSpace \u03a9'\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9'\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9'\u2082)]\n  {X\u2081 : \u03a9 \u2192 G} {X\u2082 : \u03a9 \u2192 G} {X'\u2081 : \u03a9'\u2081 \u2192 G} {X'\u2082 : \u03a9'\u2082 \u2192 G}\n\nlemma is_tau_min (h : tau_minimizes p X\u2081 X\u2082) (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    \u03c4[X\u2081 # X\u2082 | p] \u2264 \u03c4[X'\u2081 # X'\u2082 | p] := by\n  let \u03bd\u2081 := (\u2119 : Measure \u03a9'\u2081).map X'\u2081\n  let \u03bd\u2082 := (\u2119 : Measure \u03a9'\u2082).map X'\u2082\n  have B : \u03c4[X'\u2081 # X'\u2082 | p] = \u03c4[id ; \u03bd\u2081 # id ; \u03bd\u2082 | p] :=\n    (identDistrib_id_right h1.aemeasurable).tau_eq p (identDistrib_id_right h2.aemeasurable)\n  convert h \u03bd\u2081 \u03bd\u2082 (isProbabilityMeasure_map h1.aemeasurable)\n    (isProbabilityMeasure_map h2.aemeasurable)\n\n/-- Let `X\u2081` and `X\u2082` be tau-minimizers associated to `p`, with $d[X_1,X_2]=k$, then\n$$ d[X'_1;X'_2] \\geq\n    k - \\eta (d[X^0_1;X'_1] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2] - d[X^0_2;X_2] )$$\nfor any $G$-valued random variables $X'_1,X'_2$.\n-/\nlemma distance_ge_of_min (h : tau_minimizes p X\u2081 X\u2082) (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    d[X\u2081 # X\u2082] - p.\u03b7 * (d[p.X\u2080\u2081 # X'\u2081] - d[p.X\u2080\u2081 # X\u2081]) - p.\u03b7 * (d[p.X\u2080\u2082 # X'\u2082] - d[p.X\u2080\u2082 # X\u2082])\n      \u2264 d[X'\u2081 # X'\u2082] := by\n  have Z := is_tau_min p h h1 h2\n  simp [tau] at Z\n  linarith\n\n/-- Version of `distance_ge_of_min` with the measures made explicit. -/\nlemma distance_ge_of_min' {\u03a9'\u2081 \u03a9'\u2082 : Type*} (h : tau_minimizes p X\u2081 X\u2082)\n    [MeasurableSpace \u03a9'\u2081] [MeasurableSpace \u03a9'\u2082] {\u03bc : Measure \u03a9'\u2081} {\u03bc' : Measure \u03a9'\u2082}\n    [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc'] {X'\u2081: \u03a9'\u2081 \u2192 G} {X'\u2082: \u03a9'\u2082 \u2192 G}\n    (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082) :\n    d[X\u2081 # X\u2082] - p.\u03b7 * (d[p.X\u2080\u2081; \u2119 # X'\u2081; \u03bc] - d[p.X\u2080\u2081 # X\u2081])\n      - p.\u03b7 * (d[p.X\u2080\u2082; \u2119 # X'\u2082; \u03bc'] - d[p.X\u2080\u2082 # X\u2082]) \u2264 d[X'\u2081; \u03bc # X'\u2082; \u03bc'] := by\n  set M1 : MeasureSpace \u03a9'\u2081 := { volume := \u03bc }\n  set M2 : MeasureSpace \u03a9'\u2082 := { volume := \u03bc' }\n  exact distance_ge_of_min p h h1 h2\n\n\nopen BigOperators\n\n/-- For any $G$-valued random variables $X'_1,X'_2$ and random variables $Z,W$, one can lower\nbound $d[X'_1|Z;X'_2|W]$ by\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] ).$$\n-/\n", "theoremStatement": "lemma condRuzsaDistance_ge_of_min [MeasurableSingletonClass G]\n    [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T]\n    (h : tau_minimizes p X\u2081 X\u2082) (h1 : Measurable X'\u2081) (h2 : Measurable X'\u2082)\n    (Z : \u03a9'\u2081 \u2192 S) (W : \u03a9'\u2082 \u2192 T) (hZ : Measurable Z) (hW : Measurable W) :\n    d[X\u2081 # X\u2082] - p.\u03b7 * (d[p.X\u2080\u2081 # X'\u2081 | Z] - d[p.X\u2080\u2081 # X\u2081])\n      - p.\u03b7 * (d[p.X\u2080\u2082 # X'\u2082 | W] - d[p.X\u2080\u2082 # X\u2082]) \u2264 d[X'\u2081 | Z # X'\u2082 | W]", "fileCreated": "623ad58 20231116", "theoremCreated": "9087ab7 20231122", "file": "PFR/TauFunctional.lean", "positionMetadata": {"lineInFile": 197, "tokenPositionInFile": 9493, "theoremPositionInFile": 13}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have hz (a : \u211d) : a = \u2211 z in FiniteRange.toFinset Z, (\u2119 (Z \u207b\u00b9' {z})).toReal * a := by\n    simp_rw [\u2190 Finset.sum_mul,\u2190 Measure.map_apply hZ (MeasurableSet.singleton _), Finset.sum_toReal_measure_singleton]\n    rw [FiniteRange.full hZ]\n    simp\n  have hw (a : \u211d) : a = \u2211 w in FiniteRange.toFinset W, (\u2119 (W \u207b\u00b9' {w})).toReal * a := by\n    simp_rw [\u2190 Finset.sum_mul,\u2190 Measure.map_apply hW (MeasurableSet.singleton _), Finset.sum_toReal_measure_singleton]\n    rw [FiniteRange.full hW]\n    simp\n  rw [condRuzsaDist_eq_sum h1 hZ h2 hW, condRuzsaDist'_eq_sum h1 hZ, hz d[X\u2081 # X\u2082],\n    hz d[p.X\u2080\u2081 # X\u2081], hz (p.\u03b7 * (d[p.X\u2080\u2082 # X'\u2082 | W] - d[p.X\u2080\u2082 # X\u2082])),\n    \u2190 Finset.sum_sub_distrib, Finset.mul_sum, \u2190 Finset.sum_sub_distrib, \u2190 Finset.sum_sub_distrib]\n  apply Finset.sum_le_sum\n  intro z _\n  rw [condRuzsaDist'_eq_sum h2 hW, hw d[p.X\u2080\u2082 # X\u2082],\n    hw ((\u2119 (Z \u207b\u00b9' {z})).toReal * d[X\u2081 # X\u2082] - p.\u03b7 * ((\u2119 (Z \u207b\u00b9' {z})).toReal *\n      d[p.X\u2080\u2081 ; \u2119 # X'\u2081 ; \u2119[|Z \u2190 z]] - (\u2119 (Z \u207b\u00b9' {z})).toReal * d[p.X\u2080\u2081 # X\u2081])),\n    \u2190 Finset.sum_sub_distrib, Finset.mul_sum, Finset.mul_sum, \u2190 Finset.sum_sub_distrib]\n  apply Finset.sum_le_sum\n  intro w _\n  rcases eq_or_ne (\u2119 (Z \u207b\u00b9' {z})) 0 with hpz | hpz\n  . simp [hpz]\n  rcases eq_or_ne (\u2119 (W \u207b\u00b9' {w})) 0 with hpw | hpw\n  . simp [hpw]\n  set \u03bc := (h\u03a9\u2081.volume)[|Z \u2190 z]\n  have h\u03bc : IsProbabilityMeasure \u03bc := cond_isProbabilityMeasure \u2119 hpz\n  set \u03bc' := \u2119[|W \u2190 w]\n  have h\u03bc' : IsProbabilityMeasure \u03bc' := cond_isProbabilityMeasure \u2119 hpw\n  suffices d[X\u2081 # X\u2082] - p.\u03b7 * (d[p.X\u2080\u2081; volume # X'\u2081; \u03bc] - d[p.X\u2080\u2081 # X\u2081]) -\n    p.\u03b7 * (d[p.X\u2080\u2082; volume # X'\u2082; \u03bc'] - d[p.X\u2080\u2082 # X\u2082]) \u2264 d[X'\u2081 ; \u03bc # X'\u2082; \u03bc'] by\n    replace this := mul_le_mul_of_nonneg_left this (show 0 \u2264 (\u2119 (Z \u207b\u00b9' {z})).toReal * (\u2119 (W \u207b\u00b9' {w})).toReal by positivity)\n    convert this using 1\n    ring\n  exact distance_ge_of_min' p h h1 h2", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 34, "proofLengthTokens": 1802}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\n", "theoremStatement": "lemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B)", "fileCreated": "516205a 20231114", "theoremCreated": "b94162e 20231128", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 31, "tokenPositionInFile": 1061, "theoremPositionInFile": 1}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 34, "proofLengthTokens": 1653}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V + x` with probability `# (A \u2229 (B + x)) / #A \u2b1d #B`. -/\n", "theoremStatement": "lemma IsUniform.measureReal_preimage_sub (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) (x : G) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {x})\n      = Nat.card (A \u2229 (B + {x}) : Set G) / (Nat.card A * Nat.card B)", "fileCreated": "516205a 20231114", "theoremCreated": "b94162e 20231128", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 71, "tokenPositionInFile": 3165, "theoremPositionInFile": 2}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  classical\n  let W := fun \u03c9 \u21a6 V \u03c9 + x\n  have Wunif : IsUniform (B + {x} : Set G) W := by\n    convert Vunif.comp (add_left_injective x)\n    simp\n  have Wmeas : Measurable W := Vmeas.add_const _\n  have UWindep : IndepFun U W := by\n    have : Measurable (fun g \u21a6 g + x) := measurable_add_const x\n    exact hindep.comp measurable_id this\n  have : (U - V) \u207b\u00b9' {x} = (U - W) \u207b\u00b9' {0} := by\n    ext \u03c9\n    simp only [W, mem_preimage, Pi.add_apply, mem_singleton_iff, Pi.sub_apply, \u2190 sub_eq_zero (b := x)]\n    abel_nf\n  have h : (B:Set G)+{x} = (B+{x}:Finset G) := by simp\n  rw [h] at Wunif\n  rw [this, Uunif.measureReal_preimage_sub_zero Umeas Wunif Wmeas UWindep]\n  congr 3\n  . rw [add_singleton]; simp\n  convert Finset.card_vadd_finset (AddOpposite.op x) B\n  . simp\n  simp", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 22, "proofLengthTokens": 769}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V + x` with probability `# (A \u2229 (B + x)) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) (x : G) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {x})\n      = Nat.card (A \u2229 (B + {x}) : Set G) / (Nat.card A * Nat.card B) := by\n  classical\n  let W := fun \u03c9 \u21a6 V \u03c9 + x\n  have Wunif : IsUniform (B + {x} : Set G) W := by\n    convert Vunif.comp (add_left_injective x)\n    simp\n  have Wmeas : Measurable W := Vmeas.add_const _\n  have UWindep : IndepFun U W := by\n    have : Measurable (fun g \u21a6 g + x) := measurable_add_const x\n    exact hindep.comp measurable_id this\n  have : (U - V) \u207b\u00b9' {x} = (U - W) \u207b\u00b9' {0} := by\n    ext \u03c9\n    simp only [W, mem_preimage, Pi.add_apply, mem_singleton_iff, Pi.sub_apply, \u2190 sub_eq_zero (b := x)]\n    abel_nf\n  have h : (B:Set G)+{x} = (B+{x}:Finset G) := by simp\n  rw [h] at Wunif\n  rw [this, Uunif.measureReal_preimage_sub_zero Umeas Wunif Wmeas UWindep]\n  congr 3\n  . rw [add_singleton]; simp\n  convert Finset.card_vadd_finset (AddOpposite.op x) B\n  . simp\n  simp\n\nend ProbabilityTheory\n\n\n/-- Record positivity results that are useful in the proof of PFR. -/\n", "theoremStatement": "lemma PFR_conjecture_pos_aux {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K", "fileCreated": "516205a 20231114", "theoremCreated": "a028962 20231126", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 101, "tokenPositionInFile": 4318, "theoremPositionInFile": 3}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A - A) := by\n    have : Nonempty (A - A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.sub h\u2080A h\u2080A)\n    have : Finite (A - A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 9, "proofLengthTokens": 519}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V + x` with probability `# (A \u2229 (B + x)) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) (x : G) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {x})\n      = Nat.card (A \u2229 (B + {x}) : Set G) / (Nat.card A * Nat.card B) := by\n  classical\n  let W := fun \u03c9 \u21a6 V \u03c9 + x\n  have Wunif : IsUniform (B + {x} : Set G) W := by\n    convert Vunif.comp (add_left_injective x)\n    simp\n  have Wmeas : Measurable W := Vmeas.add_const _\n  have UWindep : IndepFun U W := by\n    have : Measurable (fun g \u21a6 g + x) := measurable_add_const x\n    exact hindep.comp measurable_id this\n  have : (U - V) \u207b\u00b9' {x} = (U - W) \u207b\u00b9' {0} := by\n    ext \u03c9\n    simp only [W, mem_preimage, Pi.add_apply, mem_singleton_iff, Pi.sub_apply, \u2190 sub_eq_zero (b := x)]\n    abel_nf\n  have h : (B:Set G)+{x} = (B+{x}:Finset G) := by simp\n  rw [h] at Wunif\n  rw [this, Uunif.measureReal_preimage_sub_zero Umeas Wunif Wmeas UWindep]\n  congr 3\n  . rw [add_singleton]; simp\n  convert Finset.card_vadd_finset (AddOpposite.op x) B\n  . simp\n  simp\n\nend ProbabilityTheory\n\n\n/-- Record positivity results that are useful in the proof of PFR. -/\nlemma PFR_conjecture_pos_aux {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A - A) := by\n    have : Nonempty (A - A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.sub h\u2080A h\u2080A)\n    have : Finite (A - A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\n", "theoremStatement": "lemma PFR_conjecture_pos_aux' {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A + A) \u2227 0 < K", "fileCreated": "516205a 20231114", "theoremCreated": "2ac9116 20231227", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 112, "tokenPositionInFile": 5055, "theoremPositionInFile": 4}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A + A) := by\n    have : Nonempty (A + A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.add h\u2080A h\u2080A)\n    have : Finite (A + A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 9, "proofLengthTokens": 519}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V + x` with probability `# (A \u2229 (B + x)) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) (x : G) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {x})\n      = Nat.card (A \u2229 (B + {x}) : Set G) / (Nat.card A * Nat.card B) := by\n  classical\n  let W := fun \u03c9 \u21a6 V \u03c9 + x\n  have Wunif : IsUniform (B + {x} : Set G) W := by\n    convert Vunif.comp (add_left_injective x)\n    simp\n  have Wmeas : Measurable W := Vmeas.add_const _\n  have UWindep : IndepFun U W := by\n    have : Measurable (fun g \u21a6 g + x) := measurable_add_const x\n    exact hindep.comp measurable_id this\n  have : (U - V) \u207b\u00b9' {x} = (U - W) \u207b\u00b9' {0} := by\n    ext \u03c9\n    simp only [W, mem_preimage, Pi.add_apply, mem_singleton_iff, Pi.sub_apply, \u2190 sub_eq_zero (b := x)]\n    abel_nf\n  have h : (B:Set G)+{x} = (B+{x}:Finset G) := by simp\n  rw [h] at Wunif\n  rw [this, Uunif.measureReal_preimage_sub_zero Umeas Wunif Wmeas UWindep]\n  congr 3\n  . rw [add_singleton]; simp\n  convert Finset.card_vadd_finset (AddOpposite.op x) B\n  . simp\n  simp\n\nend ProbabilityTheory\n\n\n/-- Record positivity results that are useful in the proof of PFR. -/\nlemma PFR_conjecture_pos_aux {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A - A) := by\n    have : Nonempty (A - A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.sub h\u2080A h\u2080A)\n    have : Finite (A - A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nlemma PFR_conjecture_pos_aux' {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A + A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A + A) := by\n    have : Nonempty (A + A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.add h\u2080A h\u2080A)\n    have : Finite (A + A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nvariable {G : Type*} [AddCommGroup G] [MeasurableSpace G]\n  [MeasurableSingletonClass G] {A : Set G} [Finite A] {K : \u211d} [Countable G]\n\n/-- A uniform distribution on a set with doubling constant `K` has self Rusza distance\nat most `log K`. -/\n", "theoremStatement": "theorem rdist_le_of_isUniform_of_card_add_le (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A)\n    {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U\u2080 : \u03a9 \u2192 G}\n    (U\u2080unif : IsUniform A U\u2080) (U\u2080meas : Measurable U\u2080) : d[U\u2080 # U\u2080] \u2264 log K", "fileCreated": "516205a 20231114", "theoremCreated": "b94162e 20231128", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 128, "tokenPositionInFile": 6035, "theoremPositionInFile": 5}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8A_pos, AA_pos, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux h\u2080A hA\n  rcases independent_copies_two U\u2080meas U\u2080meas with \u27e8\u03a9, m\u03a9, U, U', hP, hU, hU', UU'_indep, idU, idU'\u27e9\n  have Uunif : IsUniform A U := U\u2080unif.of_identDistrib idU.symm $ measurableSet_discrete _\n  have U'unif : IsUniform A U' := U\u2080unif.of_identDistrib idU'.symm $ measurableSet_discrete _\n  have IU : d[U # U'] \u2264 log K := by\n    have I : H[U - U'] \u2264 log (Nat.card (A - A)) := by\n      convert entropy_le_log_card_of_mem (A := (A-A).toFinite.toFinset) ?_ ?_ with x\n      . simp\n        exact Iff.rfl\n      . measurability\n      filter_upwards [Uunif.ae_mem, U'unif.ae_mem] with \u03c9 h1 h2\n      simp\n      exact Set.sub_mem_sub h1 h2\n    have J : log (Nat.card (A - A)) \u2264 log K + log (Nat.card A) := by\n      apply (log_le_log AA_pos hA).trans (le_of_eq _)\n      rw [log_mul K_pos.ne' A_pos.ne']\n--    have : H[U + U'] = H[U - U'] := by congr; simp\n    rw [UU'_indep.rdist_eq hU hU', IsUniform.entropy_eq' Uunif hU, IsUniform.entropy_eq' U'unif hU']\n    linarith\n  rwa [idU.rdist_eq idU'] at IU", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 22, "proofLengthTokens": 1119}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V + x` with probability `# (A \u2229 (B + x)) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) (x : G) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {x})\n      = Nat.card (A \u2229 (B + {x}) : Set G) / (Nat.card A * Nat.card B) := by\n  classical\n  let W := fun \u03c9 \u21a6 V \u03c9 + x\n  have Wunif : IsUniform (B + {x} : Set G) W := by\n    convert Vunif.comp (add_left_injective x)\n    simp\n  have Wmeas : Measurable W := Vmeas.add_const _\n  have UWindep : IndepFun U W := by\n    have : Measurable (fun g \u21a6 g + x) := measurable_add_const x\n    exact hindep.comp measurable_id this\n  have : (U - V) \u207b\u00b9' {x} = (U - W) \u207b\u00b9' {0} := by\n    ext \u03c9\n    simp only [W, mem_preimage, Pi.add_apply, mem_singleton_iff, Pi.sub_apply, \u2190 sub_eq_zero (b := x)]\n    abel_nf\n  have h : (B:Set G)+{x} = (B+{x}:Finset G) := by simp\n  rw [h] at Wunif\n  rw [this, Uunif.measureReal_preimage_sub_zero Umeas Wunif Wmeas UWindep]\n  congr 3\n  . rw [add_singleton]; simp\n  convert Finset.card_vadd_finset (AddOpposite.op x) B\n  . simp\n  simp\n\nend ProbabilityTheory\n\n\n/-- Record positivity results that are useful in the proof of PFR. -/\nlemma PFR_conjecture_pos_aux {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A - A) := by\n    have : Nonempty (A - A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.sub h\u2080A h\u2080A)\n    have : Finite (A - A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nlemma PFR_conjecture_pos_aux' {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A + A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A + A) := by\n    have : Nonempty (A + A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.add h\u2080A h\u2080A)\n    have : Finite (A + A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nvariable {G : Type*} [AddCommGroup G] [MeasurableSpace G]\n  [MeasurableSingletonClass G] {A : Set G} [Finite A] {K : \u211d} [Countable G]\n\n/-- A uniform distribution on a set with doubling constant `K` has self Rusza distance\nat most `log K`. -/\ntheorem rdist_le_of_isUniform_of_card_add_le (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A)\n    {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U\u2080 : \u03a9 \u2192 G}\n    (U\u2080unif : IsUniform A U\u2080) (U\u2080meas : Measurable U\u2080) : d[U\u2080 # U\u2080] \u2264 log K := by\n  obtain \u27e8A_pos, AA_pos, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux h\u2080A hA\n  rcases independent_copies_two U\u2080meas U\u2080meas with \u27e8\u03a9, m\u03a9, U, U', hP, hU, hU', UU'_indep, idU, idU'\u27e9\n  have Uunif : IsUniform A U := U\u2080unif.of_identDistrib idU.symm $ measurableSet_discrete _\n  have U'unif : IsUniform A U' := U\u2080unif.of_identDistrib idU'.symm $ measurableSet_discrete _\n  have IU : d[U # U'] \u2264 log K := by\n    have I : H[U - U'] \u2264 log (Nat.card (A - A)) := by\n      convert entropy_le_log_card_of_mem (A := (A-A).toFinite.toFinset) ?_ ?_ with x\n      . simp\n        exact Iff.rfl\n      . measurability\n      filter_upwards [Uunif.ae_mem, U'unif.ae_mem] with \u03c9 h1 h2\n      simp\n      exact Set.sub_mem_sub h1 h2\n    have J : log (Nat.card (A - A)) \u2264 log K + log (Nat.card A) := by\n      apply (log_le_log AA_pos hA).trans (le_of_eq _)\n      rw [log_mul K_pos.ne' A_pos.ne']\n--    have : H[U + U'] = H[U - U'] := by congr; simp\n    rw [UU'_indep.rdist_eq hU hU', IsUniform.entropy_eq' Uunif hU, IsUniform.entropy_eq' U'unif hU']\n    linarith\n  rwa [idU.rdist_eq idU'] at IU\n\nvariable [ElementaryAddCommGroup G 2] [Fintype G]\n\n", "theoremStatement": "lemma sumset_eq_sub : A + A = A - A", "fileCreated": "516205a 20231114", "theoremCreated": "93e5ee0 20240113", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 155, "tokenPositionInFile": 7476, "theoremPositionInFile": 6}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [\u2190 Set.image2_add, \u2190 Set.image2_sub]\n  congr! 1 with a _ b _\n  show a + b = a - b\n  simp", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 5, "proofLengthTokens": 96}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V + x` with probability `# (A \u2229 (B + x)) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) (x : G) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {x})\n      = Nat.card (A \u2229 (B + {x}) : Set G) / (Nat.card A * Nat.card B) := by\n  classical\n  let W := fun \u03c9 \u21a6 V \u03c9 + x\n  have Wunif : IsUniform (B + {x} : Set G) W := by\n    convert Vunif.comp (add_left_injective x)\n    simp\n  have Wmeas : Measurable W := Vmeas.add_const _\n  have UWindep : IndepFun U W := by\n    have : Measurable (fun g \u21a6 g + x) := measurable_add_const x\n    exact hindep.comp measurable_id this\n  have : (U - V) \u207b\u00b9' {x} = (U - W) \u207b\u00b9' {0} := by\n    ext \u03c9\n    simp only [W, mem_preimage, Pi.add_apply, mem_singleton_iff, Pi.sub_apply, \u2190 sub_eq_zero (b := x)]\n    abel_nf\n  have h : (B:Set G)+{x} = (B+{x}:Finset G) := by simp\n  rw [h] at Wunif\n  rw [this, Uunif.measureReal_preimage_sub_zero Umeas Wunif Wmeas UWindep]\n  congr 3\n  . rw [add_singleton]; simp\n  convert Finset.card_vadd_finset (AddOpposite.op x) B\n  . simp\n  simp\n\nend ProbabilityTheory\n\n\n/-- Record positivity results that are useful in the proof of PFR. -/\nlemma PFR_conjecture_pos_aux {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A - A) := by\n    have : Nonempty (A - A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.sub h\u2080A h\u2080A)\n    have : Finite (A - A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nlemma PFR_conjecture_pos_aux' {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A + A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A + A) := by\n    have : Nonempty (A + A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.add h\u2080A h\u2080A)\n    have : Finite (A + A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nvariable {G : Type*} [AddCommGroup G] [MeasurableSpace G]\n  [MeasurableSingletonClass G] {A : Set G} [Finite A] {K : \u211d} [Countable G]\n\n/-- A uniform distribution on a set with doubling constant `K` has self Rusza distance\nat most `log K`. -/\ntheorem rdist_le_of_isUniform_of_card_add_le (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A)\n    {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U\u2080 : \u03a9 \u2192 G}\n    (U\u2080unif : IsUniform A U\u2080) (U\u2080meas : Measurable U\u2080) : d[U\u2080 # U\u2080] \u2264 log K := by\n  obtain \u27e8A_pos, AA_pos, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux h\u2080A hA\n  rcases independent_copies_two U\u2080meas U\u2080meas with \u27e8\u03a9, m\u03a9, U, U', hP, hU, hU', UU'_indep, idU, idU'\u27e9\n  have Uunif : IsUniform A U := U\u2080unif.of_identDistrib idU.symm $ measurableSet_discrete _\n  have U'unif : IsUniform A U' := U\u2080unif.of_identDistrib idU'.symm $ measurableSet_discrete _\n  have IU : d[U # U'] \u2264 log K := by\n    have I : H[U - U'] \u2264 log (Nat.card (A - A)) := by\n      convert entropy_le_log_card_of_mem (A := (A-A).toFinite.toFinset) ?_ ?_ with x\n      . simp\n        exact Iff.rfl\n      . measurability\n      filter_upwards [Uunif.ae_mem, U'unif.ae_mem] with \u03c9 h1 h2\n      simp\n      exact Set.sub_mem_sub h1 h2\n    have J : log (Nat.card (A - A)) \u2264 log K + log (Nat.card A) := by\n      apply (log_le_log AA_pos hA).trans (le_of_eq _)\n      rw [log_mul K_pos.ne' A_pos.ne']\n--    have : H[U + U'] = H[U - U'] := by congr; simp\n    rw [UU'_indep.rdist_eq hU hU', IsUniform.entropy_eq' Uunif hU, IsUniform.entropy_eq' U'unif hU']\n    linarith\n  rwa [idU.rdist_eq idU'] at IU\n\nvariable [ElementaryAddCommGroup G 2] [Fintype G]\n\nlemma sumset_eq_sub : A + A = A - A := by\n  rw [\u2190 Set.image2_add, \u2190 Set.image2_sub]\n  congr! 1 with a _ b _\n  show a + b = a - b\n  simp\n\n/-- Auxiliary statement towards the polynomial Freiman-Ruzsa (PFR) conjecture: if $A$ is a subset of\nan elementary abelian 2-group of doubling constant at most $K$, then there exists a subgroup $H$\nsuch that $A$ can be covered by at most $K^{13/2} |A|^{1/2} / |H|^{1/2}$ cosets of $H$, and $H$ has\nthe same cardinality as $A$ up to a multiplicative factor $K^11$. -/\n", "theoremStatement": "lemma PFR_conjecture_aux (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    \u2203 (H : AddSubgroup G) (c : Set G),\n    Nat.card c \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2)\n      \u2227 Nat.card H \u2264 K ^ 11 * Nat.card A \u2227 Nat.card A \u2264 K ^ 11 * Nat.card H \u2227 A \u2286 c + H", "fileCreated": "516205a 20231114", "theoremCreated": "b94162e 20231128", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 165, "tokenPositionInFile": 7980, "theoremPositionInFile": 7}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  classical\n  let _mG : MeasurableSpace G := \u22a4\n  rw [sumset_eq_sub] at hA\n  have : MeasurableSingletonClass G := \u27e8\u03bb _ \u21a6 trivial\u27e9\n  obtain \u27e8A_pos, -, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux h\u2080A hA\n  let A' := A.toFinite.toFinset\n  have h\u2080A' : Finset.Nonempty A' := by\n    simp [A', Finset.Nonempty]\n    exact h\u2080A\n  have hAA' : A' = A := Finite.coe_toFinset (toFinite A)\n  rcases exists_isUniform_measureSpace A' h\u2080A' with \u27e8\u03a9\u2080, m\u03a9\u2080, UA, hP\u2080, UAmeas, UAunif, -, -\u27e9\n  rw [hAA'] at UAunif\n  have : d[UA # UA] \u2264 log K := rdist_le_of_isUniform_of_card_add_le h\u2080A hA UAunif UAmeas\n  rw [\u2190 sumset_eq_sub] at hA\n  let p : refPackage \u03a9\u2080 \u03a9\u2080 G := \u27e8UA, UA, UAmeas, UAmeas, 1/9, (by norm_num), (by norm_num)\u27e9\n  -- entropic PFR gives a subgroup `H` which is close to `A` for the Rusza distance\n  rcases entropic_PFR_conjecture p (by norm_num) with \u27e8H, \u03a9\u2081, m\u03a9\u2081, UH, hP\u2081, UHmeas, UHunif, hUH\u27e9\n  rcases independent_copies_two UAmeas UHmeas\n    with \u27e8\u03a9, m\u03a9, VA, VH, hP, VAmeas, VHmeas, Vindep, idVA, idVH\u27e9\n  have VAunif : IsUniform A VA := UAunif.of_identDistrib idVA.symm $ measurableSet_discrete _\n  have VA'unif := VAunif\n  rw [\u2190 hAA'] at VA'unif\n  have VHunif : IsUniform H VH := UHunif.of_identDistrib idVH.symm $ measurableSet_discrete _\n  let H' := (H:Set G).toFinite.toFinset\n  have hHH' : H' = (H:Set G) := Finite.coe_toFinset (toFinite (H:Set G))\n  have VH'unif := VHunif\n  rw [\u2190 hHH'] at VH'unif\n\n  have : d[VA # VH] \u2264 11/2 * log K := by rw [idVA.rdist_eq idVH]; linarith\n  have H_pos : (0 : \u211d) < Nat.card (H : Set G) := by\n    have : 0 < Nat.card (H : Set G) := Nat.card_pos\n    positivity\n  have VA_ent : H[VA] = log (Nat.card A) := IsUniform.entropy_eq' VAunif VAmeas\n  have VH_ent : H[VH] = log (Nat.card (H : Set G)) := IsUniform.entropy_eq' VHunif VHmeas\n  have Icard : |log (Nat.card A) - log (Nat.card (H : Set G))| \u2264 11 * log K := by\n    rw [\u2190 VA_ent, \u2190 VH_ent]\n    apply (diff_ent_le_rdist VAmeas VHmeas).trans\n    linarith\n  have IAH : Nat.card A \u2264 K ^ 11 * Nat.card (H : Set G) := by\n    have : log (Nat.card A) \u2264 log K * 11 + log (Nat.card (H : Set G)) := by\n      linarith [(le_abs_self _).trans Icard]\n    convert exp_monotone this using 1\n    \u00b7 exact (exp_log A_pos).symm\n    \u00b7 rw [exp_add, exp_log H_pos, \u2190 rpow_def_of_pos K_pos]\n  have IHA : Nat.card (H : Set G) \u2264 K ^ 11 * Nat.card A := by\n    have : log (Nat.card (H : Set G)) \u2264 log K * 11 + log (Nat.card A) := by\n      linarith [(neg_le_abs _).trans Icard]\n    convert exp_monotone this using 1\n    \u00b7 exact (exp_log H_pos).symm\n    \u00b7 rw [exp_add, exp_log A_pos, \u2190 rpow_def_of_pos K_pos]\n  -- entropic PFR shows that the entropy of `VA - VH` is small\n  have I : log K * (-11/2) + log (Nat.card A) * (-1/2) + log (Nat.card (H : Set G)) * (-1/2)\n      \u2264 - H[VA - VH] := by\n    rw [Vindep.rdist_eq VAmeas VHmeas] at this\n    have : H[VA] = log (Nat.card A) := IsUniform.entropy_eq' VAunif VAmeas\n    have : H[VH] = log (Nat.card (H : Set G)) := IsUniform.entropy_eq' VHunif VHmeas\n    linarith\n  -- therefore, there exists a point `x\u2080` which is attained by `VA - VH` with a large probability\n  obtain \u27e8x\u2080, h\u2080\u27e9 : \u2203 x\u2080 : G, rexp (- H[VA - VH]) \u2264 (\u2119 : Measure \u03a9).real ((VA - VH) \u207b\u00b9' {x\u2080}) :=\n    prob_ge_exp_neg_entropy' _ ((VAmeas.sub VHmeas).comp measurable_id')\n  -- massage the previous inequality to get that `A \u2229 (H + {x\u2080})` is large\n  have J : K ^ (-11/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (1/2) \u2264\n      Nat.card (A \u2229 (H + {x\u2080}) : Set G) := by\n    rw [VA'unif.measureReal_preimage_sub VAmeas VH'unif VHmeas Vindep] at h\u2080\n    have := (Real.exp_monotone I).trans h\u2080\n    have hAA'_card : Nat.card A' = Nat.card A := congrArg Nat.card (congrArg Subtype hAA')\n    have hHH'_card : Nat.card H' = Nat.card (H : Set G) := congrArg Nat.card (congrArg Subtype hHH')\n    rw [hAA'_card, hHH'_card, le_div_iff] at this\n    convert this using 1\n    . rw [exp_add, exp_add, \u2190 rpow_def_of_pos K_pos, \u2190 rpow_def_of_pos A_pos, \u2190 rpow_def_of_pos H_pos]\n      rpow_ring\n      norm_num\n    . rw [hAA', hHH']\n    positivity\n\n  have Hne : Set.Nonempty (A \u2229 (H + {x\u2080} : Set G)) := by\n    by_contra h'\n    have : (0 : \u211d) < Nat.card (A \u2229 (H + {x\u2080}) : Set G) := lt_of_lt_of_le (by positivity) J\n    simp only [Nat.card_eq_fintype_card, card_of_isEmpty, CharP.cast_eq_zero, lt_self_iff_false,\n      not_nonempty_iff_eq_empty.1 h'] at this\n  /- use Rusza covering lemma to cover `A` by few translates of `A \u2229 (H + {x\u2080}) - A \u2229 (H + {x\u2080})`\n  (which is contained in `H`). The number of translates is at most\n  `#(A + (A \u2229 (H + {x\u2080}))) / #(A \u2229 (H + {x\u2080}))`, where the numerator is controlled as this is\n  a subset of `A + A`, and the denominator is bounded below by the previous inequality`. -/\n  rcases Set.exists_subset_add_sub (toFinite A) (toFinite (A \u2229 ((H + {x\u2080} : Set G)))) Hne with\n    \u27e8u, hu, Au, -\u27e9\n  have Iu : Nat.card u \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2) := by\n    have : (0 : \u211d) \u2264 Nat.card u := by simp\n    have Z1 := mul_le_mul_of_nonneg_left J this\n    have Z2 : (Nat.card u * Nat.card (A \u2229 (H + {x\u2080}) : Set G) : \u211d)\n      \u2264 Nat.card (A + A \u2229 (\u2191H + {x\u2080})) := by norm_cast\n    have Z3 : (Nat.card (A + A \u2229 (\u2191H + {x\u2080})) : \u211d) \u2264 K * Nat.card A := by\n      apply le_trans _ hA\n      simp only [Nat.cast_le]\n      apply Nat.card_mono (toFinite _)\n      apply add_subset_add_left (inter_subset_left _ _)\n    have : 0 \u2264 K ^ (11/2) * Nat.card A ^ (-1/2) * Nat.card (H : Set G) ^ (-1/2) := by positivity\n    have T := mul_le_mul_of_nonneg_left ((Z1.trans Z2).trans Z3) this\n    convert T using 1 <;> rpow_ring <;> norm_num\n  have A_subset_uH : A \u2286 u + H := by\n    rw [add_sub_assoc] at Au\n    refine Au.trans $ add_subset_add_left $\n      (sub_subset_sub (inter_subset_right ..) (inter_subset_right ..)).trans ?_\n    rw [add_sub_add_comm, singleton_sub_singleton, sub_self]\n    simp\n  exact \u27e8H, u, Iu, IHA, IAH, A_subset_uH\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 108, "proofLengthTokens": 5869}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V + x` with probability `# (A \u2229 (B + x)) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) (x : G) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {x})\n      = Nat.card (A \u2229 (B + {x}) : Set G) / (Nat.card A * Nat.card B) := by\n  classical\n  let W := fun \u03c9 \u21a6 V \u03c9 + x\n  have Wunif : IsUniform (B + {x} : Set G) W := by\n    convert Vunif.comp (add_left_injective x)\n    simp\n  have Wmeas : Measurable W := Vmeas.add_const _\n  have UWindep : IndepFun U W := by\n    have : Measurable (fun g \u21a6 g + x) := measurable_add_const x\n    exact hindep.comp measurable_id this\n  have : (U - V) \u207b\u00b9' {x} = (U - W) \u207b\u00b9' {0} := by\n    ext \u03c9\n    simp only [W, mem_preimage, Pi.add_apply, mem_singleton_iff, Pi.sub_apply, \u2190 sub_eq_zero (b := x)]\n    abel_nf\n  have h : (B:Set G)+{x} = (B+{x}:Finset G) := by simp\n  rw [h] at Wunif\n  rw [this, Uunif.measureReal_preimage_sub_zero Umeas Wunif Wmeas UWindep]\n  congr 3\n  . rw [add_singleton]; simp\n  convert Finset.card_vadd_finset (AddOpposite.op x) B\n  . simp\n  simp\n\nend ProbabilityTheory\n\n\n/-- Record positivity results that are useful in the proof of PFR. -/\nlemma PFR_conjecture_pos_aux {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A - A) := by\n    have : Nonempty (A - A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.sub h\u2080A h\u2080A)\n    have : Finite (A - A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nlemma PFR_conjecture_pos_aux' {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A + A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A + A) := by\n    have : Nonempty (A + A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.add h\u2080A h\u2080A)\n    have : Finite (A + A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nvariable {G : Type*} [AddCommGroup G] [MeasurableSpace G]\n  [MeasurableSingletonClass G] {A : Set G} [Finite A] {K : \u211d} [Countable G]\n\n/-- A uniform distribution on a set with doubling constant `K` has self Rusza distance\nat most `log K`. -/\ntheorem rdist_le_of_isUniform_of_card_add_le (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A)\n    {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U\u2080 : \u03a9 \u2192 G}\n    (U\u2080unif : IsUniform A U\u2080) (U\u2080meas : Measurable U\u2080) : d[U\u2080 # U\u2080] \u2264 log K := by\n  obtain \u27e8A_pos, AA_pos, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux h\u2080A hA\n  rcases independent_copies_two U\u2080meas U\u2080meas with \u27e8\u03a9, m\u03a9, U, U', hP, hU, hU', UU'_indep, idU, idU'\u27e9\n  have Uunif : IsUniform A U := U\u2080unif.of_identDistrib idU.symm $ measurableSet_discrete _\n  have U'unif : IsUniform A U' := U\u2080unif.of_identDistrib idU'.symm $ measurableSet_discrete _\n  have IU : d[U # U'] \u2264 log K := by\n    have I : H[U - U'] \u2264 log (Nat.card (A - A)) := by\n      convert entropy_le_log_card_of_mem (A := (A-A).toFinite.toFinset) ?_ ?_ with x\n      . simp\n        exact Iff.rfl\n      . measurability\n      filter_upwards [Uunif.ae_mem, U'unif.ae_mem] with \u03c9 h1 h2\n      simp\n      exact Set.sub_mem_sub h1 h2\n    have J : log (Nat.card (A - A)) \u2264 log K + log (Nat.card A) := by\n      apply (log_le_log AA_pos hA).trans (le_of_eq _)\n      rw [log_mul K_pos.ne' A_pos.ne']\n--    have : H[U + U'] = H[U - U'] := by congr; simp\n    rw [UU'_indep.rdist_eq hU hU', IsUniform.entropy_eq' Uunif hU, IsUniform.entropy_eq' U'unif hU']\n    linarith\n  rwa [idU.rdist_eq idU'] at IU\n\nvariable [ElementaryAddCommGroup G 2] [Fintype G]\n\nlemma sumset_eq_sub : A + A = A - A := by\n  rw [\u2190 Set.image2_add, \u2190 Set.image2_sub]\n  congr! 1 with a _ b _\n  show a + b = a - b\n  simp\n\n/-- Auxiliary statement towards the polynomial Freiman-Ruzsa (PFR) conjecture: if $A$ is a subset of\nan elementary abelian 2-group of doubling constant at most $K$, then there exists a subgroup $H$\nsuch that $A$ can be covered by at most $K^{13/2} |A|^{1/2} / |H|^{1/2}$ cosets of $H$, and $H$ has\nthe same cardinality as $A$ up to a multiplicative factor $K^11$. -/\nlemma PFR_conjecture_aux (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    \u2203 (H : AddSubgroup G) (c : Set G),\n    Nat.card c \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2)\n      \u2227 Nat.card H \u2264 K ^ 11 * Nat.card A \u2227 Nat.card A \u2264 K ^ 11 * Nat.card H \u2227 A \u2286 c + H := by\n  classical\n  let _mG : MeasurableSpace G := \u22a4\n  rw [sumset_eq_sub] at hA\n  have : MeasurableSingletonClass G := \u27e8\u03bb _ \u21a6 trivial\u27e9\n  obtain \u27e8A_pos, -, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux h\u2080A hA\n  let A' := A.toFinite.toFinset\n  have h\u2080A' : Finset.Nonempty A' := by\n    simp [A', Finset.Nonempty]\n    exact h\u2080A\n  have hAA' : A' = A := Finite.coe_toFinset (toFinite A)\n  rcases exists_isUniform_measureSpace A' h\u2080A' with \u27e8\u03a9\u2080, m\u03a9\u2080, UA, hP\u2080, UAmeas, UAunif, -, -\u27e9\n  rw [hAA'] at UAunif\n  have : d[UA # UA] \u2264 log K := rdist_le_of_isUniform_of_card_add_le h\u2080A hA UAunif UAmeas\n  rw [\u2190 sumset_eq_sub] at hA\n  let p : refPackage \u03a9\u2080 \u03a9\u2080 G := \u27e8UA, UA, UAmeas, UAmeas, 1/9, (by norm_num), (by norm_num)\u27e9\n  -- entropic PFR gives a subgroup `H` which is close to `A` for the Rusza distance\n  rcases entropic_PFR_conjecture p (by norm_num) with \u27e8H, \u03a9\u2081, m\u03a9\u2081, UH, hP\u2081, UHmeas, UHunif, hUH\u27e9\n  rcases independent_copies_two UAmeas UHmeas\n    with \u27e8\u03a9, m\u03a9, VA, VH, hP, VAmeas, VHmeas, Vindep, idVA, idVH\u27e9\n  have VAunif : IsUniform A VA := UAunif.of_identDistrib idVA.symm $ measurableSet_discrete _\n  have VA'unif := VAunif\n  rw [\u2190 hAA'] at VA'unif\n  have VHunif : IsUniform H VH := UHunif.of_identDistrib idVH.symm $ measurableSet_discrete _\n  let H' := (H:Set G).toFinite.toFinset\n  have hHH' : H' = (H:Set G) := Finite.coe_toFinset (toFinite (H:Set G))\n  have VH'unif := VHunif\n  rw [\u2190 hHH'] at VH'unif\n\n  have : d[VA # VH] \u2264 11/2 * log K := by rw [idVA.rdist_eq idVH]; linarith\n  have H_pos : (0 : \u211d) < Nat.card (H : Set G) := by\n    have : 0 < Nat.card (H : Set G) := Nat.card_pos\n    positivity\n  have VA_ent : H[VA] = log (Nat.card A) := IsUniform.entropy_eq' VAunif VAmeas\n  have VH_ent : H[VH] = log (Nat.card (H : Set G)) := IsUniform.entropy_eq' VHunif VHmeas\n  have Icard : |log (Nat.card A) - log (Nat.card (H : Set G))| \u2264 11 * log K := by\n    rw [\u2190 VA_ent, \u2190 VH_ent]\n    apply (diff_ent_le_rdist VAmeas VHmeas).trans\n    linarith\n  have IAH : Nat.card A \u2264 K ^ 11 * Nat.card (H : Set G) := by\n    have : log (Nat.card A) \u2264 log K * 11 + log (Nat.card (H : Set G)) := by\n      linarith [(le_abs_self _).trans Icard]\n    convert exp_monotone this using 1\n    \u00b7 exact (exp_log A_pos).symm\n    \u00b7 rw [exp_add, exp_log H_pos, \u2190 rpow_def_of_pos K_pos]\n  have IHA : Nat.card (H : Set G) \u2264 K ^ 11 * Nat.card A := by\n    have : log (Nat.card (H : Set G)) \u2264 log K * 11 + log (Nat.card A) := by\n      linarith [(neg_le_abs _).trans Icard]\n    convert exp_monotone this using 1\n    \u00b7 exact (exp_log H_pos).symm\n    \u00b7 rw [exp_add, exp_log A_pos, \u2190 rpow_def_of_pos K_pos]\n  -- entropic PFR shows that the entropy of `VA - VH` is small\n  have I : log K * (-11/2) + log (Nat.card A) * (-1/2) + log (Nat.card (H : Set G)) * (-1/2)\n      \u2264 - H[VA - VH] := by\n    rw [Vindep.rdist_eq VAmeas VHmeas] at this\n    have : H[VA] = log (Nat.card A) := IsUniform.entropy_eq' VAunif VAmeas\n    have : H[VH] = log (Nat.card (H : Set G)) := IsUniform.entropy_eq' VHunif VHmeas\n    linarith\n  -- therefore, there exists a point `x\u2080` which is attained by `VA - VH` with a large probability\n  obtain \u27e8x\u2080, h\u2080\u27e9 : \u2203 x\u2080 : G, rexp (- H[VA - VH]) \u2264 (\u2119 : Measure \u03a9).real ((VA - VH) \u207b\u00b9' {x\u2080}) :=\n    prob_ge_exp_neg_entropy' _ ((VAmeas.sub VHmeas).comp measurable_id')\n  -- massage the previous inequality to get that `A \u2229 (H + {x\u2080})` is large\n  have J : K ^ (-11/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (1/2) \u2264\n      Nat.card (A \u2229 (H + {x\u2080}) : Set G) := by\n    rw [VA'unif.measureReal_preimage_sub VAmeas VH'unif VHmeas Vindep] at h\u2080\n    have := (Real.exp_monotone I).trans h\u2080\n    have hAA'_card : Nat.card A' = Nat.card A := congrArg Nat.card (congrArg Subtype hAA')\n    have hHH'_card : Nat.card H' = Nat.card (H : Set G) := congrArg Nat.card (congrArg Subtype hHH')\n    rw [hAA'_card, hHH'_card, le_div_iff] at this\n    convert this using 1\n    . rw [exp_add, exp_add, \u2190 rpow_def_of_pos K_pos, \u2190 rpow_def_of_pos A_pos, \u2190 rpow_def_of_pos H_pos]\n      rpow_ring\n      norm_num\n    . rw [hAA', hHH']\n    positivity\n\n  have Hne : Set.Nonempty (A \u2229 (H + {x\u2080} : Set G)) := by\n    by_contra h'\n    have : (0 : \u211d) < Nat.card (A \u2229 (H + {x\u2080}) : Set G) := lt_of_lt_of_le (by positivity) J\n    simp only [Nat.card_eq_fintype_card, card_of_isEmpty, CharP.cast_eq_zero, lt_self_iff_false,\n      not_nonempty_iff_eq_empty.1 h'] at this\n  /- use Rusza covering lemma to cover `A` by few translates of `A \u2229 (H + {x\u2080}) - A \u2229 (H + {x\u2080})`\n  (which is contained in `H`). The number of translates is at most\n  `#(A + (A \u2229 (H + {x\u2080}))) / #(A \u2229 (H + {x\u2080}))`, where the numerator is controlled as this is\n  a subset of `A + A`, and the denominator is bounded below by the previous inequality`. -/\n  rcases Set.exists_subset_add_sub (toFinite A) (toFinite (A \u2229 ((H + {x\u2080} : Set G)))) Hne with\n    \u27e8u, hu, Au, -\u27e9\n  have Iu : Nat.card u \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2) := by\n    have : (0 : \u211d) \u2264 Nat.card u := by simp\n    have Z1 := mul_le_mul_of_nonneg_left J this\n    have Z2 : (Nat.card u * Nat.card (A \u2229 (H + {x\u2080}) : Set G) : \u211d)\n      \u2264 Nat.card (A + A \u2229 (\u2191H + {x\u2080})) := by norm_cast\n    have Z3 : (Nat.card (A + A \u2229 (\u2191H + {x\u2080})) : \u211d) \u2264 K * Nat.card A := by\n      apply le_trans _ hA\n      simp only [Nat.cast_le]\n      apply Nat.card_mono (toFinite _)\n      apply add_subset_add_left (inter_subset_left _ _)\n    have : 0 \u2264 K ^ (11/2) * Nat.card A ^ (-1/2) * Nat.card (H : Set G) ^ (-1/2) := by positivity\n    have T := mul_le_mul_of_nonneg_left ((Z1.trans Z2).trans Z3) this\n    convert T using 1 <;> rpow_ring <;> norm_num\n  have A_subset_uH : A \u2286 u + H := by\n    rw [add_sub_assoc] at Au\n    refine Au.trans $ add_subset_add_left $\n      (sub_subset_sub (inter_subset_right ..) (inter_subset_right ..)).trans ?_\n    rw [add_sub_add_comm, singleton_sub_singleton, sub_self]\n    simp\n  exact \u27e8H, u, Iu, IHA, IAH, A_subset_uH\u27e9\n\n\n/-- The polynomial Freiman-Ruzsa (PFR) conjecture: if $A$ is a subset of an elementary abelian\n2-group of doubling constant at most $K$, then $A$ can be covered by at most $2K^{12}$ cosets of\na subgroup of cardinality at most $|A|$. -/\n", "theoremStatement": "theorem PFR_conjecture (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n     \u2203 (H : AddSubgroup G) (c : Set G),\n      Nat.card c < 2 * K ^ 12 \u2227 Nat.card H \u2264 Nat.card A \u2227 A \u2286 c + H", "fileCreated": "516205a 20231114", "theoremCreated": "b94162e 20231128", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 281, "tokenPositionInFile": 14390, "theoremPositionInFile": 8}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8A_pos, -, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A + A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux' h\u2080A hA\n  -- consider the subgroup `H` given by Lemma `PFR_conjecture_aux`.\n  obtain \u27e8H, c, hc, IHA, IAH, A_subs_cH\u27e9 : \u2203 (H : AddSubgroup G) (c : Set G),\n    Nat.card c \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2)\n      \u2227 Nat.card (H : Set G) \u2264 K ^ 11 * Nat.card A \u2227 Nat.card A \u2264 K ^ 11 * Nat.card (H : Set G)\n      \u2227 A \u2286 c + H :=\n    PFR_conjecture_aux h\u2080A hA\n  have H_pos : (0 : \u211d) < Nat.card (H : Set G) := by\n    have : 0 < Nat.card (H : Set G) := Nat.card_pos; positivity\n  rcases le_or_lt (Nat.card (H : Set G)) (Nat.card A) with h|h\n  -- If `#H \u2264 #A`, then `H` satisfies the conclusion of the theorem\n  \u00b7 refine \u27e8H, c, ?_, h, A_subs_cH\u27e9\n    calc\n    Nat.card c \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2) := hc\n    _ \u2264 K ^ (13/2) * (K ^ 11 * Nat.card (H : Set G)) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2) := by\n      gcongr\n    _ = K ^ 12 := by rpow_ring; norm_num\n    _ < 2 * K ^ 12 := by linarith [show 0 < K ^ 12 by positivity]\n  -- otherwise, we decompose `H` into cosets of one of its subgroups `H'`, chosen so that\n  -- `#A / 2 < #H' \u2264 #A`. This `H'` satisfies the desired conclusion.\n  \u00b7 obtain \u27e8H', IH'A, IAH', H'H\u27e9 : \u2203 H' : AddSubgroup G, Nat.card (H' : Set G) \u2264 Nat.card A\n          \u2227 Nat.card A < 2 * Nat.card (H' : Set G) \u2227 H' \u2264 H := by\n      have A_pos' : 0 < Nat.card A := mod_cast A_pos\n      exact ElementaryAddCommGroup.exists_subgroup_subset_card_le Nat.prime_two H h.le A_pos'.ne'\n    have : (Nat.card A / 2 : \u211d) < Nat.card (H' : Set G) := by\n      rw [div_lt_iff zero_lt_two, mul_comm]; norm_cast\n    have H'_pos : (0 : \u211d) < Nat.card (H' : Set G) := by\n      have : 0 < Nat.card (H' : Set G) := Nat.card_pos; positivity\n    obtain \u27e8u, HH'u, hu\u27e9 := AddSubgroup.exists_left_transversal_of_le H'H\n    refine \u27e8H', c + u, ?_, IH'A, by rwa [add_assoc, HH'u]\u27e9\n    calc\n    (Nat.card (c + u) : \u211d)\n      \u2264 Nat.card c * Nat.card u := mod_cast card_add_le\n    _ \u2264 (K ^ (13/2) * (Nat.card A) ^ (1 / 2) * (Nat.card (H : Set G) ^ (-1 / 2)))\n          * (Nat.card (H : Set G) / Nat.card (H' : Set G)) := by\n        gcongr\n        apply le_of_eq\n        rw [eq_div_iff H'_pos.ne']\n        norm_cast\n    _ < (K ^ (13/2) * (Nat.card A) ^ (1 / 2) * (Nat.card (H : Set G) ^ (-1 / 2)))\n          * (Nat.card (H : Set G) / (Nat.card A / 2)) := by\n        gcongr\n    _ = 2 * K ^ (13/2) * (Nat.card A) ^ (-1/2) * (Nat.card (H : Set G)) ^ (1/2) := by\n        have : (0 : \u211d) < Nat.card H := H_pos\n        field_simp\n        rpow_ring\n        norm_num\n    _ \u2264 2 * K ^ (13/2) * (Nat.card A) ^ (-1/2) * (K ^ 11 * Nat.card A) ^ (1/2) := by\n        gcongr\n    _ = 2 * K ^ 12 := by\n        rpow_ring\n        norm_num", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 54, "proofLengthTokens": 2783}}
{"srcContext": "import Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.GroupTheory.Complement\nimport Mathlib.GroupTheory.OrderOfElement\nimport PFR.Mathlib.GroupTheory.Subgroup.Pointwise\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Tactic.RPowSimp\nimport PFR.TauFunctional\nimport PFR.EntropyPFR\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : \u211d) ($y : \u211d))\n\n/-!\n# Polynomial Freiman-Ruzsa conjecture\n\nHere we prove the polynomial Freiman-Ruzsa conjecture.\n-/\n\nopen ProbabilityTheory MeasureTheory Real Set Fintype Function\nopen scoped BigOperators Pointwise\n\nuniverse u\n\nnamespace ProbabilityTheory\nvariable {G \u03a9 : Type*} [AddCommGroup G] [Fintype G]\n    [MeasurableSpace G] [MeasurableSingletonClass G] {A B : Finset G}\n    [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U V : \u03a9 \u2192 G}\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V` with probability `# (A \u2229 B) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub_zero (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {0})\n      = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n  have : (U - V) \u207b\u00b9' {0} = \u22c3 (g : G), (U \u207b\u00b9' {g} \u2229 V\u207b\u00b9' {g}) := by\n    ext \u03c9; simp [sub_eq_zero, eq_comm]\n  rw [this, measureReal_iUnion_fintype _\n    (fun i \u21a6 (Umeas $ measurableSet_discrete _).inter $ Vmeas $ measurableSet_discrete _)]; swap\n  \u00b7 intro g g' hgg'\n    apply Set.disjoint_iff_inter_eq_empty.2\n    ext a\n    simp (config := {contextual := True}) [hgg']\n  classical\n  let W : Finset G := A \u2229 B\n  calc\n    \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p} \u2229 V \u207b\u00b9' {p})\n      = \u2211 p, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply sum_congr _ _ (fun g \u21a6 ?_)\n        rw [hindep.measureReal_inter_preimage_eq_mul (measurableSet_discrete _) $\n          measurableSet_discrete _]\n    _ = \u2211 p in W, (\u2119 : Measure \u03a9).real (U \u207b\u00b9' {p}) * (\u2119 : Measure \u03a9).real (V \u207b\u00b9' {p}) := by\n        apply (Finset.sum_subset W.subset_univ _).symm\n        intro i _ hi\n        replace hi : i \u2209 A \u2228 i \u2209 B := by simp [W] at hi; tauto\n        rcases hi with h'i|h'i\n        \u00b7 simp [Uunif.measureReal_preimage_of_nmem h'i]\n        \u00b7 simp [Vunif.measureReal_preimage_of_nmem h'i]\n    _ = \u2211 p in W, (1 / Nat.card A : \u211d) * (1 / Nat.card B) := by\n        apply Finset.sum_congr rfl (fun i hi \u21a6 ?_)\n        replace hi : i \u2208 A \u2227 i \u2208 B := by simpa [W] using hi\n        rw [Uunif.measureReal_preimage_of_mem (by trivial) hi.1,\n            Vunif.measureReal_preimage_of_mem (by trivial) hi.2]\n    _ = (W.card : \u211d) / (Nat.card A * Nat.card B) := by simp [div_eq_inv_mul]; ring\n    _ = Nat.card (A \u2229 B : Set G) / (Nat.card A * Nat.card B) := by\n        congr\n        rw [\u2190 Finset.coe_inter, Nat.card_eq_fintype_card, Fintype.card_ofFinset]\n        simp\n\n/-- Given two independent random variables `U` and `V` uniformly distributed respectively on `A`\nand `B`, then `U = V + x` with probability `# (A \u2229 (B + x)) / #A \u2b1d #B`. -/\nlemma IsUniform.measureReal_preimage_sub (Uunif : IsUniform A U) (Umeas : Measurable U)\n    (Vunif : IsUniform B V) (Vmeas : Measurable V) (hindep : IndepFun U V) (x : G) :\n    (\u2119 : Measure \u03a9).real ((U - V) \u207b\u00b9' {x})\n      = Nat.card (A \u2229 (B + {x}) : Set G) / (Nat.card A * Nat.card B) := by\n  classical\n  let W := fun \u03c9 \u21a6 V \u03c9 + x\n  have Wunif : IsUniform (B + {x} : Set G) W := by\n    convert Vunif.comp (add_left_injective x)\n    simp\n  have Wmeas : Measurable W := Vmeas.add_const _\n  have UWindep : IndepFun U W := by\n    have : Measurable (fun g \u21a6 g + x) := measurable_add_const x\n    exact hindep.comp measurable_id this\n  have : (U - V) \u207b\u00b9' {x} = (U - W) \u207b\u00b9' {0} := by\n    ext \u03c9\n    simp only [W, mem_preimage, Pi.add_apply, mem_singleton_iff, Pi.sub_apply, \u2190 sub_eq_zero (b := x)]\n    abel_nf\n  have h : (B:Set G)+{x} = (B+{x}:Finset G) := by simp\n  rw [h] at Wunif\n  rw [this, Uunif.measureReal_preimage_sub_zero Umeas Wunif Wmeas UWindep]\n  congr 3\n  . rw [add_singleton]; simp\n  convert Finset.card_vadd_finset (AddOpposite.op x) B\n  . simp\n  simp\n\nend ProbabilityTheory\n\n\n/-- Record positivity results that are useful in the proof of PFR. -/\nlemma PFR_conjecture_pos_aux {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A - A) := by\n    have : Nonempty (A - A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.sub h\u2080A h\u2080A)\n    have : Finite (A - A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nlemma PFR_conjecture_pos_aux' {G : Type*} [AddCommGroup G] {A : Set G} [Finite A] {K : \u211d} (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A + A) \u2227 0 < K := by\n  have card_AA_pos : (0 : \u211d) < Nat.card (A + A) := by\n    have : Nonempty (A + A) := Set.nonempty_coe_sort.mpr (Set.Nonempty.add h\u2080A h\u2080A)\n    have : Finite (A + A) := finite_coe_iff.mpr (Finite.image2 _ (Set.toFinite A) (Set.toFinite A))\n    simp [Nat.cast_pos, Nat.card_pos_iff]\n  have KA_pos : 0 < K \u2227 (0 : \u211d) < Nat.card A := by\n    have I : \u00ac ((Nat.card A : \u211d) < 0) := by simp\n    simpa [Nat.cast_pos, I, and_false, or_false] using mul_pos_iff.1 (card_AA_pos.trans_le hA)\n  exact \u27e8KA_pos.2, card_AA_pos, KA_pos.1\u27e9\n\nvariable {G : Type*} [AddCommGroup G] [MeasurableSpace G]\n  [MeasurableSingletonClass G] {A : Set G} [Finite A] {K : \u211d} [Countable G]\n\n/-- A uniform distribution on a set with doubling constant `K` has self Rusza distance\nat most `log K`. -/\ntheorem rdist_le_of_isUniform_of_card_add_le (h\u2080A : A.Nonempty) (hA : Nat.card (A - A) \u2264 K * Nat.card A)\n    {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)] {U\u2080 : \u03a9 \u2192 G}\n    (U\u2080unif : IsUniform A U\u2080) (U\u2080meas : Measurable U\u2080) : d[U\u2080 # U\u2080] \u2264 log K := by\n  obtain \u27e8A_pos, AA_pos, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux h\u2080A hA\n  rcases independent_copies_two U\u2080meas U\u2080meas with \u27e8\u03a9, m\u03a9, U, U', hP, hU, hU', UU'_indep, idU, idU'\u27e9\n  have Uunif : IsUniform A U := U\u2080unif.of_identDistrib idU.symm $ measurableSet_discrete _\n  have U'unif : IsUniform A U' := U\u2080unif.of_identDistrib idU'.symm $ measurableSet_discrete _\n  have IU : d[U # U'] \u2264 log K := by\n    have I : H[U - U'] \u2264 log (Nat.card (A - A)) := by\n      convert entropy_le_log_card_of_mem (A := (A-A).toFinite.toFinset) ?_ ?_ with x\n      . simp\n        exact Iff.rfl\n      . measurability\n      filter_upwards [Uunif.ae_mem, U'unif.ae_mem] with \u03c9 h1 h2\n      simp\n      exact Set.sub_mem_sub h1 h2\n    have J : log (Nat.card (A - A)) \u2264 log K + log (Nat.card A) := by\n      apply (log_le_log AA_pos hA).trans (le_of_eq _)\n      rw [log_mul K_pos.ne' A_pos.ne']\n--    have : H[U + U'] = H[U - U'] := by congr; simp\n    rw [UU'_indep.rdist_eq hU hU', IsUniform.entropy_eq' Uunif hU, IsUniform.entropy_eq' U'unif hU']\n    linarith\n  rwa [idU.rdist_eq idU'] at IU\n\nvariable [ElementaryAddCommGroup G 2] [Fintype G]\n\nlemma sumset_eq_sub : A + A = A - A := by\n  rw [\u2190 Set.image2_add, \u2190 Set.image2_sub]\n  congr! 1 with a _ b _\n  show a + b = a - b\n  simp\n\n/-- Auxiliary statement towards the polynomial Freiman-Ruzsa (PFR) conjecture: if $A$ is a subset of\nan elementary abelian 2-group of doubling constant at most $K$, then there exists a subgroup $H$\nsuch that $A$ can be covered by at most $K^{13/2} |A|^{1/2} / |H|^{1/2}$ cosets of $H$, and $H$ has\nthe same cardinality as $A$ up to a multiplicative factor $K^11$. -/\nlemma PFR_conjecture_aux (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    \u2203 (H : AddSubgroup G) (c : Set G),\n    Nat.card c \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2)\n      \u2227 Nat.card H \u2264 K ^ 11 * Nat.card A \u2227 Nat.card A \u2264 K ^ 11 * Nat.card H \u2227 A \u2286 c + H := by\n  classical\n  let _mG : MeasurableSpace G := \u22a4\n  rw [sumset_eq_sub] at hA\n  have : MeasurableSingletonClass G := \u27e8\u03bb _ \u21a6 trivial\u27e9\n  obtain \u27e8A_pos, -, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A - A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux h\u2080A hA\n  let A' := A.toFinite.toFinset\n  have h\u2080A' : Finset.Nonempty A' := by\n    simp [A', Finset.Nonempty]\n    exact h\u2080A\n  have hAA' : A' = A := Finite.coe_toFinset (toFinite A)\n  rcases exists_isUniform_measureSpace A' h\u2080A' with \u27e8\u03a9\u2080, m\u03a9\u2080, UA, hP\u2080, UAmeas, UAunif, -, -\u27e9\n  rw [hAA'] at UAunif\n  have : d[UA # UA] \u2264 log K := rdist_le_of_isUniform_of_card_add_le h\u2080A hA UAunif UAmeas\n  rw [\u2190 sumset_eq_sub] at hA\n  let p : refPackage \u03a9\u2080 \u03a9\u2080 G := \u27e8UA, UA, UAmeas, UAmeas, 1/9, (by norm_num), (by norm_num)\u27e9\n  -- entropic PFR gives a subgroup `H` which is close to `A` for the Rusza distance\n  rcases entropic_PFR_conjecture p (by norm_num) with \u27e8H, \u03a9\u2081, m\u03a9\u2081, UH, hP\u2081, UHmeas, UHunif, hUH\u27e9\n  rcases independent_copies_two UAmeas UHmeas\n    with \u27e8\u03a9, m\u03a9, VA, VH, hP, VAmeas, VHmeas, Vindep, idVA, idVH\u27e9\n  have VAunif : IsUniform A VA := UAunif.of_identDistrib idVA.symm $ measurableSet_discrete _\n  have VA'unif := VAunif\n  rw [\u2190 hAA'] at VA'unif\n  have VHunif : IsUniform H VH := UHunif.of_identDistrib idVH.symm $ measurableSet_discrete _\n  let H' := (H:Set G).toFinite.toFinset\n  have hHH' : H' = (H:Set G) := Finite.coe_toFinset (toFinite (H:Set G))\n  have VH'unif := VHunif\n  rw [\u2190 hHH'] at VH'unif\n\n  have : d[VA # VH] \u2264 11/2 * log K := by rw [idVA.rdist_eq idVH]; linarith\n  have H_pos : (0 : \u211d) < Nat.card (H : Set G) := by\n    have : 0 < Nat.card (H : Set G) := Nat.card_pos\n    positivity\n  have VA_ent : H[VA] = log (Nat.card A) := IsUniform.entropy_eq' VAunif VAmeas\n  have VH_ent : H[VH] = log (Nat.card (H : Set G)) := IsUniform.entropy_eq' VHunif VHmeas\n  have Icard : |log (Nat.card A) - log (Nat.card (H : Set G))| \u2264 11 * log K := by\n    rw [\u2190 VA_ent, \u2190 VH_ent]\n    apply (diff_ent_le_rdist VAmeas VHmeas).trans\n    linarith\n  have IAH : Nat.card A \u2264 K ^ 11 * Nat.card (H : Set G) := by\n    have : log (Nat.card A) \u2264 log K * 11 + log (Nat.card (H : Set G)) := by\n      linarith [(le_abs_self _).trans Icard]\n    convert exp_monotone this using 1\n    \u00b7 exact (exp_log A_pos).symm\n    \u00b7 rw [exp_add, exp_log H_pos, \u2190 rpow_def_of_pos K_pos]\n  have IHA : Nat.card (H : Set G) \u2264 K ^ 11 * Nat.card A := by\n    have : log (Nat.card (H : Set G)) \u2264 log K * 11 + log (Nat.card A) := by\n      linarith [(neg_le_abs _).trans Icard]\n    convert exp_monotone this using 1\n    \u00b7 exact (exp_log H_pos).symm\n    \u00b7 rw [exp_add, exp_log A_pos, \u2190 rpow_def_of_pos K_pos]\n  -- entropic PFR shows that the entropy of `VA - VH` is small\n  have I : log K * (-11/2) + log (Nat.card A) * (-1/2) + log (Nat.card (H : Set G)) * (-1/2)\n      \u2264 - H[VA - VH] := by\n    rw [Vindep.rdist_eq VAmeas VHmeas] at this\n    have : H[VA] = log (Nat.card A) := IsUniform.entropy_eq' VAunif VAmeas\n    have : H[VH] = log (Nat.card (H : Set G)) := IsUniform.entropy_eq' VHunif VHmeas\n    linarith\n  -- therefore, there exists a point `x\u2080` which is attained by `VA - VH` with a large probability\n  obtain \u27e8x\u2080, h\u2080\u27e9 : \u2203 x\u2080 : G, rexp (- H[VA - VH]) \u2264 (\u2119 : Measure \u03a9).real ((VA - VH) \u207b\u00b9' {x\u2080}) :=\n    prob_ge_exp_neg_entropy' _ ((VAmeas.sub VHmeas).comp measurable_id')\n  -- massage the previous inequality to get that `A \u2229 (H + {x\u2080})` is large\n  have J : K ^ (-11/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (1/2) \u2264\n      Nat.card (A \u2229 (H + {x\u2080}) : Set G) := by\n    rw [VA'unif.measureReal_preimage_sub VAmeas VH'unif VHmeas Vindep] at h\u2080\n    have := (Real.exp_monotone I).trans h\u2080\n    have hAA'_card : Nat.card A' = Nat.card A := congrArg Nat.card (congrArg Subtype hAA')\n    have hHH'_card : Nat.card H' = Nat.card (H : Set G) := congrArg Nat.card (congrArg Subtype hHH')\n    rw [hAA'_card, hHH'_card, le_div_iff] at this\n    convert this using 1\n    . rw [exp_add, exp_add, \u2190 rpow_def_of_pos K_pos, \u2190 rpow_def_of_pos A_pos, \u2190 rpow_def_of_pos H_pos]\n      rpow_ring\n      norm_num\n    . rw [hAA', hHH']\n    positivity\n\n  have Hne : Set.Nonempty (A \u2229 (H + {x\u2080} : Set G)) := by\n    by_contra h'\n    have : (0 : \u211d) < Nat.card (A \u2229 (H + {x\u2080}) : Set G) := lt_of_lt_of_le (by positivity) J\n    simp only [Nat.card_eq_fintype_card, card_of_isEmpty, CharP.cast_eq_zero, lt_self_iff_false,\n      not_nonempty_iff_eq_empty.1 h'] at this\n  /- use Rusza covering lemma to cover `A` by few translates of `A \u2229 (H + {x\u2080}) - A \u2229 (H + {x\u2080})`\n  (which is contained in `H`). The number of translates is at most\n  `#(A + (A \u2229 (H + {x\u2080}))) / #(A \u2229 (H + {x\u2080}))`, where the numerator is controlled as this is\n  a subset of `A + A`, and the denominator is bounded below by the previous inequality`. -/\n  rcases Set.exists_subset_add_sub (toFinite A) (toFinite (A \u2229 ((H + {x\u2080} : Set G)))) Hne with\n    \u27e8u, hu, Au, -\u27e9\n  have Iu : Nat.card u \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2) := by\n    have : (0 : \u211d) \u2264 Nat.card u := by simp\n    have Z1 := mul_le_mul_of_nonneg_left J this\n    have Z2 : (Nat.card u * Nat.card (A \u2229 (H + {x\u2080}) : Set G) : \u211d)\n      \u2264 Nat.card (A + A \u2229 (\u2191H + {x\u2080})) := by norm_cast\n    have Z3 : (Nat.card (A + A \u2229 (\u2191H + {x\u2080})) : \u211d) \u2264 K * Nat.card A := by\n      apply le_trans _ hA\n      simp only [Nat.cast_le]\n      apply Nat.card_mono (toFinite _)\n      apply add_subset_add_left (inter_subset_left _ _)\n    have : 0 \u2264 K ^ (11/2) * Nat.card A ^ (-1/2) * Nat.card (H : Set G) ^ (-1/2) := by positivity\n    have T := mul_le_mul_of_nonneg_left ((Z1.trans Z2).trans Z3) this\n    convert T using 1 <;> rpow_ring <;> norm_num\n  have A_subset_uH : A \u2286 u + H := by\n    rw [add_sub_assoc] at Au\n    refine Au.trans $ add_subset_add_left $\n      (sub_subset_sub (inter_subset_right ..) (inter_subset_right ..)).trans ?_\n    rw [add_sub_add_comm, singleton_sub_singleton, sub_self]\n    simp\n  exact \u27e8H, u, Iu, IHA, IAH, A_subset_uH\u27e9\n\n\n/-- The polynomial Freiman-Ruzsa (PFR) conjecture: if $A$ is a subset of an elementary abelian\n2-group of doubling constant at most $K$, then $A$ can be covered by at most $2K^{12}$ cosets of\na subgroup of cardinality at most $|A|$. -/\ntheorem PFR_conjecture (h\u2080A : A.Nonempty) (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n     \u2203 (H : AddSubgroup G) (c : Set G),\n      Nat.card c < 2 * K ^ 12 \u2227 Nat.card H \u2264 Nat.card A \u2227 A \u2286 c + H := by\n  obtain \u27e8A_pos, -, K_pos\u27e9 : (0 : \u211d) < Nat.card A \u2227 (0 : \u211d) < Nat.card (A + A) \u2227 0 < K :=\n    PFR_conjecture_pos_aux' h\u2080A hA\n  -- consider the subgroup `H` given by Lemma `PFR_conjecture_aux`.\n  obtain \u27e8H, c, hc, IHA, IAH, A_subs_cH\u27e9 : \u2203 (H : AddSubgroup G) (c : Set G),\n    Nat.card c \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2)\n      \u2227 Nat.card (H : Set G) \u2264 K ^ 11 * Nat.card A \u2227 Nat.card A \u2264 K ^ 11 * Nat.card (H : Set G)\n      \u2227 A \u2286 c + H :=\n    PFR_conjecture_aux h\u2080A hA\n  have H_pos : (0 : \u211d) < Nat.card (H : Set G) := by\n    have : 0 < Nat.card (H : Set G) := Nat.card_pos; positivity\n  rcases le_or_lt (Nat.card (H : Set G)) (Nat.card A) with h|h\n  -- If `#H \u2264 #A`, then `H` satisfies the conclusion of the theorem\n  \u00b7 refine \u27e8H, c, ?_, h, A_subs_cH\u27e9\n    calc\n    Nat.card c \u2264 K ^ (13/2) * (Nat.card A) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2) := hc\n    _ \u2264 K ^ (13/2) * (K ^ 11 * Nat.card (H : Set G)) ^ (1/2) * (Nat.card (H : Set G)) ^ (-1/2) := by\n      gcongr\n    _ = K ^ 12 := by rpow_ring; norm_num\n    _ < 2 * K ^ 12 := by linarith [show 0 < K ^ 12 by positivity]\n  -- otherwise, we decompose `H` into cosets of one of its subgroups `H'`, chosen so that\n  -- `#A / 2 < #H' \u2264 #A`. This `H'` satisfies the desired conclusion.\n  \u00b7 obtain \u27e8H', IH'A, IAH', H'H\u27e9 : \u2203 H' : AddSubgroup G, Nat.card (H' : Set G) \u2264 Nat.card A\n          \u2227 Nat.card A < 2 * Nat.card (H' : Set G) \u2227 H' \u2264 H := by\n      have A_pos' : 0 < Nat.card A := mod_cast A_pos\n      exact ElementaryAddCommGroup.exists_subgroup_subset_card_le Nat.prime_two H h.le A_pos'.ne'\n    have : (Nat.card A / 2 : \u211d) < Nat.card (H' : Set G) := by\n      rw [div_lt_iff zero_lt_two, mul_comm]; norm_cast\n    have H'_pos : (0 : \u211d) < Nat.card (H' : Set G) := by\n      have : 0 < Nat.card (H' : Set G) := Nat.card_pos; positivity\n    obtain \u27e8u, HH'u, hu\u27e9 := AddSubgroup.exists_left_transversal_of_le H'H\n    refine \u27e8H', c + u, ?_, IH'A, by rwa [add_assoc, HH'u]\u27e9\n    calc\n    (Nat.card (c + u) : \u211d)\n      \u2264 Nat.card c * Nat.card u := mod_cast card_add_le\n    _ \u2264 (K ^ (13/2) * (Nat.card A) ^ (1 / 2) * (Nat.card (H : Set G) ^ (-1 / 2)))\n          * (Nat.card (H : Set G) / Nat.card (H' : Set G)) := by\n        gcongr\n        apply le_of_eq\n        rw [eq_div_iff H'_pos.ne']\n        norm_cast\n    _ < (K ^ (13/2) * (Nat.card A) ^ (1 / 2) * (Nat.card (H : Set G) ^ (-1 / 2)))\n          * (Nat.card (H : Set G) / (Nat.card A / 2)) := by\n        gcongr\n    _ = 2 * K ^ (13/2) * (Nat.card A) ^ (-1/2) * (Nat.card (H : Set G)) ^ (1/2) := by\n        have : (0 : \u211d) < Nat.card H := H_pos\n        field_simp\n        rpow_ring\n        norm_num\n    _ \u2264 2 * K ^ (13/2) * (Nat.card A) ^ (-1/2) * (K ^ 11 * Nat.card A) ^ (1/2) := by\n        gcongr\n    _ = 2 * K ^ 12 := by\n        rpow_ring\n        norm_num\n\n/-- Corollary of `PFR_conjecture` in which the ambient group is not required to be finite (but) then\n$H$ and $c$ are finite. -/\n", "theoremStatement": "theorem PFR_conjecture' {G : Type*} [AddCommGroup G] [ElementaryAddCommGroup G 2]\n    {A : Set G} {K : \u211d} (h\u2080A : A.Nonempty) (Afin : A.Finite)\n    (hA : Nat.card (A + A) \u2264 K * Nat.card A) :\n    \u2203 (H : AddSubgroup G) (c : Set G), c.Finite \u2227 (H : Set G).Finite \u2227\n      Nat.card c < 2 * K ^ 12 \u2227 Nat.card H \u2264 Nat.card A \u2227 A \u2286 c + H", "fileCreated": "516205a 20231114", "theoremCreated": "12e0125 20231127", "file": "PFR/Main.lean", "positionMetadata": {"lineInFile": 340, "tokenPositionInFile": 17499, "theoremPositionInFile": 9}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  let G' := AddSubgroup.closure A\n  let G'fin : Fintype G' := by\n    exact Finite.fintype (ElementaryAddCommGroup.finite_closure Afin)\n  have G'Elem : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.subgroup _\n  let \u03b9 : G'\u2192+ G := G'.subtype\n  have \u03b9_inj : Injective \u03b9 := AddSubgroup.subtype_injective G'\n  let A' : Set G' := \u03b9 \u207b\u00b9' A\n  have A_rg : A \u2286 range \u03b9 := by\n    simp only [AddSubgroup.coeSubtype, Subtype.range_coe_subtype, SetLike.mem_coe, G', \u03b9]\n    exact AddSubgroup.subset_closure\n  have cardA' : Nat.card A' = Nat.card A := Nat.card_preimage_of_injective \u03b9_inj A_rg\n  have hA' : Nat.card (A' + A') \u2264 K * Nat.card A' := by\n    rwa [cardA', \u2190 preimage_add _ \u03b9_inj A_rg A_rg,\n         Nat.card_preimage_of_injective \u03b9_inj (add_subset_range _ A_rg A_rg)]\n  rcases PFR_conjecture (h\u2080A.preimage' A_rg) hA' with \u27e8H', c', hc', hH', hH'\u2082\u27e9\n  refine \u27e8AddSubgroup.map \u03b9 H', \u03b9 '' c', toFinite _, toFinite (\u03b9 '' H'), ?_, ?_, fun x hx \u21a6 ?_\u27e9\n  \u00b7 rwa [Nat.card_image_of_injective \u03b9_inj]\n  \u00b7 erw [Nat.card_image_of_injective \u03b9_inj, \u2190 cardA']\n    exact hH'\n  \u00b7 erw [\u2190 image_add]\n    exact \u27e8\u27e8x, AddSubgroup.subset_closure hx\u27e9, hH'\u2082 hx, rfl\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 22, "proofLengthTokens": 1141}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\n", "theoremStatement": "lemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 33, "tokenPositionInFile": 881, "theoremPositionInFile": 1}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 2, "proofLengthTokens": 63}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\n", "theoremStatement": "lemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 36, "tokenPositionInFile": 1008, "theoremPositionInFile": 2}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by rintro \u27e8x, rfl\u27e9; simp", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 24}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\n", "theoremStatement": "lemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B'", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1455, "theoremPositionInFile": 4}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 25, "proofLengthTokens": 1355}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\n", "theoremStatement": "lemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc']", "fileCreated": "25309ad 20231211", "theoremCreated": "1226201 20240103", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 82, "tokenPositionInFile": 3455, "theoremPositionInFile": 5}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 118, "proofLengthTokens": 8122}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\n", "theoremStatement": "lemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc']", "fileCreated": "25309ad 20231211", "theoremCreated": "22c3a7e 20240105", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 206, "tokenPositionInFile": 11946, "theoremPositionInFile": 6}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 8, "proofLengthTokens": 489}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\n", "theoremStatement": "instance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H)", "fileCreated": "25309ad 20231211", "theoremCreated": "9275a21 20240110", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 221, "tokenPositionInFile": 12769, "theoremPositionInFile": 7}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "\u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 73}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\n", "theoremStatement": "lemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y])", "fileCreated": "25309ad 20231211", "theoremCreated": "9275a21 20240110", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 240, "tokenPositionInFile": 13644, "theoremPositionInFile": 8}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 37, "proofLengthTokens": 1581}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n", "theoremStatement": "lemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc'])", "fileCreated": "25309ad 20231211", "theoremCreated": "9275a21 20240110", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 286, "tokenPositionInFile": 15840, "theoremPositionInFile": 9}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "@app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 91}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\n", "theoremStatement": "lemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']", "fileCreated": "25309ad 20231211", "theoremCreated": "9692d13 20240111", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 299, "tokenPositionInFile": 16657, "theoremPositionInFile": 10}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 94, "proofLengthTokens": 4970}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\n", "theoremStatement": "lemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc']", "fileCreated": "25309ad 20231211", "theoremCreated": "9692d13 20240111", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 403, "tokenPositionInFile": 22324, "theoremPositionInFile": 11}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 8, "proofLengthTokens": 340}}
{"srcContext": "ProbabilityTheory.IdentDistrib.tau_minimizes", "theoremStatement": "lemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 420, "tokenPositionInFile": 23051, "theoremPositionInFile": 12}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 59}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\n", "theoremStatement": "lemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 424, "tokenPositionInFile": 23253, "theoremPositionInFile": 13}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 11, "proofLengthTokens": 527}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\n", "theoremStatement": "lemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By])", "fileCreated": "25309ad 20231211", "theoremCreated": "58758d0 20240119", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 440, "tokenPositionInFile": 24430, "theoremPositionInFile": 14}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 132, "proofLengthTokens": 7864}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\n", "theoremStatement": "lemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S", "fileCreated": "25309ad 20231211", "theoremCreated": "b43acd3 20231224", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 595, "tokenPositionInFile": 33499, "theoremPositionInFile": 15}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 100}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\n", "theoremStatement": "lemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 604, "tokenPositionInFile": 33913, "theoremPositionInFile": 17}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 4, "proofLengthTokens": 56}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\n", "theoremStatement": "lemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G", "fileCreated": "25309ad 20231211", "theoremCreated": "f86b5a6 20231231", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 610, "tokenPositionInFile": 34124, "theoremPositionInFile": 18}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 4, "proofLengthTokens": 118}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\n", "theoremStatement": "lemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf)", "fileCreated": "25309ad 20231211", "theoremCreated": "f025369 20231228", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 623, "tokenPositionInFile": 34643, "theoremPositionInFile": 19}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 15, "proofLengthTokens": 458}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\n", "theoremStatement": "lemma torsion_free : AddMonoid.IsTorsionFree G", "fileCreated": "25309ad 20231211", "theoremCreated": "f025369 20231228", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 641, "tokenPositionInFile": 35373, "theoremPositionInFile": 20}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 7, "proofLengthTokens": 259}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\n", "theoremStatement": "lemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G)", "fileCreated": "25309ad 20231211", "theoremCreated": "f025369 20231228", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 650, "tokenPositionInFile": 35818, "theoremPositionInFile": 21}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 88, "proofLengthTokens": 4044}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G\u2082 \u2264 G and H' is a subgroup of G\u29f8G\u2082, then there is a canonical isomorphism between H\u29f8H' and G\u29f8N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\n", "theoremStatement": "lemma third_iso {G : Type u} [AddCommGroup G] {G\u2082 : AddSubgroup G} (H' : AddSubgroup (G \u29f8 G\u2082)) :\n  let H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  \u2203 e : H \u29f8 H' \u2243+ G \u29f8 N, \u2200 x : G, e (mk' H' (\u03c6 x))= mk' N x", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 744, "tokenPositionInFile": 40301, "theoremPositionInFile": 22}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  have h1 : G\u2082 \u2264 N := by\n    intro x hx\n    rw [\u2190 eq_zero_iff] at hx\n    have : \u03c6 x = 0 := hx\n    simp [N, this, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G\u2082) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G\u2082) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G\u2082)]\n    simp\n  let e1 : H \u29f8 H'' \u2243+ G \u29f8 N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 20, "proofLengthTokens": 645}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G\u2082 \u2264 G and H' is a subgroup of G\u29f8G\u2082, then there is a canonical isomorphism between H\u29f8H' and G\u29f8N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G\u2082 : AddSubgroup G} (H' : AddSubgroup (G \u29f8 G\u2082)) :\n  let H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  \u2203 e : H \u29f8 H' \u2243+ G \u29f8 N, \u2200 x : G, e (mk' H' (\u03c6 x))= mk' N x := by\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  have h1 : G\u2082 \u2264 N := by\n    intro x hx\n    rw [\u2190 eq_zero_iff] at hx\n    have : \u03c6 x = 0 := hx\n    simp [N, this, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G\u2082) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G\u2082) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G\u2082)]\n    simp\n  let e1 : H \u29f8 H'' \u2243+ G \u29f8 N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\n", "theoremStatement": "lemma single {\u03a9 : Type u} [MeasurableSpace \u03a9] [DiscreteMeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n    [IsProbabilityMeasure \u03bc] {A : Set \u03a9} {z : \u03a9} (hA : \u03bc.real A = 1) (hz : \u03bc.real {z} > 0) :\n    z \u2208 A", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 769, "tokenPositionInFile": 41187, "theoremPositionInFile": 23}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (\u03bc := \u03bc) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (\u03bc := \u03bc) (show insert z A \u2286 Set.univ by simp)\n  simp [this] at h\n  assumption", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 8, "proofLengthTokens": 263}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G\u2082 \u2264 G and H' is a subgroup of G\u29f8G\u2082, then there is a canonical isomorphism between H\u29f8H' and G\u29f8N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G\u2082 : AddSubgroup G} (H' : AddSubgroup (G \u29f8 G\u2082)) :\n  let H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  \u2203 e : H \u29f8 H' \u2243+ G \u29f8 N, \u2200 x : G, e (mk' H' (\u03c6 x))= mk' N x := by\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  have h1 : G\u2082 \u2264 N := by\n    intro x hx\n    rw [\u2190 eq_zero_iff] at hx\n    have : \u03c6 x = 0 := hx\n    simp [N, this, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G\u2082) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G\u2082) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G\u2082)]\n    simp\n  let e1 : H \u29f8 H'' \u2243+ G \u29f8 N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {\u03a9 : Type u} [MeasurableSpace \u03a9] [DiscreteMeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n    [IsProbabilityMeasure \u03bc] {A : Set \u03a9} {z : \u03a9} (hA : \u03bc.real A = 1) (hz : \u03bc.real {z} > 0) :\n    z \u2208 A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (\u03bc := \u03bc) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (\u03bc := \u03bc) (show insert z A \u2286 Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} \u2264 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 \u2264 \\log |G/N| + 40 d[U_A; U_B].$$\n -/\n", "theoremStatement": "lemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    \u2203 (N : AddSubgroup G) (x y : G \u29f8 N) (Ax By : Set G), Ax.Nonempty \u2227 By.Nonempty \u2227\n    Set.Finite Ax \u2227 Set.Finite By \u2227 Ax = {z:G | z \u2208 A \u2227 QuotientAddGroup.mk' N z = x } \u2227\n    By = {z:G | z \u2208 B \u2227 QuotientAddGroup.mk' N z = y } \u2227\n    (log 2) * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) +\n      40 * d\u1d64[ A # B ] \u2227 log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      \u2264 34 * (d\u1d64[ A # B ] - d\u1d64[ Ax # By ])", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 785, "tokenPositionInFile": 42027, "theoremPositionInFile": 24}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain \u27e8 h_elem, h_finite, h_card \u27e9 := weak_PFR_quotient_prelim (G := G)\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  let _mH : MeasurableSpace H := \u22a4\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain \u27e8 \u03a9, m\u03a9, UA, h\u03bc, hUA_mes, hUA_unif, hUA_mem, hUA_fin \u27e9 := exists_isUniform_measureSpace' A\n  obtain \u27e8 \u03a9', m\u03a9', UB, h\u03bc', hUB_mes, hUB_unif, hUB_mem, hUB_fin \u27e9 :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (\u03c6.toFun \u2218 UA) (\u03c6.toFun \u2218 UB) \u2119 \u2119 (by measurability) (by measurability)) with \u27e8H', \u27e8 hH1, hH2 \u27e9 \u27e9\n  let N := AddSubgroup.comap \u03c6 H'\n  set \u03c6' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G \u29f8 N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G \u29f8 N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with \u27e8 e : H \u29f8 H' \u2243+ G \u29f8 N, he \u27e9\n  rcases single_fibres \u03c6' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    \u27e8x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq\u27e9\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB \u2119 \u2119 hUA_mes hUB_mes h_torsionfree \u03c6\n  have h2 := torsion_dist_shrinking UB UA \u2119 \u2119 hUB_mes hUA_mes h_torsionfree \u03c6\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[\u03c6.toFun \u2218 UA] \u2264 10 * d\u1d64[A # B] at h1\n  change H[\u03c6.toFun \u2218 UB] \u2264 10 * d\u1d64[A # B] at h2\n  replace hH1 : log (Nat.card H') \u2264 40  * d\u1d64[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) + 40 * d\u1d64[A # B] := by\n    rw [mul_comm, \u2190 log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [\u2190 h_card, \u2190 Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, \u2190 AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, \u2190 Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine \u27e8 hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ \u27e9\n\n  replace hH2 : H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] \u2264 34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] := by\n    set X := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UA\n    set Y := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] \u2264 34 * d[X # Y] at hH2\n\n    have ha : \u03c6'.toFun \u2218 UA = e.toFun \u2218 X := by ext x; exact (he (UA x)).symm\n    have hb : \u03c6'.toFun \u2218 UB = e.toFun \u2218 Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun \u2218 X # e.toFun \u2218 Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : \u03a9 \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UA\n  set Y : \u03a9' \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (\u03bc := \u2119) (\u03bc' := \u2119) hX hY) with h | h\n  swap\n  . rw [\u2190 h] at hH2\n    have hH2A : H[X] \u2265 0 := entropy_nonneg _ _\n    have hH2B : H[Y] \u2265 0 := entropy_nonneg _ _\n    have hH2A' : H[X] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hX hH2A' with \u27e8 x', hx \u27e9\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hY hH2B' with \u27e8 y', hy \u27e9\n\n    have hAAx {z : G} (hz : z \u2208 A) : \u03c6'.toFun z = x' := by\n      change (\u2119).real (UA\u207b\u00b9' (\u03c6'\u207b\u00b9' {x'})) = 1 at hx\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Af, Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Af, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Af := by simp [Af, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((\u2119).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some \u2208 Ax := hnAx.some_mem\n      simp [hAx] at h \u22a2\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z \u2208 B) : \u03c6'.toFun z = y' := by\n      change (\u2119).real (UB\u207b\u00b9' (\u03c6'\u207b\u00b9' {y'})) = 1 at hy\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Bf, Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Bf, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Bf := by simp [Bf, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((\u2119).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some \u2208 By := hnBy.some_mem\n      simp [hBy] at h \u22a2\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ \u2264 (H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := hcard_ineq\n    _ \u2264 (34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete \u03c6'.toFun) hUA_mes) (Measurable.comp (measurable_discrete \u03c6'.toFun) hUB_mes)\n      replace this : 0 < H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] := by linarith\n      rw [\u2190 mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 \u2264 d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [\u2190 mul_zero d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d[UA # UB] - d\u1d64[Ax # By])) := by ring\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d\u1d64[A # B] - d\u1d64[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 165, "proofLengthTokens": 7951}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G\u2082 \u2264 G and H' is a subgroup of G\u29f8G\u2082, then there is a canonical isomorphism between H\u29f8H' and G\u29f8N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G\u2082 : AddSubgroup G} (H' : AddSubgroup (G \u29f8 G\u2082)) :\n  let H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  \u2203 e : H \u29f8 H' \u2243+ G \u29f8 N, \u2200 x : G, e (mk' H' (\u03c6 x))= mk' N x := by\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  have h1 : G\u2082 \u2264 N := by\n    intro x hx\n    rw [\u2190 eq_zero_iff] at hx\n    have : \u03c6 x = 0 := hx\n    simp [N, this, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G\u2082) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G\u2082) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G\u2082)]\n    simp\n  let e1 : H \u29f8 H'' \u2243+ G \u29f8 N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {\u03a9 : Type u} [MeasurableSpace \u03a9] [DiscreteMeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n    [IsProbabilityMeasure \u03bc] {A : Set \u03a9} {z : \u03a9} (hA : \u03bc.real A = 1) (hz : \u03bc.real {z} > 0) :\n    z \u2208 A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (\u03bc := \u03bc) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (\u03bc := \u03bc) (show insert z A \u2286 Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} \u2264 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 \u2264 \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    \u2203 (N : AddSubgroup G) (x y : G \u29f8 N) (Ax By : Set G), Ax.Nonempty \u2227 By.Nonempty \u2227\n    Set.Finite Ax \u2227 Set.Finite By \u2227 Ax = {z:G | z \u2208 A \u2227 QuotientAddGroup.mk' N z = x } \u2227\n    By = {z:G | z \u2208 B \u2227 QuotientAddGroup.mk' N z = y } \u2227\n    (log 2) * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) +\n      40 * d\u1d64[ A # B ] \u2227 log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      \u2264 34 * (d\u1d64[ A # B ] - d\u1d64[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain \u27e8 h_elem, h_finite, h_card \u27e9 := weak_PFR_quotient_prelim (G := G)\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  let _mH : MeasurableSpace H := \u22a4\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain \u27e8 \u03a9, m\u03a9, UA, h\u03bc, hUA_mes, hUA_unif, hUA_mem, hUA_fin \u27e9 := exists_isUniform_measureSpace' A\n  obtain \u27e8 \u03a9', m\u03a9', UB, h\u03bc', hUB_mes, hUB_unif, hUB_mem, hUB_fin \u27e9 :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (\u03c6.toFun \u2218 UA) (\u03c6.toFun \u2218 UB) \u2119 \u2119 (by measurability) (by measurability)) with \u27e8H', \u27e8 hH1, hH2 \u27e9 \u27e9\n  let N := AddSubgroup.comap \u03c6 H'\n  set \u03c6' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G \u29f8 N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G \u29f8 N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with \u27e8 e : H \u29f8 H' \u2243+ G \u29f8 N, he \u27e9\n  rcases single_fibres \u03c6' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    \u27e8x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq\u27e9\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB \u2119 \u2119 hUA_mes hUB_mes h_torsionfree \u03c6\n  have h2 := torsion_dist_shrinking UB UA \u2119 \u2119 hUB_mes hUA_mes h_torsionfree \u03c6\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[\u03c6.toFun \u2218 UA] \u2264 10 * d\u1d64[A # B] at h1\n  change H[\u03c6.toFun \u2218 UB] \u2264 10 * d\u1d64[A # B] at h2\n  replace hH1 : log (Nat.card H') \u2264 40  * d\u1d64[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) + 40 * d\u1d64[A # B] := by\n    rw [mul_comm, \u2190 log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [\u2190 h_card, \u2190 Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, \u2190 AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, \u2190 Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine \u27e8 hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ \u27e9\n\n  replace hH2 : H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] \u2264 34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] := by\n    set X := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UA\n    set Y := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] \u2264 34 * d[X # Y] at hH2\n\n    have ha : \u03c6'.toFun \u2218 UA = e.toFun \u2218 X := by ext x; exact (he (UA x)).symm\n    have hb : \u03c6'.toFun \u2218 UB = e.toFun \u2218 Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun \u2218 X # e.toFun \u2218 Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : \u03a9 \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UA\n  set Y : \u03a9' \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (\u03bc := \u2119) (\u03bc' := \u2119) hX hY) with h | h\n  swap\n  . rw [\u2190 h] at hH2\n    have hH2A : H[X] \u2265 0 := entropy_nonneg _ _\n    have hH2B : H[Y] \u2265 0 := entropy_nonneg _ _\n    have hH2A' : H[X] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hX hH2A' with \u27e8 x', hx \u27e9\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hY hH2B' with \u27e8 y', hy \u27e9\n\n    have hAAx {z : G} (hz : z \u2208 A) : \u03c6'.toFun z = x' := by\n      change (\u2119).real (UA\u207b\u00b9' (\u03c6'\u207b\u00b9' {x'})) = 1 at hx\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Af, Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Af, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Af := by simp [Af, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((\u2119).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some \u2208 Ax := hnAx.some_mem\n      simp [hAx] at h \u22a2\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z \u2208 B) : \u03c6'.toFun z = y' := by\n      change (\u2119).real (UB\u207b\u00b9' (\u03c6'\u207b\u00b9' {y'})) = 1 at hy\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Bf, Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Bf, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Bf := by simp [Bf, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((\u2119).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some \u2208 By := hnBy.some_mem\n      simp [hBy] at h \u22a2\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ \u2264 (H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := hcard_ineq\n    _ \u2264 (34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete \u03c6'.toFun) hUA_mes) (Measurable.comp (measurable_discrete \u03c6'.toFun) hUB_mes)\n      replace this : 0 < H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] := by linarith\n      rw [\u2190 mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 \u2264 d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [\u2190 mul_zero d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d[UA # UB] - d\u1d64[Ax # By])) := by ring\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d\u1d64[A # B] - d\u1d64[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  \u2203 A' B' : Set G, A' \u2286 A \u2227 B' \u2286 B \u2227 A'.Nonempty \u2227 B'.Nonempty \u2227\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) \u2264 34 * d\u1d64[A # B] \u2227\n  max (dimension A') (dimension B') \u2264 (40 / log 2) * d\u1d64[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) \u222a (B-B)) = \u22a4\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\n", "theoremStatement": "lemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H \u21a6 (a:G) + x) '' A) \u2264 dimension A", "fileCreated": "25309ad 20231211", "theoremCreated": "1612a14 20240111", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 968, "tokenPositionInFile": 51218, "theoremPositionInFile": 27}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with \u27e8 S, v, hrank, hshift \u27e9\n  change FiniteDimensional.finrank \u2124 S = dimension A at hrank\n  rw [\u2190 hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with \u27e8 b, \u27e8 hb, hb'\u27e9 \u27e9\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [\u2190 hb']\n  abel", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 15, "proofLengthTokens": 521}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G\u2082 \u2264 G and H' is a subgroup of G\u29f8G\u2082, then there is a canonical isomorphism between H\u29f8H' and G\u29f8N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G\u2082 : AddSubgroup G} (H' : AddSubgroup (G \u29f8 G\u2082)) :\n  let H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  \u2203 e : H \u29f8 H' \u2243+ G \u29f8 N, \u2200 x : G, e (mk' H' (\u03c6 x))= mk' N x := by\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  have h1 : G\u2082 \u2264 N := by\n    intro x hx\n    rw [\u2190 eq_zero_iff] at hx\n    have : \u03c6 x = 0 := hx\n    simp [N, this, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G\u2082) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G\u2082) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G\u2082)]\n    simp\n  let e1 : H \u29f8 H'' \u2243+ G \u29f8 N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {\u03a9 : Type u} [MeasurableSpace \u03a9] [DiscreteMeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n    [IsProbabilityMeasure \u03bc] {A : Set \u03a9} {z : \u03a9} (hA : \u03bc.real A = 1) (hz : \u03bc.real {z} > 0) :\n    z \u2208 A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (\u03bc := \u03bc) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (\u03bc := \u03bc) (show insert z A \u2286 Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} \u2264 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 \u2264 \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    \u2203 (N : AddSubgroup G) (x y : G \u29f8 N) (Ax By : Set G), Ax.Nonempty \u2227 By.Nonempty \u2227\n    Set.Finite Ax \u2227 Set.Finite By \u2227 Ax = {z:G | z \u2208 A \u2227 QuotientAddGroup.mk' N z = x } \u2227\n    By = {z:G | z \u2208 B \u2227 QuotientAddGroup.mk' N z = y } \u2227\n    (log 2) * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) +\n      40 * d\u1d64[ A # B ] \u2227 log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      \u2264 34 * (d\u1d64[ A # B ] - d\u1d64[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain \u27e8 h_elem, h_finite, h_card \u27e9 := weak_PFR_quotient_prelim (G := G)\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  let _mH : MeasurableSpace H := \u22a4\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain \u27e8 \u03a9, m\u03a9, UA, h\u03bc, hUA_mes, hUA_unif, hUA_mem, hUA_fin \u27e9 := exists_isUniform_measureSpace' A\n  obtain \u27e8 \u03a9', m\u03a9', UB, h\u03bc', hUB_mes, hUB_unif, hUB_mem, hUB_fin \u27e9 :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (\u03c6.toFun \u2218 UA) (\u03c6.toFun \u2218 UB) \u2119 \u2119 (by measurability) (by measurability)) with \u27e8H', \u27e8 hH1, hH2 \u27e9 \u27e9\n  let N := AddSubgroup.comap \u03c6 H'\n  set \u03c6' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G \u29f8 N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G \u29f8 N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with \u27e8 e : H \u29f8 H' \u2243+ G \u29f8 N, he \u27e9\n  rcases single_fibres \u03c6' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    \u27e8x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq\u27e9\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB \u2119 \u2119 hUA_mes hUB_mes h_torsionfree \u03c6\n  have h2 := torsion_dist_shrinking UB UA \u2119 \u2119 hUB_mes hUA_mes h_torsionfree \u03c6\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[\u03c6.toFun \u2218 UA] \u2264 10 * d\u1d64[A # B] at h1\n  change H[\u03c6.toFun \u2218 UB] \u2264 10 * d\u1d64[A # B] at h2\n  replace hH1 : log (Nat.card H') \u2264 40  * d\u1d64[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) + 40 * d\u1d64[A # B] := by\n    rw [mul_comm, \u2190 log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [\u2190 h_card, \u2190 Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, \u2190 AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, \u2190 Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine \u27e8 hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ \u27e9\n\n  replace hH2 : H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] \u2264 34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] := by\n    set X := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UA\n    set Y := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] \u2264 34 * d[X # Y] at hH2\n\n    have ha : \u03c6'.toFun \u2218 UA = e.toFun \u2218 X := by ext x; exact (he (UA x)).symm\n    have hb : \u03c6'.toFun \u2218 UB = e.toFun \u2218 Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun \u2218 X # e.toFun \u2218 Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : \u03a9 \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UA\n  set Y : \u03a9' \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (\u03bc := \u2119) (\u03bc' := \u2119) hX hY) with h | h\n  swap\n  . rw [\u2190 h] at hH2\n    have hH2A : H[X] \u2265 0 := entropy_nonneg _ _\n    have hH2B : H[Y] \u2265 0 := entropy_nonneg _ _\n    have hH2A' : H[X] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hX hH2A' with \u27e8 x', hx \u27e9\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hY hH2B' with \u27e8 y', hy \u27e9\n\n    have hAAx {z : G} (hz : z \u2208 A) : \u03c6'.toFun z = x' := by\n      change (\u2119).real (UA\u207b\u00b9' (\u03c6'\u207b\u00b9' {x'})) = 1 at hx\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Af, Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Af, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Af := by simp [Af, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((\u2119).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some \u2208 Ax := hnAx.some_mem\n      simp [hAx] at h \u22a2\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z \u2208 B) : \u03c6'.toFun z = y' := by\n      change (\u2119).real (UB\u207b\u00b9' (\u03c6'\u207b\u00b9' {y'})) = 1 at hy\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Bf, Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Bf, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Bf := by simp [Bf, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((\u2119).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some \u2208 By := hnBy.some_mem\n      simp [hBy] at h \u22a2\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ \u2264 (H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := hcard_ineq\n    _ \u2264 (34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete \u03c6'.toFun) hUA_mes) (Measurable.comp (measurable_discrete \u03c6'.toFun) hUB_mes)\n      replace this : 0 < H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] := by linarith\n      rw [\u2190 mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 \u2264 d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [\u2190 mul_zero d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d[UA # UB] - d\u1d64[Ax # By])) := by ring\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d\u1d64[A # B] - d\u1d64[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  \u2203 A' B' : Set G, A' \u2286 A \u2227 B' \u2286 B \u2227 A'.Nonempty \u2227 B'.Nonempty \u2227\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) \u2264 34 * d\u1d64[A # B] \u2227\n  max (dimension A') (dimension B') \u2264 (40 / log 2) * d\u1d64[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) \u222a (B-B)) = \u22a4\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H \u21a6 (a:G) + x) '' A) \u2264 dimension A := by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with \u27e8 S, v, hrank, hshift \u27e9\n  change FiniteDimensional.finrank \u2124 S = dimension A at hrank\n  rw [\u2190 hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with \u27e8 b, \u27e8 hb, hb'\u27e9 \u27e9\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [\u2190 hb']\n  abel\n\n", "theoremStatement": "lemma conclusion_transfers {A B : Set G}\n    (G': AddSubgroup G) (A' B' : Set G')\n    (hA : IsShift A A') (hB : IsShift B B') [Finite A'] [Finite B'] (hA' : A'.Nonempty) (hB' : B'.Nonempty)\n    (h : WeakPFRAsymmConclusion A' B') : WeakPFRAsymmConclusion A B", "fileCreated": "25309ad 20231211", "theoremCreated": "1612a14 20240111", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 986, "tokenPositionInFile": 51896, "theoremPositionInFile": 28}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  have : Nonempty A' := hA'.to_subtype\n  have : Nonempty B' := hB'.to_subtype\n  rcases h with \u27e8A'', B'', hA'', hB'', hA''_non, hB''_non, hcard_ineq, hdim_ineq\u27e9\n  rcases hA with \u27e8 x, hA \u27e9\n  set f : G' \u2192 G := fun a \u21a6 (a : G) + x\n  have hf : Function.Injective f := by\n    intro y z hyz\n    simp [f] at hyz\n    exact hyz\n  have hA' : A = f '' A' := by\n    simp_rw [hA, \u2190 Set.image_vadd, Set.image_image, vadd_eq_add, f, add_comm]; rfl\n  rcases hB with \u27e8 y, hB \u27e9\n  set g : G' \u2192 G := fun a \u21a6 (a : G) + y\n  have hg : Function.Injective g := by\n    intro y z hyz\n    simp [g] at hyz\n    exact hyz\n  have hB' : B = g '' B' := by\n    simp_rw [hB, \u2190 Set.image_vadd, Set.image_image, vadd_eq_add, g, add_comm]; rfl\n  use f '' A'', g '' B''\n  have : d\u1d64[A # B] = d\u1d64[A' # B'] := by\n    rw [<-rdist_set_of_inj _ _ (\u03c6 := G'.subtype) Subtype.val_injective, <-rdist_set_add_const (G'.subtype '' A') (G'.subtype '' B') x y]\n    congr\n    . rw [hA]\n      ext y\n      simp [Set.mem_vadd_set]\n      constructor\n      . rintro \u27e8 z, \u27e8 \u27e8 w, hw \u27e9, rfl \u27e9 \u27e9\n        have : x + z + -x \u2208 G' := by simp [w]\n        use this\n        simp\n        convert hw\n      rintro \u27e8 h, ha \u27e9\n      use y + -x\n      constructor\n      . use h\n      abel\n    rw [hB]\n    ext x\n    simp [Set.mem_vadd_set]\n    constructor\n    . rintro \u27e8 z, \u27e8 \u27e8 w, hw \u27e9, rfl \u27e9 \u27e9\n      have : y + z + -y \u2208 G' := by simp [w]\n      use this\n      simp\n      convert hw\n    rintro \u27e8 h, ha \u27e9\n    use x + -y\n    constructor\n    . use h\n    abel\n\n\n  refine \u27e8 ?_, ?_, ?_, ?_, ?_, ?_ \u27e9\n  . simp [hA', hf, hA'']\n  . simp [hB', hg, hB'']\n  . simp [hA''_non]\n  . simp [hB''_non]\n  . convert hcard_ineq using 2\n    . congr 3\n      . rw [hA', Nat.card_image_of_injective hf]\n      . rw [hB', Nat.card_image_of_injective hg]\n      . rw [Nat.card_image_of_injective hf]\n      rw [Nat.card_image_of_injective hg]\n  convert LE.le.trans _ hdim_ineq using 2\n  norm_cast\n  apply max_le_max\n  . exact dimension_of_shift A'' x\n  \u00b7 exact dimension_of_shift B'' y", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 70, "proofLengthTokens": 1975}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G\u2082 \u2264 G and H' is a subgroup of G\u29f8G\u2082, then there is a canonical isomorphism between H\u29f8H' and G\u29f8N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G\u2082 : AddSubgroup G} (H' : AddSubgroup (G \u29f8 G\u2082)) :\n  let H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  \u2203 e : H \u29f8 H' \u2243+ G \u29f8 N, \u2200 x : G, e (mk' H' (\u03c6 x))= mk' N x := by\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  have h1 : G\u2082 \u2264 N := by\n    intro x hx\n    rw [\u2190 eq_zero_iff] at hx\n    have : \u03c6 x = 0 := hx\n    simp [N, this, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G\u2082) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G\u2082) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G\u2082)]\n    simp\n  let e1 : H \u29f8 H'' \u2243+ G \u29f8 N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {\u03a9 : Type u} [MeasurableSpace \u03a9] [DiscreteMeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n    [IsProbabilityMeasure \u03bc] {A : Set \u03a9} {z : \u03a9} (hA : \u03bc.real A = 1) (hz : \u03bc.real {z} > 0) :\n    z \u2208 A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (\u03bc := \u03bc) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (\u03bc := \u03bc) (show insert z A \u2286 Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} \u2264 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 \u2264 \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    \u2203 (N : AddSubgroup G) (x y : G \u29f8 N) (Ax By : Set G), Ax.Nonempty \u2227 By.Nonempty \u2227\n    Set.Finite Ax \u2227 Set.Finite By \u2227 Ax = {z:G | z \u2208 A \u2227 QuotientAddGroup.mk' N z = x } \u2227\n    By = {z:G | z \u2208 B \u2227 QuotientAddGroup.mk' N z = y } \u2227\n    (log 2) * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) +\n      40 * d\u1d64[ A # B ] \u2227 log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      \u2264 34 * (d\u1d64[ A # B ] - d\u1d64[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain \u27e8 h_elem, h_finite, h_card \u27e9 := weak_PFR_quotient_prelim (G := G)\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  let _mH : MeasurableSpace H := \u22a4\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain \u27e8 \u03a9, m\u03a9, UA, h\u03bc, hUA_mes, hUA_unif, hUA_mem, hUA_fin \u27e9 := exists_isUniform_measureSpace' A\n  obtain \u27e8 \u03a9', m\u03a9', UB, h\u03bc', hUB_mes, hUB_unif, hUB_mem, hUB_fin \u27e9 :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (\u03c6.toFun \u2218 UA) (\u03c6.toFun \u2218 UB) \u2119 \u2119 (by measurability) (by measurability)) with \u27e8H', \u27e8 hH1, hH2 \u27e9 \u27e9\n  let N := AddSubgroup.comap \u03c6 H'\n  set \u03c6' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G \u29f8 N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G \u29f8 N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with \u27e8 e : H \u29f8 H' \u2243+ G \u29f8 N, he \u27e9\n  rcases single_fibres \u03c6' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    \u27e8x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq\u27e9\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB \u2119 \u2119 hUA_mes hUB_mes h_torsionfree \u03c6\n  have h2 := torsion_dist_shrinking UB UA \u2119 \u2119 hUB_mes hUA_mes h_torsionfree \u03c6\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[\u03c6.toFun \u2218 UA] \u2264 10 * d\u1d64[A # B] at h1\n  change H[\u03c6.toFun \u2218 UB] \u2264 10 * d\u1d64[A # B] at h2\n  replace hH1 : log (Nat.card H') \u2264 40  * d\u1d64[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) + 40 * d\u1d64[A # B] := by\n    rw [mul_comm, \u2190 log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [\u2190 h_card, \u2190 Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, \u2190 AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, \u2190 Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine \u27e8 hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ \u27e9\n\n  replace hH2 : H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] \u2264 34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] := by\n    set X := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UA\n    set Y := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] \u2264 34 * d[X # Y] at hH2\n\n    have ha : \u03c6'.toFun \u2218 UA = e.toFun \u2218 X := by ext x; exact (he (UA x)).symm\n    have hb : \u03c6'.toFun \u2218 UB = e.toFun \u2218 Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun \u2218 X # e.toFun \u2218 Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : \u03a9 \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UA\n  set Y : \u03a9' \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (\u03bc := \u2119) (\u03bc' := \u2119) hX hY) with h | h\n  swap\n  . rw [\u2190 h] at hH2\n    have hH2A : H[X] \u2265 0 := entropy_nonneg _ _\n    have hH2B : H[Y] \u2265 0 := entropy_nonneg _ _\n    have hH2A' : H[X] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hX hH2A' with \u27e8 x', hx \u27e9\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hY hH2B' with \u27e8 y', hy \u27e9\n\n    have hAAx {z : G} (hz : z \u2208 A) : \u03c6'.toFun z = x' := by\n      change (\u2119).real (UA\u207b\u00b9' (\u03c6'\u207b\u00b9' {x'})) = 1 at hx\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Af, Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Af, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Af := by simp [Af, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((\u2119).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some \u2208 Ax := hnAx.some_mem\n      simp [hAx] at h \u22a2\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z \u2208 B) : \u03c6'.toFun z = y' := by\n      change (\u2119).real (UB\u207b\u00b9' (\u03c6'\u207b\u00b9' {y'})) = 1 at hy\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Bf, Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Bf, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Bf := by simp [Bf, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((\u2119).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some \u2208 By := hnBy.some_mem\n      simp [hBy] at h \u22a2\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ \u2264 (H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := hcard_ineq\n    _ \u2264 (34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete \u03c6'.toFun) hUA_mes) (Measurable.comp (measurable_discrete \u03c6'.toFun) hUB_mes)\n      replace this : 0 < H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] := by linarith\n      rw [\u2190 mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 \u2264 d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [\u2190 mul_zero d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d[UA # UB] - d\u1d64[Ax # By])) := by ring\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d\u1d64[A # B] - d\u1d64[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  \u2203 A' B' : Set G, A' \u2286 A \u2227 B' \u2286 B \u2227 A'.Nonempty \u2227 B'.Nonempty \u2227\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) \u2264 34 * d\u1d64[A # B] \u2227\n  max (dimension A') (dimension B') \u2264 (40 / log 2) * d\u1d64[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) \u222a (B-B)) = \u22a4\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H \u21a6 (a:G) + x) '' A) \u2264 dimension A := by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with \u27e8 S, v, hrank, hshift \u27e9\n  change FiniteDimensional.finrank \u2124 S = dimension A at hrank\n  rw [\u2190 hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with \u27e8 b, \u27e8 hb, hb'\u27e9 \u27e9\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [\u2190 hb']\n  abel\n\nlemma conclusion_transfers {A B : Set G}\n    (G': AddSubgroup G) (A' B' : Set G')\n    (hA : IsShift A A') (hB : IsShift B B') [Finite A'] [Finite B'] (hA' : A'.Nonempty) (hB' : B'.Nonempty)\n    (h : WeakPFRAsymmConclusion A' B') : WeakPFRAsymmConclusion A B := by\n  have : Nonempty A' := hA'.to_subtype\n  have : Nonempty B' := hB'.to_subtype\n  rcases h with \u27e8A'', B'', hA'', hB'', hA''_non, hB''_non, hcard_ineq, hdim_ineq\u27e9\n  rcases hA with \u27e8 x, hA \u27e9\n  set f : G' \u2192 G := fun a \u21a6 (a : G) + x\n  have hf : Function.Injective f := by\n    intro y z hyz\n    simp [f] at hyz\n    exact hyz\n  have hA' : A = f '' A' := by\n    simp_rw [hA, \u2190 Set.image_vadd, Set.image_image, vadd_eq_add, f, add_comm]; rfl\n  rcases hB with \u27e8 y, hB \u27e9\n  set g : G' \u2192 G := fun a \u21a6 (a : G) + y\n  have hg : Function.Injective g := by\n    intro y z hyz\n    simp [g] at hyz\n    exact hyz\n  have hB' : B = g '' B' := by\n    simp_rw [hB, \u2190 Set.image_vadd, Set.image_image, vadd_eq_add, g, add_comm]; rfl\n  use f '' A'', g '' B''\n  have : d\u1d64[A # B] = d\u1d64[A' # B'] := by\n    rw [<-rdist_set_of_inj _ _ (\u03c6 := G'.subtype) Subtype.val_injective, <-rdist_set_add_const (G'.subtype '' A') (G'.subtype '' B') x y]\n    congr\n    . rw [hA]\n      ext y\n      simp [Set.mem_vadd_set]\n      constructor\n      . rintro \u27e8 z, \u27e8 \u27e8 w, hw \u27e9, rfl \u27e9 \u27e9\n        have : x + z + -x \u2208 G' := by simp [w]\n        use this\n        simp\n        convert hw\n      rintro \u27e8 h, ha \u27e9\n      use y + -x\n      constructor\n      . use h\n      abel\n    rw [hB]\n    ext x\n    simp [Set.mem_vadd_set]\n    constructor\n    . rintro \u27e8 z, \u27e8 \u27e8 w, hw \u27e9, rfl \u27e9 \u27e9\n      have : y + z + -y \u2208 G' := by simp [w]\n      use this\n      simp\n      convert hw\n    rintro \u27e8 h, ha \u27e9\n    use x + -y\n    constructor\n    . use h\n    abel\n\n\n  refine \u27e8 ?_, ?_, ?_, ?_, ?_, ?_ \u27e9\n  . simp [hA', hf, hA'']\n  . simp [hB', hg, hB'']\n  . simp [hA''_non]\n  . simp [hB''_non]\n  . convert hcard_ineq using 2\n    . congr 3\n      . rw [hA', Nat.card_image_of_injective hf]\n      . rw [hB', Nat.card_image_of_injective hg]\n      . rw [Nat.card_image_of_injective hf]\n      rw [Nat.card_image_of_injective hg]\n  convert LE.le.trans _ hdim_ineq using 2\n  norm_cast\n  apply max_le_max\n  . exact dimension_of_shift A'' x\n  \u00b7 exact dimension_of_shift B'' y\n\n/-- If $A,B\\subseteq \\mathbb{Z}^d$ are finite non-empty sets then there exist non-empty $A'\\subseteq A$ and $B'\\subseteq B$ such that\n\\[\\log\\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A'\\rvert\\lvert B'\\rvert}\\leq 34 d[U_A;U_B]\\]\nsuch that $\\max(\\dim A',\\dim B')\\leq \\frac{40}{\\log 2} d[U_A;U_B]$. -/\n", "theoremStatement": "lemma weak_PFR_asymm (A B : Set G) [Finite A] [Finite B] (hA : A.Nonempty) (hB : B.Nonempty) : WeakPFRAsymmConclusion A B", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 1063, "tokenPositionInFile": 54433, "theoremPositionInFile": 29}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  let P : \u2115 \u2192 Prop := fun M \u21a6 (\u2200 (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free \u2124 G) (_hG_fin : Module.Finite \u2124 G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) \u2264 M), WeakPFRAsymmConclusion A B)\n  suffices \u2200 M, (\u2200 M', M' < M \u2192 P M') \u2192 P M by\n    set M := (Nat.card A) + (Nat.card B)\n    have hM : (Nat.card A) + (Nat.card B) \u2264 M := Nat.le_refl _\n    convert (Nat.strong_induction_on (p := P) M this) G \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a _ \u2039_\u203a A B \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a hM\n  intro M h_induct\n  -- wlog we can assume A, B are not in cosets of a smaller subgroup\n  suffices \u2200 (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free \u2124 G)\n    (_hG_fin : Module.Finite \u2124 G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G)\n    (_hG_sing : MeasurableSingletonClass G) (A B : Set G) (_hA_fin : Finite A) (_hB_fin : Finite B) (_hA_non : A.Nonempty) (_hB_non : B.Nonempty) (_hM : Nat.card A + Nat.card B \u2264 M)\n    (_hnot : NotInCoset A B), WeakPFRAsymmConclusion A B by\n    intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM\n    obtain \u27e8 G', A', B', hAA', hBB', hnot' \u27e9 := wlog_notInCoset hA_non hB_non\n    have hG'_fin : Module.Finite \u2124 G' :=\n      Module.Finite.iff_fg (N := AddSubgroup.toIntSubmodule G').2 (IsNoetherian.noetherian _)\n\n    have hG'_free : Module.Free \u2124 G' := by\n      rcases Submodule.nonempty_basis_of_pid (Module.Free.chooseBasis \u2124 G) (AddSubgroup.toIntSubmodule G') with \u27e8 n, \u27e8 b \u27e9 \u27e9\n      exact Module.Free.of_basis b\n    have hAA'_card: Nat.card A = Nat.card A' := (Nat.card_image_of_injective Subtype.val_injective _) \u25b8 hAA'.card_congr\n    have hBB'_card: Nat.card B = Nat.card B' := (Nat.card_image_of_injective Subtype.val_injective _) \u25b8 hBB'.card_congr\n    have hA_non' : Nonempty A := Set.nonempty_coe_sort.mpr hA_non\n    have hB_non' : Nonempty B := Set.nonempty_coe_sort.mpr hB_non\n\n    rw [hAA'_card, hBB'_card] at hM\n\n    have hA'_nonfin : A'.Nonempty \u2227 Finite A' := by\n      have := Nat.card_pos (\u03b1 := A)\n      rw [hAA'_card, Nat.card_pos_iff] at this\n      exact \u27e8@nonempty_of_nonempty_subtype _ _ this.1, this.2\u27e9\n    have hB'_nonfin : B'.Nonempty \u2227 Finite B' := by\n      have := Nat.card_pos (\u03b1 := B)\n      rw [hBB'_card, Nat.card_pos_iff] at this\n      exact \u27e8@nonempty_of_nonempty_subtype _ _ this.1, this.2\u27e9\n    obtain \u27e8 hA'_non, hA'_fin \u27e9 := hA'_nonfin\n    obtain \u27e8 hB'_non, hB'_fin \u27e9 := hB'_nonfin\n\n    replace this := this G' _ hG'_free hG'_fin (by infer_instance) (by infer_instance) (by infer_instance) A' B' hA'_fin hB'_fin hA'_non hB'_non hM hnot'\n    exact conclusion_transfers G' A' B' hAA' hBB' hA'_non hB'_non this\n  intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM hnot\n  rcases weak_PFR_asymm_prelim A B hA_non hB_non with \u27e8 N, x, y, Ax, By, hAx_non, hBy_non, hAx_fin, hBy_fin, hAx, hBy, hdim, hcard\u27e9\n  have hAxA : Ax \u2286 A := by rw [hAx]; simp\n  have hByB : By \u2286 B := by rw [hBy]; simp\n  have hA_pos : (0 : \u211d) < Nat.card A := Nat.cast_pos.mpr (@Nat.card_pos _ hA_non.to_subtype _)\n  have hB_pos : (0 : \u211d) < Nat.card B := Nat.cast_pos.mpr (@Nat.card_pos _ hB_non.to_subtype _)\n\n  rcases lt_or_ge (Nat.card Ax + Nat.card By) (Nat.card A + Nat.card B) with h | h\n  . replace h := h_induct (Nat.card Ax + Nat.card By) (h.trans_le hM) G hG_comm hG_free hG_fin hG_count hG_mes hG_sing Ax By (Set.finite_coe_iff.mpr hAx_fin) (Set.finite_coe_iff.mpr hBy_fin) hAx_non hBy_non (Eq.le rfl)\n    rcases h with \u27e8 A', B', hA', hB', hA'_non, hB'_non, hcard_ineq, hdim_ineq \u27e9\n    use A', B'\n    have hAx_fin' := Set.finite_coe_iff.mpr hAx_fin\n    have hBy_fin' := Set.finite_coe_iff.mpr hBy_fin\n    have hA'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hAx_fin hA')\n    have hB'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hBy_fin hB')\n    have hAx_non' := Set.nonempty_coe_sort.mpr hAx_non\n    have hBy_non' := Set.nonempty_coe_sort.mpr hBy_non\n    have hA'_non' := Set.nonempty_coe_sort.mpr hA'_non\n    have hB'_non' := Set.nonempty_coe_sort.mpr hB'_non\n    have hAx_pos : (0 : \u211d) < Nat.card Ax := Nat.cast_pos.mpr Nat.card_pos\n    have hBy_pos : (0 : \u211d) < Nat.card By := Nat.cast_pos.mpr Nat.card_pos\n    have hA'_pos : (0 : \u211d) < Nat.card A' := Nat.cast_pos.mpr Nat.card_pos\n    have hB'_pos : (0 : \u211d) < Nat.card B' := Nat.cast_pos.mpr Nat.card_pos\n    have hAxA_le : (Nat.card Ax : \u211d) \u2264 (Nat.card A : \u211d) := Nat.cast_le.mpr (Nat.card_mono A.toFinite hAxA)\n    have hByB_le : (Nat.card By : \u211d) \u2264 (Nat.card B : \u211d) := Nat.cast_le.mpr (Nat.card_mono B.toFinite hByB)\n\n    refine \u27e8 hA'.trans hAxA, hB'.trans hByB, hA'_non, hB'_non, ?_, ?_ \u27e9\n    . rw [four_logs hA_pos hB_pos hA'_pos hB'_pos]\n      rw [four_logs hAx_pos hBy_pos hA'_pos hB'_pos] at hcard_ineq\n      linarith only [hcard, hcard_ineq]\n    apply hdim_ineq.trans\n    gcongr\n    linarith only [Real.log_le_log hAx_pos hAxA_le, Real.log_le_log hBy_pos hByB_le, hcard]\n  use A, B\n  refine \u27e8 Eq.subset rfl, Eq.subset rfl, hA_non, hB_non, ?_, ?_ \u27e9\n  . have := hA_non.to_subtype\n    have := hB_non.to_subtype\n    apply LE.le.trans _ <| mul_nonneg (by norm_num) <| rdist_set_nonneg A B\n    rw [div_self (by positivity)]\n    simp\n  have hAx_eq : Ax = A := by\n    apply Set.Finite.eq_of_subset_of_card_le A.toFinite hAxA\n    linarith only [h, Nat.card_mono B.toFinite hByB]\n  have hBy_eq : By = B := by\n    apply Set.Finite.eq_of_subset_of_card_le B.toFinite hByB\n    linarith only [h, Nat.card_mono A.toFinite hAxA]\n  have hN : N = \u22a4 := by\n    have : (A-A) \u222a (B-B) \u2286 N := by\n      rw [\u2190 hAx_eq, \u2190 hBy_eq, hAx, hBy]\n      intro z hz\n      simp [Set.mem_sub] at hz\n      convert (QuotientAddGroup.eq_zero_iff z).mp ?_\n      . infer_instance\n      rcases hz with \u27e8 a, \u27e8 -, ha\u27e9, a', \u27e8-, ha'\u27e9, haa' \u27e9 | \u27e8 b, \u27e8 -, hb\u27e9, b', \u27e8 -,hb'\u27e9, hbb' \u27e9\n      . rw [\u2190 haa']; simp [ha, ha']\n      rw [\u2190 hbb']; simp [hb, hb']\n    rw [\u2190 AddSubgroup.closure_le, hnot] at this\n    exact top_le_iff.mp this\n  have : Nat.card (G \u29f8 N) = 1 := by\n    rw [Nat.card_eq_one_iff_unique]\n    constructor\n    . rw [hN]\n      exact  QuotientAddGroup.subsingleton_quotient_top\n    infer_instance\n  simp [this] at hdim\n  rw [\u2190 le_div_iff' (by positivity)] at hdim\n  convert LE.le.trans ?_ hdim using 1\n  . field_simp\n  simp\n  exact \u27e8 dimension_le_rank A, dimension_le_rank B \u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 110, "proofLengthTokens": 6393}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G\u2082 \u2264 G and H' is a subgroup of G\u29f8G\u2082, then there is a canonical isomorphism between H\u29f8H' and G\u29f8N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G\u2082 : AddSubgroup G} (H' : AddSubgroup (G \u29f8 G\u2082)) :\n  let H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  \u2203 e : H \u29f8 H' \u2243+ G \u29f8 N, \u2200 x : G, e (mk' H' (\u03c6 x))= mk' N x := by\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  have h1 : G\u2082 \u2264 N := by\n    intro x hx\n    rw [\u2190 eq_zero_iff] at hx\n    have : \u03c6 x = 0 := hx\n    simp [N, this, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G\u2082) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G\u2082) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G\u2082)]\n    simp\n  let e1 : H \u29f8 H'' \u2243+ G \u29f8 N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {\u03a9 : Type u} [MeasurableSpace \u03a9] [DiscreteMeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n    [IsProbabilityMeasure \u03bc] {A : Set \u03a9} {z : \u03a9} (hA : \u03bc.real A = 1) (hz : \u03bc.real {z} > 0) :\n    z \u2208 A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (\u03bc := \u03bc) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (\u03bc := \u03bc) (show insert z A \u2286 Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} \u2264 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 \u2264 \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    \u2203 (N : AddSubgroup G) (x y : G \u29f8 N) (Ax By : Set G), Ax.Nonempty \u2227 By.Nonempty \u2227\n    Set.Finite Ax \u2227 Set.Finite By \u2227 Ax = {z:G | z \u2208 A \u2227 QuotientAddGroup.mk' N z = x } \u2227\n    By = {z:G | z \u2208 B \u2227 QuotientAddGroup.mk' N z = y } \u2227\n    (log 2) * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) +\n      40 * d\u1d64[ A # B ] \u2227 log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      \u2264 34 * (d\u1d64[ A # B ] - d\u1d64[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain \u27e8 h_elem, h_finite, h_card \u27e9 := weak_PFR_quotient_prelim (G := G)\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  let _mH : MeasurableSpace H := \u22a4\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain \u27e8 \u03a9, m\u03a9, UA, h\u03bc, hUA_mes, hUA_unif, hUA_mem, hUA_fin \u27e9 := exists_isUniform_measureSpace' A\n  obtain \u27e8 \u03a9', m\u03a9', UB, h\u03bc', hUB_mes, hUB_unif, hUB_mem, hUB_fin \u27e9 :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (\u03c6.toFun \u2218 UA) (\u03c6.toFun \u2218 UB) \u2119 \u2119 (by measurability) (by measurability)) with \u27e8H', \u27e8 hH1, hH2 \u27e9 \u27e9\n  let N := AddSubgroup.comap \u03c6 H'\n  set \u03c6' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G \u29f8 N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G \u29f8 N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with \u27e8 e : H \u29f8 H' \u2243+ G \u29f8 N, he \u27e9\n  rcases single_fibres \u03c6' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    \u27e8x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq\u27e9\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB \u2119 \u2119 hUA_mes hUB_mes h_torsionfree \u03c6\n  have h2 := torsion_dist_shrinking UB UA \u2119 \u2119 hUB_mes hUA_mes h_torsionfree \u03c6\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[\u03c6.toFun \u2218 UA] \u2264 10 * d\u1d64[A # B] at h1\n  change H[\u03c6.toFun \u2218 UB] \u2264 10 * d\u1d64[A # B] at h2\n  replace hH1 : log (Nat.card H') \u2264 40  * d\u1d64[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) + 40 * d\u1d64[A # B] := by\n    rw [mul_comm, \u2190 log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [\u2190 h_card, \u2190 Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, \u2190 AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, \u2190 Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine \u27e8 hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ \u27e9\n\n  replace hH2 : H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] \u2264 34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] := by\n    set X := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UA\n    set Y := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] \u2264 34 * d[X # Y] at hH2\n\n    have ha : \u03c6'.toFun \u2218 UA = e.toFun \u2218 X := by ext x; exact (he (UA x)).symm\n    have hb : \u03c6'.toFun \u2218 UB = e.toFun \u2218 Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun \u2218 X # e.toFun \u2218 Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : \u03a9 \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UA\n  set Y : \u03a9' \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (\u03bc := \u2119) (\u03bc' := \u2119) hX hY) with h | h\n  swap\n  . rw [\u2190 h] at hH2\n    have hH2A : H[X] \u2265 0 := entropy_nonneg _ _\n    have hH2B : H[Y] \u2265 0 := entropy_nonneg _ _\n    have hH2A' : H[X] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hX hH2A' with \u27e8 x', hx \u27e9\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hY hH2B' with \u27e8 y', hy \u27e9\n\n    have hAAx {z : G} (hz : z \u2208 A) : \u03c6'.toFun z = x' := by\n      change (\u2119).real (UA\u207b\u00b9' (\u03c6'\u207b\u00b9' {x'})) = 1 at hx\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Af, Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Af, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Af := by simp [Af, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((\u2119).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some \u2208 Ax := hnAx.some_mem\n      simp [hAx] at h \u22a2\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z \u2208 B) : \u03c6'.toFun z = y' := by\n      change (\u2119).real (UB\u207b\u00b9' (\u03c6'\u207b\u00b9' {y'})) = 1 at hy\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Bf, Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Bf, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Bf := by simp [Bf, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((\u2119).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some \u2208 By := hnBy.some_mem\n      simp [hBy] at h \u22a2\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ \u2264 (H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := hcard_ineq\n    _ \u2264 (34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete \u03c6'.toFun) hUA_mes) (Measurable.comp (measurable_discrete \u03c6'.toFun) hUB_mes)\n      replace this : 0 < H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] := by linarith\n      rw [\u2190 mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 \u2264 d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [\u2190 mul_zero d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d[UA # UB] - d\u1d64[Ax # By])) := by ring\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d\u1d64[A # B] - d\u1d64[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  \u2203 A' B' : Set G, A' \u2286 A \u2227 B' \u2286 B \u2227 A'.Nonempty \u2227 B'.Nonempty \u2227\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) \u2264 34 * d\u1d64[A # B] \u2227\n  max (dimension A') (dimension B') \u2264 (40 / log 2) * d\u1d64[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) \u222a (B-B)) = \u22a4\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H \u21a6 (a:G) + x) '' A) \u2264 dimension A := by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with \u27e8 S, v, hrank, hshift \u27e9\n  change FiniteDimensional.finrank \u2124 S = dimension A at hrank\n  rw [\u2190 hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with \u27e8 b, \u27e8 hb, hb'\u27e9 \u27e9\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [\u2190 hb']\n  abel\n\nlemma conclusion_transfers {A B : Set G}\n    (G': AddSubgroup G) (A' B' : Set G')\n    (hA : IsShift A A') (hB : IsShift B B') [Finite A'] [Finite B'] (hA' : A'.Nonempty) (hB' : B'.Nonempty)\n    (h : WeakPFRAsymmConclusion A' B') : WeakPFRAsymmConclusion A B := by\n  have : Nonempty A' := hA'.to_subtype\n  have : Nonempty B' := hB'.to_subtype\n  rcases h with \u27e8A'', B'', hA'', hB'', hA''_non, hB''_non, hcard_ineq, hdim_ineq\u27e9\n  rcases hA with \u27e8 x, hA \u27e9\n  set f : G' \u2192 G := fun a \u21a6 (a : G) + x\n  have hf : Function.Injective f := by\n    intro y z hyz\n    simp [f] at hyz\n    exact hyz\n  have hA' : A = f '' A' := by\n    simp_rw [hA, \u2190 Set.image_vadd, Set.image_image, vadd_eq_add, f, add_comm]; rfl\n  rcases hB with \u27e8 y, hB \u27e9\n  set g : G' \u2192 G := fun a \u21a6 (a : G) + y\n  have hg : Function.Injective g := by\n    intro y z hyz\n    simp [g] at hyz\n    exact hyz\n  have hB' : B = g '' B' := by\n    simp_rw [hB, \u2190 Set.image_vadd, Set.image_image, vadd_eq_add, g, add_comm]; rfl\n  use f '' A'', g '' B''\n  have : d\u1d64[A # B] = d\u1d64[A' # B'] := by\n    rw [<-rdist_set_of_inj _ _ (\u03c6 := G'.subtype) Subtype.val_injective, <-rdist_set_add_const (G'.subtype '' A') (G'.subtype '' B') x y]\n    congr\n    . rw [hA]\n      ext y\n      simp [Set.mem_vadd_set]\n      constructor\n      . rintro \u27e8 z, \u27e8 \u27e8 w, hw \u27e9, rfl \u27e9 \u27e9\n        have : x + z + -x \u2208 G' := by simp [w]\n        use this\n        simp\n        convert hw\n      rintro \u27e8 h, ha \u27e9\n      use y + -x\n      constructor\n      . use h\n      abel\n    rw [hB]\n    ext x\n    simp [Set.mem_vadd_set]\n    constructor\n    . rintro \u27e8 z, \u27e8 \u27e8 w, hw \u27e9, rfl \u27e9 \u27e9\n      have : y + z + -y \u2208 G' := by simp [w]\n      use this\n      simp\n      convert hw\n    rintro \u27e8 h, ha \u27e9\n    use x + -y\n    constructor\n    . use h\n    abel\n\n\n  refine \u27e8 ?_, ?_, ?_, ?_, ?_, ?_ \u27e9\n  . simp [hA', hf, hA'']\n  . simp [hB', hg, hB'']\n  . simp [hA''_non]\n  . simp [hB''_non]\n  . convert hcard_ineq using 2\n    . congr 3\n      . rw [hA', Nat.card_image_of_injective hf]\n      . rw [hB', Nat.card_image_of_injective hg]\n      . rw [Nat.card_image_of_injective hf]\n      rw [Nat.card_image_of_injective hg]\n  convert LE.le.trans _ hdim_ineq using 2\n  norm_cast\n  apply max_le_max\n  . exact dimension_of_shift A'' x\n  \u00b7 exact dimension_of_shift B'' y\n\n/-- If $A,B\\subseteq \\mathbb{Z}^d$ are finite non-empty sets then there exist non-empty $A'\\subseteq A$ and $B'\\subseteq B$ such that\n\\[\\log\\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A'\\rvert\\lvert B'\\rvert}\\leq 34 d[U_A;U_B]\\]\nsuch that $\\max(\\dim A',\\dim B')\\leq \\frac{40}{\\log 2} d[U_A;U_B]$. -/\nlemma weak_PFR_asymm (A B : Set G) [Finite A] [Finite B] (hA : A.Nonempty) (hB : B.Nonempty) : WeakPFRAsymmConclusion A B  := by\n  let P : \u2115 \u2192 Prop := fun M \u21a6 (\u2200 (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free \u2124 G) (_hG_fin : Module.Finite \u2124 G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) \u2264 M), WeakPFRAsymmConclusion A B)\n  suffices \u2200 M, (\u2200 M', M' < M \u2192 P M') \u2192 P M by\n    set M := (Nat.card A) + (Nat.card B)\n    have hM : (Nat.card A) + (Nat.card B) \u2264 M := Nat.le_refl _\n    convert (Nat.strong_induction_on (p := P) M this) G \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a _ \u2039_\u203a A B \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a hM\n  intro M h_induct\n  -- wlog we can assume A, B are not in cosets of a smaller subgroup\n  suffices \u2200 (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free \u2124 G)\n    (_hG_fin : Module.Finite \u2124 G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G)\n    (_hG_sing : MeasurableSingletonClass G) (A B : Set G) (_hA_fin : Finite A) (_hB_fin : Finite B) (_hA_non : A.Nonempty) (_hB_non : B.Nonempty) (_hM : Nat.card A + Nat.card B \u2264 M)\n    (_hnot : NotInCoset A B), WeakPFRAsymmConclusion A B by\n    intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM\n    obtain \u27e8 G', A', B', hAA', hBB', hnot' \u27e9 := wlog_notInCoset hA_non hB_non\n    have hG'_fin : Module.Finite \u2124 G' :=\n      Module.Finite.iff_fg (N := AddSubgroup.toIntSubmodule G').2 (IsNoetherian.noetherian _)\n\n    have hG'_free : Module.Free \u2124 G' := by\n      rcases Submodule.nonempty_basis_of_pid (Module.Free.chooseBasis \u2124 G) (AddSubgroup.toIntSubmodule G') with \u27e8 n, \u27e8 b \u27e9 \u27e9\n      exact Module.Free.of_basis b\n    have hAA'_card: Nat.card A = Nat.card A' := (Nat.card_image_of_injective Subtype.val_injective _) \u25b8 hAA'.card_congr\n    have hBB'_card: Nat.card B = Nat.card B' := (Nat.card_image_of_injective Subtype.val_injective _) \u25b8 hBB'.card_congr\n    have hA_non' : Nonempty A := Set.nonempty_coe_sort.mpr hA_non\n    have hB_non' : Nonempty B := Set.nonempty_coe_sort.mpr hB_non\n\n    rw [hAA'_card, hBB'_card] at hM\n\n    have hA'_nonfin : A'.Nonempty \u2227 Finite A' := by\n      have := Nat.card_pos (\u03b1 := A)\n      rw [hAA'_card, Nat.card_pos_iff] at this\n      exact \u27e8@nonempty_of_nonempty_subtype _ _ this.1, this.2\u27e9\n    have hB'_nonfin : B'.Nonempty \u2227 Finite B' := by\n      have := Nat.card_pos (\u03b1 := B)\n      rw [hBB'_card, Nat.card_pos_iff] at this\n      exact \u27e8@nonempty_of_nonempty_subtype _ _ this.1, this.2\u27e9\n    obtain \u27e8 hA'_non, hA'_fin \u27e9 := hA'_nonfin\n    obtain \u27e8 hB'_non, hB'_fin \u27e9 := hB'_nonfin\n\n    replace this := this G' _ hG'_free hG'_fin (by infer_instance) (by infer_instance) (by infer_instance) A' B' hA'_fin hB'_fin hA'_non hB'_non hM hnot'\n    exact conclusion_transfers G' A' B' hAA' hBB' hA'_non hB'_non this\n  intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM hnot\n  rcases weak_PFR_asymm_prelim A B hA_non hB_non with \u27e8 N, x, y, Ax, By, hAx_non, hBy_non, hAx_fin, hBy_fin, hAx, hBy, hdim, hcard\u27e9\n  have hAxA : Ax \u2286 A := by rw [hAx]; simp\n  have hByB : By \u2286 B := by rw [hBy]; simp\n  have hA_pos : (0 : \u211d) < Nat.card A := Nat.cast_pos.mpr (@Nat.card_pos _ hA_non.to_subtype _)\n  have hB_pos : (0 : \u211d) < Nat.card B := Nat.cast_pos.mpr (@Nat.card_pos _ hB_non.to_subtype _)\n\n  rcases lt_or_ge (Nat.card Ax + Nat.card By) (Nat.card A + Nat.card B) with h | h\n  . replace h := h_induct (Nat.card Ax + Nat.card By) (h.trans_le hM) G hG_comm hG_free hG_fin hG_count hG_mes hG_sing Ax By (Set.finite_coe_iff.mpr hAx_fin) (Set.finite_coe_iff.mpr hBy_fin) hAx_non hBy_non (Eq.le rfl)\n    rcases h with \u27e8 A', B', hA', hB', hA'_non, hB'_non, hcard_ineq, hdim_ineq \u27e9\n    use A', B'\n    have hAx_fin' := Set.finite_coe_iff.mpr hAx_fin\n    have hBy_fin' := Set.finite_coe_iff.mpr hBy_fin\n    have hA'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hAx_fin hA')\n    have hB'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hBy_fin hB')\n    have hAx_non' := Set.nonempty_coe_sort.mpr hAx_non\n    have hBy_non' := Set.nonempty_coe_sort.mpr hBy_non\n    have hA'_non' := Set.nonempty_coe_sort.mpr hA'_non\n    have hB'_non' := Set.nonempty_coe_sort.mpr hB'_non\n    have hAx_pos : (0 : \u211d) < Nat.card Ax := Nat.cast_pos.mpr Nat.card_pos\n    have hBy_pos : (0 : \u211d) < Nat.card By := Nat.cast_pos.mpr Nat.card_pos\n    have hA'_pos : (0 : \u211d) < Nat.card A' := Nat.cast_pos.mpr Nat.card_pos\n    have hB'_pos : (0 : \u211d) < Nat.card B' := Nat.cast_pos.mpr Nat.card_pos\n    have hAxA_le : (Nat.card Ax : \u211d) \u2264 (Nat.card A : \u211d) := Nat.cast_le.mpr (Nat.card_mono A.toFinite hAxA)\n    have hByB_le : (Nat.card By : \u211d) \u2264 (Nat.card B : \u211d) := Nat.cast_le.mpr (Nat.card_mono B.toFinite hByB)\n\n    refine \u27e8 hA'.trans hAxA, hB'.trans hByB, hA'_non, hB'_non, ?_, ?_ \u27e9\n    . rw [four_logs hA_pos hB_pos hA'_pos hB'_pos]\n      rw [four_logs hAx_pos hBy_pos hA'_pos hB'_pos] at hcard_ineq\n      linarith only [hcard, hcard_ineq]\n    apply hdim_ineq.trans\n    gcongr\n    linarith only [Real.log_le_log hAx_pos hAxA_le, Real.log_le_log hBy_pos hByB_le, hcard]\n  use A, B\n  refine \u27e8 Eq.subset rfl, Eq.subset rfl, hA_non, hB_non, ?_, ?_ \u27e9\n  . have := hA_non.to_subtype\n    have := hB_non.to_subtype\n    apply LE.le.trans _ <| mul_nonneg (by norm_num) <| rdist_set_nonneg A B\n    rw [div_self (by positivity)]\n    simp\n  have hAx_eq : Ax = A := by\n    apply Set.Finite.eq_of_subset_of_card_le A.toFinite hAxA\n    linarith only [h, Nat.card_mono B.toFinite hByB]\n  have hBy_eq : By = B := by\n    apply Set.Finite.eq_of_subset_of_card_le B.toFinite hByB\n    linarith only [h, Nat.card_mono A.toFinite hAxA]\n  have hN : N = \u22a4 := by\n    have : (A-A) \u222a (B-B) \u2286 N := by\n      rw [\u2190 hAx_eq, \u2190 hBy_eq, hAx, hBy]\n      intro z hz\n      simp [Set.mem_sub] at hz\n      convert (QuotientAddGroup.eq_zero_iff z).mp ?_\n      . infer_instance\n      rcases hz with \u27e8 a, \u27e8 -, ha\u27e9, a', \u27e8-, ha'\u27e9, haa' \u27e9 | \u27e8 b, \u27e8 -, hb\u27e9, b', \u27e8 -,hb'\u27e9, hbb' \u27e9\n      . rw [\u2190 haa']; simp [ha, ha']\n      rw [\u2190 hbb']; simp [hb, hb']\n    rw [\u2190 AddSubgroup.closure_le, hnot] at this\n    exact top_le_iff.mp this\n  have : Nat.card (G \u29f8 N) = 1 := by\n    rw [Nat.card_eq_one_iff_unique]\n    constructor\n    . rw [hN]\n      exact  QuotientAddGroup.subsingleton_quotient_top\n    infer_instance\n  simp [this] at hdim\n  rw [\u2190 le_div_iff' (by positivity)] at hdim\n  convert LE.le.trans ?_ hdim using 1\n  . field_simp\n  simp\n  exact \u27e8 dimension_le_rank A, dimension_le_rank B \u27e9\n\n/-- If $A\\subseteq \\mathbb{Z}^d$ is a finite non-empty set with $d[U_A;U_A]\\leq \\log K$ then there exists a non-empty $A'\\subseteq A$ such that\n$\\lvert A'\\rvert\\geq K^{-17}\\lvert A\\rvert$\nand $\\dim A'\\leq \\frac{40}{\\log 2} \\log K$. -/\n", "theoremStatement": "lemma weak_PFR {A : Set G} [Finite A] {K : \u211d} (hA : A.Nonempty) (hK: 0 < K) (hdist: d\u1d64[A # A] \u2264 log K):\n    \u2203 A' : Set G, A' \u2286 A \u2227 (Nat.card A') \u2265 K^(-17 : \u211d) * (Nat.card A)\n    \u2227 (dimension A') \u2264 (40 / log 2) * log K", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 1177, "tokenPositionInFile": 61189, "theoremPositionInFile": 30}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rcases weak_PFR_asymm A A hA hA with \u27e8A', A'', hA', hA'', hA'nonempty, hA''nonempty, hcard, hdim\u27e9\n\n  have : \u2203 B : Set G, B \u2286 A \u2227 (Nat.card B) \u2265 (Nat.card A') \u2227 (Nat.card B) \u2265 (Nat.card A'') \u2227 (dimension B) \u2264\nmax (dimension A') (dimension A'') := by\n    rcases lt_or_ge (Nat.card A') (Nat.card A'') with h | h\n    . use A''\n      exact \u27e8hA'', by linarith, by linarith, le_max_right _ _\u27e9\n    use A'\n    exact \u27e8hA', by linarith, by linarith, le_max_left _ _\u27e9\n\n  rcases this with \u27e8B, hB, hBcard, hBcard', hBdim\u27e9\n  use B\n  have hApos : Nat.card A > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    exact \u27e8hA.to_subtype, inferInstance\u27e9\n  have hA'pos : Nat.card A' > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    refine \u27e8 hA'nonempty.to_subtype, Finite.Set.subset _ hA' \u27e9\n  have hA''pos : Nat.card A'' > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    refine \u27e8 hA''nonempty.to_subtype, Finite.Set.subset _ hA'' \u27e9\n  have hBpos : Nat.card B > 0 := by linarith\n\n  refine \u27e8hB, ?_, ?_\u27e9\n  . have := calc 2 * log ((Nat.card A) / (Nat.card B))\n      _ = log ( ((Nat.card A) * (Nat.card A)) / ((Nat.card B) * (Nat.card B)) ) := by\n        convert (log_pow (((Nat.card A) : \u211d)/(Nat.card B)) 2).symm\n        field_simp\n        rw [\u2190 pow_two, \u2190 pow_two]\n      _ \u2264 log ( ((Nat.card A) * (Nat.card A)) / ((Nat.card A') * (Nat.card A'')) ) := by\n        apply log_le_log\n        . positivity\n        gcongr\n      _ \u2264 34 * d\u1d64[A # A] := hcard\n      _ \u2264 34 * log K := mul_le_mul_of_nonneg_left hdist (by linarith)\n      _ = 2 * (17 * log K) := by ring\n      _ = 2 * log (K^17) := by\n        congr\n        convert (log_pow K 17).symm\n    rw [mul_le_mul_left (by norm_num), log_le_log_iff (by positivity) (by positivity), div_le_iff (by positivity), <- mul_inv_le_iff (by positivity), <-ge_iff_le, mul_comm] at this\n    convert this using 2\n    convert zpow_neg K 17 using 1\n    norm_cast\n  calc (dimension B : \u211d)\n    _ \u2264 (((max (dimension A') (dimension A'')) : \u2115) : \u211d) := by norm_cast\n    _ \u2264 (40 / log 2) * d\u1d64[A # A] := hdim\n    _ \u2264 (40 / log 2) * log K := mul_le_mul_of_nonneg_left hdist (by positivity)", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 48, "proofLengthTokens": 2089}}
{"srcContext": "import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := \u2203 x : G, A = x +\u1d65 B\n\nlemma IsShift.sub_self_congr : IsShift A B \u2192 A - A = B - B := by\n  rintro \u27e8x, rfl\u27e9; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B \u2192 Nat.card A = Nat.card B := by rintro \u27e8x, rfl\u27e9; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) \u222a (B - B)) = \u22a4\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    \u2203 (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' \u2227 IsShift B B' \u2227 NotInCoset A' B' := by\n  obtain \u27e8x, hx\u27e9 := hA\n  obtain \u27e8y, hy\u27e9 := hB\n  set G' := AddSubgroup.closure ((A - A) \u222a (B - B))\n  set A' : Set G' := (\u2191) \u207b\u00b9' ((-x) +\u1d65 A)\n  set B' : Set G' := (\u2191) \u207b\u00b9' ((-y) +\u1d65 B)\n  have hxA : -x +\u1d65 A \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +\u1d65 B \u2286 range ((\u2191) : G' \u2192 G) := by\n    simp only [\u2190 singleton_add', \u2190 neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := \u27e8x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]\u27e9\n  have hB : IsShift B B' := \u27e8y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]\u27e9\n  refine \u27e8G', A', B', hA, hB, ?_\u27e9\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) \u222a (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [A', B', preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {\u03a9 \u03a9' : Type u} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  (\u03bc : Measure \u03a9 := by volume_tac) (\u03bc': Measure \u03a9' := by volume_tac)\n  [IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; \u03bc # (Y + Y) ; \u03bc'] \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := by\n  obtain \u27e8A, mA, \u03bcA, X', Y'\u2081, Y'\u2082, h\u03bcA, h_indep, hX'_meas, hY'\u2081_meas, hY'\u2082_meas, hX'_ident,\n    hY'\u2081_ident, hY'\u2082_ident, _, _, _\u27e9 := independent_copies3_nondep_finiteRange hX hY hY \u03bc \u03bc' \u03bc'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'\u2081, Y'\u2082] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors \u2115 G := hG.noZeroNsmulDivisors\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] = H[\u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8x, y\u2081, y\u2082\u27e9 \u21a6 (x, y\u2081 - y\u2082, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', \u27e8Y'\u2081, Y'\u2082\u27e9\u27e9 ; \u03bcA] = _\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hX'_meas <| Measurable.prod hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun X' (prod Y'\u2081 Y'\u2082) \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'\u2081_meas hY'\u2082_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2081_meas hY'\u2082_meas (h_indep.indepFun (show 1 \u2260 2 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, two_mul]\n  have : H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[X ; \u03bc] + H[Y ; \u03bc'] := calc\n    H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[\u27e8X', Y'\u2081\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u2081\u27e9 \u21a6 (x, x - 2 \u2022 y\u2081)\n      show H[f \u2218 \u27e8X', Y'\u2081\u27e9 ; \u03bcA] = _\n      apply entropy_comp_of_injective \u03bcA (by exact Measurable.prod hX'_meas hY'\u2081_meas) f\n      exact fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all [smul_right_inj]\n    _ = H[X ; \u03bc] + H[Y ; \u03bc'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'\u2081_meas (h_indep.indepFun (show 0 \u2260 1 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq]\n  let f : G \u00d7 G \u2192 G \u00d7 G := fun \u27e8x, y\u27e9 \u21a6 (x, y - x)\n  have hf : f.Injective := fun \u27e8_, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _\u27e9 := h; simp_all\n  have : H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      show _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082 - (Y'\u2081 - Y'\u2082)\u27e9 ; \u03bcA]\n      rw [sub_sub_sub_cancel_right, \u2190 sub_add_eq_sub_sub, two_nsmul]\n    _ = H[\u27e8Y'\u2081 - Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n      refine entropy_comp_of_injective \u03bcA (Measurable.prod ?_ ?_) f hf\n      \u00b7 exact Measurable.sub hY'\u2081_meas hY'\u2082_meas\n      \u00b7 exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] :=\n      entropy_pair_le_add (hY'\u2081_meas.sub' hY'\u2082_meas) (hX'_meas.sub' hY'\u2081_meas |>.sub' hY'\u2082_meas) \u03bcA\n  have : H[\u27e8X', \u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9\u27e9 ; \u03bcA] + H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] \u2264\n      H[\u27e8X', X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] + H[\u27e8Y'\u2081 - Y'\u2082, X' - 2 \u2022 Y'\u2081\u27e9 ; \u03bcA] := by\n    haveI : FiniteRange (Y'\u2081 - Y'\u2082) := FiniteRange.sub Y'\u2081 Y'\u2082\n    haveI : FiniteRange (2 \u2022 Y'\u2081) := by show FiniteRange ((fun x \u21a6 2 \u2022 x) \u2218 Y'\u2081); infer_instance\n    apply entropy_triple_add_entropy_le \u03bcA hX'_meas (Measurable.sub hY'\u2081_meas hY'\u2082_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'\u2081_meas 2\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := calc\n    H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] := by\n      let f : G \u00d7 G \u00d7 G \u2192 G \u00d7 G \u00d7 G := fun \u27e8y\u2081, y\u2082, x\u27e9 \u21a6 (y\u2081, y\u2082, x - y\u2081 - y\u2082)\n      show H[f \u2218 \u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA] = H[\u27e8Y'\u2081, \u27e8Y'\u2082, X'\u27e9\u27e9 ; \u03bcA]\n      refine entropy_comp_of_injective \u03bcA ?_ f ?_\n      \u00b7 exact Measurable.prod hY'\u2081_meas <| Measurable.prod hY'\u2082_meas hX'_meas\n      \u00b7 exact fun \u27e8_, _, _\u27e9 _ h \u21a6 by simp [f] at h; obtain \u27e8_, _, _\u27e9 := h; simp_all\n    _ = H[X ; \u03bc] + 2 * H[Y ; \u03bc'] := by\n      have : IndepFun Y'\u2081 (prod Y'\u2082 X') \u03bcA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'\u2081_meas (by exact Measurable.prod hY'\u2082_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'\u2082_meas hX'_meas (h_indep.indepFun (show 2 \u2260 0 by decide)),\n        hX'_ident.entropy_eq, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq]\n      group\n  have : H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := calc\n    H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := by rw [sub_right_comm] ; rfl\n    _ = H[\u27e8Y'\u2081, X' - Y'\u2082\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2081_meas <| Measurable.sub hX'_meas hY'\u2082_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2082 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2082) := FiniteRange.sub X' Y'\u2082\n      convert IndepFun.entropy_pair_eq_add hY'\u2081_meas (hX'_meas.sub hY'\u2082_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'\u2081_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := calc\n    H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] = H[f \u2218 \u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := rfl\n    _ = H[\u27e8Y'\u2082, X' - Y'\u2081\u27e9 ; \u03bcA] := entropy_comp_of_injective \u03bcA\n      (by exact Measurable.prod hY'\u2082_meas <| Measurable.sub hX'_meas hY'\u2081_meas) f hf\n    _ = H[Y ; \u03bc'] + H[X' - Y'\u2081 ; \u03bcA] := by\n      haveI : FiniteRange (X' - Y'\u2081) := FiniteRange.sub X' Y'\u2081\n      convert IndepFun.entropy_pair_eq_add hY'\u2082_meas (hX'_meas.sub hY'\u2081_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'\u2082_ident.entropy_eq.symm\n  have : H[\u27e8Y'\u2081, \u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9\u27e9 ; \u03bcA] + H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264\n      H[\u27e8Y'\u2081, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] + H[\u27e8Y'\u2082, X' - Y'\u2081 - Y'\u2082\u27e9 ; \u03bcA] := by\n    apply entropy_triple_add_entropy_le \u03bcA hY'\u2081_meas hY'\u2082_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'\u2081_meas) hY'\u2082_meas\n  have : H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := calc\n    H[X' - Y'\u2081 - Y'\u2082 ; \u03bcA] \u2264 H[X' - Y'\u2081 ; \u03bcA] + H[X' - Y'\u2082 ; \u03bcA] - H[X ; \u03bc] := by linarith\n    _ = 2 * d[X ; \u03bc # Y ; \u03bc'] + H[Y ; \u03bc'] := by\n      nth_rw 1 [two_mul, \u2190 hX'_ident.rdist_eq hY'\u2081_ident, \u2190 hX'_ident.rdist_eq hY'\u2082_ident]\n      have h1 : d[X' ; \u03bcA # Y'\u2081 ; \u03bcA] = H[X' - Y'\u2081 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2081 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 1 by decide)).rdist_eq hX'_meas hY'\u2081_meas\n      have h2 : d[X' ; \u03bcA # Y'\u2082 ; \u03bcA] = H[X' - Y'\u2082 ; \u03bcA] - H[X' ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 0 \u2260 2 by decide)).rdist_eq hX'_meas hY'\u2082_meas\n      rw [h1, h2, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] \u2264\n      d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := calc\n    d[X ; \u03bc # 2 \u2022 Y ; \u03bc'] = H[X' - 2 \u2022 Y'\u2081 ; \u03bcA] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 \u2022 Y'\u2081) (2 \u2022 Y) (\u03bc := \u03bcA) (\u03bd := \u03bc') := by\n        convert hY'\u2081_ident.comp <| measurable_discrete <| fun g \u21a6 2 \u2022 g\n      have h2Y_indep : IndepFun X' (2 \u2022 Y'\u2081) (\u03bc := \u03bcA) := by\n        convert (h_indep.indepFun (show 0 \u2260 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [\u2190 hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'\u2081_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ \u2264 H[Y'\u2081 - Y'\u2082 ; \u03bcA] + 2 * d[X ; \u03bc # Y ; \u03bc'] - H[X ; \u03bc] / 2 - H[2 \u2022 Y ; \u03bc'] / 2 := by linarith\n    _ = d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] + (H[Y ; \u03bc'] - H[X ; \u03bc]) / 2 + 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n      have H2Y : H[2 \u2022 Y ; \u03bc'] = H[Y ; \u03bc'] := by\n        let f (g : G) := 2 \u2022 g\n        exact entropy_comp_of_injective \u03bc' hY f (fun _ _ \u21a6 by simp [f, smul_right_inj])\n      have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] = H[Y'\u2081 - Y'\u2082 ; \u03bcA] - H[Y'\u2081 ; \u03bcA] / 2 - H[Y'\u2082 ; \u03bcA] / 2 :=\n        (h_indep.indepFun (show 1 \u2260 2 by decide)).rdist_eq hY'\u2081_meas hY'\u2082_meas\n      rw [this, hY'\u2081_ident.entropy_eq, hY'\u2082_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'\u2081 ; \u03bcA # Y'\u2082 ; \u03bcA] \u2264 2 * d[X ; \u03bc # Y ; \u03bc'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'\u2081_meas hX'_meas hY'\u2082_meas (\u03bc := \u03bcA) (\u03bc' := \u03bcA) (\u03bc'' := \u03bcA)\n    \u00b7 exact rdist_symm.trans (hY'\u2081_ident.rdist_eq hX'_ident).symm\n    \u00b7 exact (hX'_ident.rdist_eq hY'\u2082_ident).symm\n  rw [\u2190 two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (\u03bc := \u03bc) (\u03bc' := \u03bc')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (\u03c6 : G \u2192+ H) :\n  H[\u03c6 \u2218 X ; \u03bc] \u2264 10 * d[X; \u03bc # Y ; \u03bc'] := by\n  have :=\n    calc d[\u03c6 \u2218 X ; \u03bc # \u03c6 \u2218 (Y + Y); \u03bc'] \u2264 d[X; \u03bc # (Y + Y) ; \u03bc'] := rdist_of_hom_le \u03c6 hX (Measurable.add hY hY)\n    _ \u2264 5 * d[X; \u03bc # Y ; \u03bc'] := torsion_free_doubling X Y \u03bc \u03bc' hX hY hG\n  have eq_zero : \u03c6 \u2218 (Y + Y) = fun _ \u21a6 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, \u2190mul_assoc,\n    show (5*2 : \u211d) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G \u29f8 H) :=\n  \u27e8\u03bb _ \u21a6 by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }\u27e9\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {\u03a9 \u03a9' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace \u03a9] [MeasureSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n  {\u03b1 : \u211d} (hent : 20 * d[X # Y] < \u03b1 * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X] + H[Y]) \u2227\n  H[(QuotientAddGroup.mk' H) \u2218 X] + H[(QuotientAddGroup.mk' H) \u2218 Y] < \u03b1 * (H[X] + H[Y]) := by\n  let p : refPackage \u03a9 \u03a9' G := {\n    X\u2080\u2081 := X\n    X\u2080\u2082 := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    \u03b7 := 1/8\n    h\u03b7 := by norm_num\n    h\u03b7' := by norm_num }\n  obtain \u27e8H, \u03a9'', h\u03a9'', U, _, hUmeas, hUunif, ineq\u27e9 := entropic_PFR_conjecture_improv p rfl\n  let \u03c8 := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y]\n  have ent_le : H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 20 * d[X # Y] := calc\n    H[\u03c8 \u2218 X] + H[\u03c8 \u2218 Y] \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 exact ent_of_proj_le hX hUmeas hUunif\n      \u00b7 exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) \u2264 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ \u2264 |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ \u2264 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      \u00b7 rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ \u2264 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact \u27e8by linarith, by linarith\u27e9\n\nvariable [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (X : \u03a9 \u2192 G) (Y : \u03a9' \u2192 G)\n(\u03bc : Measure \u03a9 := by volume_tac) (\u03bc' : Measure \u03a9' := by volume_tac)\n[IsProbabilityMeasure \u03bc] [IsProbabilityMeasure \u03bc']\n\nlemma app_ent_PFR (\u03b1 : \u211d) (hent: 20 * d[X;\u03bc # Y;\u03bc'] < \u03b1 * (H[X; \u03bc] + H[Y; \u03bc'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) < (1 + \u03b1) / 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc']\n      < \u03b1 * (H[ X; \u03bc] + H[Y; \u03bc']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk \u03bc) (MeasureSpace.mk \u03bc') _ _ _ _ \u03b1 hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + \u03b1) / (2 * (1 - \u03b1)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (\u03b1 : \u211d) (hX : Measurable X) (hY : Measurable Y) (\u03b1pos : 0 < \u03b1) (\u03b1one : \u03b1 < 1) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X ; \u03bc] + H[Y ; \u03bc']) \u2227\n    \u03b1 * (H[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc']) \u2264\n      20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] := by\n  let S := { H : AddSubgroup G | (\u2203 (c : \u211d), 0 \u2264 c \u2227\n      log (Nat.card H) \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      c * (H[X; \u03bc] + H[Y;\u03bc'])) \u2227\n    20 * d[(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # (QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] <\n      \u03b1 * (H[ (QuotientAddGroup.mk' H) \u2218 X; \u03bc ] + H[ (QuotientAddGroup.mk' H) \u2218 Y; \u03bc']) }\n  have : 0 \u2264 H[X ; \u03bc] + H[Y ; \u03bc'] := by linarith [entropy_nonneg X \u03bc, entropy_nonneg Y \u03bc']\n  have : 0 < 1 - \u03b1 := sub_pos.mpr \u03b1one\n  by_cases hE : (\u22a5 : AddSubgroup G) \u2208 S\n  \u00b7 classical\n    obtain \u27e8H, \u27e8\u27e8c, hc, hlog, hup\u27e9, hent\u27e9, hMaxl\u27e9 :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set \u03c8 : G \u2192+ G \u29f8 H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective \u03c8 := QuotientAddGroup.mk'_surjective H\n\n    set G' := G \u29f8 H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain \u27e8H', hlog', hup'\u27e9 := app_ent_PFR _ _ _ _ \u03b1 hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' \u2260 \u22a5 := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (\u22a5 : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' \u29f8 \u22a5) \u2243+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (\u03c8 \u2218 X) \u03bc, entropy_nonneg (\u03c8 \u2218 Y) \u03bc']\n    let H'' := H'.comap \u03c8\n    use H''\n\n    rw [\u2190 (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map \u03c8 = H')] at hup' hlog'\n    set H' := H''.map \u03c8\n\n    have Hlt : H < H'' := by\n      have : H = (\u22a5 : AddSubgroup G').comap \u03c8 := by\n        simp only [\u03c8, AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let \u03c6 : G' \u29f8 H' \u2243+ G \u29f8 H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set \u03c8' : G' \u2192+ G' \u29f8 H' := QuotientAddGroup.mk' H'\n    set \u03c8'' : G \u2192+ G \u29f8 H'' := QuotientAddGroup.mk' H''\n    have diag : \u03c8' \u2218 \u03c8 = \u03c6.symm \u2218 \u03c8'' := rfl\n    rw [\u2190 Function.comp.assoc, \u2190 Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') \u2264\n        (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard\u2080 := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard\u2081 := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (\u03c8.restrict H'')).toEquiv\n        have hcard\u2082 := AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup (H.addSubgroupOf H'')\n        rw [\u03c8.ker_restrict H'', QuotientAddGroup.ker_mk', \u03c8.restrict_range H''] at hcard\u2081\n        simpa only [\u2190 Nat.card_eq_fintype_card, hcard\u2080, hcard\u2081] using hcard\u2082\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : \u211d) * (Nat.card H : \u211d)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ \u2264 (1 + \u03b1) / 2 * (H[\u21d1\u03c8 \u2218 X ; \u03bc] + H[\u21d1\u03c8 \u2218 Y ; \u03bc']) + log (Nat.card H) := by gcongr\n      _ \u2264 (1 + \u03b1) / 2 * (c * (H[X; \u03bc] + H[Y;\u03bc'])) +\n            (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by gcongr\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by\n        field_simp; ring\n\n    have HS : H'' \u2209 S := \u03bb Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [S, Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine \u27e8?_, HS \u27e8\u03b1 * c, by positivity, cond, ?_\u27e9\u27e9\n    \u00b7 calc\n      log (Nat.card H'')\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * (1 - \u03b1 * c) * (H[X; \u03bc] + H[Y;\u03bc']) := cond\n      _ \u2264 (1 + \u03b1) / (2 * (1 - \u03b1)) * 1 * (H[X; \u03bc] + H[Y;\u03bc']) := by gcongr; simp; positivity\n      _ = (1 + \u03b1) / (2 * (1 - \u03b1)) * (H[X; \u03bc] + H[Y;\u03bc']) := by simp only [mul_one]\n    \u00b7 calc\n      H[ \u03c8'' \u2218 X; \u03bc ] + H[ \u03c8'' \u2218 Y; \u03bc' ]\n      _ = H[ \u03c6.symm \u2218 \u03c8'' \u2218 X; \u03bc ] + H[ \u03c6.symm \u2218 \u03c8'' \u2218 Y; \u03bc' ] := by\n        simp_rw [\u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ \u03c6.symm.injective,\n                 \u2190 entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ \u03c6.symm.injective]\n      _ \u2264 \u03b1 * (H[ \u03c8 \u2218 X; \u03bc ] + H[ \u03c8 \u2218 Y; \u03bc' ]) := hup'.le\n      _ \u2264 \u03b1 * (c * (H[X ; \u03bc] + H[Y ; \u03bc'])) := by gcongr\n      _ = (\u03b1 * c) * (H[X ; \u03bc] + H[Y ; \u03bc']) := by ring\n  \u00b7 use \u22a5\n    constructor\n    \u00b7 simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    \u00b7 simp only [S, Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE \u27e81, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le \u03bc hX _) (entropy_comp_le \u03bc' hY _)\u27e9\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    \u2203 H : AddSubgroup G, log (Nat.card H) \u2264 2 * (H[X; \u03bc] + H[Y;\u03bc']) \u2227\n    H[(QuotientAddGroup.mk' H) \u2218 X; \u03bc] + H[(QuotientAddGroup.mk' H) \u2218 Y; \u03bc'] \u2264\n      34 * d[(QuotientAddGroup.mk' H) \u2218 X;\u03bc # (QuotientAddGroup.mk' H) \u2218 Y;\u03bc'] := by\n  rcases PFR_projection' X Y \u03bc \u03bc' ((3 : \u211d) / 5) hX hY (by norm_num) (by norm_num) with \u27e8H, h, h'\u27e9\n  refine \u27e8H, ?_, ?_\u27e9\n  \u00b7 convert h\n    norm_num\n  \u00b7 have : 0 \u2264 d[\u21d1(QuotientAddGroup.mk' H) \u2218 X ; \u03bc # \u21d1(QuotientAddGroup.mk' H) \u2218 Y ; \u03bc'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : \u211d} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {\u03c6 : A \u2192 X}\n    {A_ : H \u2192 Set G} (hA : A.Nonempty) (h\u03c6 : \u2200 x : X, A_ x = Subtype.val '' (\u03c6 \u207b\u00b9' {x})) :\n    \u2211 x in X, (Nat.card (A_ x) : \u211d) / (Nat.card A) = 1 := by\n  rw [\u2190 Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, \u2190 Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ \u21a6 Finset.mem_univ (\u03c6 a), \u2190 Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [\u2190 Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, \u2190 Nat.card_eq_fintype_card,\n    h\u03c6, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H \u03a9 \u03a9': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace \u03a9] [MeasureSpace \u03a9']\n    [IsProbabilityMeasure (\u2119 : Measure \u03a9)] [IsProbabilityMeasure (\u2119 : Measure \u03a9')]\n    (\u03c6 : G \u2192+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : \u03a9 \u2192 G} {UB: \u03a9' \u2192 G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : \u2200 \u03c9, UA \u03c9 \u2208 A) (hUB_mem : \u2200 \u03c9, UB \u03c9 \u2208 B) :\n    \u2203 (x y : H) (Ax By: Set G),\n    Ax = A \u2229 \u03c6.toFun \u207b\u00b9' {x} \u2227 By = B \u2229 \u03c6.toFun \u207b\u00b9' {y} \u2227 Ax.Nonempty \u2227 By.Nonempty \u2227\n    d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) \u2264\n    (H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A \u2229 \u03c6.toFun \u207b\u00b9' {x}\n  let B_ (y : H) : Set G := B \u2229 \u03c6.toFun \u207b\u00b9' {y}\n  let X : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UA)\n  let Y : Finset H := FiniteRange.toFinset (\u03c6.toFun \u2218 UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp x.property\n    use UA \u03c9; exact Set.mem_inter (hUA_mem \u03c9) (by exact h\u03c9)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := (FiniteRange.mem_iff _ _).mp y.property\n    use UB \u03c9; exact Set.mem_inter (hUB_mem \u03c9) (by exact h\u03c9)\n  have h_AX (a : A) : \u03c6.toFun a.val \u2208 X := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun a.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n  have h_BY (b : B) : \u03c6.toFun b.val \u2208 Y := by\n    obtain \u27e8\u03c9, h\u03c9\u27e9 := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (\u03c6.toFun b.val)).mpr \u27e8\u03c9, congr_arg _ h\u03c9\u27e9\n\n  let \u03c6_AX (a : A) : X := by use \u03c6.toFun a.val; exact h_AX a\n  let \u03c6_BY (b : B) : Y := by use \u03c6.toFun b.val; exact h_BY b\n  have h_\u03c6_AX (x : X) : A_ x.val = \u03c6_AX \u207b\u00b9' {x} := by ext; simp [A_, \u03c6_AX]; simp [Subtype.ext_iff]\n  have h_\u03c6_BY (y : Y) : B_ y.val = \u03c6_BY \u207b\u00b9' {y} := by ext; simp [B_, \u03c6_BY]; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : \u211d :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have :\n    \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] :=\n  calc\n    _ = d[UA | \u03c6.toFun \u2218 UA # UB | \u03c6.toFun \u2218 UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx \u21a6 Finset.sum_congr rfl <| fun y hy \u21a6 ?_\n      haveI : Nonempty (A_ x) := h_Ax \u27e8x, hx\u27e9\n      haveI : Nonempty (B_ y) := h_By \u27e8y, hy\u27e9\n      let \u03bcx := (\u2119 : Measure \u03a9)[|(\u03c6.toFun \u2218 UA) \u207b\u00b9' {x}]\n      let \u03bcy := (\u2119 : Measure \u03a9')[|(\u03c6.toFun \u2218 UB) \u207b\u00b9' {y}]\n      have h_\u03bc_p : IsProbabilityMeasure \u03bcx \u2227 IsProbabilityMeasure \u03bcy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_\u03bc_unif : IsUniform (A_ x) UA \u03bcx \u2227 IsUniform (B_ y) UB \u03bcy := by\n        have : _ \u2227 _ := \u27e8hUA.restrict hUA' (\u03c6.toFun \u207b\u00b9' {x}), hUB.restrict hUB' (\u03c6.toFun \u207b\u00b9' {y})\u27e9\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_\u03bc_p.1 h_\u03bc_p.2 h_\u03bc_unif.1 h_\u03bc_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA \u207b\u00b9' (_ \u207b\u00b9' _))) * (Measure.real _ (UB \u207b\u00b9' (_ \u207b\u00b9' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [p, A_, B_, IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ \u2264 d[UA # UB] - d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre \u03c6 hUA' hUB' (\u03bc := \u2119) (\u03bc' := \u2119)]\n  let M := H[\u03c6.toFun \u2218 UA] + H[\u03c6.toFun \u2218 UB]\n  have hM : M = \u2211 x in X, \u2211 y in Y, Real.negMulLog (p x y) := by\n    have h_compl {x y} (h_notin : (x, y) \u2209 X \u00d7\u02e2 Y) : Real.negMulLog (p x y) = 0 := by\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      suffices A_ x = \u2205 \u2228 B_ y = \u2205 by obtain h | h := this <;> rw [h] <;> simp\n      refine h_notin.imp ?_ ?_\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_AX \u27e8a, ha\u27e9)\n      \u00b7 rw [\u2190 not_nonempty_iff_eq_empty]\n        rintro h \u27e8a, ha, rfl\u27e9\n        exact h (h_BY \u27e8a, ha\u27e9)\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (\u03bc := \u2119) ((measurable_discrete \u03c6).comp hUB').aemeasurable\n    rewrite [\u2190 Finset.sum_product', \u2190 tsum_eq_sum fun _ \u21a6 h_compl, \u2190 measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [\u2190 Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp [p, A_, B_, mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n  have h_sum : \u2211 x in X, \u2211 y in Y,\n      (p x y) * (M * d\u1d64[A_ x # B_ y] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x y)) \u2264\n      M * d[UA # UB] :=\n  calc\n    _ = \u2211 x in X, \u2211 y in Y, (p x y) * M * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [hM, Finset.sum_mul, \u2190 Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ \u21a6 Finset.sum_congr rfl <| fun _ _ \u21a6 ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * \u2211 x in X, \u2211 y in Y, (p x y) * d\u1d64[A_ x # B_ y] + M * d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ \u2264 M * d[UA # UB] := by\n      rewrite [\u2190 left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      \u00b7 linarith\n      \u00b7 unfold_let M\n        linarith only [entropy_nonneg (\u03c6.toFun \u2218 UA) \u2119, entropy_nonneg (\u03c6.toFun \u2218 UB) \u2119]\n  have : \u2203 x : X, \u2203 y : Y,\n      M * d\u1d64[A_ x.val # B_ y.val] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p x.val y.val) \u2264\n      M * d[UA # UB] := by\n    let f (xy : H \u00d7 H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H \u00d7 H) := (p xy.1 xy.2) *\n      (M * d\u1d64[A_ xy.1 # B_ xy.2] + d[\u03c6.toFun \u2218 UA # \u03c6.toFun \u2218 UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : \u2200 xy \u2208 X \u00d7\u02e2 Y, f xy < g xy := by\n      refine fun xy h \u21a6 mul_lt_mul_of_pos_left ?_ ?_\n      \u00b7 exact hc \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9 \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n      \u00b7 haveI : Nonempty _ := h_Ax \u27e8xy.1, (Finset.mem_product.mp h).1\u27e9\n        haveI : Nonempty _ := h_By \u27e8xy.2, (Finset.mem_product.mp h).2\u27e9\n        simp only [p, div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X \u00d7\u02e2 Y) := by\n      use \u27e8\u03c6.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9,\n        \u03c6.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty \u27e8\u2119, inferInstance\u27e9\u27e9\n      exact Finset.mem_product.mpr \u27e8FiniteRange.mem _ _, FiniteRange.mem _ _\u27e9\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : \u2211 x in X \u00d7\u02e2 Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, p, mul_div_mul_comm, \u2190 Finset.mul_sum,\n        \u2190 sum_prob_preimage hA h_\u03c6_AX, sum_prob_preimage hB h_\u03c6_BY, mul_one]\n    rewrite [\u2190 Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain \u27e8x, y, hxy\u27e9 := this\n  refine \u27e8x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_\u27e9\n  rewrite [\u2190 inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) \u2264 M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G \u2245 \u2124\u1d48 then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    \u2203 (d : \u2115), \u2203 (S : Submodule \u2124 G) (v : G),\n      FiniteDimensional.finrank \u2124 S = d \u2227 \u2200 a \u2208 A, a - v \u2208 S := by\n  existsi FiniteDimensional.finrank \u2124 (\u22a4 : Submodule \u2124 G), \u22a4, 0\n  refine \u27e8rfl, fun a _ \u21a6 trivial\u27e9\n\n/-- The dimension of the affine span over `\u2124` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : \u2115 := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule \u2124 G) (v : G)\n    (hA : \u2200 a \u2208 A, a - v \u2208 S) : dimension A \u2264 FiniteDimensional.finrank \u2124 S := by\n  apply Nat.find_le\n  existsi S , v\n  exact \u27e8rfl, hA\u27e9\n\nlemma dimension_le_rank [Module.Finite \u2124 G] (A : Set G) :\n    dimension A \u2264 FiniteDimensional.finrank \u2124 G := by\n  obtain \u27e8S, v, hs, _\u27e9 := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, \u2190hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free \u2124 G] [Module.Finite \u2124 G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M \u2192 N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (\u03b1 := \u03b1) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [g, h, hf]\n    \u00b7 simp [g, h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp [g]\n  have hfg : (f \u2218 g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [\u2190 Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with \u27e8 n, hn, hn' \u27e9\n    apply_fun Module.Free.repr \u2124 G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G \u29f8 (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 \u2227 Finite H \u2227 Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  set \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex \u2124 G\n  let bG : Basis B \u2124 G := Module.Free.chooseBasis \u2124 G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank \u2124 G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B \u2192\u2080 \u2124) \u2192+ (B \u2192\u2080 ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G \u2192+ (B \u2192\u2080 \u2124) := bG.repr\n  have hker : G\u2082 \u2264 AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp only [AddMonoidHom.mem_range, G\u2082, \u03c8, zsmulAddGroupHom_apply] at hx\n    simp_rw [AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, Function.comp_apply, mod,\n      Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom]\n    rcases hx with \u27e8y, rfl\u27e9\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H \u2192+ (B \u2192\u2080 ZMod 2) := QuotientAddGroup.lift G\u2082 (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod \u2218 bG.repr = g \u2218 (QuotientAddGroup.mk' G\u2082) := by\n      ext x b\n      simp_rw [mod, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', g]\n      rw [QuotientAddGroup.lift_mk]\n      simp [mod, f]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G\u2082 x with \u27e8y, rfl\u27e9\n    simp only [QuotientAddGroup.mk'_apply, g] at hx\n    rw [QuotientAddGroup.lift_mk] at hx\n    simp_rw [AddMonoidHom.coe_comp, Function.comp_apply, mod, Finsupp.mapRange.addMonoidHom_apply,\n      Int.coe_castAddHom, DFunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,\n      ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x \u21a6 Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis \u2124 G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change \u2200 b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range]\n    simp_rw [\u03c8, zsmulAddGroupHom_apply]\n    use x'\n    change 2 \u2022 (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [\u2190 AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : \u2124)]\n    rw [\u2190 LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 \u2022 z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, \u2190 hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp \u27e8 hinj, hsur \u27e9 with \u27e8 g', hg' \u27e9\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with \u27e8 n, rfl \u27e9\n        change g ((n : ZMod 2) \u2022 x) = (n : ZMod 2) \u2022 g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank \u2124 G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, \u2190 Nat.card_eq_fintype_card (\u03b1 := B), hB_card]\n    congr\n  exact \u27e8 hH_elem, Finite.of_fintype H, hH_card \u27e9\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G\u2082 \u2264 G and H' is a subgroup of G\u29f8G\u2082, then there is a canonical isomorphism between H\u29f8H' and G\u29f8N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G\u2082 : AddSubgroup G} (H' : AddSubgroup (G \u29f8 G\u2082)) :\n  let H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  \u2203 e : H \u29f8 H' \u2243+ G \u29f8 N, \u2200 x : G, e (mk' H' (\u03c6 x))= mk' N x := by\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := mk' G\u2082\n  let N := AddSubgroup.comap \u03c6 H'\n  have h1 : G\u2082 \u2264 N := by\n    intro x hx\n    rw [\u2190 eq_zero_iff] at hx\n    have : \u03c6 x = 0 := hx\n    simp [N, this, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G\u2082) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G\u2082) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G\u2082)]\n    simp\n  let e1 : H \u29f8 H'' \u2243+ G \u29f8 N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {\u03a9 : Type u} [MeasurableSpace \u03a9] [DiscreteMeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n    [IsProbabilityMeasure \u03bc] {A : Set \u03a9} {z : \u03a9} (hA : \u03bc.real A = 1) (hz : \u03bc.real {z} > 0) :\n    z \u2208 A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (\u03bc := \u03bc) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (\u03bc := \u03bc) (show insert z A \u2286 Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} \u2264 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 \u2264 \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    \u2203 (N : AddSubgroup G) (x y : G \u29f8 N) (Ax By : Set G), Ax.Nonempty \u2227 By.Nonempty \u2227\n    Set.Finite Ax \u2227 Set.Finite By \u2227 Ax = {z:G | z \u2208 A \u2227 QuotientAddGroup.mk' N z = x } \u2227\n    By = {z:G | z \u2208 B \u2227 QuotientAddGroup.mk' N z = y } \u2227\n    (log 2) * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) +\n      40 * d\u1d64[ A # B ] \u2227 log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      \u2264 34 * (d\u1d64[ A # B ] - d\u1d64[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain \u27e8 h_elem, h_finite, h_card \u27e9 := weak_PFR_quotient_prelim (G := G)\n  set \u03c8 : G \u2192+ G := zsmulAddGroupHom 2\n  set G\u2082 := AddMonoidHom.range \u03c8\n  set H := G \u29f8 G\u2082\n  let \u03c6 : G \u2192+ H := QuotientAddGroup.mk' G\u2082\n  let _mH : MeasurableSpace H := \u22a4\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain \u27e8 \u03a9, m\u03a9, UA, h\u03bc, hUA_mes, hUA_unif, hUA_mem, hUA_fin \u27e9 := exists_isUniform_measureSpace' A\n  obtain \u27e8 \u03a9', m\u03a9', UB, h\u03bc', hUB_mes, hUB_unif, hUB_mem, hUB_fin \u27e9 :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (\u03c6.toFun \u2218 UA) (\u03c6.toFun \u2218 UB) \u2119 \u2119 (by measurability) (by measurability)) with \u27e8H', \u27e8 hH1, hH2 \u27e9 \u27e9\n  let N := AddSubgroup.comap \u03c6 H'\n  set \u03c6' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G \u29f8 N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G \u29f8 N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with \u27e8 e : H \u29f8 H' \u2243+ G \u29f8 N, he \u27e9\n  rcases single_fibres \u03c6' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    \u27e8x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq\u27e9\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB \u2119 \u2119 hUA_mes hUB_mes h_torsionfree \u03c6\n  have h2 := torsion_dist_shrinking UB UA \u2119 \u2119 hUB_mes hUA_mes h_torsionfree \u03c6\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[\u03c6.toFun \u2218 UA] \u2264 10 * d\u1d64[A # B] at h1\n  change H[\u03c6.toFun \u2218 UB] \u2264 10 * d\u1d64[A # B] at h2\n  replace hH1 : log (Nat.card H') \u2264 40  * d\u1d64[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank \u2124 G \u2264 log (Nat.card (G \u29f8 N)) + 40 * d\u1d64[A # B] := by\n    rw [mul_comm, \u2190 log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [\u2190 h_card, \u2190 Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, \u2190 AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, \u2190 Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine \u27e8 hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ \u27e9\n\n  replace hH2 : H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] \u2264 34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] := by\n    set X := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UA\n    set Y := ((mk' H').toFun \u2218 \u03c6.toFun) \u2218 UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] \u2264 34 * d[X # Y] at hH2\n\n    have ha : \u03c6'.toFun \u2218 UA = e.toFun \u2218 X := by ext x; exact (he (UA x)).symm\n    have hb : \u03c6'.toFun \u2218 UB = e.toFun \u2218 Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun \u2218 X # e.toFun \u2218 Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : \u03a9 \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UA\n  set Y : \u03a9' \u2192 G \u29f8 N := \u03c6'.toFun \u2218 UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (\u03bc := \u2119) (\u03bc' := \u2119) hX hY) with h | h\n  swap\n  . rw [\u2190 h] at hH2\n    have hH2A : H[X] \u2265 0 := entropy_nonneg _ _\n    have hH2B : H[Y] \u2265 0 := entropy_nonneg _ _\n    have hH2A' : H[X] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] \u2264 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hX hH2A' with \u27e8 x', hx \u27e9\n    rcases const_of_nonpos_entropy (\u03bc := \u2119) hY hH2B' with \u27e8 y', hy \u27e9\n\n    have hAAx {z : G} (hz : z \u2208 A) : \u03c6'.toFun z = x' := by\n      change (\u2119).real (UA\u207b\u00b9' (\u03c6'\u207b\u00b9' {x'})) = 1 at hx\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Af, Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Af, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Af := by simp [Af, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((\u2119).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some \u2208 Ax := hnAx.some_mem\n      simp [hAx] at h \u22a2\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z \u2208 B) : \u03c6'.toFun z = y' := by\n      change (\u2119).real (UB\u207b\u00b9' (\u03c6'\u207b\u00b9' {y'})) = 1 at hy\n      rw [\u2190 MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Bf, Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Bf, Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z \u2208 Bf := by simp [Bf, Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB \u2119).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((\u2119).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((\u2119).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some \u2208 By := hnBy.some_mem\n      simp [hBy] at h \u22a2\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ \u2264 (H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := hcard_ineq\n    _ \u2264 (34 * d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB]) * (d[UA # UB] - d\u1d64[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete \u03c6'.toFun) hUA_mes) (Measurable.comp (measurable_discrete \u03c6'.toFun) hUB_mes)\n      replace this : 0 < H[\u03c6'.toFun \u2218 UA] + H[\u03c6'.toFun \u2218 UB] := by linarith\n      rw [\u2190 mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 \u2264 d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [\u2190 mul_zero d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d[UA # UB] - d\u1d64[Ax # By])) := by ring\n    _ = d[\u03c6'.toFun \u2218 UA # \u03c6'.toFun \u2218 UB] * (34 * (d\u1d64[A # B] - d\u1d64[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist h\u03bc h\u03bc' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  \u2203 A' B' : Set G, A' \u2286 A \u2227 B' \u2286 B \u2227 A'.Nonempty \u2227 B'.Nonempty \u2227\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) \u2264 34 * d\u1d64[A # B] \u2227\n  max (dimension A') (dimension B') \u2264 (40 / log 2) * d\u1d64[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) \u222a (B-B)) = \u22a4\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H \u21a6 (a:G) + x) '' A) \u2264 dimension A := by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with \u27e8 S, v, hrank, hshift \u27e9\n  change FiniteDimensional.finrank \u2124 S = dimension A at hrank\n  rw [\u2190 hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with \u27e8 b, \u27e8 hb, hb'\u27e9 \u27e9\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [\u2190 hb']\n  abel\n\nlemma conclusion_transfers {A B : Set G}\n    (G': AddSubgroup G) (A' B' : Set G')\n    (hA : IsShift A A') (hB : IsShift B B') [Finite A'] [Finite B'] (hA' : A'.Nonempty) (hB' : B'.Nonempty)\n    (h : WeakPFRAsymmConclusion A' B') : WeakPFRAsymmConclusion A B := by\n  have : Nonempty A' := hA'.to_subtype\n  have : Nonempty B' := hB'.to_subtype\n  rcases h with \u27e8A'', B'', hA'', hB'', hA''_non, hB''_non, hcard_ineq, hdim_ineq\u27e9\n  rcases hA with \u27e8 x, hA \u27e9\n  set f : G' \u2192 G := fun a \u21a6 (a : G) + x\n  have hf : Function.Injective f := by\n    intro y z hyz\n    simp [f] at hyz\n    exact hyz\n  have hA' : A = f '' A' := by\n    simp_rw [hA, \u2190 Set.image_vadd, Set.image_image, vadd_eq_add, f, add_comm]; rfl\n  rcases hB with \u27e8 y, hB \u27e9\n  set g : G' \u2192 G := fun a \u21a6 (a : G) + y\n  have hg : Function.Injective g := by\n    intro y z hyz\n    simp [g] at hyz\n    exact hyz\n  have hB' : B = g '' B' := by\n    simp_rw [hB, \u2190 Set.image_vadd, Set.image_image, vadd_eq_add, g, add_comm]; rfl\n  use f '' A'', g '' B''\n  have : d\u1d64[A # B] = d\u1d64[A' # B'] := by\n    rw [<-rdist_set_of_inj _ _ (\u03c6 := G'.subtype) Subtype.val_injective, <-rdist_set_add_const (G'.subtype '' A') (G'.subtype '' B') x y]\n    congr\n    . rw [hA]\n      ext y\n      simp [Set.mem_vadd_set]\n      constructor\n      . rintro \u27e8 z, \u27e8 \u27e8 w, hw \u27e9, rfl \u27e9 \u27e9\n        have : x + z + -x \u2208 G' := by simp [w]\n        use this\n        simp\n        convert hw\n      rintro \u27e8 h, ha \u27e9\n      use y + -x\n      constructor\n      . use h\n      abel\n    rw [hB]\n    ext x\n    simp [Set.mem_vadd_set]\n    constructor\n    . rintro \u27e8 z, \u27e8 \u27e8 w, hw \u27e9, rfl \u27e9 \u27e9\n      have : y + z + -y \u2208 G' := by simp [w]\n      use this\n      simp\n      convert hw\n    rintro \u27e8 h, ha \u27e9\n    use x + -y\n    constructor\n    . use h\n    abel\n\n\n  refine \u27e8 ?_, ?_, ?_, ?_, ?_, ?_ \u27e9\n  . simp [hA', hf, hA'']\n  . simp [hB', hg, hB'']\n  . simp [hA''_non]\n  . simp [hB''_non]\n  . convert hcard_ineq using 2\n    . congr 3\n      . rw [hA', Nat.card_image_of_injective hf]\n      . rw [hB', Nat.card_image_of_injective hg]\n      . rw [Nat.card_image_of_injective hf]\n      rw [Nat.card_image_of_injective hg]\n  convert LE.le.trans _ hdim_ineq using 2\n  norm_cast\n  apply max_le_max\n  . exact dimension_of_shift A'' x\n  \u00b7 exact dimension_of_shift B'' y\n\n/-- If $A,B\\subseteq \\mathbb{Z}^d$ are finite non-empty sets then there exist non-empty $A'\\subseteq A$ and $B'\\subseteq B$ such that\n\\[\\log\\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A'\\rvert\\lvert B'\\rvert}\\leq 34 d[U_A;U_B]\\]\nsuch that $\\max(\\dim A',\\dim B')\\leq \\frac{40}{\\log 2} d[U_A;U_B]$. -/\nlemma weak_PFR_asymm (A B : Set G) [Finite A] [Finite B] (hA : A.Nonempty) (hB : B.Nonempty) : WeakPFRAsymmConclusion A B  := by\n  let P : \u2115 \u2192 Prop := fun M \u21a6 (\u2200 (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free \u2124 G) (_hG_fin : Module.Finite \u2124 G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) \u2264 M), WeakPFRAsymmConclusion A B)\n  suffices \u2200 M, (\u2200 M', M' < M \u2192 P M') \u2192 P M by\n    set M := (Nat.card A) + (Nat.card B)\n    have hM : (Nat.card A) + (Nat.card B) \u2264 M := Nat.le_refl _\n    convert (Nat.strong_induction_on (p := P) M this) G \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a _ \u2039_\u203a A B \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a hM\n  intro M h_induct\n  -- wlog we can assume A, B are not in cosets of a smaller subgroup\n  suffices \u2200 (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free \u2124 G)\n    (_hG_fin : Module.Finite \u2124 G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G)\n    (_hG_sing : MeasurableSingletonClass G) (A B : Set G) (_hA_fin : Finite A) (_hB_fin : Finite B) (_hA_non : A.Nonempty) (_hB_non : B.Nonempty) (_hM : Nat.card A + Nat.card B \u2264 M)\n    (_hnot : NotInCoset A B), WeakPFRAsymmConclusion A B by\n    intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM\n    obtain \u27e8 G', A', B', hAA', hBB', hnot' \u27e9 := wlog_notInCoset hA_non hB_non\n    have hG'_fin : Module.Finite \u2124 G' :=\n      Module.Finite.iff_fg (N := AddSubgroup.toIntSubmodule G').2 (IsNoetherian.noetherian _)\n\n    have hG'_free : Module.Free \u2124 G' := by\n      rcases Submodule.nonempty_basis_of_pid (Module.Free.chooseBasis \u2124 G) (AddSubgroup.toIntSubmodule G') with \u27e8 n, \u27e8 b \u27e9 \u27e9\n      exact Module.Free.of_basis b\n    have hAA'_card: Nat.card A = Nat.card A' := (Nat.card_image_of_injective Subtype.val_injective _) \u25b8 hAA'.card_congr\n    have hBB'_card: Nat.card B = Nat.card B' := (Nat.card_image_of_injective Subtype.val_injective _) \u25b8 hBB'.card_congr\n    have hA_non' : Nonempty A := Set.nonempty_coe_sort.mpr hA_non\n    have hB_non' : Nonempty B := Set.nonempty_coe_sort.mpr hB_non\n\n    rw [hAA'_card, hBB'_card] at hM\n\n    have hA'_nonfin : A'.Nonempty \u2227 Finite A' := by\n      have := Nat.card_pos (\u03b1 := A)\n      rw [hAA'_card, Nat.card_pos_iff] at this\n      exact \u27e8@nonempty_of_nonempty_subtype _ _ this.1, this.2\u27e9\n    have hB'_nonfin : B'.Nonempty \u2227 Finite B' := by\n      have := Nat.card_pos (\u03b1 := B)\n      rw [hBB'_card, Nat.card_pos_iff] at this\n      exact \u27e8@nonempty_of_nonempty_subtype _ _ this.1, this.2\u27e9\n    obtain \u27e8 hA'_non, hA'_fin \u27e9 := hA'_nonfin\n    obtain \u27e8 hB'_non, hB'_fin \u27e9 := hB'_nonfin\n\n    replace this := this G' _ hG'_free hG'_fin (by infer_instance) (by infer_instance) (by infer_instance) A' B' hA'_fin hB'_fin hA'_non hB'_non hM hnot'\n    exact conclusion_transfers G' A' B' hAA' hBB' hA'_non hB'_non this\n  intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM hnot\n  rcases weak_PFR_asymm_prelim A B hA_non hB_non with \u27e8 N, x, y, Ax, By, hAx_non, hBy_non, hAx_fin, hBy_fin, hAx, hBy, hdim, hcard\u27e9\n  have hAxA : Ax \u2286 A := by rw [hAx]; simp\n  have hByB : By \u2286 B := by rw [hBy]; simp\n  have hA_pos : (0 : \u211d) < Nat.card A := Nat.cast_pos.mpr (@Nat.card_pos _ hA_non.to_subtype _)\n  have hB_pos : (0 : \u211d) < Nat.card B := Nat.cast_pos.mpr (@Nat.card_pos _ hB_non.to_subtype _)\n\n  rcases lt_or_ge (Nat.card Ax + Nat.card By) (Nat.card A + Nat.card B) with h | h\n  . replace h := h_induct (Nat.card Ax + Nat.card By) (h.trans_le hM) G hG_comm hG_free hG_fin hG_count hG_mes hG_sing Ax By (Set.finite_coe_iff.mpr hAx_fin) (Set.finite_coe_iff.mpr hBy_fin) hAx_non hBy_non (Eq.le rfl)\n    rcases h with \u27e8 A', B', hA', hB', hA'_non, hB'_non, hcard_ineq, hdim_ineq \u27e9\n    use A', B'\n    have hAx_fin' := Set.finite_coe_iff.mpr hAx_fin\n    have hBy_fin' := Set.finite_coe_iff.mpr hBy_fin\n    have hA'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hAx_fin hA')\n    have hB'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hBy_fin hB')\n    have hAx_non' := Set.nonempty_coe_sort.mpr hAx_non\n    have hBy_non' := Set.nonempty_coe_sort.mpr hBy_non\n    have hA'_non' := Set.nonempty_coe_sort.mpr hA'_non\n    have hB'_non' := Set.nonempty_coe_sort.mpr hB'_non\n    have hAx_pos : (0 : \u211d) < Nat.card Ax := Nat.cast_pos.mpr Nat.card_pos\n    have hBy_pos : (0 : \u211d) < Nat.card By := Nat.cast_pos.mpr Nat.card_pos\n    have hA'_pos : (0 : \u211d) < Nat.card A' := Nat.cast_pos.mpr Nat.card_pos\n    have hB'_pos : (0 : \u211d) < Nat.card B' := Nat.cast_pos.mpr Nat.card_pos\n    have hAxA_le : (Nat.card Ax : \u211d) \u2264 (Nat.card A : \u211d) := Nat.cast_le.mpr (Nat.card_mono A.toFinite hAxA)\n    have hByB_le : (Nat.card By : \u211d) \u2264 (Nat.card B : \u211d) := Nat.cast_le.mpr (Nat.card_mono B.toFinite hByB)\n\n    refine \u27e8 hA'.trans hAxA, hB'.trans hByB, hA'_non, hB'_non, ?_, ?_ \u27e9\n    . rw [four_logs hA_pos hB_pos hA'_pos hB'_pos]\n      rw [four_logs hAx_pos hBy_pos hA'_pos hB'_pos] at hcard_ineq\n      linarith only [hcard, hcard_ineq]\n    apply hdim_ineq.trans\n    gcongr\n    linarith only [Real.log_le_log hAx_pos hAxA_le, Real.log_le_log hBy_pos hByB_le, hcard]\n  use A, B\n  refine \u27e8 Eq.subset rfl, Eq.subset rfl, hA_non, hB_non, ?_, ?_ \u27e9\n  . have := hA_non.to_subtype\n    have := hB_non.to_subtype\n    apply LE.le.trans _ <| mul_nonneg (by norm_num) <| rdist_set_nonneg A B\n    rw [div_self (by positivity)]\n    simp\n  have hAx_eq : Ax = A := by\n    apply Set.Finite.eq_of_subset_of_card_le A.toFinite hAxA\n    linarith only [h, Nat.card_mono B.toFinite hByB]\n  have hBy_eq : By = B := by\n    apply Set.Finite.eq_of_subset_of_card_le B.toFinite hByB\n    linarith only [h, Nat.card_mono A.toFinite hAxA]\n  have hN : N = \u22a4 := by\n    have : (A-A) \u222a (B-B) \u2286 N := by\n      rw [\u2190 hAx_eq, \u2190 hBy_eq, hAx, hBy]\n      intro z hz\n      simp [Set.mem_sub] at hz\n      convert (QuotientAddGroup.eq_zero_iff z).mp ?_\n      . infer_instance\n      rcases hz with \u27e8 a, \u27e8 -, ha\u27e9, a', \u27e8-, ha'\u27e9, haa' \u27e9 | \u27e8 b, \u27e8 -, hb\u27e9, b', \u27e8 -,hb'\u27e9, hbb' \u27e9\n      . rw [\u2190 haa']; simp [ha, ha']\n      rw [\u2190 hbb']; simp [hb, hb']\n    rw [\u2190 AddSubgroup.closure_le, hnot] at this\n    exact top_le_iff.mp this\n  have : Nat.card (G \u29f8 N) = 1 := by\n    rw [Nat.card_eq_one_iff_unique]\n    constructor\n    . rw [hN]\n      exact  QuotientAddGroup.subsingleton_quotient_top\n    infer_instance\n  simp [this] at hdim\n  rw [\u2190 le_div_iff' (by positivity)] at hdim\n  convert LE.le.trans ?_ hdim using 1\n  . field_simp\n  simp\n  exact \u27e8 dimension_le_rank A, dimension_le_rank B \u27e9\n\n/-- If $A\\subseteq \\mathbb{Z}^d$ is a finite non-empty set with $d[U_A;U_A]\\leq \\log K$ then there exists a non-empty $A'\\subseteq A$ such that\n$\\lvert A'\\rvert\\geq K^{-17}\\lvert A\\rvert$\nand $\\dim A'\\leq \\frac{40}{\\log 2} \\log K$. -/\nlemma weak_PFR {A : Set G} [Finite A] {K : \u211d} (hA : A.Nonempty) (hK: 0 < K) (hdist: d\u1d64[A # A] \u2264 log K):\n    \u2203 A' : Set G, A' \u2286 A \u2227 (Nat.card A') \u2265 K^(-17 : \u211d) * (Nat.card A)\n    \u2227 (dimension A') \u2264 (40 / log 2) * log K := by\n  rcases weak_PFR_asymm A A hA hA with \u27e8A', A'', hA', hA'', hA'nonempty, hA''nonempty, hcard, hdim\u27e9\n\n  have : \u2203 B : Set G, B \u2286 A \u2227 (Nat.card B) \u2265 (Nat.card A') \u2227 (Nat.card B) \u2265 (Nat.card A'') \u2227 (dimension B) \u2264\nmax (dimension A') (dimension A'') := by\n    rcases lt_or_ge (Nat.card A') (Nat.card A'') with h | h\n    . use A''\n      exact \u27e8hA'', by linarith, by linarith, le_max_right _ _\u27e9\n    use A'\n    exact \u27e8hA', by linarith, by linarith, le_max_left _ _\u27e9\n\n  rcases this with \u27e8B, hB, hBcard, hBcard', hBdim\u27e9\n  use B\n  have hApos : Nat.card A > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    exact \u27e8hA.to_subtype, inferInstance\u27e9\n  have hA'pos : Nat.card A' > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    refine \u27e8 hA'nonempty.to_subtype, Finite.Set.subset _ hA' \u27e9\n  have hA''pos : Nat.card A'' > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    refine \u27e8 hA''nonempty.to_subtype, Finite.Set.subset _ hA'' \u27e9\n  have hBpos : Nat.card B > 0 := by linarith\n\n  refine \u27e8hB, ?_, ?_\u27e9\n  . have := calc 2 * log ((Nat.card A) / (Nat.card B))\n      _ = log ( ((Nat.card A) * (Nat.card A)) / ((Nat.card B) * (Nat.card B)) ) := by\n        convert (log_pow (((Nat.card A) : \u211d)/(Nat.card B)) 2).symm\n        field_simp\n        rw [\u2190 pow_two, \u2190 pow_two]\n      _ \u2264 log ( ((Nat.card A) * (Nat.card A)) / ((Nat.card A') * (Nat.card A'')) ) := by\n        apply log_le_log\n        . positivity\n        gcongr\n      _ \u2264 34 * d\u1d64[A # A] := hcard\n      _ \u2264 34 * log K := mul_le_mul_of_nonneg_left hdist (by linarith)\n      _ = 2 * (17 * log K) := by ring\n      _ = 2 * log (K^17) := by\n        congr\n        convert (log_pow K 17).symm\n    rw [mul_le_mul_left (by norm_num), log_le_log_iff (by positivity) (by positivity), div_le_iff (by positivity), <- mul_inv_le_iff (by positivity), <-ge_iff_le, mul_comm] at this\n    convert this using 2\n    convert zpow_neg K 17 using 1\n    norm_cast\n  calc (dimension B : \u211d)\n    _ \u2264 (((max (dimension A') (dimension A'')) : \u2115) : \u211d) := by norm_cast\n    _ \u2264 (40 / log 2) * d\u1d64[A # A] := hdim\n    _ \u2264 (40 / log 2) * log K := mul_le_mul_of_nonneg_left hdist (by positivity)\n\n/-- Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A-A\\rvert\\leq K\\lvert A\\rvert$.\nThere exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$\nand $\\dim A' \\leq \\frac{40}{\\log 2} \\log K$.-/\n", "theoremStatement": "theorem weak_PFR_int {A : Set G} [Finite A] (hnA : A.Nonempty) {K : \u211d} (hK : 0 < K)\n    (hA: Nat.card (A-A) \u2264 K * Nat.card A) :\n    \u2203 A' : Set G, A' \u2286 A \u2227 Nat.card A' \u2265 K ^ (-17 : \u211d) * (Nat.card A) \u2227\n      dimension A' \u2264 (40 / log 2) * log K", "fileCreated": "25309ad 20231211", "theoremCreated": "c0c547a 20240116", "file": "PFR/WeakPFR.lean", "positionMetadata": {"lineInFile": 1231, "tokenPositionInFile": 63710, "theoremPositionInFile": 31}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  apply weak_PFR hnA hK ((rdist_set_le A A hnA hnA).trans _)\n  suffices log (Nat.card (A-A)) \u2264 log K + log (Nat.card A) by linarith\n  rw [\u2190 log_mul (by positivity) _]\n  . apply log_le_log _ hA\n    norm_cast\n    have : Nonempty (A-A) := by\n      exact Set.Nonempty.coe_sort (Set.Nonempty.sub hnA hnA)\n    apply Nat.card_pos\n  norm_cast\n  apply ne_of_gt (@Nat.card_pos _ hnA.to_subtype _)", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 11, "proofLengthTokens": 389}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\n", "theoremStatement": "lemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k", "fileCreated": "59160fb 20231116", "theoremCreated": "8035e66 20231125", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 55, "tokenPositionInFile": 1892, "theoremPositionInFile": 2}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 15, "proofLengthTokens": 516}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\nlemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k := by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring\n\n/-- The distance $d[X_1+\\tilde X_2; X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1]) - \\eta (d[X^0_2; X_2+\\tilde X_1] - d[X^0_2; X_2]).$$ -/\n", "theoremStatement": "lemma rdist_of_sums_ge :\n    d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082])", "fileCreated": "59160fb 20231116", "theoremCreated": "f99eb0d 20231123", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 74, "tokenPositionInFile": 2747, "theoremPositionInFile": 3}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "distance_ge_of_min _ h_min (hX\u2081.add hX\u2082') (hX\u2082.add hX\u2081')", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 1, "proofLengthTokens": 56}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\nlemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k := by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring\n\n/-- The distance $d[X_1+\\tilde X_2; X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1]) - \\eta (d[X^0_2; X_2+\\tilde X_1] - d[X^0_2; X_2]).$$ -/\nlemma rdist_of_sums_ge :\n    d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  distance_ge_of_min _ h_min (hX\u2081.add hX\u2082') (hX\u2082.add hX\u2081')\n\n/-- The distance $d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1 | X_1 + \\tilde X_2] - d[X^0_1; X_1]) - \\eta(d[X^0_2; X_2 | X_2 + \\tilde X_1] - d[X^0_2; X_2]).$$\n-/\n", "theoremStatement": "lemma condRuzsaDist_of_sums_ge :\n    d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082])", "fileCreated": "59160fb 20231116", "theoremCreated": "2e4cc62 20231201", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 83, "tokenPositionInFile": 3171, "theoremPositionInFile": 4}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "condRuzsaDistance_ge_of_min _ h_min hX\u2081 hX\u2082 _ _ (by measurability) (by measurability)", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 1, "proofLengthTokens": 85}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\nlemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k := by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring\n\n/-- The distance $d[X_1+\\tilde X_2; X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1]) - \\eta (d[X^0_2; X_2+\\tilde X_1] - d[X^0_2; X_2]).$$ -/\nlemma rdist_of_sums_ge :\n    d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  distance_ge_of_min _ h_min (hX\u2081.add hX\u2082') (hX\u2082.add hX\u2081')\n\n/-- The distance $d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1 | X_1 + \\tilde X_2] - d[X^0_1; X_1]) - \\eta(d[X^0_2; X_2 | X_2 + \\tilde X_1] - d[X^0_2; X_2]).$$\n-/\nlemma condRuzsaDist_of_sums_ge :\n    d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  condRuzsaDistance_ge_of_min _ h_min hX\u2081 hX\u2082 _ _ (by measurability) (by measurability)\n\n/-- $$d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\bbH[X_2] - \\tfrac{1}{4} \\bbH[X_1].$$ -/\n", "theoremStatement": "lemma diff_rdist_le_1 : d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4", "fileCreated": "59160fb 20231116", "theoremCreated": "41c6859 20231124", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 90, "tokenPositionInFile": 3576, "theoremPositionInFile": 5}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 4\n  \u00b7 exact ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl hX\u2081.aemeasurable) h\u2082\n  \u00b7 exact h\u2082.entropy_eq", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 5, "proofLengthTokens": 272}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\nlemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k := by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring\n\n/-- The distance $d[X_1+\\tilde X_2; X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1]) - \\eta (d[X^0_2; X_2+\\tilde X_1] - d[X^0_2; X_2]).$$ -/\nlemma rdist_of_sums_ge :\n    d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  distance_ge_of_min _ h_min (hX\u2081.add hX\u2082') (hX\u2082.add hX\u2081')\n\n/-- The distance $d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1 | X_1 + \\tilde X_2] - d[X^0_1; X_1]) - \\eta(d[X^0_2; X_2 | X_2 + \\tilde X_1] - d[X^0_2; X_2]).$$\n-/\nlemma condRuzsaDist_of_sums_ge :\n    d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  condRuzsaDistance_ge_of_min _ h_min hX\u2081 hX\u2082 _ _ (by measurability) (by measurability)\n\n/-- $$d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\bbH[X_2] - \\tfrac{1}{4} \\bbH[X_1].$$ -/\nlemma diff_rdist_le_1 : d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4 := by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 4\n  \u00b7 exact ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl hX\u2081.aemeasurable) h\u2082\n  \u00b7 exact h\u2082.entropy_eq\n\n/-- $$ d[X^0_2;X_2+\\tilde X_1] - d[X^0_2; X_2] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\n", "theoremStatement": "lemma diff_rdist_le_2 : d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4", "fileCreated": "59160fb 20231116", "theoremCreated": "41c6859 20231124", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 97, "tokenPositionInFile": 4074, "theoremPositionInFile": 6}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have h : IndepFun X\u2082 X\u2081' := by simpa using h_indep.indepFun (show (1:Fin 4) \u2260 3 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas2 hX\u2082 hX\u2081' h using 4\n  \u00b7 rw [rdist_symm]\n    exact (IdentDistrib.refl hX\u2082.aemeasurable).rdist_eq h\u2081\n  \u00b7 exact h\u2081.entropy_eq", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 6, "proofLengthTokens": 261}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\nlemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k := by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring\n\n/-- The distance $d[X_1+\\tilde X_2; X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1]) - \\eta (d[X^0_2; X_2+\\tilde X_1] - d[X^0_2; X_2]).$$ -/\nlemma rdist_of_sums_ge :\n    d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  distance_ge_of_min _ h_min (hX\u2081.add hX\u2082') (hX\u2082.add hX\u2081')\n\n/-- The distance $d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1 | X_1 + \\tilde X_2] - d[X^0_1; X_1]) - \\eta(d[X^0_2; X_2 | X_2 + \\tilde X_1] - d[X^0_2; X_2]).$$\n-/\nlemma condRuzsaDist_of_sums_ge :\n    d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  condRuzsaDistance_ge_of_min _ h_min hX\u2081 hX\u2082 _ _ (by measurability) (by measurability)\n\n/-- $$d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\bbH[X_2] - \\tfrac{1}{4} \\bbH[X_1].$$ -/\nlemma diff_rdist_le_1 : d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4 := by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 4\n  \u00b7 exact ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl hX\u2081.aemeasurable) h\u2082\n  \u00b7 exact h\u2082.entropy_eq\n\n/-- $$ d[X^0_2;X_2+\\tilde X_1] - d[X^0_2; X_2] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\nlemma diff_rdist_le_2 : d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4 := by\n  have h : IndepFun X\u2082 X\u2081' := by simpa using h_indep.indepFun (show (1:Fin 4) \u2260 3 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas2 hX\u2082 hX\u2081' h using 4\n  \u00b7 rw [rdist_symm]\n    exact (IdentDistrib.refl hX\u2082.aemeasurable).rdist_eq h\u2081\n  \u00b7 exact h\u2081.entropy_eq\n\n/-- $$ d[X_1^0;X_1|X_1+\\tilde X_2] - d[X_1^0;X_1] \\leq\n    \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\n", "theoremStatement": "lemma diff_rdist_le_3 : d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4", "fileCreated": "59160fb 20231116", "theoremCreated": "41c6859 20231124", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 106, "tokenPositionInFile": 4568, "theoremPositionInFile": 7}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le''' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 3\n  \u00b7 rw [(IdentDistrib.refl hX\u2081.aemeasurable).rdist_eq h\u2082]\n  \u00b7 apply h\u2082.entropy_eq", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 5, "proofLengthTokens": 242}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\nlemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k := by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring\n\n/-- The distance $d[X_1+\\tilde X_2; X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1]) - \\eta (d[X^0_2; X_2+\\tilde X_1] - d[X^0_2; X_2]).$$ -/\nlemma rdist_of_sums_ge :\n    d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  distance_ge_of_min _ h_min (hX\u2081.add hX\u2082') (hX\u2082.add hX\u2081')\n\n/-- The distance $d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1 | X_1 + \\tilde X_2] - d[X^0_1; X_1]) - \\eta(d[X^0_2; X_2 | X_2 + \\tilde X_1] - d[X^0_2; X_2]).$$\n-/\nlemma condRuzsaDist_of_sums_ge :\n    d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  condRuzsaDistance_ge_of_min _ h_min hX\u2081 hX\u2082 _ _ (by measurability) (by measurability)\n\n/-- $$d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\bbH[X_2] - \\tfrac{1}{4} \\bbH[X_1].$$ -/\nlemma diff_rdist_le_1 : d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4 := by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 4\n  \u00b7 exact ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl hX\u2081.aemeasurable) h\u2082\n  \u00b7 exact h\u2082.entropy_eq\n\n/-- $$ d[X^0_2;X_2+\\tilde X_1] - d[X^0_2; X_2] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\nlemma diff_rdist_le_2 : d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4 := by\n  have h : IndepFun X\u2082 X\u2081' := by simpa using h_indep.indepFun (show (1:Fin 4) \u2260 3 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas2 hX\u2082 hX\u2081' h using 4\n  \u00b7 rw [rdist_symm]\n    exact (IdentDistrib.refl hX\u2082.aemeasurable).rdist_eq h\u2081\n  \u00b7 exact h\u2081.entropy_eq\n\n/-- $$ d[X_1^0;X_1|X_1+\\tilde X_2] - d[X_1^0;X_1] \\leq\n    \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\nlemma diff_rdist_le_3 : d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4 := by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le''' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 3\n  \u00b7 rw [(IdentDistrib.refl hX\u2081.aemeasurable).rdist_eq h\u2082]\n  \u00b7 apply h\u2082.entropy_eq\n\n/-- $$ d[X_2^0; X_2|X_2+\\tilde X_1] - d[X_2^0; X_2] \\leq\n    \\tfrac{1}{2}k + \\tfrac{1}{4} \\mathbb{H}[X_2] - \\tfrac{1}{4} \\mathbb{H}[X_1].$$ -/\n", "theoremStatement": "lemma diff_rdist_le_4 : d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4", "fileCreated": "59160fb 20231116", "theoremCreated": "41c6859 20231124", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 114, "tokenPositionInFile": 5049, "theoremPositionInFile": 8}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have h : IndepFun X\u2082 X\u2081' := by simpa using h_indep.indepFun (show (1:Fin 4) \u2260 3 by decide)\n  convert condRuzsaDist_diff_le''' \u2119 p.hmeas2 hX\u2082 hX\u2081' h using 3\n  \u00b7 rw [rdist_symm, (IdentDistrib.refl hX\u2082.aemeasurable).rdist_eq h\u2081]\n  \u00b7 apply h\u2081.entropy_eq", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": true, "proofLengthLines": 5, "proofLengthTokens": 254}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\nlemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k := by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring\n\n/-- The distance $d[X_1+\\tilde X_2; X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1]) - \\eta (d[X^0_2; X_2+\\tilde X_1] - d[X^0_2; X_2]).$$ -/\nlemma rdist_of_sums_ge :\n    d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  distance_ge_of_min _ h_min (hX\u2081.add hX\u2082') (hX\u2082.add hX\u2081')\n\n/-- The distance $d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1 | X_1 + \\tilde X_2] - d[X^0_1; X_1]) - \\eta(d[X^0_2; X_2 | X_2 + \\tilde X_1] - d[X^0_2; X_2]).$$\n-/\nlemma condRuzsaDist_of_sums_ge :\n    d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  condRuzsaDistance_ge_of_min _ h_min hX\u2081 hX\u2082 _ _ (by measurability) (by measurability)\n\n/-- $$d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\bbH[X_2] - \\tfrac{1}{4} \\bbH[X_1].$$ -/\nlemma diff_rdist_le_1 : d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4 := by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 4\n  \u00b7 exact ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl hX\u2081.aemeasurable) h\u2082\n  \u00b7 exact h\u2082.entropy_eq\n\n/-- $$ d[X^0_2;X_2+\\tilde X_1] - d[X^0_2; X_2] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\nlemma diff_rdist_le_2 : d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4 := by\n  have h : IndepFun X\u2082 X\u2081' := by simpa using h_indep.indepFun (show (1:Fin 4) \u2260 3 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas2 hX\u2082 hX\u2081' h using 4\n  \u00b7 rw [rdist_symm]\n    exact (IdentDistrib.refl hX\u2082.aemeasurable).rdist_eq h\u2081\n  \u00b7 exact h\u2081.entropy_eq\n\n/-- $$ d[X_1^0;X_1|X_1+\\tilde X_2] - d[X_1^0;X_1] \\leq\n    \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\nlemma diff_rdist_le_3 : d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4 := by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le''' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 3\n  \u00b7 rw [(IdentDistrib.refl hX\u2081.aemeasurable).rdist_eq h\u2082]\n  \u00b7 apply h\u2082.entropy_eq\n\n/-- $$ d[X_2^0; X_2|X_2+\\tilde X_1] - d[X_2^0; X_2] \\leq\n    \\tfrac{1}{2}k + \\tfrac{1}{4} \\mathbb{H}[X_2] - \\tfrac{1}{4} \\mathbb{H}[X_1].$$ -/\nlemma diff_rdist_le_4 : d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4 := by\n  have h : IndepFun X\u2082 X\u2081' := by simpa using h_indep.indepFun (show (1:Fin 4) \u2260 3 by decide)\n  convert condRuzsaDist_diff_le''' \u2119 p.hmeas2 hX\u2082 hX\u2081' h using 3\n  \u00b7 rw [rdist_symm, (IdentDistrib.refl hX\u2082.aemeasurable).rdist_eq h\u2081]\n  \u00b7 apply h\u2081.entropy_eq\n\n/-- We have $I_1 \\leq 2 \\eta k$ -/\n", "theoremStatement": "lemma first_estimate : I\u2081 \u2264 2 * p.\u03b7 * k", "fileCreated": "59160fb 20231116", "theoremCreated": "4f8e0e8 20231124", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 121, "tokenPositionInFile": 5434, "theoremPositionInFile": 9}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have v1 := rdist_add_rdist_add_condMutual_eq X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a\n  have v2 := rdist_of_sums_ge p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a\n  have v3 := condRuzsaDist_of_sums_ge p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a (by measurability) (by measurability)\n  have v4 := (mul_le_mul_left p.h\u03b7).2 (diff_rdist_le_1 p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a)\n  have v5 := (mul_le_mul_left p.h\u03b7).2 (diff_rdist_le_2 p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a)\n  have v6 := (mul_le_mul_left p.h\u03b7).2 (diff_rdist_le_3 p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a)\n  have v7 := (mul_le_mul_left p.h\u03b7).2 (diff_rdist_le_4 p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a)\n  simp only [inv_eq_one_div] at *\n  linarith [v1, v2, v3, v4, v5, v6, v7]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 10, "proofLengthTokens": 687}}
{"srcContext": "import PFR.Fibring\nimport PFR.TauFunctional\n\n/-!\n# First estimate\n\nThe first estimate on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ are independent random variables, with $X_1,\\tilde X_1$ copies of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $k := d[X_1;X_2]$\n* $I_1 := I [X_1+X_2 : \\tilde X_1 + X_2 | X_1+X_2+\\tilde X_1+\\tilde X_2]$\n\n## Main results\n\n* `first_estimate` : $I_1 \u2264 2 \u03b7 k$\n* `ent_ofsum_le` : $H[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} H[X_1]+\\tfrac{1}{2} H[X_2] + (2 + \\eta) k - I_1.$\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nvariable {G : Type*} [addgroup: AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd\u2082 G]\n\nvariable {\u03a9\u2080\u2081 \u03a9\u2080\u2082 : Type*} [MeasureSpace \u03a9\u2080\u2081] [MeasureSpace \u03a9\u2080\u2082]\n  [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2081)] [IsProbabilityMeasure (\u2119 : Measure \u03a9\u2080\u2082)]\n\nvariable (p : refPackage \u03a9\u2080\u2081 \u03a9\u2080\u2082 G)\n\nvariable {\u03a9 : Type*} [MeasureSpace \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n\nvariable (X\u2081 X\u2082 X\u2081' X\u2082' : \u03a9 \u2192 G)\n  (hX\u2081 : Measurable X\u2081) (hX\u2082 : Measurable X\u2082) (hX\u2081' : Measurable X\u2081') (hX\u2082' : Measurable X\u2082')\n\nvariable (h\u2081 : IdentDistrib X\u2081 X\u2081') (h\u2082 : IdentDistrib X\u2082 X\u2082')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X\u2081, X\u2082, X\u2082', X\u2081'])\n\nvariable (h_min: tau_minimizes p X\u2081 X\u2082)\n\n/-- `k := d[X\u2081 # X\u2082]`, the Ruzsa distance `rdist` between X\u2081 and X\u2082. -/\nlocal notation3 \"k\" => d[X\u2081 # X\u2082]\n\n/-- `I\u2081 := I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']`, the conditional mutual information\nof `X\u2081 + X\u2082` and `X\u2081' + X\u2082` given the quadruple sum `X\u2081 + X\u2082 + X\u2081' + X\u2082'`. -/\nlocal notation3 \"I\u2081\" => I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082']\n\n/-- The sum of\n$$ d[X_1+\\tilde X_2;X_2+\\tilde X_1] + d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1] $$\nand\n$$ I[X_1+ X_2 : \\tilde X_1 + X_2 \\,|\\, X_1 + X_2 + \\tilde X_1 + \\tilde X_2] $$\nis equal to $2k$. -/\nlemma rdist_add_rdist_add_condMutual_eq : d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] + d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n    + I[X\u2081 + X\u2082 : X\u2081' + X\u2082 | X\u2081 + X\u2082 + X\u2081' + X\u2082'] = 2 * k := by\n  have h0 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 0 = X\u2081 := rfl\n  have h1 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 1 = X\u2082 := rfl\n  have h2 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 2 = X\u2082' := rfl\n  have h3 : ![X\u2081, X\u2082, X\u2082', X\u2081'] 3 = X\u2081' := rfl\n  have h := sum_of_rdist_eq_char_2 ![X\u2081, X\u2082, X\u2082', X\u2081'] h_indep\n    (fun i => by fin_cases i <;> assumption)\n  rw [h0, h1, h2, h3] at h\n  have heq : d[X\u2082' # X\u2081'] = k := by\n    rw [rdist_symm]\n    apply ProbabilityTheory.IdentDistrib.rdist_eq h\u2081.symm h\u2082.symm\n  rw [heq] at h\n  convert h.symm using 1\n  \u00b7 congr 2 <;> abel\n  \u00b7 ring\n\n/-- The distance $d[X_1+\\tilde X_2; X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1]) - \\eta (d[X^0_2; X_2+\\tilde X_1] - d[X^0_2; X_2]).$$ -/\nlemma rdist_of_sums_ge :\n    d[X\u2081 + X\u2082' # X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  distance_ge_of_min _ h_min (hX\u2081.add hX\u2082') (hX\u2082.add hX\u2081')\n\n/-- The distance $d[X_1|X_1+\\tilde X_2; X_2|X_2+\\tilde X_1]$ is at least\n$$ k - \\eta (d[X^0_1; X_1 | X_1 + \\tilde X_2] - d[X^0_1; X_1]) - \\eta(d[X^0_2; X_2 | X_2 + \\tilde X_1] - d[X^0_2; X_2]).$$\n-/\nlemma condRuzsaDist_of_sums_ge :\n    d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081'] \u2265\n      k - p.\u03b7 * (d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081])\n        - p.\u03b7 * (d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082]) :=\n  condRuzsaDistance_ge_of_min _ h_min hX\u2081 hX\u2082 _ _ (by measurability) (by measurability)\n\n/-- $$d[X^0_1; X_1+\\tilde X_2] - d[X^0_1; X_1] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\bbH[X_2] - \\tfrac{1}{4} \\bbH[X_1].$$ -/\nlemma diff_rdist_le_1 : d[p.X\u2080\u2081 # X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4 := by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 4\n  \u00b7 exact ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl hX\u2081.aemeasurable) h\u2082\n  \u00b7 exact h\u2082.entropy_eq\n\n/-- $$ d[X^0_2;X_2+\\tilde X_1] - d[X^0_2; X_2] \\leq \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\nlemma diff_rdist_le_2 : d[p.X\u2080\u2082 # X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4 := by\n  have h : IndepFun X\u2082 X\u2081' := by simpa using h_indep.indepFun (show (1:Fin 4) \u2260 3 by decide)\n  convert condRuzsaDist_diff_le' \u2119 p.hmeas2 hX\u2082 hX\u2081' h using 4\n  \u00b7 rw [rdist_symm]\n    exact (IdentDistrib.refl hX\u2082.aemeasurable).rdist_eq h\u2081\n  \u00b7 exact h\u2081.entropy_eq\n\n/-- $$ d[X_1^0;X_1|X_1+\\tilde X_2] - d[X_1^0;X_1] \\leq\n    \\tfrac{1}{2} k + \\tfrac{1}{4} \\mathbb{H}[X_1] - \\tfrac{1}{4} \\mathbb{H}[X_2].$$ -/\nlemma diff_rdist_le_3 : d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082'] - d[p.X\u2080\u2081 # X\u2081] \u2264 k/2 + H[X\u2081]/4 - H[X\u2082]/4 := by\n  have h : IndepFun X\u2081 X\u2082' := by simpa using h_indep.indepFun (show (0:Fin 4) \u2260 2 by decide)\n  convert condRuzsaDist_diff_le''' \u2119 p.hmeas1 hX\u2081 hX\u2082' h using 3\n  \u00b7 rw [(IdentDistrib.refl hX\u2081.aemeasurable).rdist_eq h\u2082]\n  \u00b7 apply h\u2082.entropy_eq\n\n/-- $$ d[X_2^0; X_2|X_2+\\tilde X_1] - d[X_2^0; X_2] \\leq\n    \\tfrac{1}{2}k + \\tfrac{1}{4} \\mathbb{H}[X_2] - \\tfrac{1}{4} \\mathbb{H}[X_1].$$ -/\nlemma diff_rdist_le_4 : d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081'] - d[p.X\u2080\u2082 # X\u2082] \u2264 k/2 + H[X\u2082]/4 - H[X\u2081]/4 := by\n  have h : IndepFun X\u2082 X\u2081' := by simpa using h_indep.indepFun (show (1:Fin 4) \u2260 3 by decide)\n  convert condRuzsaDist_diff_le''' \u2119 p.hmeas2 hX\u2082 hX\u2081' h using 3\n  \u00b7 rw [rdist_symm, (IdentDistrib.refl hX\u2082.aemeasurable).rdist_eq h\u2081]\n  \u00b7 apply h\u2081.entropy_eq\n\n/-- We have $I_1 \\leq 2 \\eta k$ -/\nlemma first_estimate : I\u2081 \u2264 2 * p.\u03b7 * k := by\n  have v1 := rdist_add_rdist_add_condMutual_eq X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a\n  have v2 := rdist_of_sums_ge p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a\n  have v3 := condRuzsaDist_of_sums_ge p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a (by measurability) (by measurability)\n  have v4 := (mul_le_mul_left p.h\u03b7).2 (diff_rdist_le_1 p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a)\n  have v5 := (mul_le_mul_left p.h\u03b7).2 (diff_rdist_le_2 p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a)\n  have v6 := (mul_le_mul_left p.h\u03b7).2 (diff_rdist_le_3 p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a)\n  have v7 := (mul_le_mul_left p.h\u03b7).2 (diff_rdist_le_4 p X\u2081 X\u2082 X\u2081' X\u2082' \u2039_\u203a \u2039_\u203a \u2039_\u203a \u2039_\u203a)\n  simp only [inv_eq_one_div] at *\n  linarith [v1, v2, v3, v4, v5, v6, v7]\n\n/--\n$$\\mathbb{H}[X_1+X_2+\\tilde X_1+\\tilde X_2] \\le \\tfrac{1}{2} \\mathbb{H}[X_1]+\\tfrac{1}{2} \\mathbb{H}[X_2] + (2 + \\eta) k - I_1.$$\n-/\n", "theoremStatement": "lemma ent_ofsum_le : H[X\u2081 + X\u2082 + X\u2081' + X\u2082'] \u2264 H[X\u2081]/2 + H[X\u2082]/2 + (2+p.\u03b7)*k - I\u2081", "fileCreated": "59160fb 20231116", "theoremCreated": "c7fb2a4 20231125", "file": "PFR/FirstEstimate.lean", "positionMetadata": {"lineInFile": 135, "tokenPositionInFile": 6303, "theoremPositionInFile": 10}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  let D := d[X\u2081 + X\u2082' # X\u2082 + X\u2081']\n  let Dcc := d[X\u2081 | X\u2081 + X\u2082' # X\u2082 | X\u2082 + X\u2081']\n  let D1 := d[p.X\u2080\u2081 # X\u2081]\n  let Dc1 := d[p.X\u2080\u2081 # X\u2081 | X\u2081 + X\u2082']\n  let D2 := d[p.X\u2080\u2082 # X\u2082]\n  let Dc2 := d[p.X\u2080\u2082 # X\u2082 | X\u2082 + X\u2081']\n  have lem68 : D + Dcc + I\u2081 = 2 * k :=\n    rdist_add_rdist_add_condMutual_eq _ _ _ _ hX\u2081 hX\u2082 hX\u2081' hX\u2082' h\u2081 h\u2082 h_indep\n  have lem610 : Dcc \u2265 k - p.\u03b7 * (Dc1 - D1) - p.\u03b7 * (Dc2 - D2) :=\n    condRuzsaDist_of_sums_ge p X\u2081 X\u2082 X\u2081' X\u2082' hX\u2081 hX\u2082 (by measurability) (by measurability) h_min\n  have lem611c : Dc1 - D1 \u2264 k / 2 + H[X\u2081] / 4 - H[X\u2082] / 4 :=\n    diff_rdist_le_3 p X\u2081 X\u2082 X\u2081' X\u2082' hX\u2081 hX\u2082' h\u2082 h_indep\n  have lem611d : Dc2 - D2 \u2264 k / 2 + H[X\u2082] / 4 - H[X\u2081] / 4 :=\n    diff_rdist_le_4 p X\u2081 X\u2082 X\u2081' X\u2082' hX\u2082 hX\u2081' h\u2081 h_indep\n  have aux : D + I\u2081 \u2264 (1 + p.\u03b7) * k := by\n    calc D + I\u2081\n       \u2264 k + p.\u03b7 * (Dc1 - D1) + p.\u03b7 * (Dc2 - D2)                                         := ?_\n     _ \u2264 k + p.\u03b7 * (k / 2 + H[X\u2081] / 4 - H[X\u2082] / 4) + p.\u03b7 * (k / 2 + H[X\u2082] / 4 - H[X\u2081] / 4)  := ?_\n     _ = (1 + p.\u03b7) * k                                                                    := by ring\n    \u00b7 convert add_le_add lem68.le (neg_le_neg lem610) using 1 <;> ring\n    \u00b7 refine add_le_add (add_le_add (le_refl _) ?_) ?_\n      \u00b7 apply (mul_le_mul_left p.h\u03b7).mpr lem611c\n      \u00b7 apply (mul_le_mul_left p.h\u03b7).mpr lem611d\n  have ent_sub_eq_ent_add : H[X\u2081 + X\u2082' - (X\u2082 + X\u2081')] = H[X\u2081 + X\u2082' + (X\u2082 + X\u2081')] := by simp\n  have rw\u2081 : X\u2081 + X\u2082' + (X\u2082 + X\u2081') = X\u2081 + X\u2082 + X\u2081' + X\u2082' := by abel\n  have ind_aux : IndepFun (X\u2081 + X\u2082') (X\u2082 + X\u2081') := by\n    exact iIndepFun.indepFun_add_add h_indep (fun i \u21a6 by fin_cases i <;> assumption) 0 2 1 3\n      (by decide) (by decide) (by decide) (by decide)\n  have ind : D = H[X\u2081 + X\u2082' - (X\u2082 + X\u2081')] - H[X\u2081 + X\u2082'] / 2 - H[X\u2082 + X\u2081'] / 2 :=\n    @IndepFun.rdist_eq \u03a9 G _ \u2119 _ _ _ (X\u2081 + X\u2082') _ (X\u2082 + X\u2081') ind_aux (by measurability) (by measurability)\n  rw [ind, ent_sub_eq_ent_add, rw\u2081] at aux\n  have obs : H[X\u2081 + X\u2082 + X\u2081' + X\u2082'] \u2264 H[X\u2081 + X\u2082'] / 2 + H[X\u2082 + X\u2081'] / 2 + (1 + p.\u03b7) * k - I\u2081 := by\n    linarith\n  have rw\u2082 : H[X\u2081 + X\u2082'] = k + H[X\u2081]/2 + H[X\u2082]/2 := by\n    have HX\u2082_eq : H[X\u2082] = H[X\u2082'] :=\n      congr_arg (fun (\u03bc : Measure G) \u21a6 measureEntropy (\u03bc := \u03bc)) h\u2082.map_eq\n    have k_eq : k = H[X\u2081 - X\u2082'] - H[X\u2081] / 2 - H[X\u2082'] / 2 := by\n      have k_eq_aux : k = d[X\u2081 # X\u2082'] := (IdentDistrib.refl hX\u2081.aemeasurable).rdist_eq h\u2082\n      rw [k_eq_aux]\n      exact (h_indep.indepFun (show (0 : Fin 4) \u2260 2 by decide)).rdist_eq hX\u2081 hX\u2082'\n    rw [k_eq, \u2190 ElementaryAddCommGroup.sub_eq_add, \u2190 HX\u2082_eq]\n    ring\n  have rw\u2083 : H[X\u2082 + X\u2081'] = k + H[X\u2081]/2 + H[X\u2082]/2 := by\n    have HX\u2081_eq : H[X\u2081] = H[X\u2081'] :=\n      congr_arg (fun (\u03bc : Measure G) \u21a6 measureEntropy (\u03bc := \u03bc)) h\u2081.map_eq\n    have k_eq' : k = H[X\u2081' - X\u2082] - H[X\u2081'] / 2 - H[X\u2082] / 2 := by\n      have k_eq_aux : k = d[X\u2081' # X\u2082] :=\n        IdentDistrib.rdist_eq h\u2081 (IdentDistrib.refl hX\u2082.aemeasurable)\n      rw [k_eq_aux]\n      exact IndepFun.rdist_eq (h_indep.indepFun (show (3 : Fin 4) \u2260 1 by decide)) hX\u2081' hX\u2082\n    rw [add_comm X\u2082 X\u2081', k_eq', \u2190 ElementaryAddCommGroup.sub_eq_add, \u2190 HX\u2081_eq]\n    ring\n  calc H[X\u2081 + X\u2082 + X\u2081' + X\u2082']\n      \u2264 H[X\u2081 + X\u2082'] / 2 + H[X\u2082 + X\u2081'] / 2 + (1 + p.\u03b7) * k - I\u2081    := obs\n    _ = (k + H[X\u2081] / 2 + H[X\u2082] / 2) / 2\n        + (k + H[X\u2081] / 2 + H[X\u2082] / 2) / 2 + (1 + p.\u03b7) * k - I\u2081    := by rw [rw\u2082, rw\u2083]\n    _ = H[X\u2081] / 2 + H[X\u2082] / 2 + (2 + p.\u03b7) * k - I\u2081                := by ring", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": true, "proofLengthLines": 58, "proofLengthTokens": 3337}}
