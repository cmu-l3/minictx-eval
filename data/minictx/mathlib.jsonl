{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Basic\nimport Mathlib.RingTheory.MvPowerSeries.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-!\n# Formal power series (in one variable)\n\nThis file defines (univariate) formal power series\nand develops the basic properties of these objects.\n\nA formal power series is to a polynomial like an infinite sum is to a finite sum.\n\nFormal power series in one variable are defined from multivariate\npower series as `PowerSeries R := MvPowerSeries Unit R`.\n\nThe file sets up the (semi)ring structure on univariate power series.\n\nWe provide the natural inclusion from polynomials to formal power series.\n\nAdditional results can be found in:\n* `Mathlib.RingTheory.PowerSeries.Trunc`, truncation of power series;\n* `Mathlib.RingTheory.PowerSeries.Inverse`, about inverses of power series,\nand the fact that power series over a local ring form a local ring;\n* `Mathlib.RingTheory.PowerSeries.Order`, the order of a power series at 0,\nand application to the fact that power series over an integral domain\nform an integral domain.\n\n## Implementation notes\n\nBecause of its definition,\n  `PowerSeries R := MvPowerSeries Unit R`.\na lot of proofs and properties from the multivariate case\ncan be ported to the single variable case.\nHowever, it means that formal power series are indexed by `Unit \u2192\u2080 \u2115`,\nwhich is of course canonically isomorphic to `\u2115`.\nWe then build some glue to treat formal power series as if they were indexed by `\u2115`.\nOccasionally this leads to proofs that are uglier than expected.\n\n-/\n\nnoncomputable section\n\nopen BigOperators\n\nopen Finset (antidiagonal mem_antidiagonal)\n\n/-- Formal power series over a coefficient type `R` -/\ndef PowerSeries (R : Type*) :=\n  MvPowerSeries Unit R\n#align power_series PowerSeries\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection\n\n-- Porting note: not available in Lean 4\n-- local reducible PowerSeries\n\n\n/--\n`R\u27e6X\u27e7` is notation for `PowerSeries R`,\nthe semiring of formal power series in one variable over a semiring `R`.\n-/\nscoped notation:9000 R \"\u27e6X\u27e7\" => PowerSeries R\n\ninstance [Inhabited R] : Inhabited R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Zero R] : Zero R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddMonoid R] : AddMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddGroup R] : AddGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommMonoid R] : AddCommMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommGroup R] : AddCommGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Semiring R] : Semiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommSemiring R] : CommSemiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Ring R] : Ring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommRing R] : CommRing R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Nontrivial R] : Nontrivial R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A} [Semiring R] [AddCommMonoid A] [Module R A] : Module R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A S} [Semiring R] [Semiring S] [AddCommMonoid A] [Module R A] [Module S A] [SMul R S]\n    [IsScalarTower R S A] : IsScalarTower R S A\u27e6X\u27e7 :=\n  Pi.isScalarTower\n\ninstance {A} [Semiring A] [CommSemiring R] [Algebra R A] : Algebra R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\nend\n\nsection Semiring\n\nvariable (R) [Semiring R]\n\n/-- The `n`th coefficient of a formal power series. -/\ndef coeff (n : \u2115) : R\u27e6X\u27e7 \u2192\u2097[R] R :=\n  MvPowerSeries.coeff R (single () n)\n#align power_series.coeff PowerSeries.coeff\n\n/-- The `n`th monomial with coefficient `a` as formal power series. -/\ndef monomial (n : \u2115) : R \u2192\u2097[R] R\u27e6X\u27e7 :=\n  MvPowerSeries.monomial R (single () n)\n#align power_series.monomial PowerSeries.monomial\n\nvariable {R}\n\ntheorem coeff_def {s : Unit \u2192\u2080 \u2115} {n : \u2115} (h : s () = n) : coeff R n = MvPowerSeries.coeff R s := by\n  erw [coeff, \u2190 h, \u2190 Finsupp.unique_single s]\n#align power_series.coeff_def PowerSeries.coeff_def\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {\u03c6 \u03c8 : R\u27e6X\u27e7} (h : \u2200 n, coeff R n \u03c6 = coeff R n \u03c8) : \u03c6 = \u03c8 :=\n  MvPowerSeries.ext fun n => by\n    rw [\u2190 coeff_def]\n    \u00b7 apply h\n    rfl\n#align power_series.ext PowerSeries.ext\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\ntheorem ext_iff {\u03c6 \u03c8 : R\u27e6X\u27e7} : \u03c6 = \u03c8 \u2194 \u2200 n, coeff R n \u03c6 = coeff R n \u03c8 :=\n  \u27e8fun h n => congr_arg (coeff R n) h, ext\u27e9\n#align power_series.ext_iff PowerSeries.ext_iff\n\ninstance [Subsingleton R] : Subsingleton R\u27e6X\u27e7 := by\n  simp only [subsingleton_iff, ext_iff]\n  exact fun _ _ _ \u21a6 (subsingleton_iff).mp (by infer_instance) _ _\n\n/-- Constructor for formal power series. -/\ndef mk {R} (f : \u2115 \u2192 R) : R\u27e6X\u27e7 := fun s => f (s ())\n#align power_series.mk PowerSeries.mk\n\n@[simp]\ntheorem coeff_mk (n : \u2115) (f : \u2115 \u2192 R) : coeff R n (mk f) = f n :=\n  congr_arg f Finsupp.single_eq_same\n#align power_series.coeff_mk PowerSeries.coeff_mk\n\ntheorem coeff_monomial (m n : \u2115) (a : R) : coeff R m (monomial R n a) = if m = n then a else 0 :=\n  calc\n    coeff R m (monomial R n a) = _ := MvPowerSeries.coeff_monomial _ _ _\n    _ = if m = n then a else 0 := by simp only [Finsupp.unique_single_eq_iff]\n\n#align power_series.coeff_monomial PowerSeries.coeff_monomial\n\ntheorem monomial_eq_mk (n : \u2115) (a : R) : monomial R n a = mk fun m => if m = n then a else 0 :=\n  ext fun m => by rw [coeff_monomial, coeff_mk]\n#align power_series.monomial_eq_mk PowerSeries.monomial_eq_mk\n\n@[simp]\ntheorem coeff_monomial_same (n : \u2115) (a : R) : coeff R n (monomial R n a) = a :=\n  MvPowerSeries.coeff_monomial_same _ _\n#align power_series.coeff_monomial_same PowerSeries.coeff_monomial_same\n\n@[simp]\ntheorem coeff_comp_monomial (n : \u2115) : (coeff R n).comp (monomial R n) = LinearMap.id :=\n  LinearMap.ext <| coeff_monomial_same n\n#align power_series.coeff_comp_monomial PowerSeries.coeff_comp_monomial\n\nvariable (R)\n\n/-- The constant coefficient of a formal power series. -/\ndef constantCoeff : R\u27e6X\u27e7 \u2192+* R :=\n  MvPowerSeries.constantCoeff Unit R\n#align power_series.constant_coeff PowerSeries.constantCoeff\n\n/-- The constant formal power series. -/\ndef C : R \u2192+* R\u27e6X\u27e7 :=\n  MvPowerSeries.C Unit R\nset_option linter.uppercaseLean3 false in\n#align power_series.C PowerSeries.C\n\nvariable {R}\n\n/-- The variable of the formal power series ring. -/\ndef X : R\u27e6X\u27e7 :=\n  MvPowerSeries.X ()\nset_option linter.uppercaseLean3 false in\n#align power_series.X PowerSeries.X\n\ntheorem commute_X (\u03c6 : R\u27e6X\u27e7) : Commute \u03c6 X :=\n  MvPowerSeries.commute_X _ _\nset_option linter.uppercaseLean3 false in\n#align power_series.commute_X PowerSeries.commute_X\n\n@[simp]\ntheorem coeff_zero_eq_constantCoeff : \u21d1(coeff R 0) = constantCoeff R := by\n  rw [coeff, Finsupp.single_zero]\n  rfl\n#align power_series.coeff_zero_eq_constant_coeff PowerSeries.coeff_zero_eq_constantCoeff\n\ntheorem coeff_zero_eq_constantCoeff_apply (\u03c6 : R\u27e6X\u27e7) : coeff R 0 \u03c6 = constantCoeff R \u03c6 :=\n  by rw [coeff_zero_eq_constantCoeff]\n#align power_series.coeff_zero_eq_constant_coeff_apply PowerSeries.coeff_zero_eq_constantCoeff_apply\n\n@[simp]\ntheorem monomial_zero_eq_C : \u21d1(monomial R 0) = C R := by\n  -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644\n  erw [monomial, Finsupp.single_zero, MvPowerSeries.monomial_zero_eq_C]\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C PowerSeries.monomial_zero_eq_C\n\ntheorem monomial_zero_eq_C_apply (a : R) : monomial R 0 a = C R a := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C_apply PowerSeries.monomial_zero_eq_C_apply\n\ntheorem coeff_C (n : \u2115) (a : R) : coeff R n (C R a : R\u27e6X\u27e7) = if n = 0 then a else 0 := by\n  rw [\u2190 monomial_zero_eq_C_apply, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C PowerSeries.coeff_C\n\n@[simp]\ntheorem coeff_zero_C (a : R) : coeff R 0 (C R a) = a := by\n  rw [coeff_C, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_C PowerSeries.coeff_zero_C\n\ntheorem coeff_ne_zero_C {a : R} {n : \u2115} (h : n \u2260 0) : coeff R n (C R a) = 0 := by\n  rw [coeff_C, if_neg h]\n\n@[simp]\ntheorem coeff_succ_C {a : R} {n : \u2115} : coeff R (n + 1) (C R a) = 0 :=\n  coeff_ne_zero_C n.succ_ne_zero\n\n", "theoremStatement": "theorem C_injective : Function.Injective (C R)", "theoremName": "C_injective", "fileCreated": {"commit": "3d924717cd", "date": "2023-05-22"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "positionMetadata": {"lineInFile": 268, "tokenPositionInFile": 8671, "theoremPositionInFile": 39}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  intro a b H\n  have := (ext_iff (\u03c6 := C R a) (\u03c8 := C R b)).mp H 0\n  rwa [coeff_zero_C, coeff_zero_C] at this", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 112}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Basic\nimport Mathlib.RingTheory.MvPowerSeries.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-!\n# Formal power series (in one variable)\n\nThis file defines (univariate) formal power series\nand develops the basic properties of these objects.\n\nA formal power series is to a polynomial like an infinite sum is to a finite sum.\n\nFormal power series in one variable are defined from multivariate\npower series as `PowerSeries R := MvPowerSeries Unit R`.\n\nThe file sets up the (semi)ring structure on univariate power series.\n\nWe provide the natural inclusion from polynomials to formal power series.\n\nAdditional results can be found in:\n* `Mathlib.RingTheory.PowerSeries.Trunc`, truncation of power series;\n* `Mathlib.RingTheory.PowerSeries.Inverse`, about inverses of power series,\nand the fact that power series over a local ring form a local ring;\n* `Mathlib.RingTheory.PowerSeries.Order`, the order of a power series at 0,\nand application to the fact that power series over an integral domain\nform an integral domain.\n\n## Implementation notes\n\nBecause of its definition,\n  `PowerSeries R := MvPowerSeries Unit R`.\na lot of proofs and properties from the multivariate case\ncan be ported to the single variable case.\nHowever, it means that formal power series are indexed by `Unit \u2192\u2080 \u2115`,\nwhich is of course canonically isomorphic to `\u2115`.\nWe then build some glue to treat formal power series as if they were indexed by `\u2115`.\nOccasionally this leads to proofs that are uglier than expected.\n\n-/\n\nnoncomputable section\n\nopen BigOperators\n\nopen Finset (antidiagonal mem_antidiagonal)\n\n/-- Formal power series over a coefficient type `R` -/\ndef PowerSeries (R : Type*) :=\n  MvPowerSeries Unit R\n#align power_series PowerSeries\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection\n\n-- Porting note: not available in Lean 4\n-- local reducible PowerSeries\n\n\n/--\n`R\u27e6X\u27e7` is notation for `PowerSeries R`,\nthe semiring of formal power series in one variable over a semiring `R`.\n-/\nscoped notation:9000 R \"\u27e6X\u27e7\" => PowerSeries R\n\ninstance [Inhabited R] : Inhabited R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Zero R] : Zero R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddMonoid R] : AddMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddGroup R] : AddGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommMonoid R] : AddCommMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommGroup R] : AddCommGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Semiring R] : Semiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommSemiring R] : CommSemiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Ring R] : Ring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommRing R] : CommRing R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Nontrivial R] : Nontrivial R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A} [Semiring R] [AddCommMonoid A] [Module R A] : Module R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A S} [Semiring R] [Semiring S] [AddCommMonoid A] [Module R A] [Module S A] [SMul R S]\n    [IsScalarTower R S A] : IsScalarTower R S A\u27e6X\u27e7 :=\n  Pi.isScalarTower\n\ninstance {A} [Semiring A] [CommSemiring R] [Algebra R A] : Algebra R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\nend\n\nsection Semiring\n\nvariable (R) [Semiring R]\n\n/-- The `n`th coefficient of a formal power series. -/\ndef coeff (n : \u2115) : R\u27e6X\u27e7 \u2192\u2097[R] R :=\n  MvPowerSeries.coeff R (single () n)\n#align power_series.coeff PowerSeries.coeff\n\n/-- The `n`th monomial with coefficient `a` as formal power series. -/\ndef monomial (n : \u2115) : R \u2192\u2097[R] R\u27e6X\u27e7 :=\n  MvPowerSeries.monomial R (single () n)\n#align power_series.monomial PowerSeries.monomial\n\nvariable {R}\n\ntheorem coeff_def {s : Unit \u2192\u2080 \u2115} {n : \u2115} (h : s () = n) : coeff R n = MvPowerSeries.coeff R s := by\n  erw [coeff, \u2190 h, \u2190 Finsupp.unique_single s]\n#align power_series.coeff_def PowerSeries.coeff_def\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {\u03c6 \u03c8 : R\u27e6X\u27e7} (h : \u2200 n, coeff R n \u03c6 = coeff R n \u03c8) : \u03c6 = \u03c8 :=\n  MvPowerSeries.ext fun n => by\n    rw [\u2190 coeff_def]\n    \u00b7 apply h\n    rfl\n#align power_series.ext PowerSeries.ext\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\ntheorem ext_iff {\u03c6 \u03c8 : R\u27e6X\u27e7} : \u03c6 = \u03c8 \u2194 \u2200 n, coeff R n \u03c6 = coeff R n \u03c8 :=\n  \u27e8fun h n => congr_arg (coeff R n) h, ext\u27e9\n#align power_series.ext_iff PowerSeries.ext_iff\n\ninstance [Subsingleton R] : Subsingleton R\u27e6X\u27e7 := by\n  simp only [subsingleton_iff, ext_iff]\n  exact fun _ _ _ \u21a6 (subsingleton_iff).mp (by infer_instance) _ _\n\n/-- Constructor for formal power series. -/\ndef mk {R} (f : \u2115 \u2192 R) : R\u27e6X\u27e7 := fun s => f (s ())\n#align power_series.mk PowerSeries.mk\n\n@[simp]\ntheorem coeff_mk (n : \u2115) (f : \u2115 \u2192 R) : coeff R n (mk f) = f n :=\n  congr_arg f Finsupp.single_eq_same\n#align power_series.coeff_mk PowerSeries.coeff_mk\n\ntheorem coeff_monomial (m n : \u2115) (a : R) : coeff R m (monomial R n a) = if m = n then a else 0 :=\n  calc\n    coeff R m (monomial R n a) = _ := MvPowerSeries.coeff_monomial _ _ _\n    _ = if m = n then a else 0 := by simp only [Finsupp.unique_single_eq_iff]\n\n#align power_series.coeff_monomial PowerSeries.coeff_monomial\n\ntheorem monomial_eq_mk (n : \u2115) (a : R) : monomial R n a = mk fun m => if m = n then a else 0 :=\n  ext fun m => by rw [coeff_monomial, coeff_mk]\n#align power_series.monomial_eq_mk PowerSeries.monomial_eq_mk\n\n@[simp]\ntheorem coeff_monomial_same (n : \u2115) (a : R) : coeff R n (monomial R n a) = a :=\n  MvPowerSeries.coeff_monomial_same _ _\n#align power_series.coeff_monomial_same PowerSeries.coeff_monomial_same\n\n@[simp]\ntheorem coeff_comp_monomial (n : \u2115) : (coeff R n).comp (monomial R n) = LinearMap.id :=\n  LinearMap.ext <| coeff_monomial_same n\n#align power_series.coeff_comp_monomial PowerSeries.coeff_comp_monomial\n\nvariable (R)\n\n/-- The constant coefficient of a formal power series. -/\ndef constantCoeff : R\u27e6X\u27e7 \u2192+* R :=\n  MvPowerSeries.constantCoeff Unit R\n#align power_series.constant_coeff PowerSeries.constantCoeff\n\n/-- The constant formal power series. -/\ndef C : R \u2192+* R\u27e6X\u27e7 :=\n  MvPowerSeries.C Unit R\nset_option linter.uppercaseLean3 false in\n#align power_series.C PowerSeries.C\n\nvariable {R}\n\n/-- The variable of the formal power series ring. -/\ndef X : R\u27e6X\u27e7 :=\n  MvPowerSeries.X ()\nset_option linter.uppercaseLean3 false in\n#align power_series.X PowerSeries.X\n\ntheorem commute_X (\u03c6 : R\u27e6X\u27e7) : Commute \u03c6 X :=\n  MvPowerSeries.commute_X _ _\nset_option linter.uppercaseLean3 false in\n#align power_series.commute_X PowerSeries.commute_X\n\n@[simp]\ntheorem coeff_zero_eq_constantCoeff : \u21d1(coeff R 0) = constantCoeff R := by\n  rw [coeff, Finsupp.single_zero]\n  rfl\n#align power_series.coeff_zero_eq_constant_coeff PowerSeries.coeff_zero_eq_constantCoeff\n\ntheorem coeff_zero_eq_constantCoeff_apply (\u03c6 : R\u27e6X\u27e7) : coeff R 0 \u03c6 = constantCoeff R \u03c6 :=\n  by rw [coeff_zero_eq_constantCoeff]\n#align power_series.coeff_zero_eq_constant_coeff_apply PowerSeries.coeff_zero_eq_constantCoeff_apply\n\n@[simp]\ntheorem monomial_zero_eq_C : \u21d1(monomial R 0) = C R := by\n  -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644\n  erw [monomial, Finsupp.single_zero, MvPowerSeries.monomial_zero_eq_C]\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C PowerSeries.monomial_zero_eq_C\n\ntheorem monomial_zero_eq_C_apply (a : R) : monomial R 0 a = C R a := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C_apply PowerSeries.monomial_zero_eq_C_apply\n\ntheorem coeff_C (n : \u2115) (a : R) : coeff R n (C R a : R\u27e6X\u27e7) = if n = 0 then a else 0 := by\n  rw [\u2190 monomial_zero_eq_C_apply, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C PowerSeries.coeff_C\n\n@[simp]\ntheorem coeff_zero_C (a : R) : coeff R 0 (C R a) = a := by\n  rw [coeff_C, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_C PowerSeries.coeff_zero_C\n\ntheorem coeff_ne_zero_C {a : R} {n : \u2115} (h : n \u2260 0) : coeff R n (C R a) = 0 := by\n  rw [coeff_C, if_neg h]\n\n@[simp]\ntheorem coeff_succ_C {a : R} {n : \u2115} : coeff R (n + 1) (C R a) = 0 :=\n  coeff_ne_zero_C n.succ_ne_zero\n\ntheorem C_injective : Function.Injective (C R) := by\n  intro a b H\n  have := (ext_iff (\u03c6 := C R a) (\u03c8 := C R b)).mp H 0\n  rwa [coeff_zero_C, coeff_zero_C] at this\n\n", "theoremStatement": "protected theorem subsingleton_iff : Subsingleton R\u27e6X\u27e7 \u2194 Subsingleton R", "theoremName": "subsingleton_iff", "fileCreated": {"commit": "3d924717cd", "date": "2023-05-22"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "positionMetadata": {"lineInFile": 273, "tokenPositionInFile": 8835, "theoremPositionInFile": 40}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  refine \u27e8fun h \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9\n  rw [subsingleton_iff] at h \u22a2\n  exact fun a b \u21a6 C_injective (h (C R a) (C R b))", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 128}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Basic\nimport Mathlib.RingTheory.MvPowerSeries.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-!\n# Formal power series (in one variable)\n\nThis file defines (univariate) formal power series\nand develops the basic properties of these objects.\n\nA formal power series is to a polynomial like an infinite sum is to a finite sum.\n\nFormal power series in one variable are defined from multivariate\npower series as `PowerSeries R := MvPowerSeries Unit R`.\n\nThe file sets up the (semi)ring structure on univariate power series.\n\nWe provide the natural inclusion from polynomials to formal power series.\n\nAdditional results can be found in:\n* `Mathlib.RingTheory.PowerSeries.Trunc`, truncation of power series;\n* `Mathlib.RingTheory.PowerSeries.Inverse`, about inverses of power series,\nand the fact that power series over a local ring form a local ring;\n* `Mathlib.RingTheory.PowerSeries.Order`, the order of a power series at 0,\nand application to the fact that power series over an integral domain\nform an integral domain.\n\n## Implementation notes\n\nBecause of its definition,\n  `PowerSeries R := MvPowerSeries Unit R`.\na lot of proofs and properties from the multivariate case\ncan be ported to the single variable case.\nHowever, it means that formal power series are indexed by `Unit \u2192\u2080 \u2115`,\nwhich is of course canonically isomorphic to `\u2115`.\nWe then build some glue to treat formal power series as if they were indexed by `\u2115`.\nOccasionally this leads to proofs that are uglier than expected.\n\n-/\n\nnoncomputable section\n\nopen BigOperators\n\nopen Finset (antidiagonal mem_antidiagonal)\n\n/-- Formal power series over a coefficient type `R` -/\ndef PowerSeries (R : Type*) :=\n  MvPowerSeries Unit R\n#align power_series PowerSeries\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection\n\n-- Porting note: not available in Lean 4\n-- local reducible PowerSeries\n\n\n/--\n`R\u27e6X\u27e7` is notation for `PowerSeries R`,\nthe semiring of formal power series in one variable over a semiring `R`.\n-/\nscoped notation:9000 R \"\u27e6X\u27e7\" => PowerSeries R\n\ninstance [Inhabited R] : Inhabited R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Zero R] : Zero R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddMonoid R] : AddMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddGroup R] : AddGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommMonoid R] : AddCommMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommGroup R] : AddCommGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Semiring R] : Semiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommSemiring R] : CommSemiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Ring R] : Ring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommRing R] : CommRing R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Nontrivial R] : Nontrivial R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A} [Semiring R] [AddCommMonoid A] [Module R A] : Module R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A S} [Semiring R] [Semiring S] [AddCommMonoid A] [Module R A] [Module S A] [SMul R S]\n    [IsScalarTower R S A] : IsScalarTower R S A\u27e6X\u27e7 :=\n  Pi.isScalarTower\n\ninstance {A} [Semiring A] [CommSemiring R] [Algebra R A] : Algebra R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\nend\n\nsection Semiring\n\nvariable (R) [Semiring R]\n\n/-- The `n`th coefficient of a formal power series. -/\ndef coeff (n : \u2115) : R\u27e6X\u27e7 \u2192\u2097[R] R :=\n  MvPowerSeries.coeff R (single () n)\n#align power_series.coeff PowerSeries.coeff\n\n/-- The `n`th monomial with coefficient `a` as formal power series. -/\ndef monomial (n : \u2115) : R \u2192\u2097[R] R\u27e6X\u27e7 :=\n  MvPowerSeries.monomial R (single () n)\n#align power_series.monomial PowerSeries.monomial\n\nvariable {R}\n\ntheorem coeff_def {s : Unit \u2192\u2080 \u2115} {n : \u2115} (h : s () = n) : coeff R n = MvPowerSeries.coeff R s := by\n  erw [coeff, \u2190 h, \u2190 Finsupp.unique_single s]\n#align power_series.coeff_def PowerSeries.coeff_def\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {\u03c6 \u03c8 : R\u27e6X\u27e7} (h : \u2200 n, coeff R n \u03c6 = coeff R n \u03c8) : \u03c6 = \u03c8 :=\n  MvPowerSeries.ext fun n => by\n    rw [\u2190 coeff_def]\n    \u00b7 apply h\n    rfl\n#align power_series.ext PowerSeries.ext\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\ntheorem ext_iff {\u03c6 \u03c8 : R\u27e6X\u27e7} : \u03c6 = \u03c8 \u2194 \u2200 n, coeff R n \u03c6 = coeff R n \u03c8 :=\n  \u27e8fun h n => congr_arg (coeff R n) h, ext\u27e9\n#align power_series.ext_iff PowerSeries.ext_iff\n\ninstance [Subsingleton R] : Subsingleton R\u27e6X\u27e7 := by\n  simp only [subsingleton_iff, ext_iff]\n  exact fun _ _ _ \u21a6 (subsingleton_iff).mp (by infer_instance) _ _\n\n/-- Constructor for formal power series. -/\ndef mk {R} (f : \u2115 \u2192 R) : R\u27e6X\u27e7 := fun s => f (s ())\n#align power_series.mk PowerSeries.mk\n\n@[simp]\ntheorem coeff_mk (n : \u2115) (f : \u2115 \u2192 R) : coeff R n (mk f) = f n :=\n  congr_arg f Finsupp.single_eq_same\n#align power_series.coeff_mk PowerSeries.coeff_mk\n\ntheorem coeff_monomial (m n : \u2115) (a : R) : coeff R m (monomial R n a) = if m = n then a else 0 :=\n  calc\n    coeff R m (monomial R n a) = _ := MvPowerSeries.coeff_monomial _ _ _\n    _ = if m = n then a else 0 := by simp only [Finsupp.unique_single_eq_iff]\n\n#align power_series.coeff_monomial PowerSeries.coeff_monomial\n\ntheorem monomial_eq_mk (n : \u2115) (a : R) : monomial R n a = mk fun m => if m = n then a else 0 :=\n  ext fun m => by rw [coeff_monomial, coeff_mk]\n#align power_series.monomial_eq_mk PowerSeries.monomial_eq_mk\n\n@[simp]\ntheorem coeff_monomial_same (n : \u2115) (a : R) : coeff R n (monomial R n a) = a :=\n  MvPowerSeries.coeff_monomial_same _ _\n#align power_series.coeff_monomial_same PowerSeries.coeff_monomial_same\n\n@[simp]\ntheorem coeff_comp_monomial (n : \u2115) : (coeff R n).comp (monomial R n) = LinearMap.id :=\n  LinearMap.ext <| coeff_monomial_same n\n#align power_series.coeff_comp_monomial PowerSeries.coeff_comp_monomial\n\nvariable (R)\n\n/-- The constant coefficient of a formal power series. -/\ndef constantCoeff : R\u27e6X\u27e7 \u2192+* R :=\n  MvPowerSeries.constantCoeff Unit R\n#align power_series.constant_coeff PowerSeries.constantCoeff\n\n/-- The constant formal power series. -/\ndef C : R \u2192+* R\u27e6X\u27e7 :=\n  MvPowerSeries.C Unit R\nset_option linter.uppercaseLean3 false in\n#align power_series.C PowerSeries.C\n\nvariable {R}\n\n/-- The variable of the formal power series ring. -/\ndef X : R\u27e6X\u27e7 :=\n  MvPowerSeries.X ()\nset_option linter.uppercaseLean3 false in\n#align power_series.X PowerSeries.X\n\ntheorem commute_X (\u03c6 : R\u27e6X\u27e7) : Commute \u03c6 X :=\n  MvPowerSeries.commute_X _ _\nset_option linter.uppercaseLean3 false in\n#align power_series.commute_X PowerSeries.commute_X\n\n@[simp]\ntheorem coeff_zero_eq_constantCoeff : \u21d1(coeff R 0) = constantCoeff R := by\n  rw [coeff, Finsupp.single_zero]\n  rfl\n#align power_series.coeff_zero_eq_constant_coeff PowerSeries.coeff_zero_eq_constantCoeff\n\ntheorem coeff_zero_eq_constantCoeff_apply (\u03c6 : R\u27e6X\u27e7) : coeff R 0 \u03c6 = constantCoeff R \u03c6 :=\n  by rw [coeff_zero_eq_constantCoeff]\n#align power_series.coeff_zero_eq_constant_coeff_apply PowerSeries.coeff_zero_eq_constantCoeff_apply\n\n@[simp]\ntheorem monomial_zero_eq_C : \u21d1(monomial R 0) = C R := by\n  -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644\n  erw [monomial, Finsupp.single_zero, MvPowerSeries.monomial_zero_eq_C]\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C PowerSeries.monomial_zero_eq_C\n\ntheorem monomial_zero_eq_C_apply (a : R) : monomial R 0 a = C R a := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C_apply PowerSeries.monomial_zero_eq_C_apply\n\ntheorem coeff_C (n : \u2115) (a : R) : coeff R n (C R a : R\u27e6X\u27e7) = if n = 0 then a else 0 := by\n  rw [\u2190 monomial_zero_eq_C_apply, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C PowerSeries.coeff_C\n\n@[simp]\ntheorem coeff_zero_C (a : R) : coeff R 0 (C R a) = a := by\n  rw [coeff_C, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_C PowerSeries.coeff_zero_C\n\ntheorem coeff_ne_zero_C {a : R} {n : \u2115} (h : n \u2260 0) : coeff R n (C R a) = 0 := by\n  rw [coeff_C, if_neg h]\n\n@[simp]\ntheorem coeff_succ_C {a : R} {n : \u2115} : coeff R (n + 1) (C R a) = 0 :=\n  coeff_ne_zero_C n.succ_ne_zero\n\ntheorem C_injective : Function.Injective (C R) := by\n  intro a b H\n  have := (ext_iff (\u03c6 := C R a) (\u03c8 := C R b)).mp H 0\n  rwa [coeff_zero_C, coeff_zero_C] at this\n\nprotected theorem subsingleton_iff : Subsingleton R\u27e6X\u27e7 \u2194 Subsingleton R := by\n  refine \u27e8fun h \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9\n  rw [subsingleton_iff] at h \u22a2\n  exact fun a b \u21a6 C_injective (h (C R a) (C R b))\n\ntheorem X_eq : (X : R\u27e6X\u27e7) = monomial R 1 1 :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.X_eq PowerSeries.X_eq\n\ntheorem coeff_X (n : \u2115) : coeff R n (X : R\u27e6X\u27e7) = if n = 1 then 1 else 0 := by\n  rw [X_eq, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X PowerSeries.coeff_X\n\n@[simp]\ntheorem coeff_zero_X : coeff R 0 (X : R\u27e6X\u27e7) = 0 := by\n  -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644\n  erw [coeff, Finsupp.single_zero, X, MvPowerSeries.coeff_zero_X]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_X PowerSeries.coeff_zero_X\n\n@[simp]\ntheorem coeff_one_X : coeff R 1 (X : R\u27e6X\u27e7) = 1 := by rw [coeff_X, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_one_X PowerSeries.coeff_one_X\n\n@[simp]\ntheorem X_ne_zero [Nontrivial R] : (X : R\u27e6X\u27e7) \u2260 0 := fun H => by\n  simpa only [coeff_one_X, one_ne_zero, map_zero] using congr_arg (coeff R 1) H\nset_option linter.uppercaseLean3 false in\n#align power_series.X_ne_zero PowerSeries.X_ne_zero\n\ntheorem X_pow_eq (n : \u2115) : (X : R\u27e6X\u27e7) ^ n = monomial R n 1 :=\n  MvPowerSeries.X_pow_eq _ n\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_eq PowerSeries.X_pow_eq\n\ntheorem coeff_X_pow (m n : \u2115) : coeff R m ((X : R\u27e6X\u27e7) ^ n) = if m = n then 1 else 0 := by\n  rw [X_pow_eq, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow PowerSeries.coeff_X_pow\n\n@[simp]\ntheorem coeff_X_pow_self (n : \u2115) : coeff R n ((X : R\u27e6X\u27e7) ^ n) = 1 := by\n  rw [coeff_X_pow, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow_self PowerSeries.coeff_X_pow_self\n\n@[simp]\ntheorem coeff_one (n : \u2115) : coeff R n (1 : R\u27e6X\u27e7) = if n = 0 then 1 else 0 :=\n  coeff_C n 1\n#align power_series.coeff_one PowerSeries.coeff_one\n\ntheorem coeff_zero_one : coeff R 0 (1 : R\u27e6X\u27e7) = 1 :=\n  coeff_zero_C 1\n#align power_series.coeff_zero_one PowerSeries.coeff_zero_one\n\ntheorem coeff_mul (n : \u2115) (\u03c6 \u03c8 : R\u27e6X\u27e7) :\n    coeff R n (\u03c6 * \u03c8) = \u2211 p in antidiagonal n, coeff R p.1 \u03c6 * coeff R p.2 \u03c8 := by\n  -- `rw` can't see that `PowerSeries = MvPowerSeries Unit`, so use `.trans`\n  refine (MvPowerSeries.coeff_mul _ \u03c6 \u03c8).trans ?_\n  rw [Finsupp.antidiagonal_single, Finset.sum_map]\n  rfl\n#align power_series.coeff_mul PowerSeries.coeff_mul\n\n@[simp]\ntheorem coeff_mul_C (n : \u2115) (\u03c6 : R\u27e6X\u27e7) (a : R) : coeff R n (\u03c6 * C R a) = coeff R n \u03c6 * a :=\n  MvPowerSeries.coeff_mul_C _ \u03c6 a\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_mul_C PowerSeries.coeff_mul_C\n\n@[simp]\ntheorem coeff_C_mul (n : \u2115) (\u03c6 : R\u27e6X\u27e7) (a : R) : coeff R n (C R a * \u03c6) = a * coeff R n \u03c6 :=\n  MvPowerSeries.coeff_C_mul _ \u03c6 a\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C_mul PowerSeries.coeff_C_mul\n\n@[simp]\ntheorem coeff_smul {S : Type*} [Semiring S] [Module R S] (n : \u2115) (\u03c6 : PowerSeries S) (a : R) :\n    coeff S n (a \u2022 \u03c6) = a \u2022 coeff S n \u03c6 :=\n  rfl\n#align power_series.coeff_smul PowerSeries.coeff_smul\n\ntheorem smul_eq_C_mul (f : R\u27e6X\u27e7) (a : R) : a \u2022 f = C R a * f := by\n  ext\n  simp\nset_option linter.uppercaseLean3 false in\n#align power_series.smul_eq_C_mul PowerSeries.smul_eq_C_mul\n\n@[simp]\ntheorem coeff_succ_mul_X (n : \u2115) (\u03c6 : R\u27e6X\u27e7) : coeff R (n + 1) (\u03c6 * X) = coeff R n \u03c6 := by\n  simp only [coeff, Finsupp.single_add]\n  convert \u03c6.coeff_add_mul_monomial (single () n) (single () 1) _\n  rw [mul_one]; rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_succ_mul_X PowerSeries.coeff_succ_mul_X\n\n@[simp]\ntheorem coeff_succ_X_mul (n : \u2115) (\u03c6 : R\u27e6X\u27e7) : coeff R (n + 1) (X * \u03c6) = coeff R n \u03c6 := by\n  simp only [coeff, Finsupp.single_add, add_comm n 1]\n  convert \u03c6.coeff_add_monomial_mul (single () 1) (single () n) _\n  rw [one_mul]; rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_succ_X_mul PowerSeries.coeff_succ_X_mul\n\n@[simp]\ntheorem constantCoeff_C (a : R) : constantCoeff R (C R a) = a :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_C PowerSeries.constantCoeff_C\n\n@[simp]\ntheorem constantCoeff_comp_C : (constantCoeff R).comp (C R) = RingHom.id R :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_comp_C PowerSeries.constantCoeff_comp_C\n\n-- Porting note (#10618): simp can prove this.\n-- @[simp]\ntheorem constantCoeff_zero : constantCoeff R 0 = 0 :=\n  rfl\n#align power_series.constant_coeff_zero PowerSeries.constantCoeff_zero\n\n-- Porting note (#10618): simp can prove this.\n-- @[simp]\ntheorem constantCoeff_one : constantCoeff R 1 = 1 :=\n  rfl\n#align power_series.constant_coeff_one PowerSeries.constantCoeff_one\n\n@[simp]\ntheorem constantCoeff_X : constantCoeff R X = 0 :=\n  MvPowerSeries.coeff_zero_X _\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_X PowerSeries.constantCoeff_X\n\ntheorem coeff_zero_mul_X (\u03c6 : R\u27e6X\u27e7) : coeff R 0 (\u03c6 * X) = 0 := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_mul_X PowerSeries.coeff_zero_mul_X\n\ntheorem coeff_zero_X_mul (\u03c6 : R\u27e6X\u27e7) : coeff R 0 (X * \u03c6) = 0 := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_X_mul PowerSeries.coeff_zero_X_mul\n\n", "theoremStatement": "theorem constantCoeff_surj : Function.Surjective (constantCoeff R)", "theoremName": "constantCoeff_surj", "fileCreated": {"commit": "3d924717cd", "date": "2023-05-22"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "positionMetadata": {"lineInFile": 417, "tokenPositionInFile": 14246, "theoremPositionInFile": 65}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "fun r => \u27e8(C R) r, constantCoeff_C r\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 37}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Basic\nimport Mathlib.RingTheory.MvPowerSeries.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-!\n# Formal power series (in one variable)\n\nThis file defines (univariate) formal power series\nand develops the basic properties of these objects.\n\nA formal power series is to a polynomial like an infinite sum is to a finite sum.\n\nFormal power series in one variable are defined from multivariate\npower series as `PowerSeries R := MvPowerSeries Unit R`.\n\nThe file sets up the (semi)ring structure on univariate power series.\n\nWe provide the natural inclusion from polynomials to formal power series.\n\nAdditional results can be found in:\n* `Mathlib.RingTheory.PowerSeries.Trunc`, truncation of power series;\n* `Mathlib.RingTheory.PowerSeries.Inverse`, about inverses of power series,\nand the fact that power series over a local ring form a local ring;\n* `Mathlib.RingTheory.PowerSeries.Order`, the order of a power series at 0,\nand application to the fact that power series over an integral domain\nform an integral domain.\n\n## Implementation notes\n\nBecause of its definition,\n  `PowerSeries R := MvPowerSeries Unit R`.\na lot of proofs and properties from the multivariate case\ncan be ported to the single variable case.\nHowever, it means that formal power series are indexed by `Unit \u2192\u2080 \u2115`,\nwhich is of course canonically isomorphic to `\u2115`.\nWe then build some glue to treat formal power series as if they were indexed by `\u2115`.\nOccasionally this leads to proofs that are uglier than expected.\n\n-/\n\nnoncomputable section\n\nopen BigOperators\n\nopen Finset (antidiagonal mem_antidiagonal)\n\n/-- Formal power series over a coefficient type `R` -/\ndef PowerSeries (R : Type*) :=\n  MvPowerSeries Unit R\n#align power_series PowerSeries\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection\n\n-- Porting note: not available in Lean 4\n-- local reducible PowerSeries\n\n\n/--\n`R\u27e6X\u27e7` is notation for `PowerSeries R`,\nthe semiring of formal power series in one variable over a semiring `R`.\n-/\nscoped notation:9000 R \"\u27e6X\u27e7\" => PowerSeries R\n\ninstance [Inhabited R] : Inhabited R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Zero R] : Zero R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddMonoid R] : AddMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddGroup R] : AddGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommMonoid R] : AddCommMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommGroup R] : AddCommGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Semiring R] : Semiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommSemiring R] : CommSemiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Ring R] : Ring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommRing R] : CommRing R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Nontrivial R] : Nontrivial R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A} [Semiring R] [AddCommMonoid A] [Module R A] : Module R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A S} [Semiring R] [Semiring S] [AddCommMonoid A] [Module R A] [Module S A] [SMul R S]\n    [IsScalarTower R S A] : IsScalarTower R S A\u27e6X\u27e7 :=\n  Pi.isScalarTower\n\ninstance {A} [Semiring A] [CommSemiring R] [Algebra R A] : Algebra R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\nend\n\nsection Semiring\n\nvariable (R) [Semiring R]\n\n/-- The `n`th coefficient of a formal power series. -/\ndef coeff (n : \u2115) : R\u27e6X\u27e7 \u2192\u2097[R] R :=\n  MvPowerSeries.coeff R (single () n)\n#align power_series.coeff PowerSeries.coeff\n\n/-- The `n`th monomial with coefficient `a` as formal power series. -/\ndef monomial (n : \u2115) : R \u2192\u2097[R] R\u27e6X\u27e7 :=\n  MvPowerSeries.monomial R (single () n)\n#align power_series.monomial PowerSeries.monomial\n\nvariable {R}\n\ntheorem coeff_def {s : Unit \u2192\u2080 \u2115} {n : \u2115} (h : s () = n) : coeff R n = MvPowerSeries.coeff R s := by\n  erw [coeff, \u2190 h, \u2190 Finsupp.unique_single s]\n#align power_series.coeff_def PowerSeries.coeff_def\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {\u03c6 \u03c8 : R\u27e6X\u27e7} (h : \u2200 n, coeff R n \u03c6 = coeff R n \u03c8) : \u03c6 = \u03c8 :=\n  MvPowerSeries.ext fun n => by\n    rw [\u2190 coeff_def]\n    \u00b7 apply h\n    rfl\n#align power_series.ext PowerSeries.ext\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\ntheorem ext_iff {\u03c6 \u03c8 : R\u27e6X\u27e7} : \u03c6 = \u03c8 \u2194 \u2200 n, coeff R n \u03c6 = coeff R n \u03c8 :=\n  \u27e8fun h n => congr_arg (coeff R n) h, ext\u27e9\n#align power_series.ext_iff PowerSeries.ext_iff\n\ninstance [Subsingleton R] : Subsingleton R\u27e6X\u27e7 := by\n  simp only [subsingleton_iff, ext_iff]\n  exact fun _ _ _ \u21a6 (subsingleton_iff).mp (by infer_instance) _ _\n\n/-- Constructor for formal power series. -/\ndef mk {R} (f : \u2115 \u2192 R) : R\u27e6X\u27e7 := fun s => f (s ())\n#align power_series.mk PowerSeries.mk\n\n@[simp]\ntheorem coeff_mk (n : \u2115) (f : \u2115 \u2192 R) : coeff R n (mk f) = f n :=\n  congr_arg f Finsupp.single_eq_same\n#align power_series.coeff_mk PowerSeries.coeff_mk\n\ntheorem coeff_monomial (m n : \u2115) (a : R) : coeff R m (monomial R n a) = if m = n then a else 0 :=\n  calc\n    coeff R m (monomial R n a) = _ := MvPowerSeries.coeff_monomial _ _ _\n    _ = if m = n then a else 0 := by simp only [Finsupp.unique_single_eq_iff]\n\n#align power_series.coeff_monomial PowerSeries.coeff_monomial\n\ntheorem monomial_eq_mk (n : \u2115) (a : R) : monomial R n a = mk fun m => if m = n then a else 0 :=\n  ext fun m => by rw [coeff_monomial, coeff_mk]\n#align power_series.monomial_eq_mk PowerSeries.monomial_eq_mk\n\n@[simp]\ntheorem coeff_monomial_same (n : \u2115) (a : R) : coeff R n (monomial R n a) = a :=\n  MvPowerSeries.coeff_monomial_same _ _\n#align power_series.coeff_monomial_same PowerSeries.coeff_monomial_same\n\n@[simp]\ntheorem coeff_comp_monomial (n : \u2115) : (coeff R n).comp (monomial R n) = LinearMap.id :=\n  LinearMap.ext <| coeff_monomial_same n\n#align power_series.coeff_comp_monomial PowerSeries.coeff_comp_monomial\n\nvariable (R)\n\n/-- The constant coefficient of a formal power series. -/\ndef constantCoeff : R\u27e6X\u27e7 \u2192+* R :=\n  MvPowerSeries.constantCoeff Unit R\n#align power_series.constant_coeff PowerSeries.constantCoeff\n\n/-- The constant formal power series. -/\ndef C : R \u2192+* R\u27e6X\u27e7 :=\n  MvPowerSeries.C Unit R\nset_option linter.uppercaseLean3 false in\n#align power_series.C PowerSeries.C\n\nvariable {R}\n\n/-- The variable of the formal power series ring. -/\ndef X : R\u27e6X\u27e7 :=\n  MvPowerSeries.X ()\nset_option linter.uppercaseLean3 false in\n#align power_series.X PowerSeries.X\n\ntheorem commute_X (\u03c6 : R\u27e6X\u27e7) : Commute \u03c6 X :=\n  MvPowerSeries.commute_X _ _\nset_option linter.uppercaseLean3 false in\n#align power_series.commute_X PowerSeries.commute_X\n\n@[simp]\ntheorem coeff_zero_eq_constantCoeff : \u21d1(coeff R 0) = constantCoeff R := by\n  rw [coeff, Finsupp.single_zero]\n  rfl\n#align power_series.coeff_zero_eq_constant_coeff PowerSeries.coeff_zero_eq_constantCoeff\n\ntheorem coeff_zero_eq_constantCoeff_apply (\u03c6 : R\u27e6X\u27e7) : coeff R 0 \u03c6 = constantCoeff R \u03c6 :=\n  by rw [coeff_zero_eq_constantCoeff]\n#align power_series.coeff_zero_eq_constant_coeff_apply PowerSeries.coeff_zero_eq_constantCoeff_apply\n\n@[simp]\ntheorem monomial_zero_eq_C : \u21d1(monomial R 0) = C R := by\n  -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644\n  erw [monomial, Finsupp.single_zero, MvPowerSeries.monomial_zero_eq_C]\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C PowerSeries.monomial_zero_eq_C\n\ntheorem monomial_zero_eq_C_apply (a : R) : monomial R 0 a = C R a := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C_apply PowerSeries.monomial_zero_eq_C_apply\n\ntheorem coeff_C (n : \u2115) (a : R) : coeff R n (C R a : R\u27e6X\u27e7) = if n = 0 then a else 0 := by\n  rw [\u2190 monomial_zero_eq_C_apply, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C PowerSeries.coeff_C\n\n@[simp]\ntheorem coeff_zero_C (a : R) : coeff R 0 (C R a) = a := by\n  rw [coeff_C, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_C PowerSeries.coeff_zero_C\n\ntheorem coeff_ne_zero_C {a : R} {n : \u2115} (h : n \u2260 0) : coeff R n (C R a) = 0 := by\n  rw [coeff_C, if_neg h]\n\n@[simp]\ntheorem coeff_succ_C {a : R} {n : \u2115} : coeff R (n + 1) (C R a) = 0 :=\n  coeff_ne_zero_C n.succ_ne_zero\n\ntheorem C_injective : Function.Injective (C R) := by\n  intro a b H\n  have := (ext_iff (\u03c6 := C R a) (\u03c8 := C R b)).mp H 0\n  rwa [coeff_zero_C, coeff_zero_C] at this\n\nprotected theorem subsingleton_iff : Subsingleton R\u27e6X\u27e7 \u2194 Subsingleton R := by\n  refine \u27e8fun h \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9\n  rw [subsingleton_iff] at h \u22a2\n  exact fun a b \u21a6 C_injective (h (C R a) (C R b))\n\ntheorem X_eq : (X : R\u27e6X\u27e7) = monomial R 1 1 :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.X_eq PowerSeries.X_eq\n\ntheorem coeff_X (n : \u2115) : coeff R n (X : R\u27e6X\u27e7) = if n = 1 then 1 else 0 := by\n  rw [X_eq, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X PowerSeries.coeff_X\n\n@[simp]\ntheorem coeff_zero_X : coeff R 0 (X : R\u27e6X\u27e7) = 0 := by\n  -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644\n  erw [coeff, Finsupp.single_zero, X, MvPowerSeries.coeff_zero_X]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_X PowerSeries.coeff_zero_X\n\n@[simp]\ntheorem coeff_one_X : coeff R 1 (X : R\u27e6X\u27e7) = 1 := by rw [coeff_X, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_one_X PowerSeries.coeff_one_X\n\n@[simp]\ntheorem X_ne_zero [Nontrivial R] : (X : R\u27e6X\u27e7) \u2260 0 := fun H => by\n  simpa only [coeff_one_X, one_ne_zero, map_zero] using congr_arg (coeff R 1) H\nset_option linter.uppercaseLean3 false in\n#align power_series.X_ne_zero PowerSeries.X_ne_zero\n\ntheorem X_pow_eq (n : \u2115) : (X : R\u27e6X\u27e7) ^ n = monomial R n 1 :=\n  MvPowerSeries.X_pow_eq _ n\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_eq PowerSeries.X_pow_eq\n\ntheorem coeff_X_pow (m n : \u2115) : coeff R m ((X : R\u27e6X\u27e7) ^ n) = if m = n then 1 else 0 := by\n  rw [X_pow_eq, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow PowerSeries.coeff_X_pow\n\n@[simp]\ntheorem coeff_X_pow_self (n : \u2115) : coeff R n ((X : R\u27e6X\u27e7) ^ n) = 1 := by\n  rw [coeff_X_pow, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow_self PowerSeries.coeff_X_pow_self\n\n@[simp]\ntheorem coeff_one (n : \u2115) : coeff R n (1 : R\u27e6X\u27e7) = if n = 0 then 1 else 0 :=\n  coeff_C n 1\n#align power_series.coeff_one PowerSeries.coeff_one\n\ntheorem coeff_zero_one : coeff R 0 (1 : R\u27e6X\u27e7) = 1 :=\n  coeff_zero_C 1\n#align power_series.coeff_zero_one PowerSeries.coeff_zero_one\n\ntheorem coeff_mul (n : \u2115) (\u03c6 \u03c8 : R\u27e6X\u27e7) :\n    coeff R n (\u03c6 * \u03c8) = \u2211 p in antidiagonal n, coeff R p.1 \u03c6 * coeff R p.2 \u03c8 := by\n  -- `rw` can't see that `PowerSeries = MvPowerSeries Unit`, so use `.trans`\n  refine (MvPowerSeries.coeff_mul _ \u03c6 \u03c8).trans ?_\n  rw [Finsupp.antidiagonal_single, Finset.sum_map]\n  rfl\n#align power_series.coeff_mul PowerSeries.coeff_mul\n\n@[simp]\ntheorem coeff_mul_C (n : \u2115) (\u03c6 : R\u27e6X\u27e7) (a : R) : coeff R n (\u03c6 * C R a) = coeff R n \u03c6 * a :=\n  MvPowerSeries.coeff_mul_C _ \u03c6 a\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_mul_C PowerSeries.coeff_mul_C\n\n@[simp]\ntheorem coeff_C_mul (n : \u2115) (\u03c6 : R\u27e6X\u27e7) (a : R) : coeff R n (C R a * \u03c6) = a * coeff R n \u03c6 :=\n  MvPowerSeries.coeff_C_mul _ \u03c6 a\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C_mul PowerSeries.coeff_C_mul\n\n@[simp]\ntheorem coeff_smul {S : Type*} [Semiring S] [Module R S] (n : \u2115) (\u03c6 : PowerSeries S) (a : R) :\n    coeff S n (a \u2022 \u03c6) = a \u2022 coeff S n \u03c6 :=\n  rfl\n#align power_series.coeff_smul PowerSeries.coeff_smul\n\ntheorem smul_eq_C_mul (f : R\u27e6X\u27e7) (a : R) : a \u2022 f = C R a * f := by\n  ext\n  simp\nset_option linter.uppercaseLean3 false in\n#align power_series.smul_eq_C_mul PowerSeries.smul_eq_C_mul\n\n@[simp]\ntheorem coeff_succ_mul_X (n : \u2115) (\u03c6 : R\u27e6X\u27e7) : coeff R (n + 1) (\u03c6 * X) = coeff R n \u03c6 := by\n  simp only [coeff, Finsupp.single_add]\n  convert \u03c6.coeff_add_mul_monomial (single () n) (single () 1) _\n  rw [mul_one]; rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_succ_mul_X PowerSeries.coeff_succ_mul_X\n\n@[simp]\ntheorem coeff_succ_X_mul (n : \u2115) (\u03c6 : R\u27e6X\u27e7) : coeff R (n + 1) (X * \u03c6) = coeff R n \u03c6 := by\n  simp only [coeff, Finsupp.single_add, add_comm n 1]\n  convert \u03c6.coeff_add_monomial_mul (single () 1) (single () n) _\n  rw [one_mul]; rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_succ_X_mul PowerSeries.coeff_succ_X_mul\n\n@[simp]\ntheorem constantCoeff_C (a : R) : constantCoeff R (C R a) = a :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_C PowerSeries.constantCoeff_C\n\n@[simp]\ntheorem constantCoeff_comp_C : (constantCoeff R).comp (C R) = RingHom.id R :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_comp_C PowerSeries.constantCoeff_comp_C\n\n-- Porting note (#10618): simp can prove this.\n-- @[simp]\ntheorem constantCoeff_zero : constantCoeff R 0 = 0 :=\n  rfl\n#align power_series.constant_coeff_zero PowerSeries.constantCoeff_zero\n\n-- Porting note (#10618): simp can prove this.\n-- @[simp]\ntheorem constantCoeff_one : constantCoeff R 1 = 1 :=\n  rfl\n#align power_series.constant_coeff_one PowerSeries.constantCoeff_one\n\n@[simp]\ntheorem constantCoeff_X : constantCoeff R X = 0 :=\n  MvPowerSeries.coeff_zero_X _\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_X PowerSeries.constantCoeff_X\n\ntheorem coeff_zero_mul_X (\u03c6 : R\u27e6X\u27e7) : coeff R 0 (\u03c6 * X) = 0 := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_mul_X PowerSeries.coeff_zero_mul_X\n\ntheorem coeff_zero_X_mul (\u03c6 : R\u27e6X\u27e7) : coeff R 0 (X * \u03c6) = 0 := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_X_mul PowerSeries.coeff_zero_X_mul\n\ntheorem constantCoeff_surj : Function.Surjective (constantCoeff R) :=\n  fun r => \u27e8(C R) r, constantCoeff_C r\u27e9\n\n-- The following section duplicates the API of `Data.Polynomial.Coeff` and should attempt to keep\n-- up to date with that\nsection\n\ntheorem coeff_C_mul_X_pow (x : R) (k n : \u2115) :\n    coeff R n (C R x * X ^ k : R\u27e6X\u27e7) = if n = k then x else 0 := by\n  simp [X_pow_eq, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C_mul_X_pow PowerSeries.coeff_C_mul_X_pow\n\n@[simp]\ntheorem coeff_mul_X_pow (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R (d + n) (p * X ^ n) = coeff R d p := by\n  rw [coeff_mul, Finset.sum_eq_single (d, n), coeff_X_pow, if_pos rfl, mul_one]\n  \u00b7 rintro \u27e8i, j\u27e9 h1 h2\n    rw [coeff_X_pow, if_neg, mul_zero]\n    rintro rfl\n    apply h2\n    rw [mem_antidiagonal, add_right_cancel_iff] at h1\n    subst h1\n    rfl\n  \u00b7 exact fun h1 => (h1 (mem_antidiagonal.2 rfl)).elim\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_mul_X_pow PowerSeries.coeff_mul_X_pow\n\n@[simp]\ntheorem coeff_X_pow_mul (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R (d + n) (X ^ n * p) = coeff R d p := by\n  rw [coeff_mul, Finset.sum_eq_single (n, d), coeff_X_pow, if_pos rfl, one_mul]\n  \u00b7 rintro \u27e8i, j\u27e9 h1 h2\n    rw [coeff_X_pow, if_neg, zero_mul]\n    rintro rfl\n    apply h2\n    rw [mem_antidiagonal, add_comm, add_right_cancel_iff] at h1\n    subst h1\n    rfl\n  \u00b7 rw [add_comm]\n    exact fun h1 => (h1 (mem_antidiagonal.2 rfl)).elim\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow_mul PowerSeries.coeff_X_pow_mul\n\ntheorem coeff_mul_X_pow' (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R d (p * X ^ n) = ite (n \u2264 d) (coeff R (d - n) p) 0 := by\n  split_ifs with h\n  \u00b7 rw [\u2190 tsub_add_cancel_of_le h, coeff_mul_X_pow, add_tsub_cancel_right]\n  \u00b7 refine' (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => _)\n    rw [coeff_X_pow, if_neg, mul_zero]\n    exact ((le_of_add_le_right (mem_antidiagonal.mp hx).le).trans_lt <| not_le.mp h).ne\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_mul_X_pow' PowerSeries.coeff_mul_X_pow'\n\ntheorem coeff_X_pow_mul' (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R d (X ^ n * p) = ite (n \u2264 d) (coeff R (d - n) p) 0 := by\n  split_ifs with h\n  \u00b7 rw [\u2190 tsub_add_cancel_of_le h, coeff_X_pow_mul]\n    simp\n  \u00b7 refine' (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => _)\n    rw [coeff_X_pow, if_neg, zero_mul]\n    have := mem_antidiagonal.mp hx\n    rw [add_comm] at this\n    exact ((le_of_add_le_right this.le).trans_lt <| not_le.mp h).ne\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow_mul' PowerSeries.coeff_X_pow_mul'\n\nend\n\n/-- If a formal power series is invertible, then so is its constant coefficient. -/\ntheorem isUnit_constantCoeff (\u03c6 : R\u27e6X\u27e7) (h : IsUnit \u03c6) : IsUnit (constantCoeff R \u03c6) :=\n  MvPowerSeries.isUnit_constantCoeff \u03c6 h\n#align power_series.is_unit_constant_coeff PowerSeries.isUnit_constantCoeff\n\n/-- Split off the constant coefficient. -/\ntheorem eq_shift_mul_X_add_const (\u03c6 : R\u27e6X\u27e7) :\n    \u03c6 = (mk fun p => coeff R (p + 1) \u03c6) * X + C R (constantCoeff R \u03c6) := by\n  ext (_ | n)\n  \u00b7 simp only [Nat.zero_eq, coeff_zero_eq_constantCoeff, map_add, map_mul, constantCoeff_X,\n      mul_zero, coeff_zero_C, zero_add]\n  \u00b7 simp only [coeff_succ_mul_X, coeff_mk, LinearMap.map_add, coeff_C, n.succ_ne_zero, sub_zero,\n      if_false, add_zero]\nset_option linter.uppercaseLean3 false in\n#align power_series.eq_shift_mul_X_add_const PowerSeries.eq_shift_mul_X_add_const\n\n/-- Split off the constant coefficient. -/\ntheorem eq_X_mul_shift_add_const (\u03c6 : R\u27e6X\u27e7) :\n    \u03c6 = (X * mk fun p => coeff R (p + 1) \u03c6) + C R (constantCoeff R \u03c6) := by\n  ext (_ | n)\n  \u00b7 simp only [Nat.zero_eq, coeff_zero_eq_constantCoeff, map_add, map_mul, constantCoeff_X,\n      zero_mul, coeff_zero_C, zero_add]\n  \u00b7 simp only [coeff_succ_X_mul, coeff_mk, LinearMap.map_add, coeff_C, n.succ_ne_zero, sub_zero,\n      if_false, add_zero]\nset_option linter.uppercaseLean3 false in\n#align power_series.eq_X_mul_shift_add_const PowerSeries.eq_X_mul_shift_add_const\n\nsection Map\n\nvariable {S : Type*} {T : Type*} [Semiring S] [Semiring T]\nvariable (f : R \u2192+* S) (g : S \u2192+* T)\n\n/-- The map between formal power series induced by a map on the coefficients. -/\ndef map : R\u27e6X\u27e7 \u2192+* S\u27e6X\u27e7 :=\n  MvPowerSeries.map _ f\n#align power_series.map PowerSeries.map\n\n@[simp]\ntheorem map_id : (map (RingHom.id R) : R\u27e6X\u27e7 \u2192 R\u27e6X\u27e7) = id :=\n  rfl\n#align power_series.map_id PowerSeries.map_id\n\ntheorem map_comp : map (g.comp f) = (map g).comp (map f) :=\n  rfl\n#align power_series.map_comp PowerSeries.map_comp\n\n@[simp]\ntheorem coeff_map (n : \u2115) (\u03c6 : R\u27e6X\u27e7) : coeff S n (map f \u03c6) = f (coeff R n \u03c6) :=\n  rfl\n#align power_series.coeff_map PowerSeries.coeff_map\n\n@[simp]\ntheorem map_C (r : R) : map f (C _ r) = C _ (f r) := by\n  ext\n  simp [coeff_C, apply_ite f]\nset_option linter.uppercaseLean3 false in\n#align power_series.map_C PowerSeries.map_C\n\n@[simp]\ntheorem map_X : map f X = X := by\n  ext\n  simp [coeff_X, apply_ite f]\nset_option linter.uppercaseLean3 false in\n#align power_series.map_X PowerSeries.map_X\n\nend Map\n\ntheorem X_pow_dvd_iff {n : \u2115} {\u03c6 : R\u27e6X\u27e7} :\n    (X : R\u27e6X\u27e7) ^ n \u2223 \u03c6 \u2194 \u2200 m, m < n \u2192 coeff R m \u03c6 = 0 := by\n  convert@MvPowerSeries.X_pow_dvd_iff Unit R _ () n \u03c6\n  constructor <;> intro h m hm\n  \u00b7 rw [Finsupp.unique_single m]\n    convert h _ hm\n  \u00b7 apply h\n    simpa only [Finsupp.single_eq_same] using hm\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_dvd_iff PowerSeries.X_pow_dvd_iff\n\ntheorem X_dvd_iff {\u03c6 : R\u27e6X\u27e7} : (X : R\u27e6X\u27e7) \u2223 \u03c6 \u2194 constantCoeff R \u03c6 = 0 := by\n  rw [\u2190 pow_one (X : R\u27e6X\u27e7), X_pow_dvd_iff, \u2190 coeff_zero_eq_constantCoeff_apply]\n  constructor <;> intro h\n  \u00b7 exact h 0 zero_lt_one\n  \u00b7 intro m hm\n    rwa [Nat.eq_zero_of_le_zero (Nat.le_of_succ_le_succ hm)]\nset_option linter.uppercaseLean3 false in\n#align power_series.X_dvd_iff PowerSeries.X_dvd_iff\n\nend Semiring\n\nsection CommSemiring\n\nvariable [CommSemiring R]\n\nopen Finset Nat\n\n/-- The ring homomorphism taking a power series `f(X)` to `f(aX)`. -/\nnoncomputable def rescale (a : R) : R\u27e6X\u27e7 \u2192+* R\u27e6X\u27e7 where\n  toFun f := PowerSeries.mk fun n => a ^ n * PowerSeries.coeff R n f\n  map_zero' := by\n    ext\n    simp only [LinearMap.map_zero, PowerSeries.coeff_mk, mul_zero]\n  map_one' := by\n    ext1\n    simp only [mul_boole, PowerSeries.coeff_mk, PowerSeries.coeff_one]\n    split_ifs with h\n    \u00b7 rw [h, pow_zero a]\n    rfl\n  map_add' := by\n    intros\n    ext\n    dsimp only\n    exact mul_add _ _ _\n  map_mul' f g := by\n    ext\n    rw [PowerSeries.coeff_mul, PowerSeries.coeff_mk, PowerSeries.coeff_mul, Finset.mul_sum]\n    apply sum_congr rfl\n    simp only [coeff_mk, Prod.forall, mem_antidiagonal]\n    intro b c H\n    rw [\u2190 H, pow_add, mul_mul_mul_comm]\n#align power_series.rescale PowerSeries.rescale\n\n@[simp]\ntheorem coeff_rescale (f : R\u27e6X\u27e7) (a : R) (n : \u2115) :\n    coeff R n (rescale a f) = a ^ n * coeff R n f :=\n  coeff_mk n (fun n \u21a6 a ^ n * (coeff R n) f)\n#align power_series.coeff_rescale PowerSeries.coeff_rescale\n\n@[simp]\ntheorem rescale_zero : rescale 0 = (C R).comp (constantCoeff R) := by\n  ext x n\n  simp only [Function.comp_apply, RingHom.coe_comp, rescale, RingHom.coe_mk,\n    PowerSeries.coeff_mk _ _, coeff_C]\n  split_ifs with h <;> simp [h]\n#align power_series.rescale_zero PowerSeries.rescale_zero\n\ntheorem rescale_zero_apply : rescale 0 X = C R (constantCoeff R X) := by simp\n#align power_series.rescale_zero_apply PowerSeries.rescale_zero_apply\n\n@[simp]\ntheorem rescale_one : rescale 1 = RingHom.id R\u27e6X\u27e7 := by\n  ext\n  simp only [coeff_rescale, one_pow, one_mul, RingHom.id_apply]\n#align power_series.rescale_one PowerSeries.rescale_one\n\ntheorem rescale_mk (f : \u2115 \u2192 R) (a : R) : rescale a (mk f) = mk fun n : \u2115 => a ^ n * f n := by\n  ext\n  rw [coeff_rescale, coeff_mk, coeff_mk]\n#align power_series.rescale_mk PowerSeries.rescale_mk\n\ntheorem rescale_rescale (f : R\u27e6X\u27e7) (a b : R) :\n    rescale b (rescale a f) = rescale (a * b) f := by\n  ext n\n  simp_rw [coeff_rescale]\n  rw [mul_pow, mul_comm _ (b ^ n), mul_assoc]\n#align power_series.rescale_rescale PowerSeries.rescale_rescale\n\ntheorem rescale_mul (a b : R) : rescale (a * b) = (rescale b).comp (rescale a) := by\n  ext\n  simp [\u2190 rescale_rescale]\n#align power_series.rescale_mul PowerSeries.rescale_mul\n\nend CommSemiring\n\nsection CommSemiring\n\nopen Finset.HasAntidiagonal Finset\n\nvariable {R : Type*} [CommSemiring R] {\u03b9 : Type*} [DecidableEq \u03b9]\n\n/-- Coefficients of a product of power series -/\ntheorem coeff_prod (f : \u03b9 \u2192 PowerSeries R) (d : \u2115) (s : Finset \u03b9) :\n    coeff R d (\u220f j in s, f j) = \u2211 l in piAntidiagonal s d, \u220f i in s, coeff R (l i) (f i) := by\n  simp only [coeff]\n  convert MvPowerSeries.coeff_prod _ _ _\n  rw [\u2190 AddEquiv.finsuppUnique_symm d, \u2190 mapRange_piAntidiagonal_eq, sum_map, sum_congr rfl]\n  intro x _\n  apply prod_congr rfl\n  intro i _\n  congr 2\n  simp only [AddEquiv.toEquiv_eq_coe, Finsupp.mapRange.addEquiv_toEquiv, AddEquiv.toEquiv_symm,\n    Equiv.coe_toEmbedding, Finsupp.mapRange.equiv_apply, AddEquiv.coe_toEquiv_symm,\n    Finsupp.mapRange_apply, AddEquiv.finsuppUnique_symm]\n\nend CommSemiring\n\nsection CommRing\n\nvariable {A : Type*} [CommRing A]\n\n", "theoremStatement": "theorem not_isField : \u00acIsField A\u27e6X\u27e7", "theoremName": "not_isField", "fileCreated": {"commit": "3d924717cd", "date": "2023-05-22"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "positionMetadata": {"lineInFile": 675, "tokenPositionInFile": 23335, "theoremPositionInFile": 91}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  by_cases hA : Subsingleton A\n  \u00b7 exact not_isField_of_subsingleton _\n  \u00b7 nontriviality A\n    rw [Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top]\n    use Ideal.span {X}\n    constructor\n    \u00b7 rw [bot_lt_iff_ne_bot, Ne.def, Ideal.span_singleton_eq_bot]\n      exact X_ne_zero\n    \u00b7 rw [lt_top_iff_ne_top, Ne.def, Ideal.eq_top_iff_one, Ideal.mem_span_singleton,\n        X_dvd_iff, constantCoeff_one]\n      exact one_ne_zero", "proofType": "tactic", "proofLengthLines": 12, "proofLengthTokens": 428}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Basic\nimport Mathlib.RingTheory.MvPowerSeries.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-!\n# Formal power series (in one variable)\n\nThis file defines (univariate) formal power series\nand develops the basic properties of these objects.\n\nA formal power series is to a polynomial like an infinite sum is to a finite sum.\n\nFormal power series in one variable are defined from multivariate\npower series as `PowerSeries R := MvPowerSeries Unit R`.\n\nThe file sets up the (semi)ring structure on univariate power series.\n\nWe provide the natural inclusion from polynomials to formal power series.\n\nAdditional results can be found in:\n* `Mathlib.RingTheory.PowerSeries.Trunc`, truncation of power series;\n* `Mathlib.RingTheory.PowerSeries.Inverse`, about inverses of power series,\nand the fact that power series over a local ring form a local ring;\n* `Mathlib.RingTheory.PowerSeries.Order`, the order of a power series at 0,\nand application to the fact that power series over an integral domain\nform an integral domain.\n\n## Implementation notes\n\nBecause of its definition,\n  `PowerSeries R := MvPowerSeries Unit R`.\na lot of proofs and properties from the multivariate case\ncan be ported to the single variable case.\nHowever, it means that formal power series are indexed by `Unit \u2192\u2080 \u2115`,\nwhich is of course canonically isomorphic to `\u2115`.\nWe then build some glue to treat formal power series as if they were indexed by `\u2115`.\nOccasionally this leads to proofs that are uglier than expected.\n\n-/\n\nnoncomputable section\n\nopen BigOperators\n\nopen Finset (antidiagonal mem_antidiagonal)\n\n/-- Formal power series over a coefficient type `R` -/\ndef PowerSeries (R : Type*) :=\n  MvPowerSeries Unit R\n#align power_series PowerSeries\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection\n\n-- Porting note: not available in Lean 4\n-- local reducible PowerSeries\n\n\n/--\n`R\u27e6X\u27e7` is notation for `PowerSeries R`,\nthe semiring of formal power series in one variable over a semiring `R`.\n-/\nscoped notation:9000 R \"\u27e6X\u27e7\" => PowerSeries R\n\ninstance [Inhabited R] : Inhabited R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Zero R] : Zero R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddMonoid R] : AddMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddGroup R] : AddGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommMonoid R] : AddCommMonoid R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [AddCommGroup R] : AddCommGroup R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Semiring R] : Semiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommSemiring R] : CommSemiring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Ring R] : Ring R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [CommRing R] : CommRing R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance [Nontrivial R] : Nontrivial R\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A} [Semiring R] [AddCommMonoid A] [Module R A] : Module R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\ninstance {A S} [Semiring R] [Semiring S] [AddCommMonoid A] [Module R A] [Module S A] [SMul R S]\n    [IsScalarTower R S A] : IsScalarTower R S A\u27e6X\u27e7 :=\n  Pi.isScalarTower\n\ninstance {A} [Semiring A] [CommSemiring R] [Algebra R A] : Algebra R A\u27e6X\u27e7 := by\n  dsimp only [PowerSeries]\n  infer_instance\n\nend\n\nsection Semiring\n\nvariable (R) [Semiring R]\n\n/-- The `n`th coefficient of a formal power series. -/\ndef coeff (n : \u2115) : R\u27e6X\u27e7 \u2192\u2097[R] R :=\n  MvPowerSeries.coeff R (single () n)\n#align power_series.coeff PowerSeries.coeff\n\n/-- The `n`th monomial with coefficient `a` as formal power series. -/\ndef monomial (n : \u2115) : R \u2192\u2097[R] R\u27e6X\u27e7 :=\n  MvPowerSeries.monomial R (single () n)\n#align power_series.monomial PowerSeries.monomial\n\nvariable {R}\n\ntheorem coeff_def {s : Unit \u2192\u2080 \u2115} {n : \u2115} (h : s () = n) : coeff R n = MvPowerSeries.coeff R s := by\n  erw [coeff, \u2190 h, \u2190 Finsupp.unique_single s]\n#align power_series.coeff_def PowerSeries.coeff_def\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {\u03c6 \u03c8 : R\u27e6X\u27e7} (h : \u2200 n, coeff R n \u03c6 = coeff R n \u03c8) : \u03c6 = \u03c8 :=\n  MvPowerSeries.ext fun n => by\n    rw [\u2190 coeff_def]\n    \u00b7 apply h\n    rfl\n#align power_series.ext PowerSeries.ext\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\ntheorem ext_iff {\u03c6 \u03c8 : R\u27e6X\u27e7} : \u03c6 = \u03c8 \u2194 \u2200 n, coeff R n \u03c6 = coeff R n \u03c8 :=\n  \u27e8fun h n => congr_arg (coeff R n) h, ext\u27e9\n#align power_series.ext_iff PowerSeries.ext_iff\n\ninstance [Subsingleton R] : Subsingleton R\u27e6X\u27e7 := by\n  simp only [subsingleton_iff, ext_iff]\n  exact fun _ _ _ \u21a6 (subsingleton_iff).mp (by infer_instance) _ _\n\n/-- Constructor for formal power series. -/\ndef mk {R} (f : \u2115 \u2192 R) : R\u27e6X\u27e7 := fun s => f (s ())\n#align power_series.mk PowerSeries.mk\n\n@[simp]\ntheorem coeff_mk (n : \u2115) (f : \u2115 \u2192 R) : coeff R n (mk f) = f n :=\n  congr_arg f Finsupp.single_eq_same\n#align power_series.coeff_mk PowerSeries.coeff_mk\n\ntheorem coeff_monomial (m n : \u2115) (a : R) : coeff R m (monomial R n a) = if m = n then a else 0 :=\n  calc\n    coeff R m (monomial R n a) = _ := MvPowerSeries.coeff_monomial _ _ _\n    _ = if m = n then a else 0 := by simp only [Finsupp.unique_single_eq_iff]\n\n#align power_series.coeff_monomial PowerSeries.coeff_monomial\n\ntheorem monomial_eq_mk (n : \u2115) (a : R) : monomial R n a = mk fun m => if m = n then a else 0 :=\n  ext fun m => by rw [coeff_monomial, coeff_mk]\n#align power_series.monomial_eq_mk PowerSeries.monomial_eq_mk\n\n@[simp]\ntheorem coeff_monomial_same (n : \u2115) (a : R) : coeff R n (monomial R n a) = a :=\n  MvPowerSeries.coeff_monomial_same _ _\n#align power_series.coeff_monomial_same PowerSeries.coeff_monomial_same\n\n@[simp]\ntheorem coeff_comp_monomial (n : \u2115) : (coeff R n).comp (monomial R n) = LinearMap.id :=\n  LinearMap.ext <| coeff_monomial_same n\n#align power_series.coeff_comp_monomial PowerSeries.coeff_comp_monomial\n\nvariable (R)\n\n/-- The constant coefficient of a formal power series. -/\ndef constantCoeff : R\u27e6X\u27e7 \u2192+* R :=\n  MvPowerSeries.constantCoeff Unit R\n#align power_series.constant_coeff PowerSeries.constantCoeff\n\n/-- The constant formal power series. -/\ndef C : R \u2192+* R\u27e6X\u27e7 :=\n  MvPowerSeries.C Unit R\nset_option linter.uppercaseLean3 false in\n#align power_series.C PowerSeries.C\n\nvariable {R}\n\n/-- The variable of the formal power series ring. -/\ndef X : R\u27e6X\u27e7 :=\n  MvPowerSeries.X ()\nset_option linter.uppercaseLean3 false in\n#align power_series.X PowerSeries.X\n\ntheorem commute_X (\u03c6 : R\u27e6X\u27e7) : Commute \u03c6 X :=\n  MvPowerSeries.commute_X _ _\nset_option linter.uppercaseLean3 false in\n#align power_series.commute_X PowerSeries.commute_X\n\n@[simp]\ntheorem coeff_zero_eq_constantCoeff : \u21d1(coeff R 0) = constantCoeff R := by\n  rw [coeff, Finsupp.single_zero]\n  rfl\n#align power_series.coeff_zero_eq_constant_coeff PowerSeries.coeff_zero_eq_constantCoeff\n\ntheorem coeff_zero_eq_constantCoeff_apply (\u03c6 : R\u27e6X\u27e7) : coeff R 0 \u03c6 = constantCoeff R \u03c6 :=\n  by rw [coeff_zero_eq_constantCoeff]\n#align power_series.coeff_zero_eq_constant_coeff_apply PowerSeries.coeff_zero_eq_constantCoeff_apply\n\n@[simp]\ntheorem monomial_zero_eq_C : \u21d1(monomial R 0) = C R := by\n  -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644\n  erw [monomial, Finsupp.single_zero, MvPowerSeries.monomial_zero_eq_C]\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C PowerSeries.monomial_zero_eq_C\n\ntheorem monomial_zero_eq_C_apply (a : R) : monomial R 0 a = C R a := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.monomial_zero_eq_C_apply PowerSeries.monomial_zero_eq_C_apply\n\ntheorem coeff_C (n : \u2115) (a : R) : coeff R n (C R a : R\u27e6X\u27e7) = if n = 0 then a else 0 := by\n  rw [\u2190 monomial_zero_eq_C_apply, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C PowerSeries.coeff_C\n\n@[simp]\ntheorem coeff_zero_C (a : R) : coeff R 0 (C R a) = a := by\n  rw [coeff_C, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_C PowerSeries.coeff_zero_C\n\ntheorem coeff_ne_zero_C {a : R} {n : \u2115} (h : n \u2260 0) : coeff R n (C R a) = 0 := by\n  rw [coeff_C, if_neg h]\n\n@[simp]\ntheorem coeff_succ_C {a : R} {n : \u2115} : coeff R (n + 1) (C R a) = 0 :=\n  coeff_ne_zero_C n.succ_ne_zero\n\ntheorem C_injective : Function.Injective (C R) := by\n  intro a b H\n  have := (ext_iff (\u03c6 := C R a) (\u03c8 := C R b)).mp H 0\n  rwa [coeff_zero_C, coeff_zero_C] at this\n\nprotected theorem subsingleton_iff : Subsingleton R\u27e6X\u27e7 \u2194 Subsingleton R := by\n  refine \u27e8fun h \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9\n  rw [subsingleton_iff] at h \u22a2\n  exact fun a b \u21a6 C_injective (h (C R a) (C R b))\n\ntheorem X_eq : (X : R\u27e6X\u27e7) = monomial R 1 1 :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.X_eq PowerSeries.X_eq\n\ntheorem coeff_X (n : \u2115) : coeff R n (X : R\u27e6X\u27e7) = if n = 1 then 1 else 0 := by\n  rw [X_eq, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X PowerSeries.coeff_X\n\n@[simp]\ntheorem coeff_zero_X : coeff R 0 (X : R\u27e6X\u27e7) = 0 := by\n  -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644\n  erw [coeff, Finsupp.single_zero, X, MvPowerSeries.coeff_zero_X]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_X PowerSeries.coeff_zero_X\n\n@[simp]\ntheorem coeff_one_X : coeff R 1 (X : R\u27e6X\u27e7) = 1 := by rw [coeff_X, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_one_X PowerSeries.coeff_one_X\n\n@[simp]\ntheorem X_ne_zero [Nontrivial R] : (X : R\u27e6X\u27e7) \u2260 0 := fun H => by\n  simpa only [coeff_one_X, one_ne_zero, map_zero] using congr_arg (coeff R 1) H\nset_option linter.uppercaseLean3 false in\n#align power_series.X_ne_zero PowerSeries.X_ne_zero\n\ntheorem X_pow_eq (n : \u2115) : (X : R\u27e6X\u27e7) ^ n = monomial R n 1 :=\n  MvPowerSeries.X_pow_eq _ n\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_eq PowerSeries.X_pow_eq\n\ntheorem coeff_X_pow (m n : \u2115) : coeff R m ((X : R\u27e6X\u27e7) ^ n) = if m = n then 1 else 0 := by\n  rw [X_pow_eq, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow PowerSeries.coeff_X_pow\n\n@[simp]\ntheorem coeff_X_pow_self (n : \u2115) : coeff R n ((X : R\u27e6X\u27e7) ^ n) = 1 := by\n  rw [coeff_X_pow, if_pos rfl]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow_self PowerSeries.coeff_X_pow_self\n\n@[simp]\ntheorem coeff_one (n : \u2115) : coeff R n (1 : R\u27e6X\u27e7) = if n = 0 then 1 else 0 :=\n  coeff_C n 1\n#align power_series.coeff_one PowerSeries.coeff_one\n\ntheorem coeff_zero_one : coeff R 0 (1 : R\u27e6X\u27e7) = 1 :=\n  coeff_zero_C 1\n#align power_series.coeff_zero_one PowerSeries.coeff_zero_one\n\ntheorem coeff_mul (n : \u2115) (\u03c6 \u03c8 : R\u27e6X\u27e7) :\n    coeff R n (\u03c6 * \u03c8) = \u2211 p in antidiagonal n, coeff R p.1 \u03c6 * coeff R p.2 \u03c8 := by\n  -- `rw` can't see that `PowerSeries = MvPowerSeries Unit`, so use `.trans`\n  refine (MvPowerSeries.coeff_mul _ \u03c6 \u03c8).trans ?_\n  rw [Finsupp.antidiagonal_single, Finset.sum_map]\n  rfl\n#align power_series.coeff_mul PowerSeries.coeff_mul\n\n@[simp]\ntheorem coeff_mul_C (n : \u2115) (\u03c6 : R\u27e6X\u27e7) (a : R) : coeff R n (\u03c6 * C R a) = coeff R n \u03c6 * a :=\n  MvPowerSeries.coeff_mul_C _ \u03c6 a\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_mul_C PowerSeries.coeff_mul_C\n\n@[simp]\ntheorem coeff_C_mul (n : \u2115) (\u03c6 : R\u27e6X\u27e7) (a : R) : coeff R n (C R a * \u03c6) = a * coeff R n \u03c6 :=\n  MvPowerSeries.coeff_C_mul _ \u03c6 a\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C_mul PowerSeries.coeff_C_mul\n\n@[simp]\ntheorem coeff_smul {S : Type*} [Semiring S] [Module R S] (n : \u2115) (\u03c6 : PowerSeries S) (a : R) :\n    coeff S n (a \u2022 \u03c6) = a \u2022 coeff S n \u03c6 :=\n  rfl\n#align power_series.coeff_smul PowerSeries.coeff_smul\n\ntheorem smul_eq_C_mul (f : R\u27e6X\u27e7) (a : R) : a \u2022 f = C R a * f := by\n  ext\n  simp\nset_option linter.uppercaseLean3 false in\n#align power_series.smul_eq_C_mul PowerSeries.smul_eq_C_mul\n\n@[simp]\ntheorem coeff_succ_mul_X (n : \u2115) (\u03c6 : R\u27e6X\u27e7) : coeff R (n + 1) (\u03c6 * X) = coeff R n \u03c6 := by\n  simp only [coeff, Finsupp.single_add]\n  convert \u03c6.coeff_add_mul_monomial (single () n) (single () 1) _\n  rw [mul_one]; rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_succ_mul_X PowerSeries.coeff_succ_mul_X\n\n@[simp]\ntheorem coeff_succ_X_mul (n : \u2115) (\u03c6 : R\u27e6X\u27e7) : coeff R (n + 1) (X * \u03c6) = coeff R n \u03c6 := by\n  simp only [coeff, Finsupp.single_add, add_comm n 1]\n  convert \u03c6.coeff_add_monomial_mul (single () 1) (single () n) _\n  rw [one_mul]; rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_succ_X_mul PowerSeries.coeff_succ_X_mul\n\n@[simp]\ntheorem constantCoeff_C (a : R) : constantCoeff R (C R a) = a :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_C PowerSeries.constantCoeff_C\n\n@[simp]\ntheorem constantCoeff_comp_C : (constantCoeff R).comp (C R) = RingHom.id R :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_comp_C PowerSeries.constantCoeff_comp_C\n\n-- Porting note (#10618): simp can prove this.\n-- @[simp]\ntheorem constantCoeff_zero : constantCoeff R 0 = 0 :=\n  rfl\n#align power_series.constant_coeff_zero PowerSeries.constantCoeff_zero\n\n-- Porting note (#10618): simp can prove this.\n-- @[simp]\ntheorem constantCoeff_one : constantCoeff R 1 = 1 :=\n  rfl\n#align power_series.constant_coeff_one PowerSeries.constantCoeff_one\n\n@[simp]\ntheorem constantCoeff_X : constantCoeff R X = 0 :=\n  MvPowerSeries.coeff_zero_X _\nset_option linter.uppercaseLean3 false in\n#align power_series.constant_coeff_X PowerSeries.constantCoeff_X\n\ntheorem coeff_zero_mul_X (\u03c6 : R\u27e6X\u27e7) : coeff R 0 (\u03c6 * X) = 0 := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_mul_X PowerSeries.coeff_zero_mul_X\n\ntheorem coeff_zero_X_mul (\u03c6 : R\u27e6X\u27e7) : coeff R 0 (X * \u03c6) = 0 := by simp\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_zero_X_mul PowerSeries.coeff_zero_X_mul\n\ntheorem constantCoeff_surj : Function.Surjective (constantCoeff R) :=\n  fun r => \u27e8(C R) r, constantCoeff_C r\u27e9\n\n-- The following section duplicates the API of `Data.Polynomial.Coeff` and should attempt to keep\n-- up to date with that\nsection\n\ntheorem coeff_C_mul_X_pow (x : R) (k n : \u2115) :\n    coeff R n (C R x * X ^ k : R\u27e6X\u27e7) = if n = k then x else 0 := by\n  simp [X_pow_eq, coeff_monomial]\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_C_mul_X_pow PowerSeries.coeff_C_mul_X_pow\n\n@[simp]\ntheorem coeff_mul_X_pow (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R (d + n) (p * X ^ n) = coeff R d p := by\n  rw [coeff_mul, Finset.sum_eq_single (d, n), coeff_X_pow, if_pos rfl, mul_one]\n  \u00b7 rintro \u27e8i, j\u27e9 h1 h2\n    rw [coeff_X_pow, if_neg, mul_zero]\n    rintro rfl\n    apply h2\n    rw [mem_antidiagonal, add_right_cancel_iff] at h1\n    subst h1\n    rfl\n  \u00b7 exact fun h1 => (h1 (mem_antidiagonal.2 rfl)).elim\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_mul_X_pow PowerSeries.coeff_mul_X_pow\n\n@[simp]\ntheorem coeff_X_pow_mul (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R (d + n) (X ^ n * p) = coeff R d p := by\n  rw [coeff_mul, Finset.sum_eq_single (n, d), coeff_X_pow, if_pos rfl, one_mul]\n  \u00b7 rintro \u27e8i, j\u27e9 h1 h2\n    rw [coeff_X_pow, if_neg, zero_mul]\n    rintro rfl\n    apply h2\n    rw [mem_antidiagonal, add_comm, add_right_cancel_iff] at h1\n    subst h1\n    rfl\n  \u00b7 rw [add_comm]\n    exact fun h1 => (h1 (mem_antidiagonal.2 rfl)).elim\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow_mul PowerSeries.coeff_X_pow_mul\n\ntheorem coeff_mul_X_pow' (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R d (p * X ^ n) = ite (n \u2264 d) (coeff R (d - n) p) 0 := by\n  split_ifs with h\n  \u00b7 rw [\u2190 tsub_add_cancel_of_le h, coeff_mul_X_pow, add_tsub_cancel_right]\n  \u00b7 refine' (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => _)\n    rw [coeff_X_pow, if_neg, mul_zero]\n    exact ((le_of_add_le_right (mem_antidiagonal.mp hx).le).trans_lt <| not_le.mp h).ne\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_mul_X_pow' PowerSeries.coeff_mul_X_pow'\n\ntheorem coeff_X_pow_mul' (p : R\u27e6X\u27e7) (n d : \u2115) :\n    coeff R d (X ^ n * p) = ite (n \u2264 d) (coeff R (d - n) p) 0 := by\n  split_ifs with h\n  \u00b7 rw [\u2190 tsub_add_cancel_of_le h, coeff_X_pow_mul]\n    simp\n  \u00b7 refine' (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => _)\n    rw [coeff_X_pow, if_neg, zero_mul]\n    have := mem_antidiagonal.mp hx\n    rw [add_comm] at this\n    exact ((le_of_add_le_right this.le).trans_lt <| not_le.mp h).ne\nset_option linter.uppercaseLean3 false in\n#align power_series.coeff_X_pow_mul' PowerSeries.coeff_X_pow_mul'\n\nend\n\n/-- If a formal power series is invertible, then so is its constant coefficient. -/\ntheorem isUnit_constantCoeff (\u03c6 : R\u27e6X\u27e7) (h : IsUnit \u03c6) : IsUnit (constantCoeff R \u03c6) :=\n  MvPowerSeries.isUnit_constantCoeff \u03c6 h\n#align power_series.is_unit_constant_coeff PowerSeries.isUnit_constantCoeff\n\n/-- Split off the constant coefficient. -/\ntheorem eq_shift_mul_X_add_const (\u03c6 : R\u27e6X\u27e7) :\n    \u03c6 = (mk fun p => coeff R (p + 1) \u03c6) * X + C R (constantCoeff R \u03c6) := by\n  ext (_ | n)\n  \u00b7 simp only [Nat.zero_eq, coeff_zero_eq_constantCoeff, map_add, map_mul, constantCoeff_X,\n      mul_zero, coeff_zero_C, zero_add]\n  \u00b7 simp only [coeff_succ_mul_X, coeff_mk, LinearMap.map_add, coeff_C, n.succ_ne_zero, sub_zero,\n      if_false, add_zero]\nset_option linter.uppercaseLean3 false in\n#align power_series.eq_shift_mul_X_add_const PowerSeries.eq_shift_mul_X_add_const\n\n/-- Split off the constant coefficient. -/\ntheorem eq_X_mul_shift_add_const (\u03c6 : R\u27e6X\u27e7) :\n    \u03c6 = (X * mk fun p => coeff R (p + 1) \u03c6) + C R (constantCoeff R \u03c6) := by\n  ext (_ | n)\n  \u00b7 simp only [Nat.zero_eq, coeff_zero_eq_constantCoeff, map_add, map_mul, constantCoeff_X,\n      zero_mul, coeff_zero_C, zero_add]\n  \u00b7 simp only [coeff_succ_X_mul, coeff_mk, LinearMap.map_add, coeff_C, n.succ_ne_zero, sub_zero,\n      if_false, add_zero]\nset_option linter.uppercaseLean3 false in\n#align power_series.eq_X_mul_shift_add_const PowerSeries.eq_X_mul_shift_add_const\n\nsection Map\n\nvariable {S : Type*} {T : Type*} [Semiring S] [Semiring T]\nvariable (f : R \u2192+* S) (g : S \u2192+* T)\n\n/-- The map between formal power series induced by a map on the coefficients. -/\ndef map : R\u27e6X\u27e7 \u2192+* S\u27e6X\u27e7 :=\n  MvPowerSeries.map _ f\n#align power_series.map PowerSeries.map\n\n@[simp]\ntheorem map_id : (map (RingHom.id R) : R\u27e6X\u27e7 \u2192 R\u27e6X\u27e7) = id :=\n  rfl\n#align power_series.map_id PowerSeries.map_id\n\ntheorem map_comp : map (g.comp f) = (map g).comp (map f) :=\n  rfl\n#align power_series.map_comp PowerSeries.map_comp\n\n@[simp]\ntheorem coeff_map (n : \u2115) (\u03c6 : R\u27e6X\u27e7) : coeff S n (map f \u03c6) = f (coeff R n \u03c6) :=\n  rfl\n#align power_series.coeff_map PowerSeries.coeff_map\n\n@[simp]\ntheorem map_C (r : R) : map f (C _ r) = C _ (f r) := by\n  ext\n  simp [coeff_C, apply_ite f]\nset_option linter.uppercaseLean3 false in\n#align power_series.map_C PowerSeries.map_C\n\n@[simp]\ntheorem map_X : map f X = X := by\n  ext\n  simp [coeff_X, apply_ite f]\nset_option linter.uppercaseLean3 false in\n#align power_series.map_X PowerSeries.map_X\n\nend Map\n\ntheorem X_pow_dvd_iff {n : \u2115} {\u03c6 : R\u27e6X\u27e7} :\n    (X : R\u27e6X\u27e7) ^ n \u2223 \u03c6 \u2194 \u2200 m, m < n \u2192 coeff R m \u03c6 = 0 := by\n  convert@MvPowerSeries.X_pow_dvd_iff Unit R _ () n \u03c6\n  constructor <;> intro h m hm\n  \u00b7 rw [Finsupp.unique_single m]\n    convert h _ hm\n  \u00b7 apply h\n    simpa only [Finsupp.single_eq_same] using hm\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_dvd_iff PowerSeries.X_pow_dvd_iff\n\ntheorem X_dvd_iff {\u03c6 : R\u27e6X\u27e7} : (X : R\u27e6X\u27e7) \u2223 \u03c6 \u2194 constantCoeff R \u03c6 = 0 := by\n  rw [\u2190 pow_one (X : R\u27e6X\u27e7), X_pow_dvd_iff, \u2190 coeff_zero_eq_constantCoeff_apply]\n  constructor <;> intro h\n  \u00b7 exact h 0 zero_lt_one\n  \u00b7 intro m hm\n    rwa [Nat.eq_zero_of_le_zero (Nat.le_of_succ_le_succ hm)]\nset_option linter.uppercaseLean3 false in\n#align power_series.X_dvd_iff PowerSeries.X_dvd_iff\n\nend Semiring\n\nsection CommSemiring\n\nvariable [CommSemiring R]\n\nopen Finset Nat\n\n/-- The ring homomorphism taking a power series `f(X)` to `f(aX)`. -/\nnoncomputable def rescale (a : R) : R\u27e6X\u27e7 \u2192+* R\u27e6X\u27e7 where\n  toFun f := PowerSeries.mk fun n => a ^ n * PowerSeries.coeff R n f\n  map_zero' := by\n    ext\n    simp only [LinearMap.map_zero, PowerSeries.coeff_mk, mul_zero]\n  map_one' := by\n    ext1\n    simp only [mul_boole, PowerSeries.coeff_mk, PowerSeries.coeff_one]\n    split_ifs with h\n    \u00b7 rw [h, pow_zero a]\n    rfl\n  map_add' := by\n    intros\n    ext\n    dsimp only\n    exact mul_add _ _ _\n  map_mul' f g := by\n    ext\n    rw [PowerSeries.coeff_mul, PowerSeries.coeff_mk, PowerSeries.coeff_mul, Finset.mul_sum]\n    apply sum_congr rfl\n    simp only [coeff_mk, Prod.forall, mem_antidiagonal]\n    intro b c H\n    rw [\u2190 H, pow_add, mul_mul_mul_comm]\n#align power_series.rescale PowerSeries.rescale\n\n@[simp]\ntheorem coeff_rescale (f : R\u27e6X\u27e7) (a : R) (n : \u2115) :\n    coeff R n (rescale a f) = a ^ n * coeff R n f :=\n  coeff_mk n (fun n \u21a6 a ^ n * (coeff R n) f)\n#align power_series.coeff_rescale PowerSeries.coeff_rescale\n\n@[simp]\ntheorem rescale_zero : rescale 0 = (C R).comp (constantCoeff R) := by\n  ext x n\n  simp only [Function.comp_apply, RingHom.coe_comp, rescale, RingHom.coe_mk,\n    PowerSeries.coeff_mk _ _, coeff_C]\n  split_ifs with h <;> simp [h]\n#align power_series.rescale_zero PowerSeries.rescale_zero\n\ntheorem rescale_zero_apply : rescale 0 X = C R (constantCoeff R X) := by simp\n#align power_series.rescale_zero_apply PowerSeries.rescale_zero_apply\n\n@[simp]\ntheorem rescale_one : rescale 1 = RingHom.id R\u27e6X\u27e7 := by\n  ext\n  simp only [coeff_rescale, one_pow, one_mul, RingHom.id_apply]\n#align power_series.rescale_one PowerSeries.rescale_one\n\ntheorem rescale_mk (f : \u2115 \u2192 R) (a : R) : rescale a (mk f) = mk fun n : \u2115 => a ^ n * f n := by\n  ext\n  rw [coeff_rescale, coeff_mk, coeff_mk]\n#align power_series.rescale_mk PowerSeries.rescale_mk\n\ntheorem rescale_rescale (f : R\u27e6X\u27e7) (a b : R) :\n    rescale b (rescale a f) = rescale (a * b) f := by\n  ext n\n  simp_rw [coeff_rescale]\n  rw [mul_pow, mul_comm _ (b ^ n), mul_assoc]\n#align power_series.rescale_rescale PowerSeries.rescale_rescale\n\ntheorem rescale_mul (a b : R) : rescale (a * b) = (rescale b).comp (rescale a) := by\n  ext\n  simp [\u2190 rescale_rescale]\n#align power_series.rescale_mul PowerSeries.rescale_mul\n\nend CommSemiring\n\nsection CommSemiring\n\nopen Finset.HasAntidiagonal Finset\n\nvariable {R : Type*} [CommSemiring R] {\u03b9 : Type*} [DecidableEq \u03b9]\n\n/-- Coefficients of a product of power series -/\ntheorem coeff_prod (f : \u03b9 \u2192 PowerSeries R) (d : \u2115) (s : Finset \u03b9) :\n    coeff R d (\u220f j in s, f j) = \u2211 l in piAntidiagonal s d, \u220f i in s, coeff R (l i) (f i) := by\n  simp only [coeff]\n  convert MvPowerSeries.coeff_prod _ _ _\n  rw [\u2190 AddEquiv.finsuppUnique_symm d, \u2190 mapRange_piAntidiagonal_eq, sum_map, sum_congr rfl]\n  intro x _\n  apply prod_congr rfl\n  intro i _\n  congr 2\n  simp only [AddEquiv.toEquiv_eq_coe, Finsupp.mapRange.addEquiv_toEquiv, AddEquiv.toEquiv_symm,\n    Equiv.coe_toEmbedding, Finsupp.mapRange.equiv_apply, AddEquiv.coe_toEquiv_symm,\n    Finsupp.mapRange_apply, AddEquiv.finsuppUnique_symm]\n\nend CommSemiring\n\nsection CommRing\n\nvariable {A : Type*} [CommRing A]\n\ntheorem not_isField : \u00acIsField A\u27e6X\u27e7 := by\n  by_cases hA : Subsingleton A\n  \u00b7 exact not_isField_of_subsingleton _\n  \u00b7 nontriviality A\n    rw [Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top]\n    use Ideal.span {X}\n    constructor\n    \u00b7 rw [bot_lt_iff_ne_bot, Ne.def, Ideal.span_singleton_eq_bot]\n      exact X_ne_zero\n    \u00b7 rw [lt_top_iff_ne_top, Ne.def, Ideal.eq_top_iff_one, Ideal.mem_span_singleton,\n        X_dvd_iff, constantCoeff_one]\n      exact one_ne_zero\n\n@[simp]\ntheorem rescale_X (a : A) : rescale a X = C A a * X := by\n  ext\n  simp only [coeff_rescale, coeff_C_mul, coeff_X]\n  split_ifs with h <;> simp [h]\nset_option linter.uppercaseLean3 false in\n#align power_series.rescale_X PowerSeries.rescale_X\n\ntheorem rescale_neg_one_X : rescale (-1 : A) X = -X := by\n  rw [rescale_X, map_neg, map_one, neg_one_mul]\nset_option linter.uppercaseLean3 false in\n#align power_series.rescale_neg_one_X PowerSeries.rescale_neg_one_X\n\n/-- The ring homomorphism taking a power series `f(X)` to `f(-X)`. -/\nnoncomputable def evalNegHom : A\u27e6X\u27e7 \u2192+* A\u27e6X\u27e7 :=\n  rescale (-1 : A)\n#align power_series.eval_neg_hom PowerSeries.evalNegHom\n\n@[simp]\ntheorem evalNegHom_X : evalNegHom (X : A\u27e6X\u27e7) = -X :=\n  rescale_neg_one_X\nset_option linter.uppercaseLean3 false in\n#align power_series.eval_neg_hom_X PowerSeries.evalNegHom_X\n\nend CommRing\n\nsection Domain\n\nvariable [Ring R]\n\ntheorem eq_zero_or_eq_zero_of_mul_eq_zero [NoZeroDivisors R] (\u03c6 \u03c8 : R\u27e6X\u27e7) (h : \u03c6 * \u03c8 = 0) :\n    \u03c6 = 0 \u2228 \u03c8 = 0 := by\n  classical\n  rw [or_iff_not_imp_left]\n  intro H\n  have ex : \u2203 m, coeff R m \u03c6 \u2260 0 := by\n    contrapose! H\n    exact ext H\n  let m := Nat.find ex\n  have hm\u2081 : coeff R m \u03c6 \u2260 0 := Nat.find_spec ex\n  have hm\u2082 : \u2200 k < m, \u00accoeff R k \u03c6 \u2260 0 := fun k => Nat.find_min ex\n  ext n\n  rw [(coeff R n).map_zero]\n  induction' n using Nat.strong_induction_on with n ih\n  replace h := congr_arg (coeff R (m + n)) h\n  rw [LinearMap.map_zero, coeff_mul, Finset.sum_eq_single (m, n)] at h\n  \u00b7 replace h := NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero h\n    rw [or_iff_not_imp_left] at h\n    exact h hm\u2081\n  \u00b7 rintro \u27e8i, j\u27e9 hij hne\n    by_cases hj : j < n\n    \u00b7 rw [ih j hj, mul_zero]\n    by_cases hi : i < m\n    \u00b7 specialize hm\u2082 _ hi\n      push_neg at hm\u2082\n      rw [hm\u2082, zero_mul]\n    rw [mem_antidiagonal] at hij\n    push_neg at hi hj\n    suffices m < i by\n      have : m + n < i + j := add_lt_add_of_lt_of_le this hj\n      exfalso\n      exact ne_of_lt this hij.symm\n    contrapose! hne\n    obtain rfl := le_antisymm hi hne\n    simpa [Ne, Prod.mk.inj_iff] using (add_right_inj m).mp hij\n  \u00b7 contrapose!\n    intro\n    rw [mem_antidiagonal]\n#align power_series.eq_zero_or_eq_zero_of_mul_eq_zero PowerSeries.eq_zero_or_eq_zero_of_mul_eq_zero\n\ninstance [NoZeroDivisors R] : NoZeroDivisors R\u27e6X\u27e7 where\n  eq_zero_or_eq_zero_of_mul_eq_zero := eq_zero_or_eq_zero_of_mul_eq_zero _ _\n\ninstance [IsDomain R] : IsDomain R\u27e6X\u27e7 :=\n  NoZeroDivisors.to_isDomain _\n\nend Domain\n\nsection IsDomain\n\nvariable [CommRing R] [IsDomain R]\n\n/-- The ideal spanned by the variable in the power series ring\n over an integral domain is a prime ideal. -/\ntheorem span_X_isPrime : (Ideal.span ({X} : Set R\u27e6X\u27e7)).IsPrime := by\n  suffices Ideal.span ({X} : Set R\u27e6X\u27e7) = RingHom.ker (constantCoeff R) by\n    rw [this]\n    exact RingHom.ker_isPrime _\n  apply Ideal.ext\n  intro \u03c6\n  rw [RingHom.mem_ker, Ideal.mem_span_singleton, X_dvd_iff]\nset_option linter.uppercaseLean3 false in\n#align power_series.span_X_is_prime PowerSeries.span_X_isPrime\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem X_prime : Prime (X : R\u27e6X\u27e7) := by\n  rw [\u2190 Ideal.span_singleton_prime]\n  \u00b7 exact span_X_isPrime\n  \u00b7 intro h\n    simpa [map_zero (coeff R 1)] using congr_arg (coeff R 1) h\nset_option linter.uppercaseLean3 false in\n#align power_series.X_prime PowerSeries.X_prime\n\n/-- The variable of the power series ring over an integral domain is irreducible. -/\n", "theoremStatement": "theorem X_irreducible : Irreducible (X : R\u27e6X\u27e7)", "theoremName": "X_irreducible", "fileCreated": {"commit": "3d924717cd", "date": "2023-05-22"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Basic.lean", "positionMetadata": {"lineInFile": 792, "tokenPositionInFile": 27232, "theoremPositionInFile": 101}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "X_prime.irreducible", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 19}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\n\nimport Mathlib.RingTheory.PowerSeries.Basic\nimport Mathlib.Algebra.CharP.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-! # Formal power series (in one variable) - Order\n\nThe `PowerSeries.order` of a formal power series `\u03c6` is the multiplicity of the variable `X` in `\u03c6`.\n\nIf the coefficients form an integral domain, then `PowerSeries.order` is an\nadditive valuation (`PowerSeries.order_mul`, `PowerSeries.le_order_add`).\n\nWe prove that if the commutative ring `R` of coefficients is an integral domain,\nthen the ring `R\u27e6X\u27e7` of formal power series in one variable over `R`\nis an integral domain.\n\nGiven a non-zero power series `f`, `divided_by_X_pow_order f` is the power series obtained by\ndividing out the largest power of X that divides `f`, that is its order. This is useful when\nproving that `R\u27e6X\u27e7` is a normalization monoid, which is done in `PowerSeries.Inverse`.\n\n-/\nnoncomputable section\n\nopen BigOperators Polynomial\n\nopen Finset (antidiagonal mem_antidiagonal)\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection OrderBasic\n\nopen multiplicity\n\nvariable [Semiring R] {\u03c6 : R\u27e6X\u27e7}\n\ntheorem exists_coeff_ne_zero_iff_ne_zero : (\u2203 n : \u2115, coeff R n \u03c6 \u2260 0) \u2194 \u03c6 \u2260 0 := by\n  refine' not_iff_not.mp _\n  push_neg\n  -- FIXME: the `FunLike.coe` doesn't seem to be picked up in the expression after #8386?\n  simp [PowerSeries.ext_iff, (coeff R _).map_zero]\n#align power_series.exists_coeff_ne_zero_iff_ne_zero PowerSeries.exists_coeff_ne_zero_iff_ne_zero\n\n/-- The order of a formal power series `\u03c6` is the greatest `n : PartENat`\nsuch that `X^n` divides `\u03c6`. The order is `\u22a4` if and only if `\u03c6 = 0`. -/\ndef order (\u03c6 : R\u27e6X\u27e7) : PartENat :=\n  letI := Classical.decEq R\n  letI := Classical.decEq R\u27e6X\u27e7\n  if h : \u03c6 = 0 then \u22a4 else Nat.find (exists_coeff_ne_zero_iff_ne_zero.mpr h)\n#align power_series.order PowerSeries.order\n\n/-- The order of the `0` power series is infinite. -/\n@[simp]\ntheorem order_zero : order (0 : R\u27e6X\u27e7) = \u22a4 :=\n  dif_pos rfl\n#align power_series.order_zero PowerSeries.order_zero\n\ntheorem order_finite_iff_ne_zero : (order \u03c6).Dom \u2194 \u03c6 \u2260 0 := by\n  simp only [order]\n  constructor\n  \u00b7 split_ifs with h <;> intro H\n    \u00b7 simp only [PartENat.top_eq_none, Part.not_none_dom] at H\n    \u00b7 exact h\n  \u00b7 intro h\n    simp [h]\n#align power_series.order_finite_iff_ne_zero PowerSeries.order_finite_iff_ne_zero\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem coeff_order (h : (order \u03c6).Dom) : coeff R (\u03c6.order.get h) \u03c6 \u2260 0 := by\n  classical\n  simp only [order, order_finite_iff_ne_zero.mp h, not_false_iff, dif_neg, PartENat.get_natCast']\n  generalize_proofs h\n  exact Nat.find_spec h\n#align power_series.coeff_order PowerSeries.coeff_order\n\n/-- If the `n`th coefficient of a formal power series is nonzero,\nthen the order of the power series is less than or equal to `n`. -/\ntheorem order_le (n : \u2115) (h : coeff R n \u03c6 \u2260 0) : order \u03c6 \u2264 n := by\n  classical\n  rw [order, dif_neg]\n  \u00b7 simp only [PartENat.coe_le_coe]\n    exact Nat.find_le h\n  \u00b7 exact exists_coeff_ne_zero_iff_ne_zero.mp \u27e8n, h\u27e9\n#align power_series.order_le PowerSeries.order_le\n\n/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series. -/\ntheorem coeff_of_lt_order (n : \u2115) (h : \u2191n < order \u03c6) : coeff R n \u03c6 = 0 := by\n  contrapose! h\n  exact order_le _ h\n#align power_series.coeff_of_lt_order PowerSeries.coeff_of_lt_order\n\n/-- The `0` power series is the unique power series with infinite order. -/\n@[simp]\ntheorem order_eq_top {\u03c6 : R\u27e6X\u27e7} : \u03c6.order = \u22a4 \u2194 \u03c6 = 0 :=\n  PartENat.not_dom_iff_eq_top.symm.trans order_finite_iff_ne_zero.not_left\n#align power_series.order_eq_top PowerSeries.order_eq_top\n\n/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem nat_le_order (\u03c6 : R\u27e6X\u27e7) (n : \u2115) (h : \u2200 i < n, coeff R i \u03c6 = 0) : \u2191n \u2264 order \u03c6 := by\n  by_contra H; rw [not_le] at H\n  have : (order \u03c6).Dom := PartENat.dom_of_le_natCast H.le\n  rw [\u2190 PartENat.natCast_get this, PartENat.coe_lt_coe] at H\n  exact coeff_order this (h _ H)\n#align power_series.nat_le_order PowerSeries.nat_le_order\n\n/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem le_order (\u03c6 : R\u27e6X\u27e7) (n : PartENat) (h : \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0) :\n    n \u2264 order \u03c6 := by\n  induction n using PartENat.casesOn\n  \u00b7 show _ \u2264 _\n    rw [top_le_iff, order_eq_top]\n    ext i\n    exact h _ (PartENat.natCast_lt_top i)\n  \u00b7 apply nat_le_order\n    simpa only [PartENat.coe_lt_coe] using h\n#align power_series.le_order PowerSeries.le_order\n\n/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq_nat {\u03c6 : R\u27e6X\u27e7} {n : \u2115} :\n    order \u03c6 = n \u2194 coeff R n \u03c6 \u2260 0 \u2227 \u2200 i, i < n \u2192 coeff R i \u03c6 = 0 := by\n  classical\n  rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)\n  \u00b7 simpa [(coeff R _).map_zero] using (PartENat.natCast_ne_top _).symm\n  simp [order, dif_neg h\u03c6, Nat.find_eq_iff]\n#align power_series.order_eq_nat PowerSeries.order_eq_nat\n\n/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq {\u03c6 : R\u27e6X\u27e7} {n : PartENat} :\n    order \u03c6 = n \u2194 (\u2200 i : \u2115, \u2191i = n \u2192 coeff R i \u03c6 \u2260 0) \u2227 \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0 := by\n  induction n using PartENat.casesOn\n  \u00b7 rw [order_eq_top]\n    constructor\n    \u00b7 rintro rfl\n      constructor <;> intros\n      \u00b7 exfalso\n        exact PartENat.natCast_ne_top \u2039_\u203a \u2039_\u203a\n      \u00b7 exact (coeff _ _).map_zero\n    \u00b7 rintro \u27e8_h\u2081, h\u2082\u27e9\n      ext i\n      exact h\u2082 i (PartENat.natCast_lt_top i)\n  \u00b7 simpa [PartENat.natCast_inj] using order_eq_nat\n#align power_series.order_eq PowerSeries.order_eq\n\n/-- The order of the sum of two formal power series\n is at least the minimum of their orders. -/\ntheorem le_order_add (\u03c6 \u03c8 : R\u27e6X\u27e7) : min (order \u03c6) (order \u03c8) \u2264 order (\u03c6 + \u03c8) := by\n  refine' le_order _ _ _\n  simp (config := { contextual := true }) [coeff_of_lt_order]\n#align power_series.le_order_add PowerSeries.le_order_add\n\nprivate theorem order_add_of_order_eq.aux (\u03c6 \u03c8 : R\u27e6X\u27e7) (_h : order \u03c6 \u2260 order \u03c8)\n    (H : order \u03c6 < order \u03c8) : order (\u03c6 + \u03c8) \u2264 order \u03c6 \u2293 order \u03c8 := by\n  suffices order (\u03c6 + \u03c8) = order \u03c6 by\n    rw [le_inf_iff, this]\n    exact \u27e8le_rfl, le_of_lt H\u27e9\n  \u00b7 rw [order_eq]\n    constructor\n    \u00b7 intro i hi\n      rw [\u2190 hi] at H\n      rw [(coeff _ _).map_add, coeff_of_lt_order i H, add_zero]\n      exact (order_eq_nat.1 hi.symm).1\n    \u00b7 intro i hi\n      rw [(coeff _ _).map_add, coeff_of_lt_order i hi, coeff_of_lt_order i (lt_trans hi H),\n        zero_add]\n-- #align power_series.order_add_of_order_eq.aux power_series.order_add_of_order_eq.aux\n\n/-- The order of the sum of two formal power series\n is the minimum of their orders if their orders differ. -/\ntheorem order_add_of_order_eq (\u03c6 \u03c8 : R\u27e6X\u27e7) (h : order \u03c6 \u2260 order \u03c8) :\n    order (\u03c6 + \u03c8) = order \u03c6 \u2293 order \u03c8 := by\n  refine' le_antisymm _ (le_order_add _ _)\n  by_cases H\u2081 : order \u03c6 < order \u03c8\n  \u00b7 apply order_add_of_order_eq.aux _ _ h H\u2081\n  by_cases H\u2082 : order \u03c8 < order \u03c6\n  \u00b7 simpa only [add_comm, inf_comm] using order_add_of_order_eq.aux _ _ h.symm H\u2082\n  exfalso; exact h (le_antisymm (not_lt.1 H\u2082) (not_lt.1 H\u2081))\n#align power_series.order_add_of_order_eq PowerSeries.order_add_of_order_eq\n\n/-- The order of the product of two formal power series\n is at least the sum of their orders. -/\ntheorem order_mul_ge (\u03c6 \u03c8 : R\u27e6X\u27e7) : order \u03c6 + order \u03c8 \u2264 order (\u03c6 * \u03c8) := by\n  apply le_order\n  intro n hn; rw [coeff_mul, Finset.sum_eq_zero]\n  rintro \u27e8i, j\u27e9 hij\n  by_cases hi : \u2191i < order \u03c6\n  \u00b7 rw [coeff_of_lt_order i hi, zero_mul]\n  by_cases hj : \u2191j < order \u03c8\n  \u00b7 rw [coeff_of_lt_order j hj, mul_zero]\n  rw [not_lt] at hi hj; rw [mem_antidiagonal] at hij\n  exfalso\n  apply ne_of_lt (lt_of_lt_of_le hn <| add_le_add hi hj)\n  rw [\u2190 Nat.cast_add, hij]\n#align power_series.order_mul_ge PowerSeries.order_mul_ge\n\n/-- The order of the monomial `a*X^n` is infinite if `a = 0` and `n` otherwise. -/\ntheorem order_monomial (n : \u2115) (a : R) [Decidable (a = 0)] :\n    order (monomial R n a) = if a = 0 then (\u22a4 : PartENat) else n := by\n  split_ifs with h\n  \u00b7 rw [h, order_eq_top, LinearMap.map_zero]\n  \u00b7 rw [order_eq]\n    constructor <;> intro i hi\n    \u00b7 rw [PartENat.natCast_inj] at hi\n      rwa [hi, coeff_monomial_same]\n    \u00b7 rw [PartENat.coe_lt_coe] at hi\n      rw [coeff_monomial, if_neg]\n      exact ne_of_lt hi\n#align power_series.order_monomial PowerSeries.order_monomial\n\n/-- The order of the monomial `a*X^n` is `n` if `a \u2260 0`. -/\ntheorem order_monomial_of_ne_zero (n : \u2115) (a : R) (h : a \u2260 0) : order (monomial R n a) = n := by\n  classical\n  rw [order_monomial, if_neg h]\n#align power_series.order_monomial_of_ne_zero PowerSeries.order_monomial_of_ne_zero\n\n/-- If `n` is strictly smaller than the order of `\u03c8`, then the `n`th coefficient of its product\nwith any other power series is `0`. -/\ntheorem coeff_mul_of_lt_order {\u03c6 \u03c8 : R\u27e6X\u27e7} {n : \u2115} (h : \u2191n < \u03c8.order) :\n    coeff R n (\u03c6 * \u03c8) = 0 := by\n  suffices coeff R n (\u03c6 * \u03c8) = \u2211 p in antidiagonal n, 0 by rw [this, Finset.sum_const_zero]\n  rw [coeff_mul]\n  apply Finset.sum_congr rfl\n  intro x hx\n  refine' mul_eq_zero_of_right (coeff R x.fst \u03c6) (coeff_of_lt_order x.snd (lt_of_le_of_lt _ h))\n  rw [mem_antidiagonal] at hx\n  norm_cast\n  omega\n#align power_series.coeff_mul_of_lt_order PowerSeries.coeff_mul_of_lt_order\n\ntheorem coeff_mul_one_sub_of_lt_order {R : Type*} [CommRing R] {\u03c6 \u03c8 : R\u27e6X\u27e7} (n : \u2115)\n    (h : \u2191n < \u03c8.order) : coeff R n (\u03c6 * (1 - \u03c8)) = coeff R n \u03c6 := by\n  simp [coeff_mul_of_lt_order h, mul_sub]\n#align power_series.coeff_mul_one_sub_of_lt_order PowerSeries.coeff_mul_one_sub_of_lt_order\n\ntheorem coeff_mul_prod_one_sub_of_lt_order {R \u03b9 : Type*} [CommRing R] (k : \u2115) (s : Finset \u03b9)\n    (\u03c6 : R\u27e6X\u27e7) (f : \u03b9 \u2192 R\u27e6X\u27e7) :\n    (\u2200 i \u2208 s, \u2191k < (f i).order) \u2192 coeff R k (\u03c6 * \u220f i in s, (1 - f i)) = coeff R k \u03c6 := by\n  classical\n  induction' s using Finset.induction_on with a s ha ih t\n  \u00b7 simp\n  \u00b7 intro t\n    simp only [Finset.mem_insert, forall_eq_or_imp] at t\n    rw [Finset.prod_insert ha, \u2190 mul_assoc, mul_right_comm, coeff_mul_one_sub_of_lt_order _ t.1]\n    exact ih t.2\n#align power_series.coeff_mul_prod_one_sub_of_lt_order PowerSeries.coeff_mul_prod_one_sub_of_lt_order\n\n-- TODO: link with `X_pow_dvd_iff`\ntheorem X_pow_order_dvd (h : (order \u03c6).Dom) : X ^ (order \u03c6).get h \u2223 \u03c6 := by\n  refine' \u27e8PowerSeries.mk fun n => coeff R (n + (order \u03c6).get h) \u03c6, _\u27e9\n  ext n\n  simp only [coeff_mul, coeff_X_pow, coeff_mk, boole_mul, Finset.sum_ite,\n    Finset.sum_const_zero, add_zero]\n  rw [Finset.filter_fst_eq_antidiagonal n (Part.get (order \u03c6) h)]\n  split_ifs with hn\n  \u00b7 simp [tsub_add_cancel_of_le hn]\n  \u00b7 simp only [Finset.sum_empty]\n    refine' coeff_of_lt_order _ _\n    simpa [PartENat.coe_lt_iff] using fun _ => hn\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_order_dvd PowerSeries.X_pow_order_dvd\n\ntheorem order_eq_multiplicity_X {R : Type*} [Semiring R] [@DecidableRel R\u27e6X\u27e7 (\u00b7 \u2223 \u00b7)] (\u03c6 : R\u27e6X\u27e7) :\n    order \u03c6 = multiplicity X \u03c6 := by\n  classical\n  rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)\n  \u00b7 simp\n  induction' ho : order \u03c6 using PartENat.casesOn with n\n  \u00b7 simp [h\u03c6] at ho\n  have hn : \u03c6.order.get (order_finite_iff_ne_zero.mpr h\u03c6) = n := by simp [ho]\n  rw [\u2190 hn]\n  refine'\n    le_antisymm (le_multiplicity_of_pow_dvd <| X_pow_order_dvd (order_finite_iff_ne_zero.mpr h\u03c6))\n      (PartENat.find_le _ _ _)\n  rintro \u27e8\u03c8, H\u27e9\n  have := congr_arg (coeff R n) H\n  rw [\u2190 (\u03c8.commute_X.pow_right _).eq, coeff_mul_of_lt_order, \u2190 hn] at this\n  \u00b7 exact coeff_order _ this\n  \u00b7 rw [X_pow_eq, order_monomial]\n    split_ifs\n    \u00b7 exact PartENat.natCast_lt_top _\n    \u00b7 rw [\u2190 hn, PartENat.coe_lt_coe]\n      exact Nat.lt_succ_self _\nset_option linter.uppercaseLean3 false in\n#align power_series.order_eq_multiplicity_X PowerSeries.order_eq_multiplicity_X\n\n/-- Given a non-zero power series `f`, `divided_by_X_pow_order f` is the power series obtained by\n  dividing out the largest power of X that divides `f`, that is its order-/\ndef divided_by_X_pow_order {f : PowerSeries R} (hf : f \u2260 0) : R\u27e6X\u27e7 :=\n  (exists_eq_mul_right_of_dvd (X_pow_order_dvd (order_finite_iff_ne_zero.2 hf))).choose\n\n", "theoremStatement": "theorem self_eq_X_pow_order_mul_divided_by_X_pow_order {f : R\u27e6X\u27e7} (hf : f \u2260 0) :\n    X ^ f.order.get (order_finite_iff_ne_zero.mpr hf) * divided_by_X_pow_order hf = f", "theoremName": "self_eq_X_pow_order_mul_divided_by_X_pow_order", "fileCreated": {"commit": "73d45f44c3", "date": "2024-02-29"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Order.lean", "positionMetadata": {"lineInFile": 305, "tokenPositionInFile": 12453, "theoremPositionInFile": 24}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "haveI dvd := X_pow_order_dvd (order_finite_iff_ne_zero.mpr hf)\n  (exists_eq_mul_right_of_dvd dvd).choose_spec.symm", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 114}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\n\nimport Mathlib.RingTheory.PowerSeries.Basic\nimport Mathlib.Algebra.CharP.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-! # Formal power series (in one variable) - Order\n\nThe `PowerSeries.order` of a formal power series `\u03c6` is the multiplicity of the variable `X` in `\u03c6`.\n\nIf the coefficients form an integral domain, then `PowerSeries.order` is an\nadditive valuation (`PowerSeries.order_mul`, `PowerSeries.le_order_add`).\n\nWe prove that if the commutative ring `R` of coefficients is an integral domain,\nthen the ring `R\u27e6X\u27e7` of formal power series in one variable over `R`\nis an integral domain.\n\nGiven a non-zero power series `f`, `divided_by_X_pow_order f` is the power series obtained by\ndividing out the largest power of X that divides `f`, that is its order. This is useful when\nproving that `R\u27e6X\u27e7` is a normalization monoid, which is done in `PowerSeries.Inverse`.\n\n-/\nnoncomputable section\n\nopen BigOperators Polynomial\n\nopen Finset (antidiagonal mem_antidiagonal)\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection OrderBasic\n\nopen multiplicity\n\nvariable [Semiring R] {\u03c6 : R\u27e6X\u27e7}\n\ntheorem exists_coeff_ne_zero_iff_ne_zero : (\u2203 n : \u2115, coeff R n \u03c6 \u2260 0) \u2194 \u03c6 \u2260 0 := by\n  refine' not_iff_not.mp _\n  push_neg\n  -- FIXME: the `FunLike.coe` doesn't seem to be picked up in the expression after #8386?\n  simp [PowerSeries.ext_iff, (coeff R _).map_zero]\n#align power_series.exists_coeff_ne_zero_iff_ne_zero PowerSeries.exists_coeff_ne_zero_iff_ne_zero\n\n/-- The order of a formal power series `\u03c6` is the greatest `n : PartENat`\nsuch that `X^n` divides `\u03c6`. The order is `\u22a4` if and only if `\u03c6 = 0`. -/\ndef order (\u03c6 : R\u27e6X\u27e7) : PartENat :=\n  letI := Classical.decEq R\n  letI := Classical.decEq R\u27e6X\u27e7\n  if h : \u03c6 = 0 then \u22a4 else Nat.find (exists_coeff_ne_zero_iff_ne_zero.mpr h)\n#align power_series.order PowerSeries.order\n\n/-- The order of the `0` power series is infinite. -/\n@[simp]\ntheorem order_zero : order (0 : R\u27e6X\u27e7) = \u22a4 :=\n  dif_pos rfl\n#align power_series.order_zero PowerSeries.order_zero\n\ntheorem order_finite_iff_ne_zero : (order \u03c6).Dom \u2194 \u03c6 \u2260 0 := by\n  simp only [order]\n  constructor\n  \u00b7 split_ifs with h <;> intro H\n    \u00b7 simp only [PartENat.top_eq_none, Part.not_none_dom] at H\n    \u00b7 exact h\n  \u00b7 intro h\n    simp [h]\n#align power_series.order_finite_iff_ne_zero PowerSeries.order_finite_iff_ne_zero\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem coeff_order (h : (order \u03c6).Dom) : coeff R (\u03c6.order.get h) \u03c6 \u2260 0 := by\n  classical\n  simp only [order, order_finite_iff_ne_zero.mp h, not_false_iff, dif_neg, PartENat.get_natCast']\n  generalize_proofs h\n  exact Nat.find_spec h\n#align power_series.coeff_order PowerSeries.coeff_order\n\n/-- If the `n`th coefficient of a formal power series is nonzero,\nthen the order of the power series is less than or equal to `n`. -/\ntheorem order_le (n : \u2115) (h : coeff R n \u03c6 \u2260 0) : order \u03c6 \u2264 n := by\n  classical\n  rw [order, dif_neg]\n  \u00b7 simp only [PartENat.coe_le_coe]\n    exact Nat.find_le h\n  \u00b7 exact exists_coeff_ne_zero_iff_ne_zero.mp \u27e8n, h\u27e9\n#align power_series.order_le PowerSeries.order_le\n\n/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series. -/\ntheorem coeff_of_lt_order (n : \u2115) (h : \u2191n < order \u03c6) : coeff R n \u03c6 = 0 := by\n  contrapose! h\n  exact order_le _ h\n#align power_series.coeff_of_lt_order PowerSeries.coeff_of_lt_order\n\n/-- The `0` power series is the unique power series with infinite order. -/\n@[simp]\ntheorem order_eq_top {\u03c6 : R\u27e6X\u27e7} : \u03c6.order = \u22a4 \u2194 \u03c6 = 0 :=\n  PartENat.not_dom_iff_eq_top.symm.trans order_finite_iff_ne_zero.not_left\n#align power_series.order_eq_top PowerSeries.order_eq_top\n\n/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem nat_le_order (\u03c6 : R\u27e6X\u27e7) (n : \u2115) (h : \u2200 i < n, coeff R i \u03c6 = 0) : \u2191n \u2264 order \u03c6 := by\n  by_contra H; rw [not_le] at H\n  have : (order \u03c6).Dom := PartENat.dom_of_le_natCast H.le\n  rw [\u2190 PartENat.natCast_get this, PartENat.coe_lt_coe] at H\n  exact coeff_order this (h _ H)\n#align power_series.nat_le_order PowerSeries.nat_le_order\n\n/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem le_order (\u03c6 : R\u27e6X\u27e7) (n : PartENat) (h : \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0) :\n    n \u2264 order \u03c6 := by\n  induction n using PartENat.casesOn\n  \u00b7 show _ \u2264 _\n    rw [top_le_iff, order_eq_top]\n    ext i\n    exact h _ (PartENat.natCast_lt_top i)\n  \u00b7 apply nat_le_order\n    simpa only [PartENat.coe_lt_coe] using h\n#align power_series.le_order PowerSeries.le_order\n\n/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq_nat {\u03c6 : R\u27e6X\u27e7} {n : \u2115} :\n    order \u03c6 = n \u2194 coeff R n \u03c6 \u2260 0 \u2227 \u2200 i, i < n \u2192 coeff R i \u03c6 = 0 := by\n  classical\n  rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)\n  \u00b7 simpa [(coeff R _).map_zero] using (PartENat.natCast_ne_top _).symm\n  simp [order, dif_neg h\u03c6, Nat.find_eq_iff]\n#align power_series.order_eq_nat PowerSeries.order_eq_nat\n\n/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq {\u03c6 : R\u27e6X\u27e7} {n : PartENat} :\n    order \u03c6 = n \u2194 (\u2200 i : \u2115, \u2191i = n \u2192 coeff R i \u03c6 \u2260 0) \u2227 \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0 := by\n  induction n using PartENat.casesOn\n  \u00b7 rw [order_eq_top]\n    constructor\n    \u00b7 rintro rfl\n      constructor <;> intros\n      \u00b7 exfalso\n        exact PartENat.natCast_ne_top \u2039_\u203a \u2039_\u203a\n      \u00b7 exact (coeff _ _).map_zero\n    \u00b7 rintro \u27e8_h\u2081, h\u2082\u27e9\n      ext i\n      exact h\u2082 i (PartENat.natCast_lt_top i)\n  \u00b7 simpa [PartENat.natCast_inj] using order_eq_nat\n#align power_series.order_eq PowerSeries.order_eq\n\n/-- The order of the sum of two formal power series\n is at least the minimum of their orders. -/\ntheorem le_order_add (\u03c6 \u03c8 : R\u27e6X\u27e7) : min (order \u03c6) (order \u03c8) \u2264 order (\u03c6 + \u03c8) := by\n  refine' le_order _ _ _\n  simp (config := { contextual := true }) [coeff_of_lt_order]\n#align power_series.le_order_add PowerSeries.le_order_add\n\nprivate theorem order_add_of_order_eq.aux (\u03c6 \u03c8 : R\u27e6X\u27e7) (_h : order \u03c6 \u2260 order \u03c8)\n    (H : order \u03c6 < order \u03c8) : order (\u03c6 + \u03c8) \u2264 order \u03c6 \u2293 order \u03c8 := by\n  suffices order (\u03c6 + \u03c8) = order \u03c6 by\n    rw [le_inf_iff, this]\n    exact \u27e8le_rfl, le_of_lt H\u27e9\n  \u00b7 rw [order_eq]\n    constructor\n    \u00b7 intro i hi\n      rw [\u2190 hi] at H\n      rw [(coeff _ _).map_add, coeff_of_lt_order i H, add_zero]\n      exact (order_eq_nat.1 hi.symm).1\n    \u00b7 intro i hi\n      rw [(coeff _ _).map_add, coeff_of_lt_order i hi, coeff_of_lt_order i (lt_trans hi H),\n        zero_add]\n-- #align power_series.order_add_of_order_eq.aux power_series.order_add_of_order_eq.aux\n\n/-- The order of the sum of two formal power series\n is the minimum of their orders if their orders differ. -/\ntheorem order_add_of_order_eq (\u03c6 \u03c8 : R\u27e6X\u27e7) (h : order \u03c6 \u2260 order \u03c8) :\n    order (\u03c6 + \u03c8) = order \u03c6 \u2293 order \u03c8 := by\n  refine' le_antisymm _ (le_order_add _ _)\n  by_cases H\u2081 : order \u03c6 < order \u03c8\n  \u00b7 apply order_add_of_order_eq.aux _ _ h H\u2081\n  by_cases H\u2082 : order \u03c8 < order \u03c6\n  \u00b7 simpa only [add_comm, inf_comm] using order_add_of_order_eq.aux _ _ h.symm H\u2082\n  exfalso; exact h (le_antisymm (not_lt.1 H\u2082) (not_lt.1 H\u2081))\n#align power_series.order_add_of_order_eq PowerSeries.order_add_of_order_eq\n\n/-- The order of the product of two formal power series\n is at least the sum of their orders. -/\ntheorem order_mul_ge (\u03c6 \u03c8 : R\u27e6X\u27e7) : order \u03c6 + order \u03c8 \u2264 order (\u03c6 * \u03c8) := by\n  apply le_order\n  intro n hn; rw [coeff_mul, Finset.sum_eq_zero]\n  rintro \u27e8i, j\u27e9 hij\n  by_cases hi : \u2191i < order \u03c6\n  \u00b7 rw [coeff_of_lt_order i hi, zero_mul]\n  by_cases hj : \u2191j < order \u03c8\n  \u00b7 rw [coeff_of_lt_order j hj, mul_zero]\n  rw [not_lt] at hi hj; rw [mem_antidiagonal] at hij\n  exfalso\n  apply ne_of_lt (lt_of_lt_of_le hn <| add_le_add hi hj)\n  rw [\u2190 Nat.cast_add, hij]\n#align power_series.order_mul_ge PowerSeries.order_mul_ge\n\n/-- The order of the monomial `a*X^n` is infinite if `a = 0` and `n` otherwise. -/\ntheorem order_monomial (n : \u2115) (a : R) [Decidable (a = 0)] :\n    order (monomial R n a) = if a = 0 then (\u22a4 : PartENat) else n := by\n  split_ifs with h\n  \u00b7 rw [h, order_eq_top, LinearMap.map_zero]\n  \u00b7 rw [order_eq]\n    constructor <;> intro i hi\n    \u00b7 rw [PartENat.natCast_inj] at hi\n      rwa [hi, coeff_monomial_same]\n    \u00b7 rw [PartENat.coe_lt_coe] at hi\n      rw [coeff_monomial, if_neg]\n      exact ne_of_lt hi\n#align power_series.order_monomial PowerSeries.order_monomial\n\n/-- The order of the monomial `a*X^n` is `n` if `a \u2260 0`. -/\ntheorem order_monomial_of_ne_zero (n : \u2115) (a : R) (h : a \u2260 0) : order (monomial R n a) = n := by\n  classical\n  rw [order_monomial, if_neg h]\n#align power_series.order_monomial_of_ne_zero PowerSeries.order_monomial_of_ne_zero\n\n/-- If `n` is strictly smaller than the order of `\u03c8`, then the `n`th coefficient of its product\nwith any other power series is `0`. -/\ntheorem coeff_mul_of_lt_order {\u03c6 \u03c8 : R\u27e6X\u27e7} {n : \u2115} (h : \u2191n < \u03c8.order) :\n    coeff R n (\u03c6 * \u03c8) = 0 := by\n  suffices coeff R n (\u03c6 * \u03c8) = \u2211 p in antidiagonal n, 0 by rw [this, Finset.sum_const_zero]\n  rw [coeff_mul]\n  apply Finset.sum_congr rfl\n  intro x hx\n  refine' mul_eq_zero_of_right (coeff R x.fst \u03c6) (coeff_of_lt_order x.snd (lt_of_le_of_lt _ h))\n  rw [mem_antidiagonal] at hx\n  norm_cast\n  omega\n#align power_series.coeff_mul_of_lt_order PowerSeries.coeff_mul_of_lt_order\n\ntheorem coeff_mul_one_sub_of_lt_order {R : Type*} [CommRing R] {\u03c6 \u03c8 : R\u27e6X\u27e7} (n : \u2115)\n    (h : \u2191n < \u03c8.order) : coeff R n (\u03c6 * (1 - \u03c8)) = coeff R n \u03c6 := by\n  simp [coeff_mul_of_lt_order h, mul_sub]\n#align power_series.coeff_mul_one_sub_of_lt_order PowerSeries.coeff_mul_one_sub_of_lt_order\n\ntheorem coeff_mul_prod_one_sub_of_lt_order {R \u03b9 : Type*} [CommRing R] (k : \u2115) (s : Finset \u03b9)\n    (\u03c6 : R\u27e6X\u27e7) (f : \u03b9 \u2192 R\u27e6X\u27e7) :\n    (\u2200 i \u2208 s, \u2191k < (f i).order) \u2192 coeff R k (\u03c6 * \u220f i in s, (1 - f i)) = coeff R k \u03c6 := by\n  classical\n  induction' s using Finset.induction_on with a s ha ih t\n  \u00b7 simp\n  \u00b7 intro t\n    simp only [Finset.mem_insert, forall_eq_or_imp] at t\n    rw [Finset.prod_insert ha, \u2190 mul_assoc, mul_right_comm, coeff_mul_one_sub_of_lt_order _ t.1]\n    exact ih t.2\n#align power_series.coeff_mul_prod_one_sub_of_lt_order PowerSeries.coeff_mul_prod_one_sub_of_lt_order\n\n-- TODO: link with `X_pow_dvd_iff`\ntheorem X_pow_order_dvd (h : (order \u03c6).Dom) : X ^ (order \u03c6).get h \u2223 \u03c6 := by\n  refine' \u27e8PowerSeries.mk fun n => coeff R (n + (order \u03c6).get h) \u03c6, _\u27e9\n  ext n\n  simp only [coeff_mul, coeff_X_pow, coeff_mk, boole_mul, Finset.sum_ite,\n    Finset.sum_const_zero, add_zero]\n  rw [Finset.filter_fst_eq_antidiagonal n (Part.get (order \u03c6) h)]\n  split_ifs with hn\n  \u00b7 simp [tsub_add_cancel_of_le hn]\n  \u00b7 simp only [Finset.sum_empty]\n    refine' coeff_of_lt_order _ _\n    simpa [PartENat.coe_lt_iff] using fun _ => hn\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_order_dvd PowerSeries.X_pow_order_dvd\n\ntheorem order_eq_multiplicity_X {R : Type*} [Semiring R] [@DecidableRel R\u27e6X\u27e7 (\u00b7 \u2223 \u00b7)] (\u03c6 : R\u27e6X\u27e7) :\n    order \u03c6 = multiplicity X \u03c6 := by\n  classical\n  rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)\n  \u00b7 simp\n  induction' ho : order \u03c6 using PartENat.casesOn with n\n  \u00b7 simp [h\u03c6] at ho\n  have hn : \u03c6.order.get (order_finite_iff_ne_zero.mpr h\u03c6) = n := by simp [ho]\n  rw [\u2190 hn]\n  refine'\n    le_antisymm (le_multiplicity_of_pow_dvd <| X_pow_order_dvd (order_finite_iff_ne_zero.mpr h\u03c6))\n      (PartENat.find_le _ _ _)\n  rintro \u27e8\u03c8, H\u27e9\n  have := congr_arg (coeff R n) H\n  rw [\u2190 (\u03c8.commute_X.pow_right _).eq, coeff_mul_of_lt_order, \u2190 hn] at this\n  \u00b7 exact coeff_order _ this\n  \u00b7 rw [X_pow_eq, order_monomial]\n    split_ifs\n    \u00b7 exact PartENat.natCast_lt_top _\n    \u00b7 rw [\u2190 hn, PartENat.coe_lt_coe]\n      exact Nat.lt_succ_self _\nset_option linter.uppercaseLean3 false in\n#align power_series.order_eq_multiplicity_X PowerSeries.order_eq_multiplicity_X\n\n/-- Given a non-zero power series `f`, `divided_by_X_pow_order f` is the power series obtained by\n  dividing out the largest power of X that divides `f`, that is its order-/\ndef divided_by_X_pow_order {f : PowerSeries R} (hf : f \u2260 0) : R\u27e6X\u27e7 :=\n  (exists_eq_mul_right_of_dvd (X_pow_order_dvd (order_finite_iff_ne_zero.2 hf))).choose\n\ntheorem self_eq_X_pow_order_mul_divided_by_X_pow_order {f : R\u27e6X\u27e7} (hf : f \u2260 0) :\n    X ^ f.order.get (order_finite_iff_ne_zero.mpr hf) * divided_by_X_pow_order hf = f :=\n  haveI dvd := X_pow_order_dvd (order_finite_iff_ne_zero.mpr hf)\n  (exists_eq_mul_right_of_dvd dvd).choose_spec.symm\n\nend OrderBasic\n\nsection OrderZeroNeOne\n\nvariable [Semiring R] [Nontrivial R]\n\n/-- The order of the formal power series `1` is `0`. -/\n@[simp]\ntheorem order_one : order (1 : R\u27e6X\u27e7) = 0 := by\n  simpa using order_monomial_of_ne_zero 0 (1 : R) one_ne_zero\n#align power_series.order_one PowerSeries.order_one\n\n/-- The order of an invertible power series is `0`. -/\n", "theoremStatement": "theorem order_zero_of_unit {f : PowerSeries R} : IsUnit f \u2192 f.order = 0", "theoremName": "order_zero_of_unit", "fileCreated": {"commit": "73d45f44c3", "date": "2024-02-29"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Order.lean", "positionMetadata": {"lineInFile": 323, "tokenPositionInFile": 13100, "theoremPositionInFile": 26}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rintro \u27e8\u27e8u, v, hu, hv\u27e9, hf\u27e9\n  apply And.left\n  rw [\u2190 add_eq_zero_iff, \u2190 hf, \u2190 nonpos_iff_eq_zero, \u2190 @order_one R _ _, \u2190 hu]\n  exact order_mul_ge _ _", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 153}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\n\nimport Mathlib.RingTheory.PowerSeries.Basic\nimport Mathlib.Algebra.CharP.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-! # Formal power series (in one variable) - Order\n\nThe `PowerSeries.order` of a formal power series `\u03c6` is the multiplicity of the variable `X` in `\u03c6`.\n\nIf the coefficients form an integral domain, then `PowerSeries.order` is an\nadditive valuation (`PowerSeries.order_mul`, `PowerSeries.le_order_add`).\n\nWe prove that if the commutative ring `R` of coefficients is an integral domain,\nthen the ring `R\u27e6X\u27e7` of formal power series in one variable over `R`\nis an integral domain.\n\nGiven a non-zero power series `f`, `divided_by_X_pow_order f` is the power series obtained by\ndividing out the largest power of X that divides `f`, that is its order. This is useful when\nproving that `R\u27e6X\u27e7` is a normalization monoid, which is done in `PowerSeries.Inverse`.\n\n-/\nnoncomputable section\n\nopen BigOperators Polynomial\n\nopen Finset (antidiagonal mem_antidiagonal)\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection OrderBasic\n\nopen multiplicity\n\nvariable [Semiring R] {\u03c6 : R\u27e6X\u27e7}\n\ntheorem exists_coeff_ne_zero_iff_ne_zero : (\u2203 n : \u2115, coeff R n \u03c6 \u2260 0) \u2194 \u03c6 \u2260 0 := by\n  refine' not_iff_not.mp _\n  push_neg\n  -- FIXME: the `FunLike.coe` doesn't seem to be picked up in the expression after #8386?\n  simp [PowerSeries.ext_iff, (coeff R _).map_zero]\n#align power_series.exists_coeff_ne_zero_iff_ne_zero PowerSeries.exists_coeff_ne_zero_iff_ne_zero\n\n/-- The order of a formal power series `\u03c6` is the greatest `n : PartENat`\nsuch that `X^n` divides `\u03c6`. The order is `\u22a4` if and only if `\u03c6 = 0`. -/\ndef order (\u03c6 : R\u27e6X\u27e7) : PartENat :=\n  letI := Classical.decEq R\n  letI := Classical.decEq R\u27e6X\u27e7\n  if h : \u03c6 = 0 then \u22a4 else Nat.find (exists_coeff_ne_zero_iff_ne_zero.mpr h)\n#align power_series.order PowerSeries.order\n\n/-- The order of the `0` power series is infinite. -/\n@[simp]\ntheorem order_zero : order (0 : R\u27e6X\u27e7) = \u22a4 :=\n  dif_pos rfl\n#align power_series.order_zero PowerSeries.order_zero\n\ntheorem order_finite_iff_ne_zero : (order \u03c6).Dom \u2194 \u03c6 \u2260 0 := by\n  simp only [order]\n  constructor\n  \u00b7 split_ifs with h <;> intro H\n    \u00b7 simp only [PartENat.top_eq_none, Part.not_none_dom] at H\n    \u00b7 exact h\n  \u00b7 intro h\n    simp [h]\n#align power_series.order_finite_iff_ne_zero PowerSeries.order_finite_iff_ne_zero\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem coeff_order (h : (order \u03c6).Dom) : coeff R (\u03c6.order.get h) \u03c6 \u2260 0 := by\n  classical\n  simp only [order, order_finite_iff_ne_zero.mp h, not_false_iff, dif_neg, PartENat.get_natCast']\n  generalize_proofs h\n  exact Nat.find_spec h\n#align power_series.coeff_order PowerSeries.coeff_order\n\n/-- If the `n`th coefficient of a formal power series is nonzero,\nthen the order of the power series is less than or equal to `n`. -/\ntheorem order_le (n : \u2115) (h : coeff R n \u03c6 \u2260 0) : order \u03c6 \u2264 n := by\n  classical\n  rw [order, dif_neg]\n  \u00b7 simp only [PartENat.coe_le_coe]\n    exact Nat.find_le h\n  \u00b7 exact exists_coeff_ne_zero_iff_ne_zero.mp \u27e8n, h\u27e9\n#align power_series.order_le PowerSeries.order_le\n\n/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series. -/\ntheorem coeff_of_lt_order (n : \u2115) (h : \u2191n < order \u03c6) : coeff R n \u03c6 = 0 := by\n  contrapose! h\n  exact order_le _ h\n#align power_series.coeff_of_lt_order PowerSeries.coeff_of_lt_order\n\n/-- The `0` power series is the unique power series with infinite order. -/\n@[simp]\ntheorem order_eq_top {\u03c6 : R\u27e6X\u27e7} : \u03c6.order = \u22a4 \u2194 \u03c6 = 0 :=\n  PartENat.not_dom_iff_eq_top.symm.trans order_finite_iff_ne_zero.not_left\n#align power_series.order_eq_top PowerSeries.order_eq_top\n\n/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem nat_le_order (\u03c6 : R\u27e6X\u27e7) (n : \u2115) (h : \u2200 i < n, coeff R i \u03c6 = 0) : \u2191n \u2264 order \u03c6 := by\n  by_contra H; rw [not_le] at H\n  have : (order \u03c6).Dom := PartENat.dom_of_le_natCast H.le\n  rw [\u2190 PartENat.natCast_get this, PartENat.coe_lt_coe] at H\n  exact coeff_order this (h _ H)\n#align power_series.nat_le_order PowerSeries.nat_le_order\n\n/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem le_order (\u03c6 : R\u27e6X\u27e7) (n : PartENat) (h : \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0) :\n    n \u2264 order \u03c6 := by\n  induction n using PartENat.casesOn\n  \u00b7 show _ \u2264 _\n    rw [top_le_iff, order_eq_top]\n    ext i\n    exact h _ (PartENat.natCast_lt_top i)\n  \u00b7 apply nat_le_order\n    simpa only [PartENat.coe_lt_coe] using h\n#align power_series.le_order PowerSeries.le_order\n\n/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq_nat {\u03c6 : R\u27e6X\u27e7} {n : \u2115} :\n    order \u03c6 = n \u2194 coeff R n \u03c6 \u2260 0 \u2227 \u2200 i, i < n \u2192 coeff R i \u03c6 = 0 := by\n  classical\n  rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)\n  \u00b7 simpa [(coeff R _).map_zero] using (PartENat.natCast_ne_top _).symm\n  simp [order, dif_neg h\u03c6, Nat.find_eq_iff]\n#align power_series.order_eq_nat PowerSeries.order_eq_nat\n\n/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq {\u03c6 : R\u27e6X\u27e7} {n : PartENat} :\n    order \u03c6 = n \u2194 (\u2200 i : \u2115, \u2191i = n \u2192 coeff R i \u03c6 \u2260 0) \u2227 \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0 := by\n  induction n using PartENat.casesOn\n  \u00b7 rw [order_eq_top]\n    constructor\n    \u00b7 rintro rfl\n      constructor <;> intros\n      \u00b7 exfalso\n        exact PartENat.natCast_ne_top \u2039_\u203a \u2039_\u203a\n      \u00b7 exact (coeff _ _).map_zero\n    \u00b7 rintro \u27e8_h\u2081, h\u2082\u27e9\n      ext i\n      exact h\u2082 i (PartENat.natCast_lt_top i)\n  \u00b7 simpa [PartENat.natCast_inj] using order_eq_nat\n#align power_series.order_eq PowerSeries.order_eq\n\n/-- The order of the sum of two formal power series\n is at least the minimum of their orders. -/\ntheorem le_order_add (\u03c6 \u03c8 : R\u27e6X\u27e7) : min (order \u03c6) (order \u03c8) \u2264 order (\u03c6 + \u03c8) := by\n  refine' le_order _ _ _\n  simp (config := { contextual := true }) [coeff_of_lt_order]\n#align power_series.le_order_add PowerSeries.le_order_add\n\nprivate theorem order_add_of_order_eq.aux (\u03c6 \u03c8 : R\u27e6X\u27e7) (_h : order \u03c6 \u2260 order \u03c8)\n    (H : order \u03c6 < order \u03c8) : order (\u03c6 + \u03c8) \u2264 order \u03c6 \u2293 order \u03c8 := by\n  suffices order (\u03c6 + \u03c8) = order \u03c6 by\n    rw [le_inf_iff, this]\n    exact \u27e8le_rfl, le_of_lt H\u27e9\n  \u00b7 rw [order_eq]\n    constructor\n    \u00b7 intro i hi\n      rw [\u2190 hi] at H\n      rw [(coeff _ _).map_add, coeff_of_lt_order i H, add_zero]\n      exact (order_eq_nat.1 hi.symm).1\n    \u00b7 intro i hi\n      rw [(coeff _ _).map_add, coeff_of_lt_order i hi, coeff_of_lt_order i (lt_trans hi H),\n        zero_add]\n-- #align power_series.order_add_of_order_eq.aux power_series.order_add_of_order_eq.aux\n\n/-- The order of the sum of two formal power series\n is the minimum of their orders if their orders differ. -/\ntheorem order_add_of_order_eq (\u03c6 \u03c8 : R\u27e6X\u27e7) (h : order \u03c6 \u2260 order \u03c8) :\n    order (\u03c6 + \u03c8) = order \u03c6 \u2293 order \u03c8 := by\n  refine' le_antisymm _ (le_order_add _ _)\n  by_cases H\u2081 : order \u03c6 < order \u03c8\n  \u00b7 apply order_add_of_order_eq.aux _ _ h H\u2081\n  by_cases H\u2082 : order \u03c8 < order \u03c6\n  \u00b7 simpa only [add_comm, inf_comm] using order_add_of_order_eq.aux _ _ h.symm H\u2082\n  exfalso; exact h (le_antisymm (not_lt.1 H\u2082) (not_lt.1 H\u2081))\n#align power_series.order_add_of_order_eq PowerSeries.order_add_of_order_eq\n\n/-- The order of the product of two formal power series\n is at least the sum of their orders. -/\ntheorem order_mul_ge (\u03c6 \u03c8 : R\u27e6X\u27e7) : order \u03c6 + order \u03c8 \u2264 order (\u03c6 * \u03c8) := by\n  apply le_order\n  intro n hn; rw [coeff_mul, Finset.sum_eq_zero]\n  rintro \u27e8i, j\u27e9 hij\n  by_cases hi : \u2191i < order \u03c6\n  \u00b7 rw [coeff_of_lt_order i hi, zero_mul]\n  by_cases hj : \u2191j < order \u03c8\n  \u00b7 rw [coeff_of_lt_order j hj, mul_zero]\n  rw [not_lt] at hi hj; rw [mem_antidiagonal] at hij\n  exfalso\n  apply ne_of_lt (lt_of_lt_of_le hn <| add_le_add hi hj)\n  rw [\u2190 Nat.cast_add, hij]\n#align power_series.order_mul_ge PowerSeries.order_mul_ge\n\n/-- The order of the monomial `a*X^n` is infinite if `a = 0` and `n` otherwise. -/\ntheorem order_monomial (n : \u2115) (a : R) [Decidable (a = 0)] :\n    order (monomial R n a) = if a = 0 then (\u22a4 : PartENat) else n := by\n  split_ifs with h\n  \u00b7 rw [h, order_eq_top, LinearMap.map_zero]\n  \u00b7 rw [order_eq]\n    constructor <;> intro i hi\n    \u00b7 rw [PartENat.natCast_inj] at hi\n      rwa [hi, coeff_monomial_same]\n    \u00b7 rw [PartENat.coe_lt_coe] at hi\n      rw [coeff_monomial, if_neg]\n      exact ne_of_lt hi\n#align power_series.order_monomial PowerSeries.order_monomial\n\n/-- The order of the monomial `a*X^n` is `n` if `a \u2260 0`. -/\ntheorem order_monomial_of_ne_zero (n : \u2115) (a : R) (h : a \u2260 0) : order (monomial R n a) = n := by\n  classical\n  rw [order_monomial, if_neg h]\n#align power_series.order_monomial_of_ne_zero PowerSeries.order_monomial_of_ne_zero\n\n/-- If `n` is strictly smaller than the order of `\u03c8`, then the `n`th coefficient of its product\nwith any other power series is `0`. -/\ntheorem coeff_mul_of_lt_order {\u03c6 \u03c8 : R\u27e6X\u27e7} {n : \u2115} (h : \u2191n < \u03c8.order) :\n    coeff R n (\u03c6 * \u03c8) = 0 := by\n  suffices coeff R n (\u03c6 * \u03c8) = \u2211 p in antidiagonal n, 0 by rw [this, Finset.sum_const_zero]\n  rw [coeff_mul]\n  apply Finset.sum_congr rfl\n  intro x hx\n  refine' mul_eq_zero_of_right (coeff R x.fst \u03c6) (coeff_of_lt_order x.snd (lt_of_le_of_lt _ h))\n  rw [mem_antidiagonal] at hx\n  norm_cast\n  omega\n#align power_series.coeff_mul_of_lt_order PowerSeries.coeff_mul_of_lt_order\n\ntheorem coeff_mul_one_sub_of_lt_order {R : Type*} [CommRing R] {\u03c6 \u03c8 : R\u27e6X\u27e7} (n : \u2115)\n    (h : \u2191n < \u03c8.order) : coeff R n (\u03c6 * (1 - \u03c8)) = coeff R n \u03c6 := by\n  simp [coeff_mul_of_lt_order h, mul_sub]\n#align power_series.coeff_mul_one_sub_of_lt_order PowerSeries.coeff_mul_one_sub_of_lt_order\n\ntheorem coeff_mul_prod_one_sub_of_lt_order {R \u03b9 : Type*} [CommRing R] (k : \u2115) (s : Finset \u03b9)\n    (\u03c6 : R\u27e6X\u27e7) (f : \u03b9 \u2192 R\u27e6X\u27e7) :\n    (\u2200 i \u2208 s, \u2191k < (f i).order) \u2192 coeff R k (\u03c6 * \u220f i in s, (1 - f i)) = coeff R k \u03c6 := by\n  classical\n  induction' s using Finset.induction_on with a s ha ih t\n  \u00b7 simp\n  \u00b7 intro t\n    simp only [Finset.mem_insert, forall_eq_or_imp] at t\n    rw [Finset.prod_insert ha, \u2190 mul_assoc, mul_right_comm, coeff_mul_one_sub_of_lt_order _ t.1]\n    exact ih t.2\n#align power_series.coeff_mul_prod_one_sub_of_lt_order PowerSeries.coeff_mul_prod_one_sub_of_lt_order\n\n-- TODO: link with `X_pow_dvd_iff`\ntheorem X_pow_order_dvd (h : (order \u03c6).Dom) : X ^ (order \u03c6).get h \u2223 \u03c6 := by\n  refine' \u27e8PowerSeries.mk fun n => coeff R (n + (order \u03c6).get h) \u03c6, _\u27e9\n  ext n\n  simp only [coeff_mul, coeff_X_pow, coeff_mk, boole_mul, Finset.sum_ite,\n    Finset.sum_const_zero, add_zero]\n  rw [Finset.filter_fst_eq_antidiagonal n (Part.get (order \u03c6) h)]\n  split_ifs with hn\n  \u00b7 simp [tsub_add_cancel_of_le hn]\n  \u00b7 simp only [Finset.sum_empty]\n    refine' coeff_of_lt_order _ _\n    simpa [PartENat.coe_lt_iff] using fun _ => hn\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_order_dvd PowerSeries.X_pow_order_dvd\n\ntheorem order_eq_multiplicity_X {R : Type*} [Semiring R] [@DecidableRel R\u27e6X\u27e7 (\u00b7 \u2223 \u00b7)] (\u03c6 : R\u27e6X\u27e7) :\n    order \u03c6 = multiplicity X \u03c6 := by\n  classical\n  rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)\n  \u00b7 simp\n  induction' ho : order \u03c6 using PartENat.casesOn with n\n  \u00b7 simp [h\u03c6] at ho\n  have hn : \u03c6.order.get (order_finite_iff_ne_zero.mpr h\u03c6) = n := by simp [ho]\n  rw [\u2190 hn]\n  refine'\n    le_antisymm (le_multiplicity_of_pow_dvd <| X_pow_order_dvd (order_finite_iff_ne_zero.mpr h\u03c6))\n      (PartENat.find_le _ _ _)\n  rintro \u27e8\u03c8, H\u27e9\n  have := congr_arg (coeff R n) H\n  rw [\u2190 (\u03c8.commute_X.pow_right _).eq, coeff_mul_of_lt_order, \u2190 hn] at this\n  \u00b7 exact coeff_order _ this\n  \u00b7 rw [X_pow_eq, order_monomial]\n    split_ifs\n    \u00b7 exact PartENat.natCast_lt_top _\n    \u00b7 rw [\u2190 hn, PartENat.coe_lt_coe]\n      exact Nat.lt_succ_self _\nset_option linter.uppercaseLean3 false in\n#align power_series.order_eq_multiplicity_X PowerSeries.order_eq_multiplicity_X\n\n/-- Given a non-zero power series `f`, `divided_by_X_pow_order f` is the power series obtained by\n  dividing out the largest power of X that divides `f`, that is its order-/\ndef divided_by_X_pow_order {f : PowerSeries R} (hf : f \u2260 0) : R\u27e6X\u27e7 :=\n  (exists_eq_mul_right_of_dvd (X_pow_order_dvd (order_finite_iff_ne_zero.2 hf))).choose\n\ntheorem self_eq_X_pow_order_mul_divided_by_X_pow_order {f : R\u27e6X\u27e7} (hf : f \u2260 0) :\n    X ^ f.order.get (order_finite_iff_ne_zero.mpr hf) * divided_by_X_pow_order hf = f :=\n  haveI dvd := X_pow_order_dvd (order_finite_iff_ne_zero.mpr hf)\n  (exists_eq_mul_right_of_dvd dvd).choose_spec.symm\n\nend OrderBasic\n\nsection OrderZeroNeOne\n\nvariable [Semiring R] [Nontrivial R]\n\n/-- The order of the formal power series `1` is `0`. -/\n@[simp]\ntheorem order_one : order (1 : R\u27e6X\u27e7) = 0 := by\n  simpa using order_monomial_of_ne_zero 0 (1 : R) one_ne_zero\n#align power_series.order_one PowerSeries.order_one\n\n/-- The order of an invertible power series is `0`. -/\ntheorem order_zero_of_unit {f : PowerSeries R} : IsUnit f \u2192 f.order = 0 := by\n  rintro \u27e8\u27e8u, v, hu, hv\u27e9, hf\u27e9\n  apply And.left\n  rw [\u2190 add_eq_zero_iff, \u2190 hf, \u2190 nonpos_iff_eq_zero, \u2190 @order_one R _ _, \u2190 hu]\n  exact order_mul_ge _ _\n\n/-- The order of the formal power series `X` is `1`. -/\n@[simp]\ntheorem order_X : order (X : R\u27e6X\u27e7) = 1 := by\n  simpa only [Nat.cast_one] using order_monomial_of_ne_zero 1 (1 : R) one_ne_zero\nset_option linter.uppercaseLean3 false in\n#align power_series.order_X PowerSeries.order_X\n\n/-- The order of the formal power series `X^n` is `n`. -/\n@[simp]\ntheorem order_X_pow (n : \u2115) : order ((X : R\u27e6X\u27e7) ^ n) = n := by\n  rw [X_pow_eq, order_monomial_of_ne_zero]\n  exact one_ne_zero\nset_option linter.uppercaseLean3 false in\n#align power_series.order_X_pow PowerSeries.order_X_pow\n\nend OrderZeroNeOne\n\nsection OrderIsDomain\n\n-- TODO: generalize to `[Semiring R] [NoZeroDivisors R]`\nvariable [CommRing R] [IsDomain R]\n\n/-- The order of the product of two formal power series over an integral domain\n is the sum of their orders. -/\ntheorem order_mul (\u03c6 \u03c8 : R\u27e6X\u27e7) : order (\u03c6 * \u03c8) = order \u03c6 + order \u03c8 := by\n  classical\n  simp_rw [order_eq_multiplicity_X]\n  exact multiplicity.mul X_prime\n#align power_series.order_mul PowerSeries.order_mul\n\n-- Dividing `X` by the maximal power of `X` dividing it leaves `1`.\n", "theoremStatement": "@[simp]\ntheorem divided_by_X_pow_order_of_X_eq_one : divided_by_X_pow_order X_ne_zero = (1 : R\u27e6X\u27e7)", "theoremName": "divided_by_X_pow_order_of_X_eq_one", "fileCreated": {"commit": "73d45f44c3", "date": "2024-02-29"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Order.lean", "positionMetadata": {"lineInFile": 360, "tokenPositionInFile": 14426, "theoremPositionInFile": 30}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [\u2190 mul_eq_left\u2080 X_ne_zero]\n  simpa only [order_X, X_ne_zero, PartENat.get_one, pow_one, Ne.def,\n    not_false_iff] using self_eq_X_pow_order_mul_divided_by_X_pow_order (@X_ne_zero R _ _)", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 194}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n-/\n\nimport Mathlib.RingTheory.PowerSeries.Basic\nimport Mathlib.Algebra.CharP.Basic\n\n#align_import ring_theory.power_series.basic from \"leanprover-community/mathlib\"@\"2d5739b61641ee4e7e53eca5688a08f66f2e6a60\"\n\n/-! # Formal power series (in one variable) - Order\n\nThe `PowerSeries.order` of a formal power series `\u03c6` is the multiplicity of the variable `X` in `\u03c6`.\n\nIf the coefficients form an integral domain, then `PowerSeries.order` is an\nadditive valuation (`PowerSeries.order_mul`, `PowerSeries.le_order_add`).\n\nWe prove that if the commutative ring `R` of coefficients is an integral domain,\nthen the ring `R\u27e6X\u27e7` of formal power series in one variable over `R`\nis an integral domain.\n\nGiven a non-zero power series `f`, `divided_by_X_pow_order f` is the power series obtained by\ndividing out the largest power of X that divides `f`, that is its order. This is useful when\nproving that `R\u27e6X\u27e7` is a normalization monoid, which is done in `PowerSeries.Inverse`.\n\n-/\nnoncomputable section\n\nopen BigOperators Polynomial\n\nopen Finset (antidiagonal mem_antidiagonal)\n\nnamespace PowerSeries\n\nopen Finsupp (single)\n\nvariable {R : Type*}\n\nsection OrderBasic\n\nopen multiplicity\n\nvariable [Semiring R] {\u03c6 : R\u27e6X\u27e7}\n\ntheorem exists_coeff_ne_zero_iff_ne_zero : (\u2203 n : \u2115, coeff R n \u03c6 \u2260 0) \u2194 \u03c6 \u2260 0 := by\n  refine' not_iff_not.mp _\n  push_neg\n  -- FIXME: the `FunLike.coe` doesn't seem to be picked up in the expression after #8386?\n  simp [PowerSeries.ext_iff, (coeff R _).map_zero]\n#align power_series.exists_coeff_ne_zero_iff_ne_zero PowerSeries.exists_coeff_ne_zero_iff_ne_zero\n\n/-- The order of a formal power series `\u03c6` is the greatest `n : PartENat`\nsuch that `X^n` divides `\u03c6`. The order is `\u22a4` if and only if `\u03c6 = 0`. -/\ndef order (\u03c6 : R\u27e6X\u27e7) : PartENat :=\n  letI := Classical.decEq R\n  letI := Classical.decEq R\u27e6X\u27e7\n  if h : \u03c6 = 0 then \u22a4 else Nat.find (exists_coeff_ne_zero_iff_ne_zero.mpr h)\n#align power_series.order PowerSeries.order\n\n/-- The order of the `0` power series is infinite. -/\n@[simp]\ntheorem order_zero : order (0 : R\u27e6X\u27e7) = \u22a4 :=\n  dif_pos rfl\n#align power_series.order_zero PowerSeries.order_zero\n\ntheorem order_finite_iff_ne_zero : (order \u03c6).Dom \u2194 \u03c6 \u2260 0 := by\n  simp only [order]\n  constructor\n  \u00b7 split_ifs with h <;> intro H\n    \u00b7 simp only [PartENat.top_eq_none, Part.not_none_dom] at H\n    \u00b7 exact h\n  \u00b7 intro h\n    simp [h]\n#align power_series.order_finite_iff_ne_zero PowerSeries.order_finite_iff_ne_zero\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem coeff_order (h : (order \u03c6).Dom) : coeff R (\u03c6.order.get h) \u03c6 \u2260 0 := by\n  classical\n  simp only [order, order_finite_iff_ne_zero.mp h, not_false_iff, dif_neg, PartENat.get_natCast']\n  generalize_proofs h\n  exact Nat.find_spec h\n#align power_series.coeff_order PowerSeries.coeff_order\n\n/-- If the `n`th coefficient of a formal power series is nonzero,\nthen the order of the power series is less than or equal to `n`. -/\ntheorem order_le (n : \u2115) (h : coeff R n \u03c6 \u2260 0) : order \u03c6 \u2264 n := by\n  classical\n  rw [order, dif_neg]\n  \u00b7 simp only [PartENat.coe_le_coe]\n    exact Nat.find_le h\n  \u00b7 exact exists_coeff_ne_zero_iff_ne_zero.mp \u27e8n, h\u27e9\n#align power_series.order_le PowerSeries.order_le\n\n/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series. -/\ntheorem coeff_of_lt_order (n : \u2115) (h : \u2191n < order \u03c6) : coeff R n \u03c6 = 0 := by\n  contrapose! h\n  exact order_le _ h\n#align power_series.coeff_of_lt_order PowerSeries.coeff_of_lt_order\n\n/-- The `0` power series is the unique power series with infinite order. -/\n@[simp]\ntheorem order_eq_top {\u03c6 : R\u27e6X\u27e7} : \u03c6.order = \u22a4 \u2194 \u03c6 = 0 :=\n  PartENat.not_dom_iff_eq_top.symm.trans order_finite_iff_ne_zero.not_left\n#align power_series.order_eq_top PowerSeries.order_eq_top\n\n/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem nat_le_order (\u03c6 : R\u27e6X\u27e7) (n : \u2115) (h : \u2200 i < n, coeff R i \u03c6 = 0) : \u2191n \u2264 order \u03c6 := by\n  by_contra H; rw [not_le] at H\n  have : (order \u03c6).Dom := PartENat.dom_of_le_natCast H.le\n  rw [\u2190 PartENat.natCast_get this, PartENat.coe_lt_coe] at H\n  exact coeff_order this (h _ H)\n#align power_series.nat_le_order PowerSeries.nat_le_order\n\n/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem le_order (\u03c6 : R\u27e6X\u27e7) (n : PartENat) (h : \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0) :\n    n \u2264 order \u03c6 := by\n  induction n using PartENat.casesOn\n  \u00b7 show _ \u2264 _\n    rw [top_le_iff, order_eq_top]\n    ext i\n    exact h _ (PartENat.natCast_lt_top i)\n  \u00b7 apply nat_le_order\n    simpa only [PartENat.coe_lt_coe] using h\n#align power_series.le_order PowerSeries.le_order\n\n/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq_nat {\u03c6 : R\u27e6X\u27e7} {n : \u2115} :\n    order \u03c6 = n \u2194 coeff R n \u03c6 \u2260 0 \u2227 \u2200 i, i < n \u2192 coeff R i \u03c6 = 0 := by\n  classical\n  rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)\n  \u00b7 simpa [(coeff R _).map_zero] using (PartENat.natCast_ne_top _).symm\n  simp [order, dif_neg h\u03c6, Nat.find_eq_iff]\n#align power_series.order_eq_nat PowerSeries.order_eq_nat\n\n/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq {\u03c6 : R\u27e6X\u27e7} {n : PartENat} :\n    order \u03c6 = n \u2194 (\u2200 i : \u2115, \u2191i = n \u2192 coeff R i \u03c6 \u2260 0) \u2227 \u2200 i : \u2115, \u2191i < n \u2192 coeff R i \u03c6 = 0 := by\n  induction n using PartENat.casesOn\n  \u00b7 rw [order_eq_top]\n    constructor\n    \u00b7 rintro rfl\n      constructor <;> intros\n      \u00b7 exfalso\n        exact PartENat.natCast_ne_top \u2039_\u203a \u2039_\u203a\n      \u00b7 exact (coeff _ _).map_zero\n    \u00b7 rintro \u27e8_h\u2081, h\u2082\u27e9\n      ext i\n      exact h\u2082 i (PartENat.natCast_lt_top i)\n  \u00b7 simpa [PartENat.natCast_inj] using order_eq_nat\n#align power_series.order_eq PowerSeries.order_eq\n\n/-- The order of the sum of two formal power series\n is at least the minimum of their orders. -/\ntheorem le_order_add (\u03c6 \u03c8 : R\u27e6X\u27e7) : min (order \u03c6) (order \u03c8) \u2264 order (\u03c6 + \u03c8) := by\n  refine' le_order _ _ _\n  simp (config := { contextual := true }) [coeff_of_lt_order]\n#align power_series.le_order_add PowerSeries.le_order_add\n\nprivate theorem order_add_of_order_eq.aux (\u03c6 \u03c8 : R\u27e6X\u27e7) (_h : order \u03c6 \u2260 order \u03c8)\n    (H : order \u03c6 < order \u03c8) : order (\u03c6 + \u03c8) \u2264 order \u03c6 \u2293 order \u03c8 := by\n  suffices order (\u03c6 + \u03c8) = order \u03c6 by\n    rw [le_inf_iff, this]\n    exact \u27e8le_rfl, le_of_lt H\u27e9\n  \u00b7 rw [order_eq]\n    constructor\n    \u00b7 intro i hi\n      rw [\u2190 hi] at H\n      rw [(coeff _ _).map_add, coeff_of_lt_order i H, add_zero]\n      exact (order_eq_nat.1 hi.symm).1\n    \u00b7 intro i hi\n      rw [(coeff _ _).map_add, coeff_of_lt_order i hi, coeff_of_lt_order i (lt_trans hi H),\n        zero_add]\n-- #align power_series.order_add_of_order_eq.aux power_series.order_add_of_order_eq.aux\n\n/-- The order of the sum of two formal power series\n is the minimum of their orders if their orders differ. -/\ntheorem order_add_of_order_eq (\u03c6 \u03c8 : R\u27e6X\u27e7) (h : order \u03c6 \u2260 order \u03c8) :\n    order (\u03c6 + \u03c8) = order \u03c6 \u2293 order \u03c8 := by\n  refine' le_antisymm _ (le_order_add _ _)\n  by_cases H\u2081 : order \u03c6 < order \u03c8\n  \u00b7 apply order_add_of_order_eq.aux _ _ h H\u2081\n  by_cases H\u2082 : order \u03c8 < order \u03c6\n  \u00b7 simpa only [add_comm, inf_comm] using order_add_of_order_eq.aux _ _ h.symm H\u2082\n  exfalso; exact h (le_antisymm (not_lt.1 H\u2082) (not_lt.1 H\u2081))\n#align power_series.order_add_of_order_eq PowerSeries.order_add_of_order_eq\n\n/-- The order of the product of two formal power series\n is at least the sum of their orders. -/\ntheorem order_mul_ge (\u03c6 \u03c8 : R\u27e6X\u27e7) : order \u03c6 + order \u03c8 \u2264 order (\u03c6 * \u03c8) := by\n  apply le_order\n  intro n hn; rw [coeff_mul, Finset.sum_eq_zero]\n  rintro \u27e8i, j\u27e9 hij\n  by_cases hi : \u2191i < order \u03c6\n  \u00b7 rw [coeff_of_lt_order i hi, zero_mul]\n  by_cases hj : \u2191j < order \u03c8\n  \u00b7 rw [coeff_of_lt_order j hj, mul_zero]\n  rw [not_lt] at hi hj; rw [mem_antidiagonal] at hij\n  exfalso\n  apply ne_of_lt (lt_of_lt_of_le hn <| add_le_add hi hj)\n  rw [\u2190 Nat.cast_add, hij]\n#align power_series.order_mul_ge PowerSeries.order_mul_ge\n\n/-- The order of the monomial `a*X^n` is infinite if `a = 0` and `n` otherwise. -/\ntheorem order_monomial (n : \u2115) (a : R) [Decidable (a = 0)] :\n    order (monomial R n a) = if a = 0 then (\u22a4 : PartENat) else n := by\n  split_ifs with h\n  \u00b7 rw [h, order_eq_top, LinearMap.map_zero]\n  \u00b7 rw [order_eq]\n    constructor <;> intro i hi\n    \u00b7 rw [PartENat.natCast_inj] at hi\n      rwa [hi, coeff_monomial_same]\n    \u00b7 rw [PartENat.coe_lt_coe] at hi\n      rw [coeff_monomial, if_neg]\n      exact ne_of_lt hi\n#align power_series.order_monomial PowerSeries.order_monomial\n\n/-- The order of the monomial `a*X^n` is `n` if `a \u2260 0`. -/\ntheorem order_monomial_of_ne_zero (n : \u2115) (a : R) (h : a \u2260 0) : order (monomial R n a) = n := by\n  classical\n  rw [order_monomial, if_neg h]\n#align power_series.order_monomial_of_ne_zero PowerSeries.order_monomial_of_ne_zero\n\n/-- If `n` is strictly smaller than the order of `\u03c8`, then the `n`th coefficient of its product\nwith any other power series is `0`. -/\ntheorem coeff_mul_of_lt_order {\u03c6 \u03c8 : R\u27e6X\u27e7} {n : \u2115} (h : \u2191n < \u03c8.order) :\n    coeff R n (\u03c6 * \u03c8) = 0 := by\n  suffices coeff R n (\u03c6 * \u03c8) = \u2211 p in antidiagonal n, 0 by rw [this, Finset.sum_const_zero]\n  rw [coeff_mul]\n  apply Finset.sum_congr rfl\n  intro x hx\n  refine' mul_eq_zero_of_right (coeff R x.fst \u03c6) (coeff_of_lt_order x.snd (lt_of_le_of_lt _ h))\n  rw [mem_antidiagonal] at hx\n  norm_cast\n  omega\n#align power_series.coeff_mul_of_lt_order PowerSeries.coeff_mul_of_lt_order\n\ntheorem coeff_mul_one_sub_of_lt_order {R : Type*} [CommRing R] {\u03c6 \u03c8 : R\u27e6X\u27e7} (n : \u2115)\n    (h : \u2191n < \u03c8.order) : coeff R n (\u03c6 * (1 - \u03c8)) = coeff R n \u03c6 := by\n  simp [coeff_mul_of_lt_order h, mul_sub]\n#align power_series.coeff_mul_one_sub_of_lt_order PowerSeries.coeff_mul_one_sub_of_lt_order\n\ntheorem coeff_mul_prod_one_sub_of_lt_order {R \u03b9 : Type*} [CommRing R] (k : \u2115) (s : Finset \u03b9)\n    (\u03c6 : R\u27e6X\u27e7) (f : \u03b9 \u2192 R\u27e6X\u27e7) :\n    (\u2200 i \u2208 s, \u2191k < (f i).order) \u2192 coeff R k (\u03c6 * \u220f i in s, (1 - f i)) = coeff R k \u03c6 := by\n  classical\n  induction' s using Finset.induction_on with a s ha ih t\n  \u00b7 simp\n  \u00b7 intro t\n    simp only [Finset.mem_insert, forall_eq_or_imp] at t\n    rw [Finset.prod_insert ha, \u2190 mul_assoc, mul_right_comm, coeff_mul_one_sub_of_lt_order _ t.1]\n    exact ih t.2\n#align power_series.coeff_mul_prod_one_sub_of_lt_order PowerSeries.coeff_mul_prod_one_sub_of_lt_order\n\n-- TODO: link with `X_pow_dvd_iff`\ntheorem X_pow_order_dvd (h : (order \u03c6).Dom) : X ^ (order \u03c6).get h \u2223 \u03c6 := by\n  refine' \u27e8PowerSeries.mk fun n => coeff R (n + (order \u03c6).get h) \u03c6, _\u27e9\n  ext n\n  simp only [coeff_mul, coeff_X_pow, coeff_mk, boole_mul, Finset.sum_ite,\n    Finset.sum_const_zero, add_zero]\n  rw [Finset.filter_fst_eq_antidiagonal n (Part.get (order \u03c6) h)]\n  split_ifs with hn\n  \u00b7 simp [tsub_add_cancel_of_le hn]\n  \u00b7 simp only [Finset.sum_empty]\n    refine' coeff_of_lt_order _ _\n    simpa [PartENat.coe_lt_iff] using fun _ => hn\nset_option linter.uppercaseLean3 false in\n#align power_series.X_pow_order_dvd PowerSeries.X_pow_order_dvd\n\ntheorem order_eq_multiplicity_X {R : Type*} [Semiring R] [@DecidableRel R\u27e6X\u27e7 (\u00b7 \u2223 \u00b7)] (\u03c6 : R\u27e6X\u27e7) :\n    order \u03c6 = multiplicity X \u03c6 := by\n  classical\n  rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)\n  \u00b7 simp\n  induction' ho : order \u03c6 using PartENat.casesOn with n\n  \u00b7 simp [h\u03c6] at ho\n  have hn : \u03c6.order.get (order_finite_iff_ne_zero.mpr h\u03c6) = n := by simp [ho]\n  rw [\u2190 hn]\n  refine'\n    le_antisymm (le_multiplicity_of_pow_dvd <| X_pow_order_dvd (order_finite_iff_ne_zero.mpr h\u03c6))\n      (PartENat.find_le _ _ _)\n  rintro \u27e8\u03c8, H\u27e9\n  have := congr_arg (coeff R n) H\n  rw [\u2190 (\u03c8.commute_X.pow_right _).eq, coeff_mul_of_lt_order, \u2190 hn] at this\n  \u00b7 exact coeff_order _ this\n  \u00b7 rw [X_pow_eq, order_monomial]\n    split_ifs\n    \u00b7 exact PartENat.natCast_lt_top _\n    \u00b7 rw [\u2190 hn, PartENat.coe_lt_coe]\n      exact Nat.lt_succ_self _\nset_option linter.uppercaseLean3 false in\n#align power_series.order_eq_multiplicity_X PowerSeries.order_eq_multiplicity_X\n\n/-- Given a non-zero power series `f`, `divided_by_X_pow_order f` is the power series obtained by\n  dividing out the largest power of X that divides `f`, that is its order-/\ndef divided_by_X_pow_order {f : PowerSeries R} (hf : f \u2260 0) : R\u27e6X\u27e7 :=\n  (exists_eq_mul_right_of_dvd (X_pow_order_dvd (order_finite_iff_ne_zero.2 hf))).choose\n\ntheorem self_eq_X_pow_order_mul_divided_by_X_pow_order {f : R\u27e6X\u27e7} (hf : f \u2260 0) :\n    X ^ f.order.get (order_finite_iff_ne_zero.mpr hf) * divided_by_X_pow_order hf = f :=\n  haveI dvd := X_pow_order_dvd (order_finite_iff_ne_zero.mpr hf)\n  (exists_eq_mul_right_of_dvd dvd).choose_spec.symm\n\nend OrderBasic\n\nsection OrderZeroNeOne\n\nvariable [Semiring R] [Nontrivial R]\n\n/-- The order of the formal power series `1` is `0`. -/\n@[simp]\ntheorem order_one : order (1 : R\u27e6X\u27e7) = 0 := by\n  simpa using order_monomial_of_ne_zero 0 (1 : R) one_ne_zero\n#align power_series.order_one PowerSeries.order_one\n\n/-- The order of an invertible power series is `0`. -/\ntheorem order_zero_of_unit {f : PowerSeries R} : IsUnit f \u2192 f.order = 0 := by\n  rintro \u27e8\u27e8u, v, hu, hv\u27e9, hf\u27e9\n  apply And.left\n  rw [\u2190 add_eq_zero_iff, \u2190 hf, \u2190 nonpos_iff_eq_zero, \u2190 @order_one R _ _, \u2190 hu]\n  exact order_mul_ge _ _\n\n/-- The order of the formal power series `X` is `1`. -/\n@[simp]\ntheorem order_X : order (X : R\u27e6X\u27e7) = 1 := by\n  simpa only [Nat.cast_one] using order_monomial_of_ne_zero 1 (1 : R) one_ne_zero\nset_option linter.uppercaseLean3 false in\n#align power_series.order_X PowerSeries.order_X\n\n/-- The order of the formal power series `X^n` is `n`. -/\n@[simp]\ntheorem order_X_pow (n : \u2115) : order ((X : R\u27e6X\u27e7) ^ n) = n := by\n  rw [X_pow_eq, order_monomial_of_ne_zero]\n  exact one_ne_zero\nset_option linter.uppercaseLean3 false in\n#align power_series.order_X_pow PowerSeries.order_X_pow\n\nend OrderZeroNeOne\n\nsection OrderIsDomain\n\n-- TODO: generalize to `[Semiring R] [NoZeroDivisors R]`\nvariable [CommRing R] [IsDomain R]\n\n/-- The order of the product of two formal power series over an integral domain\n is the sum of their orders. -/\ntheorem order_mul (\u03c6 \u03c8 : R\u27e6X\u27e7) : order (\u03c6 * \u03c8) = order \u03c6 + order \u03c8 := by\n  classical\n  simp_rw [order_eq_multiplicity_X]\n  exact multiplicity.mul X_prime\n#align power_series.order_mul PowerSeries.order_mul\n\n-- Dividing `X` by the maximal power of `X` dividing it leaves `1`.\n@[simp]\ntheorem divided_by_X_pow_order_of_X_eq_one : divided_by_X_pow_order X_ne_zero = (1 : R\u27e6X\u27e7) := by\n  rw [\u2190 mul_eq_left\u2080 X_ne_zero]\n  simpa only [order_X, X_ne_zero, PartENat.get_one, pow_one, Ne.def,\n    not_false_iff] using self_eq_X_pow_order_mul_divided_by_X_pow_order (@X_ne_zero R _ _)\n\n-- Dividing a power series by the maximal power of `X` dividing it, respects multiplication.\n", "theoremStatement": "theorem divided_by_X_pow_orderMul {f g : R\u27e6X\u27e7} (hf : f \u2260 0) (hg : g \u2260 0) :\n    divided_by_X_pow_order hf * divided_by_X_pow_order hg =\n      divided_by_X_pow_order (mul_ne_zero hf hg)", "theoremName": "divided_by_X_pow_orderMul", "fileCreated": {"commit": "73d45f44c3", "date": "2024-02-29"}, "theoremCreated": {"commit": "85a47191ab", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/PowerSeries/Order.lean", "positionMetadata": {"lineInFile": 367, "tokenPositionInFile": 14817, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  set df := f.order.get (order_finite_iff_ne_zero.mpr hf)\n  set dg := g.order.get (order_finite_iff_ne_zero.mpr hg)\n  set dfg := (f * g).order.get (order_finite_iff_ne_zero.mpr (mul_ne_zero hf hg)) with hdfg\n  have H_add_d : df + dg = dfg := by simp_all only [PartENat.get_add, order_mul f g]\n  have H := self_eq_X_pow_order_mul_divided_by_X_pow_order (mul_ne_zero hf hg)\n  have : f * g = X ^ dfg * (divided_by_X_pow_order hf * divided_by_X_pow_order hg) := by\n    calc\n      f * g = X ^ df * divided_by_X_pow_order hf * (X ^ dg * divided_by_X_pow_order hg) := by\n        rw [self_eq_X_pow_order_mul_divided_by_X_pow_order,\n          self_eq_X_pow_order_mul_divided_by_X_pow_order]\n      _ = X ^ df * X ^ dg * divided_by_X_pow_order hf * divided_by_X_pow_order hg := by ring\n      _ = X ^ (df + dg) * divided_by_X_pow_order hf * divided_by_X_pow_order hg := by rw [pow_add]\n      _ = X ^ dfg * divided_by_X_pow_order hf * divided_by_X_pow_order hg := by rw [H_add_d]\n      _ = X ^ dfg * (divided_by_X_pow_order hf * divided_by_X_pow_order hg) := by rw [mul_assoc]\n  simp [\u2190 hdfg, this] at H\n  refine' (IsLeftCancelMulZero.mul_left_cancel_of_ne_zero (pow_ne_zero dfg X_ne_zero) _).symm\n  convert H", "proofType": "tactic", "proofLengthLines": 18, "proofLengthTokens": 1199}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2021 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller\n-/\nimport Mathlib.Combinatorics.SimpleGraph.Subgraph\nimport Mathlib.Data.List.Rotate\n\n#align_import combinatorics.simple_graph.connectivity from \"leanprover-community/mathlib\"@\"b99e2d58a5e6861833fa8de11e51a81144258db4\"\n\n/-!\n\n# Graph connectivity\n\nIn a simple graph,\n\n* A *walk* is a finite sequence of adjacent vertices, and can be\n  thought of equally well as a sequence of directed edges.\n\n* A *trail* is a walk whose edges each appear no more than once.\n\n* A *path* is a trail whose vertices appear no more than once.\n\n* A *cycle* is a nonempty trail whose first and last vertices are the\n  same and whose vertices except for the first appear no more than once.\n\n**Warning:** graph theorists mean something different by \"path\" than\ndo homotopy theorists.  A \"walk\" in graph theory is a \"path\" in\nhomotopy theory.  Another warning: some graph theorists use \"path\" and\n\"simple path\" for \"walk\" and \"path.\"\n\nSome definitions and theorems have inspiration from multigraph\ncounterparts in [Chou1994].\n\n## Main definitions\n\n* `SimpleGraph.Walk` (with accompanying pattern definitions\n  `SimpleGraph.Walk.nil'` and `SimpleGraph.Walk.cons'`)\n\n* `SimpleGraph.Walk.IsTrail`, `SimpleGraph.Walk.IsPath`, and `SimpleGraph.Walk.IsCycle`.\n\n* `SimpleGraph.Path`\n\n* `SimpleGraph.Walk.map` and `SimpleGraph.Path.map` for the induced map on walks,\n  given an (injective) graph homomorphism.\n\n* `SimpleGraph.Reachable` for the relation of whether there exists\n  a walk between a given pair of vertices\n\n* `SimpleGraph.Preconnected` and `SimpleGraph.Connected` are predicates\n  on simple graphs for whether every vertex can be reached from every other,\n  and in the latter case, whether the vertex type is nonempty.\n\n* `SimpleGraph.ConnectedComponent` is the type of connected components of\n  a given graph.\n\n* `SimpleGraph.IsBridge` for whether an edge is a bridge edge\n\n## Main statements\n\n* `SimpleGraph.isBridge_iff_mem_and_forall_cycle_not_mem` characterizes bridge edges in terms of\n  there being no cycle containing them.\n\n## Tags\nwalks, trails, paths, circuits, cycles, bridge edges\n\n-/\n\nopen Function\n\nuniverse u v w\n\nnamespace SimpleGraph\n\nvariable {V : Type u} {V' : Type v} {V'' : Type w}\nvariable (G : SimpleGraph V) (G' : SimpleGraph V') (G'' : SimpleGraph V'')\n\n/-- A walk is a sequence of adjacent vertices.  For vertices `u v : V`,\nthe type `walk u v` consists of all walks starting at `u` and ending at `v`.\n\nWe say that a walk *visits* the vertices it contains.  The set of vertices a\nwalk visits is `SimpleGraph.Walk.support`.\n\nSee `SimpleGraph.Walk.nil'` and `SimpleGraph.Walk.cons'` for patterns that\ncan be useful in definitions since they make the vertices explicit. -/\ninductive Walk : V \u2192 V \u2192 Type u\n  | nil {u : V} : Walk u u\n  | cons {u v w : V} (h : G.Adj u v) (p : Walk v w) : Walk u w\n  deriving DecidableEq\n#align simple_graph.walk SimpleGraph.Walk\n\nattribute [refl] Walk.nil\n\n@[simps]\ninstance Walk.instInhabited (v : V) : Inhabited (G.Walk v v) := \u27e8Walk.nil\u27e9\n#align simple_graph.walk.inhabited SimpleGraph.Walk.instInhabited\n\n/-- The one-edge walk associated to a pair of adjacent vertices. -/\n@[match_pattern, reducible]\ndef Adj.toWalk {G : SimpleGraph V} {u v : V} (h : G.Adj u v) : G.Walk u v :=\n  Walk.cons h Walk.nil\n#align simple_graph.adj.to_walk SimpleGraph.Adj.toWalk\n\nnamespace Walk\n\nvariable {G}\n\n/-- Pattern to get `Walk.nil` with the vertex as an explicit argument. -/\n@[match_pattern]\nabbrev nil' (u : V) : G.Walk u u := Walk.nil\n#align simple_graph.walk.nil' SimpleGraph.Walk.nil'\n\n/-- Pattern to get `Walk.cons` with the vertices as explicit arguments. -/\n@[match_pattern]\nabbrev cons' (u v w : V) (h : G.Adj u v) (p : G.Walk v w) : G.Walk u w := Walk.cons h p\n#align simple_graph.walk.cons' SimpleGraph.Walk.cons'\n\n/-- Change the endpoints of a walk using equalities. This is helpful for relaxing\ndefinitional equality constraints and to be able to state otherwise difficult-to-state\nlemmas. While this is a simple wrapper around `Eq.rec`, it gives a canonical way to write it.\n\nThe simp-normal form is for the `copy` to be pushed outward. That way calculations can\noccur within the \"copy context.\" -/\nprotected def copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') : G.Walk u' v' :=\n  hu \u25b8 hv \u25b8 p\n#align simple_graph.walk.copy SimpleGraph.Walk.copy\n\n@[simp]\ntheorem copy_rfl_rfl {u v} (p : G.Walk u v) : p.copy rfl rfl = p := rfl\n#align simple_graph.walk.copy_rfl_rfl SimpleGraph.Walk.copy_rfl_rfl\n\n@[simp]\ntheorem copy_copy {u v u' v' u'' v''} (p : G.Walk u v)\n    (hu : u = u') (hv : v = v') (hu' : u' = u'') (hv' : v' = v'') :\n    (p.copy hu hv).copy hu' hv' = p.copy (hu.trans hu') (hv.trans hv') := by\n  subst_vars\n  rfl\n#align simple_graph.walk.copy_copy SimpleGraph.Walk.copy_copy\n\n@[simp]\ntheorem copy_nil {u u'} (hu : u = u') : (Walk.nil : G.Walk u u).copy hu hu = Walk.nil := by\n  subst_vars\n  rfl\n#align simple_graph.walk.copy_nil SimpleGraph.Walk.copy_nil\n\ntheorem copy_cons {u v w u' w'} (h : G.Adj u v) (p : G.Walk v w) (hu : u = u') (hw : w = w') :\n    (Walk.cons h p).copy hu hw = Walk.cons (hu \u25b8 h) (p.copy rfl hw) := by\n  subst_vars\n  rfl\n#align simple_graph.walk.copy_cons SimpleGraph.Walk.copy_cons\n\n@[simp]\ntheorem cons_copy {u v w v' w'} (h : G.Adj u v) (p : G.Walk v' w') (hv : v' = v) (hw : w' = w) :\n    Walk.cons h (p.copy hv hw) = (Walk.cons (hv \u25b8 h) p).copy rfl hw := by\n  subst_vars\n  rfl\n#align simple_graph.walk.cons_copy SimpleGraph.Walk.cons_copy\n\ntheorem exists_eq_cons_of_ne {u v : V} (hne : u \u2260 v) :\n    \u2200 (p : G.Walk u v), \u2203 (w : V) (h : G.Adj u w) (p' : G.Walk w v), p = cons h p'\n  | nil => (hne rfl).elim\n  | cons h p' => \u27e8_, h, p', rfl\u27e9\n#align simple_graph.walk.exists_eq_cons_of_ne SimpleGraph.Walk.exists_eq_cons_of_ne\n\n/-- The length of a walk is the number of edges/darts along it. -/\ndef length {u v : V} : G.Walk u v \u2192 \u2115\n  | nil => 0\n  | cons _ q => q.length.succ\n#align simple_graph.walk.length SimpleGraph.Walk.length\n\n/-- The concatenation of two compatible walks. -/\n@[trans]\ndef append {u v w : V} : G.Walk u v \u2192 G.Walk v w \u2192 G.Walk u w\n  | nil, q => q\n  | cons h p, q => cons h (p.append q)\n#align simple_graph.walk.append SimpleGraph.Walk.append\n\n/-- The reversed version of `SimpleGraph.Walk.cons`, concatenating an edge to\nthe end of a walk. -/\ndef concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) : G.Walk u w := p.append (cons h nil)\n#align simple_graph.walk.concat SimpleGraph.Walk.concat\n\ntheorem concat_eq_append {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    p.concat h = p.append (cons h nil) := rfl\n#align simple_graph.walk.concat_eq_append SimpleGraph.Walk.concat_eq_append\n\n/-- The concatenation of the reverse of the first walk with the second walk. -/\nprotected def reverseAux {u v w : V} : G.Walk u v \u2192 G.Walk u w \u2192 G.Walk v w\n  | nil, q => q\n  | cons h p, q => Walk.reverseAux p (cons (G.symm h) q)\n#align simple_graph.walk.reverse_aux SimpleGraph.Walk.reverseAux\n\n/-- The walk in reverse. -/\n@[symm]\ndef reverse {u v : V} (w : G.Walk u v) : G.Walk v u := w.reverseAux nil\n#align simple_graph.walk.reverse SimpleGraph.Walk.reverse\n\n/-- Get the `n`th vertex from a walk, where `n` is generally expected to be\nbetween `0` and `p.length`, inclusive.\nIf `n` is greater than or equal to `p.length`, the result is the path's endpoint. -/\ndef getVert {u v : V} : G.Walk u v \u2192 \u2115 \u2192 V\n  | nil, _ => u\n  | cons _ _, 0 => u\n  | cons _ q, n + 1 => q.getVert n\n#align simple_graph.walk.get_vert SimpleGraph.Walk.getVert\n\n@[simp]\ntheorem getVert_zero {u v} (w : G.Walk u v) : w.getVert 0 = u := by cases w <;> rfl\n#align simple_graph.walk.get_vert_zero SimpleGraph.Walk.getVert_zero\n\ntheorem getVert_of_length_le {u v} (w : G.Walk u v) {i : \u2115} (hi : w.length \u2264 i) :\n    w.getVert i = v := by\n  induction w generalizing i with\n  | nil => rfl\n  | cons _ _ ih =>\n    cases i\n    \u00b7 cases hi\n    \u00b7 exact ih (Nat.succ_le_succ_iff.1 hi)\n#align simple_graph.walk.get_vert_of_length_le SimpleGraph.Walk.getVert_of_length_le\n\n@[simp]\ntheorem getVert_length {u v} (w : G.Walk u v) : w.getVert w.length = v :=\n  w.getVert_of_length_le rfl.le\n#align simple_graph.walk.get_vert_length SimpleGraph.Walk.getVert_length\n\ntheorem adj_getVert_succ {u v} (w : G.Walk u v) {i : \u2115} (hi : i < w.length) :\n    G.Adj (w.getVert i) (w.getVert (i + 1)) := by\n  induction w generalizing i with\n  | nil => cases hi\n  | cons hxy _ ih =>\n    cases i\n    \u00b7 simp [getVert, hxy]\n    \u00b7 exact ih (Nat.succ_lt_succ_iff.1 hi)\n#align simple_graph.walk.adj_get_vert_succ SimpleGraph.Walk.adj_getVert_succ\n\n@[simp]\ntheorem cons_append {u v w x : V} (h : G.Adj u v) (p : G.Walk v w) (q : G.Walk w x) :\n    (cons h p).append q = cons h (p.append q) := rfl\n#align simple_graph.walk.cons_append SimpleGraph.Walk.cons_append\n\n@[simp]\ntheorem cons_nil_append {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h nil).append p = cons h p := rfl\n#align simple_graph.walk.cons_nil_append SimpleGraph.Walk.cons_nil_append\n\n@[simp]\ntheorem append_nil {u v : V} (p : G.Walk u v) : p.append nil = p := by\n  induction p with\n  | nil => rfl\n  | cons _ _ ih => rw [cons_append, ih]\n#align simple_graph.walk.append_nil SimpleGraph.Walk.append_nil\n\n@[simp]\ntheorem nil_append {u v : V} (p : G.Walk u v) : nil.append p = p :=\n  rfl\n#align simple_graph.walk.nil_append SimpleGraph.Walk.nil_append\n\ntheorem append_assoc {u v w x : V} (p : G.Walk u v) (q : G.Walk v w) (r : G.Walk w x) :\n    p.append (q.append r) = (p.append q).append r := by\n  induction p with\n  | nil => rfl\n  | cons h p' ih =>\n    dsimp only [append]\n    rw [ih]\n#align simple_graph.walk.append_assoc SimpleGraph.Walk.append_assoc\n\n@[simp]\ntheorem append_copy_copy {u v w u' v' w'} (p : G.Walk u v) (q : G.Walk v w)\n    (hu : u = u') (hv : v = v') (hw : w = w') :\n    (p.copy hu hv).append (q.copy hv hw) = (p.append q).copy hu hw := by\n  subst_vars\n  rfl\n#align simple_graph.walk.append_copy_copy SimpleGraph.Walk.append_copy_copy\n\ntheorem concat_nil {u v : V} (h : G.Adj u v) : nil.concat h = cons h nil := rfl\n#align simple_graph.walk.concat_nil SimpleGraph.Walk.concat_nil\n\n@[simp]\ntheorem concat_cons {u v w x : V} (h : G.Adj u v) (p : G.Walk v w) (h' : G.Adj w x) :\n    (cons h p).concat h' = cons h (p.concat h') := rfl\n#align simple_graph.walk.concat_cons SimpleGraph.Walk.concat_cons\n\ntheorem append_concat {u v w x : V} (p : G.Walk u v) (q : G.Walk v w) (h : G.Adj w x) :\n    p.append (q.concat h) = (p.append q).concat h := append_assoc _ _ _\n#align simple_graph.walk.append_concat SimpleGraph.Walk.append_concat\n\ntheorem concat_append {u v w x : V} (p : G.Walk u v) (h : G.Adj v w) (q : G.Walk w x) :\n    (p.concat h).append q = p.append (cons h q) := by\n  rw [concat_eq_append, \u2190 append_assoc, cons_nil_append]\n#align simple_graph.walk.concat_append SimpleGraph.Walk.concat_append\n\n/-- A non-trivial `cons` walk is representable as a `concat` walk. -/\ntheorem exists_cons_eq_concat {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    \u2203 (x : V) (q : G.Walk u x) (h' : G.Adj x w), cons h p = q.concat h' := by\n  induction p generalizing u with\n  | nil => exact \u27e8_, nil, h, rfl\u27e9\n  | cons h' p ih =>\n    obtain \u27e8y, q, h'', hc\u27e9 := ih h'\n    refine' \u27e8y, cons h q, h'', _\u27e9\n    rw [concat_cons, hc]\n#align simple_graph.walk.exists_cons_eq_concat SimpleGraph.Walk.exists_cons_eq_concat\n\n/-- A non-trivial `concat` walk is representable as a `cons` walk. -/\ntheorem exists_concat_eq_cons {u v w : V} :\n    \u2200 (p : G.Walk u v) (h : G.Adj v w),\n      \u2203 (x : V) (h' : G.Adj u x) (q : G.Walk x w), p.concat h = cons h' q\n  | nil, h => \u27e8_, h, nil, rfl\u27e9\n  | cons h' p, h => \u27e8_, h', Walk.concat p h, concat_cons _ _ _\u27e9\n#align simple_graph.walk.exists_concat_eq_cons SimpleGraph.Walk.exists_concat_eq_cons\n\n@[simp]\ntheorem reverse_nil {u : V} : (nil : G.Walk u u).reverse = nil := rfl\n#align simple_graph.walk.reverse_nil SimpleGraph.Walk.reverse_nil\n\ntheorem reverse_singleton {u v : V} (h : G.Adj u v) : (cons h nil).reverse = cons (G.symm h) nil :=\n  rfl\n#align simple_graph.walk.reverse_singleton SimpleGraph.Walk.reverse_singleton\n\n@[simp]\ntheorem cons_reverseAux {u v w x : V} (p : G.Walk u v) (q : G.Walk w x) (h : G.Adj w u) :\n    (cons h p).reverseAux q = p.reverseAux (cons (G.symm h) q) := rfl\n#align simple_graph.walk.cons_reverse_aux SimpleGraph.Walk.cons_reverseAux\n\n@[simp]\nprotected theorem append_reverseAux {u v w x : V}\n    (p : G.Walk u v) (q : G.Walk v w) (r : G.Walk u x) :\n    (p.append q).reverseAux r = q.reverseAux (p.reverseAux r) := by\n  induction p with\n  | nil => rfl\n  | cons h _ ih => exact ih q (cons (G.symm h) r)\n#align simple_graph.walk.append_reverse_aux SimpleGraph.Walk.append_reverseAux\n\n@[simp]\nprotected theorem reverseAux_append {u v w x : V}\n    (p : G.Walk u v) (q : G.Walk u w) (r : G.Walk w x) :\n    (p.reverseAux q).append r = p.reverseAux (q.append r) := by\n  induction p with\n  | nil => rfl\n  | cons h _ ih => simp [ih (cons (G.symm h) q)]\n#align simple_graph.walk.reverse_aux_append SimpleGraph.Walk.reverseAux_append\n\nprotected theorem reverseAux_eq_reverse_append {u v w : V} (p : G.Walk u v) (q : G.Walk u w) :\n    p.reverseAux q = p.reverse.append q := by simp [reverse]\n#align simple_graph.walk.reverse_aux_eq_reverse_append SimpleGraph.Walk.reverseAux_eq_reverse_append\n\n@[simp]\ntheorem reverse_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).reverse = p.reverse.append (cons (G.symm h) nil) := by simp [reverse]\n#align simple_graph.walk.reverse_cons SimpleGraph.Walk.reverse_cons\n\n@[simp]\ntheorem reverse_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).reverse = p.reverse.copy hv hu := by\n  subst_vars\n  rfl\n#align simple_graph.walk.reverse_copy SimpleGraph.Walk.reverse_copy\n\n@[simp]\ntheorem reverse_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).reverse = q.reverse.append p.reverse := by simp [reverse]\n#align simple_graph.walk.reverse_append SimpleGraph.Walk.reverse_append\n\n@[simp]\ntheorem reverse_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).reverse = cons (G.symm h) p.reverse := by simp [concat_eq_append]\n#align simple_graph.walk.reverse_concat SimpleGraph.Walk.reverse_concat\n\n@[simp]\ntheorem reverse_reverse {u v : V} (p : G.Walk u v) : p.reverse.reverse = p := by\n  induction p with\n  | nil => rfl\n  | cons _ _ ih => simp [ih]\n#align simple_graph.walk.reverse_reverse SimpleGraph.Walk.reverse_reverse\n\n@[simp]\ntheorem length_nil {u : V} : (nil : G.Walk u u).length = 0 := rfl\n#align simple_graph.walk.length_nil SimpleGraph.Walk.length_nil\n\n@[simp]\ntheorem length_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).length = p.length + 1 := rfl\n#align simple_graph.walk.length_cons SimpleGraph.Walk.length_cons\n\n@[simp]\ntheorem length_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).length = p.length := by\n  subst_vars\n  rfl\n#align simple_graph.walk.length_copy SimpleGraph.Walk.length_copy\n\n@[simp]\ntheorem length_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).length = p.length + q.length := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih => simp [ih, add_comm, add_left_comm, add_assoc]\n#align simple_graph.walk.length_append SimpleGraph.Walk.length_append\n\n@[simp]\ntheorem length_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).length = p.length + 1 := length_append _ _\n#align simple_graph.walk.length_concat SimpleGraph.Walk.length_concat\n\n@[simp]\nprotected theorem length_reverseAux {u v w : V} (p : G.Walk u v) (q : G.Walk u w) :\n    (p.reverseAux q).length = p.length + q.length := by\n  induction p with\n  | nil => simp!\n  | cons _ _ ih => simp [ih, Nat.add_succ, Nat.succ_add]\n#align simple_graph.walk.length_reverse_aux SimpleGraph.Walk.length_reverseAux\n\n@[simp]\ntheorem length_reverse {u v : V} (p : G.Walk u v) : p.reverse.length = p.length := by simp [reverse]\n#align simple_graph.walk.length_reverse SimpleGraph.Walk.length_reverse\n\ntheorem eq_of_length_eq_zero {u v : V} : \u2200 {p : G.Walk u v}, p.length = 0 \u2192 u = v\n  | nil, _ => rfl\n#align simple_graph.walk.eq_of_length_eq_zero SimpleGraph.Walk.eq_of_length_eq_zero\n\n@[simp]\ntheorem exists_length_eq_zero_iff {u v : V} : (\u2203 p : G.Walk u v, p.length = 0) \u2194 u = v := by\n  constructor\n  \u00b7 rintro \u27e8p, hp\u27e9\n    exact eq_of_length_eq_zero hp\n  \u00b7 rintro rfl\n    exact \u27e8nil, rfl\u27e9\n#align simple_graph.walk.exists_length_eq_zero_iff SimpleGraph.Walk.exists_length_eq_zero_iff\n\n@[simp]\ntheorem length_eq_zero_iff {u : V} {p : G.Walk u u} : p.length = 0 \u2194 p = nil := by cases p <;> simp\n#align simple_graph.walk.length_eq_zero_iff SimpleGraph.Walk.length_eq_zero_iff\n\nsection ConcatRec\n\nvariable {motive : \u2200 u v : V, G.Walk u v \u2192 Sort*} (Hnil : \u2200 {u : V}, motive u u nil)\n  (Hconcat : \u2200 {u v w : V} (p : G.Walk u v) (h : G.Adj v w), motive u v p \u2192 motive u w (p.concat h))\n\n/-- Auxiliary definition for `SimpleGraph.Walk.concatRec` -/\ndef concatRecAux {u v : V} : (p : G.Walk u v) \u2192 motive v u p.reverse\n  | nil => Hnil\n  | cons h p => reverse_cons h p \u25b8 Hconcat p.reverse h.symm (concatRecAux p)\n#align simple_graph.walk.concat_rec_aux SimpleGraph.Walk.concatRecAux\n\n/-- Recursor on walks by inducting on `SimpleGraph.Walk.concat`.\n\nThis is inducting from the opposite end of the walk compared\nto `SimpleGraph.Walk.rec`, which inducts on `SimpleGraph.Walk.cons`. -/\n@[elab_as_elim]\ndef concatRec {u v : V} (p : G.Walk u v) : motive u v p :=\n  reverse_reverse p \u25b8 concatRecAux @Hnil @Hconcat p.reverse\n#align simple_graph.walk.concat_rec SimpleGraph.Walk.concatRec\n\n@[simp]\ntheorem concatRec_nil (u : V) :\n    @concatRec _ _ motive @Hnil @Hconcat _ _ (nil : G.Walk u u) = Hnil := rfl\n#align simple_graph.walk.concat_rec_nil SimpleGraph.Walk.concatRec_nil\n\n@[simp]\ntheorem concatRec_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    @concatRec _ _ motive @Hnil @Hconcat _ _ (p.concat h) =\n      Hconcat p h (concatRec @Hnil @Hconcat p) := by\n  simp only [concatRec]\n  apply eq_of_heq\n  apply rec_heq_of_heq\n  trans concatRecAux @Hnil @Hconcat (cons h.symm p.reverse)\n  \u00b7 congr\n    simp\n  \u00b7 rw [concatRecAux, rec_heq_iff_heq]\n    congr <;> simp [heq_rec_iff_heq]\n#align simple_graph.walk.concat_rec_concat SimpleGraph.Walk.concatRec_concat\n\nend ConcatRec\n\ntheorem concat_ne_nil {u v : V} (p : G.Walk u v) (h : G.Adj v u) : p.concat h \u2260 nil := by\n  cases p <;> simp [concat]\n#align simple_graph.walk.concat_ne_nil SimpleGraph.Walk.concat_ne_nil\n\ntheorem concat_inj {u v v' w : V} {p : G.Walk u v} {h : G.Adj v w} {p' : G.Walk u v'}\n    {h' : G.Adj v' w} (he : p.concat h = p'.concat h') : \u2203 hv : v = v', p.copy rfl hv = p' := by\n  induction p with\n  | nil =>\n    cases p'\n    \u00b7 exact \u27e8rfl, rfl\u27e9\n    \u00b7 exfalso\n      simp only [concat_nil, concat_cons, cons.injEq] at he\n      obtain \u27e8rfl, he\u27e9 := he\n      simp only [heq_iff_eq] at he\n      exact concat_ne_nil _ _ he.symm\n  | cons _ _ ih =>\n    rw [concat_cons] at he\n    cases p'\n    \u00b7 exfalso\n      simp only [concat_nil, cons.injEq] at he\n      obtain \u27e8rfl, he\u27e9 := he\n      rw [heq_iff_eq] at he\n      exact concat_ne_nil _ _ he\n    \u00b7 rw [concat_cons, cons.injEq] at he\n      obtain \u27e8rfl, he\u27e9 := he\n      rw [heq_iff_eq] at he\n      obtain \u27e8rfl, rfl\u27e9 := ih he\n      exact \u27e8rfl, rfl\u27e9\n#align simple_graph.walk.concat_inj SimpleGraph.Walk.concat_inj\n\n/-- The `support` of a walk is the list of vertices it visits in order. -/\ndef support {u v : V} : G.Walk u v \u2192 List V\n  | nil => [u]\n  | cons _ p => u :: p.support\n#align simple_graph.walk.support SimpleGraph.Walk.support\n\n/-- The `darts` of a walk is the list of darts it visits in order. -/\ndef darts {u v : V} : G.Walk u v \u2192 List G.Dart\n  | nil => []\n  | cons h p => \u27e8(u, _), h\u27e9 :: p.darts\n#align simple_graph.walk.darts SimpleGraph.Walk.darts\n\n/-- The `edges` of a walk is the list of edges it visits in order.\nThis is defined to be the list of edges underlying `SimpleGraph.Walk.darts`. -/\ndef edges {u v : V} (p : G.Walk u v) : List (Sym2 V) := p.darts.map Dart.edge\n#align simple_graph.walk.edges SimpleGraph.Walk.edges\n\n@[simp]\ntheorem support_nil {u : V} : (nil : G.Walk u u).support = [u] := rfl\n#align simple_graph.walk.support_nil SimpleGraph.Walk.support_nil\n\n@[simp]\ntheorem support_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).support = u :: p.support := rfl\n#align simple_graph.walk.support_cons SimpleGraph.Walk.support_cons\n\n@[simp]\ntheorem support_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).support = p.support.concat w := by\n  induction p <;> simp [*, concat_nil]\n#align simple_graph.walk.support_concat SimpleGraph.Walk.support_concat\n\n@[simp]\ntheorem support_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).support = p.support := by\n  subst_vars\n  rfl\n#align simple_graph.walk.support_copy SimpleGraph.Walk.support_copy\n\ntheorem support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').support = p.support ++ p'.support.tail := by\n  induction p <;> cases p' <;> simp [*]\n#align simple_graph.walk.support_append SimpleGraph.Walk.support_append\n\n@[simp]\ntheorem support_reverse {u v : V} (p : G.Walk u v) : p.reverse.support = p.support.reverse := by\n  induction p <;> simp [support_append, *]\n#align simple_graph.walk.support_reverse SimpleGraph.Walk.support_reverse\n\n@[simp]\ntheorem support_ne_nil {u v : V} (p : G.Walk u v) : p.support \u2260 [] := by cases p <;> simp\n#align simple_graph.walk.support_ne_nil SimpleGraph.Walk.support_ne_nil\n\ntheorem tail_support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').support.tail = p.support.tail ++ p'.support.tail := by\n  rw [support_append, List.tail_append_of_ne_nil _ _ (support_ne_nil _)]\n#align simple_graph.walk.tail_support_append SimpleGraph.Walk.tail_support_append\n\ntheorem support_eq_cons {u v : V} (p : G.Walk u v) : p.support = u :: p.support.tail := by\n  cases p <;> simp\n#align simple_graph.walk.support_eq_cons SimpleGraph.Walk.support_eq_cons\n\n@[simp]\ntheorem start_mem_support {u v : V} (p : G.Walk u v) : u \u2208 p.support := by cases p <;> simp\n#align simple_graph.walk.start_mem_support SimpleGraph.Walk.start_mem_support\n\n@[simp]\ntheorem end_mem_support {u v : V} (p : G.Walk u v) : v \u2208 p.support := by induction p <;> simp [*]\n#align simple_graph.walk.end_mem_support SimpleGraph.Walk.end_mem_support\n\n@[simp]\ntheorem support_nonempty {u v : V} (p : G.Walk u v) : { w | w \u2208 p.support }.Nonempty :=\n  \u27e8u, by simp\u27e9\n#align simple_graph.walk.support_nonempty SimpleGraph.Walk.support_nonempty\n\ntheorem mem_support_iff {u v w : V} (p : G.Walk u v) : w \u2208 p.support \u2194 w = u \u2228 w \u2208 p.support.tail :=\n  by cases p <;> simp\n#align simple_graph.walk.mem_support_iff SimpleGraph.Walk.mem_support_iff\n\ntheorem mem_support_nil_iff {u v : V} : u \u2208 (nil : G.Walk v v).support \u2194 u = v := by simp\n#align simple_graph.walk.mem_support_nil_iff SimpleGraph.Walk.mem_support_nil_iff\n\n@[simp]\ntheorem mem_tail_support_append_iff {t u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    t \u2208 (p.append p').support.tail \u2194 t \u2208 p.support.tail \u2228 t \u2208 p'.support.tail := by\n  rw [tail_support_append, List.mem_append]\n#align simple_graph.walk.mem_tail_support_append_iff SimpleGraph.Walk.mem_tail_support_append_iff\n\n@[simp]\ntheorem end_mem_tail_support_of_ne {u v : V} (h : u \u2260 v) (p : G.Walk u v) : v \u2208 p.support.tail := by\n  obtain \u27e8_, _, _, rfl\u27e9 := exists_eq_cons_of_ne h p\n  simp\n#align simple_graph.walk.end_mem_tail_support_of_ne SimpleGraph.Walk.end_mem_tail_support_of_ne\n\n@[simp, nolint unusedHavesSuffices]\ntheorem mem_support_append_iff {t u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    t \u2208 (p.append p').support \u2194 t \u2208 p.support \u2228 t \u2208 p'.support := by\n  simp only [mem_support_iff, mem_tail_support_append_iff]\n  obtain rfl | h := eq_or_ne t v <;> obtain rfl | h' := eq_or_ne t u <;>\n    -- this `have` triggers the unusedHavesSuffices linter:\n    (try have := h'.symm) <;> simp [*]\n#align simple_graph.walk.mem_support_append_iff SimpleGraph.Walk.mem_support_append_iff\n\n@[simp]\ntheorem subset_support_append_left {V : Type u} {G : SimpleGraph V} {u v w : V}\n    (p : G.Walk u v) (q : G.Walk v w) : p.support \u2286 (p.append q).support := by\n  simp only [Walk.support_append, List.subset_append_left]\n#align simple_graph.walk.subset_support_append_left SimpleGraph.Walk.subset_support_append_left\n\n@[simp]\ntheorem subset_support_append_right {V : Type u} {G : SimpleGraph V} {u v w : V}\n    (p : G.Walk u v) (q : G.Walk v w) : q.support \u2286 (p.append q).support := by\n  intro h\n  simp (config := { contextual := true }) only [mem_support_append_iff, or_true_iff, imp_true_iff]\n#align simple_graph.walk.subset_support_append_right SimpleGraph.Walk.subset_support_append_right\n\ntheorem coe_support {u v : V} (p : G.Walk u v) : (p.support : Multiset V) = {u} + p.support.tail :=\n  by cases p <;> rfl\n#align simple_graph.walk.coe_support SimpleGraph.Walk.coe_support\n\ntheorem coe_support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    ((p.append p').support : Multiset V) = {u} + p.support.tail + p'.support.tail := by\n  rw [support_append, \u2190 Multiset.coe_add, coe_support]\n#align simple_graph.walk.coe_support_append SimpleGraph.Walk.coe_support_append\n\ntheorem coe_support_append' [DecidableEq V] {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    ((p.append p').support : Multiset V) = p.support + p'.support - {v} := by\n  rw [support_append, \u2190 Multiset.coe_add]\n  simp only [coe_support]\n  rw [add_comm ({v} : Multiset V)]\n  simp only [\u2190 add_assoc, add_tsub_cancel_right]\n#align simple_graph.walk.coe_support_append' SimpleGraph.Walk.coe_support_append'\n\ntheorem chain_adj_support {u v w : V} (h : G.Adj u v) :\n    \u2200 (p : G.Walk v w), List.Chain G.Adj u p.support\n  | nil => List.Chain.cons h List.Chain.nil\n  | cons h' p => List.Chain.cons h (chain_adj_support h' p)\n#align simple_graph.walk.chain_adj_support SimpleGraph.Walk.chain_adj_support\n\ntheorem chain'_adj_support {u v : V} : \u2200 (p : G.Walk u v), List.Chain' G.Adj p.support\n  | nil => List.Chain.nil\n  | cons h p => chain_adj_support h p\n#align simple_graph.walk.chain'_adj_support SimpleGraph.Walk.chain'_adj_support\n\ntheorem chain_dartAdj_darts {d : G.Dart} {v w : V} (h : d.snd = v) (p : G.Walk v w) :\n    List.Chain G.DartAdj d p.darts := by\n  induction p generalizing d with\n  | nil => exact List.Chain.nil\n  -- Porting note: needed to defer `h` and `rfl` to help elaboration\n  | cons h' p ih => exact List.Chain.cons (by exact h) (ih (by rfl))\n#align simple_graph.walk.chain_dart_adj_darts SimpleGraph.Walk.chain_dartAdj_darts\n\ntheorem chain'_dartAdj_darts {u v : V} : \u2200 (p : G.Walk u v), List.Chain' G.DartAdj p.darts\n  | nil => trivial\n  -- Porting note: needed to defer `rfl` to help elaboration\n  | cons h p => chain_dartAdj_darts (by rfl) p\n#align simple_graph.walk.chain'_dart_adj_darts SimpleGraph.Walk.chain'_dartAdj_darts\n\n/-- Every edge in a walk's edge list is an edge of the graph.\nIt is written in this form (rather than using `\u2286`) to avoid unsightly coercions. -/\ntheorem edges_subset_edgeSet {u v : V} :\n    \u2200 (p : G.Walk u v) \u2983e : Sym2 V\u2984, e \u2208 p.edges \u2192 e \u2208 G.edgeSet\n  | cons h' p', e, h => by\n    cases h\n    \u00b7 exact h'\n    next h' => exact edges_subset_edgeSet p' h'\n#align simple_graph.walk.edges_subset_edge_set SimpleGraph.Walk.edges_subset_edgeSet\n\ntheorem adj_of_mem_edges {u v x y : V} (p : G.Walk u v) (h : s(x, y) \u2208 p.edges) : G.Adj x y :=\n  edges_subset_edgeSet p h\n#align simple_graph.walk.adj_of_mem_edges SimpleGraph.Walk.adj_of_mem_edges\n\n@[simp]\ntheorem darts_nil {u : V} : (nil : G.Walk u u).darts = [] := rfl\n#align simple_graph.walk.darts_nil SimpleGraph.Walk.darts_nil\n\n@[simp]\ntheorem darts_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).darts = \u27e8(u, v), h\u27e9 :: p.darts := rfl\n#align simple_graph.walk.darts_cons SimpleGraph.Walk.darts_cons\n\n@[simp]\ntheorem darts_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).darts = p.darts.concat \u27e8(v, w), h\u27e9 := by\n  induction p <;> simp [*, concat_nil]\n#align simple_graph.walk.darts_concat SimpleGraph.Walk.darts_concat\n\n@[simp]\ntheorem darts_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).darts = p.darts := by\n  subst_vars\n  rfl\n#align simple_graph.walk.darts_copy SimpleGraph.Walk.darts_copy\n\n@[simp]\ntheorem darts_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').darts = p.darts ++ p'.darts := by\n  induction p <;> simp [*]\n#align simple_graph.walk.darts_append SimpleGraph.Walk.darts_append\n\n@[simp]\ntheorem darts_reverse {u v : V} (p : G.Walk u v) :\n    p.reverse.darts = (p.darts.map Dart.symm).reverse := by\n  induction p <;> simp [*, Sym2.eq_swap]\n#align simple_graph.walk.darts_reverse SimpleGraph.Walk.darts_reverse\n\ntheorem mem_darts_reverse {u v : V} {d : G.Dart} {p : G.Walk u v} :\n    d \u2208 p.reverse.darts \u2194 d.symm \u2208 p.darts := by simp\n#align simple_graph.walk.mem_darts_reverse SimpleGraph.Walk.mem_darts_reverse\n\ntheorem cons_map_snd_darts {u v : V} (p : G.Walk u v) : (u :: p.darts.map (\u00b7.snd)) = p.support := by\n  induction p <;> simp! [*]\n#align simple_graph.walk.cons_map_snd_darts SimpleGraph.Walk.cons_map_snd_darts\n\ntheorem map_snd_darts {u v : V} (p : G.Walk u v) : p.darts.map (\u00b7.snd) = p.support.tail := by\n  simpa using congr_arg List.tail (cons_map_snd_darts p)\n#align simple_graph.walk.map_snd_darts SimpleGraph.Walk.map_snd_darts\n\ntheorem map_fst_darts_append {u v : V} (p : G.Walk u v) :\n    p.darts.map (\u00b7.fst) ++ [v] = p.support := by\n  induction p <;> simp! [*]\n#align simple_graph.walk.map_fst_darts_append SimpleGraph.Walk.map_fst_darts_append\n\ntheorem map_fst_darts {u v : V} (p : G.Walk u v) : p.darts.map (\u00b7.fst) = p.support.dropLast := by\n  simpa! using congr_arg List.dropLast (map_fst_darts_append p)\n#align simple_graph.walk.map_fst_darts SimpleGraph.Walk.map_fst_darts\n\n@[simp]\ntheorem edges_nil {u : V} : (nil : G.Walk u u).edges = [] := rfl\n#align simple_graph.walk.edges_nil SimpleGraph.Walk.edges_nil\n\n@[simp]\ntheorem edges_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).edges = s(u, v) :: p.edges := rfl\n#align simple_graph.walk.edges_cons SimpleGraph.Walk.edges_cons\n\n@[simp]\ntheorem edges_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).edges = p.edges.concat s(v, w) := by simp [edges]\n#align simple_graph.walk.edges_concat SimpleGraph.Walk.edges_concat\n\n@[simp]\ntheorem edges_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).edges = p.edges := by\n  subst_vars\n  rfl\n#align simple_graph.walk.edges_copy SimpleGraph.Walk.edges_copy\n\n@[simp]\ntheorem edges_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').edges = p.edges ++ p'.edges := by simp [edges]\n#align simple_graph.walk.edges_append SimpleGraph.Walk.edges_append\n\n@[simp]\ntheorem edges_reverse {u v : V} (p : G.Walk u v) : p.reverse.edges = p.edges.reverse := by\n  simp [edges, List.map_reverse]\n#align simple_graph.walk.edges_reverse SimpleGraph.Walk.edges_reverse\n\n@[simp]\ntheorem length_support {u v : V} (p : G.Walk u v) : p.support.length = p.length + 1 := by\n  induction p <;> simp [*]\n#align simple_graph.walk.length_support SimpleGraph.Walk.length_support\n\n@[simp]\ntheorem length_darts {u v : V} (p : G.Walk u v) : p.darts.length = p.length := by\n  induction p <;> simp [*]\n#align simple_graph.walk.length_darts SimpleGraph.Walk.length_darts\n\n@[simp]\ntheorem length_edges {u v : V} (p : G.Walk u v) : p.edges.length = p.length := by simp [edges]\n#align simple_graph.walk.length_edges SimpleGraph.Walk.length_edges\n\ntheorem dart_fst_mem_support_of_mem_darts {u v : V} :\n    \u2200 (p : G.Walk u v) {d : G.Dart}, d \u2208 p.darts \u2192 d.fst \u2208 p.support\n  | cons h p', d, hd => by\n    simp only [support_cons, darts_cons, List.mem_cons] at hd \u22a2\n    rcases hd with (rfl | hd)\n    \u00b7 exact Or.inl rfl\n    \u00b7 exact Or.inr (dart_fst_mem_support_of_mem_darts _ hd)\n#align simple_graph.walk.dart_fst_mem_support_of_mem_darts SimpleGraph.Walk.dart_fst_mem_support_of_mem_darts\n\ntheorem dart_snd_mem_support_of_mem_darts {u v : V} (p : G.Walk u v) {d : G.Dart}\n    (h : d \u2208 p.darts) : d.snd \u2208 p.support := by\n  simpa using p.reverse.dart_fst_mem_support_of_mem_darts (by simp [h] : d.symm \u2208 p.reverse.darts)\n#align simple_graph.walk.dart_snd_mem_support_of_mem_darts SimpleGraph.Walk.dart_snd_mem_support_of_mem_darts\n\ntheorem fst_mem_support_of_mem_edges {t u v w : V} (p : G.Walk v w) (he : s(t, u) \u2208 p.edges) :\n    t \u2208 p.support := by\n  obtain \u27e8d, hd, he\u27e9 := List.mem_map.mp he\n  rw [dart_edge_eq_mk'_iff'] at he\n  rcases he with (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n  \u00b7 exact dart_fst_mem_support_of_mem_darts _ hd\n  \u00b7 exact dart_snd_mem_support_of_mem_darts _ hd\n#align simple_graph.walk.fst_mem_support_of_mem_edges SimpleGraph.Walk.fst_mem_support_of_mem_edges\n\ntheorem snd_mem_support_of_mem_edges {t u v w : V} (p : G.Walk v w) (he : s(t, u) \u2208 p.edges) :\n    u \u2208 p.support := by\n  rw [Sym2.eq_swap] at he\n  exact p.fst_mem_support_of_mem_edges he\n#align simple_graph.walk.snd_mem_support_of_mem_edges SimpleGraph.Walk.snd_mem_support_of_mem_edges\n\ntheorem darts_nodup_of_support_nodup {u v : V} {p : G.Walk u v} (h : p.support.Nodup) :\n    p.darts.Nodup := by\n  induction p with\n  | nil => simp\n  | cons _ p' ih =>\n    simp only [darts_cons, support_cons, List.nodup_cons] at h \u22a2\n    exact \u27e8fun h' => h.1 (dart_fst_mem_support_of_mem_darts p' h'), ih h.2\u27e9\n#align simple_graph.walk.darts_nodup_of_support_nodup SimpleGraph.Walk.darts_nodup_of_support_nodup\n\ntheorem edges_nodup_of_support_nodup {u v : V} {p : G.Walk u v} (h : p.support.Nodup) :\n    p.edges.Nodup := by\n  induction p with\n  | nil => simp\n  | cons _ p' ih =>\n    simp only [edges_cons, support_cons, List.nodup_cons] at h \u22a2\n    exact \u27e8fun h' => h.1 (fst_mem_support_of_mem_edges p' h'), ih h.2\u27e9\n#align simple_graph.walk.edges_nodup_of_support_nodup SimpleGraph.Walk.edges_nodup_of_support_nodup\n\n/-- Predicate for the empty walk.\n\nSolves the dependent type problem where `p = G.Walk.nil` typechecks\nonly if `p` has defeq endpoints. -/\ninductive Nil : {v w : V} \u2192 G.Walk v w \u2192 Prop\n  | nil {u : V} : Nil (nil : G.Walk u u)\n\nvariable {u v w : V}\n\n@[simp] lemma nil_nil : (nil : G.Walk u u).Nil := Nil.nil\n\n@[simp] lemma not_nil_cons {h : G.Adj u v} {p : G.Walk v w} : \u00ac (cons h p).Nil := nofun\n\ninstance (p : G.Walk v w) : Decidable p.Nil :=\n  match p with\n  | nil => isTrue .nil\n  | cons _ _ => isFalse nofun\n\nprotected lemma Nil.eq {p : G.Walk v w} : p.Nil \u2192 v = w | .nil => rfl\n\nlemma not_nil_of_ne {p : G.Walk v w} : v \u2260 w \u2192 \u00ac p.Nil := mt Nil.eq\n\nlemma nil_iff_support_eq {p : G.Walk v w} : p.Nil \u2194 p.support = [v] := by\n  cases p <;> simp\n\nlemma nil_iff_length_eq {p : G.Walk v w} : p.Nil \u2194 p.length = 0 := by\n  cases p <;> simp\n\nlemma not_nil_iff {p : G.Walk v w} :\n    \u00ac p.Nil \u2194 \u2203 (u : V) (h : G.Adj v u) (q : G.Walk u w), p = cons h q := by\n  cases p <;> simp [*]\n\n@[elab_as_elim]\ndef notNilRec {motive : {u w : V} \u2192 (p : G.Walk u w) \u2192 (h : \u00ac p.Nil) \u2192 Sort*}\n    (cons : {u v w : V} \u2192 (h : G.Adj u v) \u2192 (q : G.Walk v w) \u2192 motive (cons h q) not_nil_cons)\n    (p : G.Walk u w) : (hp : \u00ac p.Nil) \u2192 motive p hp :=\n  match p with\n  | nil => fun hp => absurd .nil hp\n  | .cons h q => fun _ => cons h q\n\n/-- The second vertex along a non-nil walk. -/\ndef sndOfNotNil (p : G.Walk v w) (hp : \u00ac p.Nil) : V :=\n  p.notNilRec (@fun _ u _ _ _ => u) hp\n\n@[simp] lemma adj_sndOfNotNil {p : G.Walk v w} (hp : \u00ac p.Nil) :\n    G.Adj v (p.sndOfNotNil hp) :=\n  p.notNilRec (fun h _ => h) hp\n\n/-- The walk obtained by removing the first dart of a non-nil walk. -/\ndef tail (p : G.Walk u v) (hp : \u00ac p.Nil) : G.Walk (p.sndOfNotNil hp) v :=\n  p.notNilRec (fun _ q => q) hp\n\n/-- The first dart of a walk. -/\n@[simps]\ndef firstDart (p : G.Walk v w) (hp : \u00ac p.Nil) : G.Dart where\n  fst := v\n  snd := p.sndOfNotNil hp\n  is_adj := p.adj_sndOfNotNil hp\n\nlemma edge_firstDart (p : G.Walk v w) (hp : \u00ac p.Nil) :\n    (p.firstDart hp).edge = s(v, p.sndOfNotNil hp) := rfl\n\nvariable {x y : V} -- TODO: rename to u, v, w instead?\n\n@[simp] lemma cons_tail_eq (p : G.Walk x y) (hp : \u00ac p.Nil) :\n    cons (p.adj_sndOfNotNil hp) (p.tail hp) = p :=\n  p.notNilRec (fun _ _ => rfl) hp\n\n@[simp] lemma cons_support_tail (p : G.Walk x y) (hp : \u00ac p.Nil) :\n    x :: (p.tail hp).support = p.support := by\n  rw [\u2190 support_cons, cons_tail_eq]\n\n@[simp] lemma length_tail_add_one {p : G.Walk x y} (hp : \u00ac p.Nil) :\n    (p.tail hp).length + 1 = p.length := by\n  rw [\u2190 length_cons, cons_tail_eq]\n\n@[simp] lemma nil_copy {x' y' : V} {p : G.Walk x y} (hx : x = x') (hy : y = y') :\n    (p.copy hx hy).Nil = p.Nil := by\n  subst_vars; rfl\n\n/-! ### Trails, paths, circuits, cycles -/\n\n/-- A *trail* is a walk with no repeating edges. -/\n@[mk_iff isTrail_def]\nstructure IsTrail {u v : V} (p : G.Walk u v) : Prop where\n  edges_nodup : p.edges.Nodup\n#align simple_graph.walk.is_trail SimpleGraph.Walk.IsTrail\n#align simple_graph.walk.is_trail_def SimpleGraph.Walk.isTrail_def\n\n/-- A *path* is a walk with no repeating vertices.\nUse `SimpleGraph.Walk.IsPath.mk'` for a simpler constructor. -/\nstructure IsPath {u v : V} (p : G.Walk u v) extends IsTrail p : Prop where\n  support_nodup : p.support.Nodup\n#align simple_graph.walk.is_path SimpleGraph.Walk.IsPath\n\n-- Porting note: used to use `extends to_trail : is_trail p` in structure\nprotected lemma IsPath.isTrail {p : Walk G u v}(h : IsPath p) : IsTrail p := h.toIsTrail\n#align simple_graph.walk.is_path.to_trail SimpleGraph.Walk.IsPath.isTrail\n\n/-- A *circuit* at `u : V` is a nonempty trail beginning and ending at `u`. -/\n@[mk_iff isCircuit_def]\nstructure IsCircuit {u : V} (p : G.Walk u u) extends IsTrail p : Prop where\n  ne_nil : p \u2260 nil\n#align simple_graph.walk.is_circuit SimpleGraph.Walk.IsCircuit\n#align simple_graph.walk.is_circuit_def SimpleGraph.Walk.isCircuit_def\n\n-- Porting note: used to use `extends to_trail : is_trail p` in structure\nprotected lemma IsCircuit.isTrail {p : Walk G u u} (h : IsCircuit p) : IsTrail p := h.toIsTrail\n#align simple_graph.walk.is_circuit.to_trail SimpleGraph.Walk.IsCircuit.isTrail\n\n/-- A *cycle* at `u : V` is a circuit at `u` whose only repeating vertex\nis `u` (which appears exactly twice). -/\nstructure IsCycle {u : V} (p : G.Walk u u) extends IsCircuit p : Prop where\n  support_nodup : p.support.tail.Nodup\n#align simple_graph.walk.is_cycle SimpleGraph.Walk.IsCycle\n\n-- Porting note: used to use `extends to_circuit : is_circuit p` in structure\nprotected lemma IsCycle.isCircuit {p : Walk G u u} (h : IsCycle p) : IsCircuit p := h.toIsCircuit\n#align simple_graph.walk.is_cycle.to_circuit SimpleGraph.Walk.IsCycle.isCircuit\n\n@[simp]\ntheorem isTrail_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).IsTrail \u2194 p.IsTrail := by\n  subst_vars\n  rfl\n#align simple_graph.walk.is_trail_copy SimpleGraph.Walk.isTrail_copy\n\ntheorem IsPath.mk' {u v : V} {p : G.Walk u v} (h : p.support.Nodup) : p.IsPath :=\n  \u27e8\u27e8edges_nodup_of_support_nodup h\u27e9, h\u27e9\n#align simple_graph.walk.is_path.mk' SimpleGraph.Walk.IsPath.mk'\n\ntheorem isPath_def {u v : V} (p : G.Walk u v) : p.IsPath \u2194 p.support.Nodup :=\n  \u27e8IsPath.support_nodup, IsPath.mk'\u27e9\n#align simple_graph.walk.is_path_def SimpleGraph.Walk.isPath_def\n\n@[simp]\ntheorem isPath_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).IsPath \u2194 p.IsPath := by\n  subst_vars\n  rfl\n#align simple_graph.walk.is_path_copy SimpleGraph.Walk.isPath_copy\n\n@[simp]\ntheorem isCircuit_copy {u u'} (p : G.Walk u u) (hu : u = u') :\n    (p.copy hu hu).IsCircuit \u2194 p.IsCircuit := by\n  subst_vars\n  rfl\n#align simple_graph.walk.is_circuit_copy SimpleGraph.Walk.isCircuit_copy\n\ntheorem isCycle_def {u : V} (p : G.Walk u u) :\n    p.IsCycle \u2194 p.IsTrail \u2227 p \u2260 nil \u2227 p.support.tail.Nodup :=\n  Iff.intro (fun h => \u27e8h.1.1, h.1.2, h.2\u27e9) fun h => \u27e8\u27e8h.1, h.2.1\u27e9, h.2.2\u27e9\n#align simple_graph.walk.is_cycle_def SimpleGraph.Walk.isCycle_def\n\n@[simp]\ntheorem isCycle_copy {u u'} (p : G.Walk u u) (hu : u = u') :\n    (p.copy hu hu).IsCycle \u2194 p.IsCycle := by\n  subst_vars\n  rfl\n#align simple_graph.walk.is_cycle_copy SimpleGraph.Walk.isCycle_copy\n\n@[simp]\ntheorem IsTrail.nil {u : V} : (nil : G.Walk u u).IsTrail :=\n  \u27e8by simp [edges]\u27e9\n#align simple_graph.walk.is_trail.nil SimpleGraph.Walk.IsTrail.nil\n\ntheorem IsTrail.of_cons {u v w : V} {h : G.Adj u v} {p : G.Walk v w} :\n    (cons h p).IsTrail \u2192 p.IsTrail := by simp [isTrail_def]\n#align simple_graph.walk.is_trail.of_cons SimpleGraph.Walk.IsTrail.of_cons\n\n@[simp]\ntheorem cons_isTrail_iff {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).IsTrail \u2194 p.IsTrail \u2227 s(u, v) \u2209 p.edges := by simp [isTrail_def, and_comm]\n#align simple_graph.walk.cons_is_trail_iff SimpleGraph.Walk.cons_isTrail_iff\n\ntheorem IsTrail.reverse {u v : V} (p : G.Walk u v) (h : p.IsTrail) : p.reverse.IsTrail := by\n  simpa [isTrail_def] using h\n#align simple_graph.walk.is_trail.reverse SimpleGraph.Walk.IsTrail.reverse\n\n@[simp]\ntheorem reverse_isTrail_iff {u v : V} (p : G.Walk u v) : p.reverse.IsTrail \u2194 p.IsTrail := by\n  constructor <;>\n    \u00b7 intro h\n      convert h.reverse _\n      try rw [reverse_reverse]\n#align simple_graph.walk.reverse_is_trail_iff SimpleGraph.Walk.reverse_isTrail_iff\n\ntheorem IsTrail.of_append_left {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsTrail) : p.IsTrail := by\n  rw [isTrail_def, edges_append, List.nodup_append] at h\n  exact \u27e8h.1\u27e9\n#align simple_graph.walk.is_trail.of_append_left SimpleGraph.Walk.IsTrail.of_append_left\n\ntheorem IsTrail.of_append_right {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsTrail) : q.IsTrail := by\n  rw [isTrail_def, edges_append, List.nodup_append] at h\n  exact \u27e8h.2.1\u27e9\n#align simple_graph.walk.is_trail.of_append_right SimpleGraph.Walk.IsTrail.of_append_right\n\ntheorem IsTrail.count_edges_le_one [DecidableEq V] {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    (e : Sym2 V) : p.edges.count e \u2264 1 :=\n  List.nodup_iff_count_le_one.mp h.edges_nodup e\n#align simple_graph.walk.is_trail.count_edges_le_one SimpleGraph.Walk.IsTrail.count_edges_le_one\n\ntheorem IsTrail.count_edges_eq_one [DecidableEq V] {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    {e : Sym2 V} (he : e \u2208 p.edges) : p.edges.count e = 1 :=\n  List.count_eq_one_of_mem h.edges_nodup he\n#align simple_graph.walk.is_trail.count_edges_eq_one SimpleGraph.Walk.IsTrail.count_edges_eq_one\n\ntheorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath := by constructor <;> simp\n#align simple_graph.walk.is_path.nil SimpleGraph.Walk.IsPath.nil\n\ntheorem IsPath.of_cons {u v w : V} {h : G.Adj u v} {p : G.Walk v w} :\n    (cons h p).IsPath \u2192 p.IsPath := by simp [isPath_def]\n#align simple_graph.walk.is_path.of_cons SimpleGraph.Walk.IsPath.of_cons\n\n@[simp]\ntheorem cons_isPath_iff {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).IsPath \u2194 p.IsPath \u2227 u \u2209 p.support := by\n  constructor <;> simp (config := { contextual := true }) [isPath_def]\n#align simple_graph.walk.cons_is_path_iff SimpleGraph.Walk.cons_isPath_iff\n\nprotected lemma IsPath.cons {p : Walk G v w} (hp : p.IsPath) (hu : u \u2209 p.support) {h : G.Adj u v} :\n    (cons h p).IsPath :=\n  (cons_isPath_iff _ _).2 \u27e8hp, hu\u27e9\n\n@[simp]\ntheorem isPath_iff_eq_nil {u : V} (p : G.Walk u u) : p.IsPath \u2194 p = nil := by\n  cases p <;> simp [IsPath.nil]\n#align simple_graph.walk.is_path_iff_eq_nil SimpleGraph.Walk.isPath_iff_eq_nil\n\ntheorem IsPath.reverse {u v : V} {p : G.Walk u v} (h : p.IsPath) : p.reverse.IsPath := by\n  simpa [isPath_def] using h\n#align simple_graph.walk.is_path.reverse SimpleGraph.Walk.IsPath.reverse\n\n@[simp]\ntheorem isPath_reverse_iff {u v : V} (p : G.Walk u v) : p.reverse.IsPath \u2194 p.IsPath := by\n  constructor <;> intro h <;> convert h.reverse; simp\n#align simple_graph.walk.is_path_reverse_iff SimpleGraph.Walk.isPath_reverse_iff\n\ntheorem IsPath.of_append_left {u v w : V} {p : G.Walk u v} {q : G.Walk v w} :\n    (p.append q).IsPath \u2192 p.IsPath := by\n  simp only [isPath_def, support_append]\n  exact List.Nodup.of_append_left\n#align simple_graph.walk.is_path.of_append_left SimpleGraph.Walk.IsPath.of_append_left\n\ntheorem IsPath.of_append_right {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsPath) : q.IsPath := by\n  rw [\u2190 isPath_reverse_iff] at h \u22a2\n  rw [reverse_append] at h\n  apply h.of_append_left\n#align simple_graph.walk.is_path.of_append_right SimpleGraph.Walk.IsPath.of_append_right\n\n@[simp]\ntheorem IsCycle.not_of_nil {u : V} : \u00ac(nil : G.Walk u u).IsCycle := fun h => h.ne_nil rfl\n#align simple_graph.walk.is_cycle.not_of_nil SimpleGraph.Walk.IsCycle.not_of_nil\n\nlemma IsCycle.ne_bot : \u2200 {p : G.Walk u u}, p.IsCycle \u2192 G \u2260 \u22a5\n  | nil, hp => by cases hp.ne_nil rfl\n  | cons h _, hp => by rintro rfl; exact h\n\nlemma IsCycle.three_le_length {v : V} {p : G.Walk v v} (hp : p.IsCycle) : 3 \u2264 p.length := by\n  have \u27e8\u27e8hp, hp'\u27e9, _\u27e9 := hp\n  match p with\n  | .nil => simp at hp'\n  | .cons h .nil => simp at h\n  | .cons _ (.cons _ .nil) => simp at hp\n  | .cons _ (.cons _ (.cons _ _)) => simp_rw [SimpleGraph.Walk.length_cons]; omega\n\ntheorem cons_isCycle_iff {u v : V} (p : G.Walk v u) (h : G.Adj u v) :\n    (Walk.cons h p).IsCycle \u2194 p.IsPath \u2227 \u00acs(u, v) \u2208 p.edges := by\n  simp only [Walk.isCycle_def, Walk.isPath_def, Walk.isTrail_def, edges_cons, List.nodup_cons,\n    support_cons, List.tail_cons]\n  have : p.support.Nodup \u2192 p.edges.Nodup := edges_nodup_of_support_nodup\n  tauto\n#align simple_graph.walk.cons_is_cycle_iff SimpleGraph.Walk.cons_isCycle_iff\n\nlemma IsPath.tail {p : G.Walk u v} (hp : p.IsPath) (hp' : \u00ac p.Nil) : (p.tail hp').IsPath := by\n  rw [Walk.isPath_def] at hp \u22a2\n  rw [\u2190 cons_support_tail _ hp', List.nodup_cons] at hp\n  exact hp.2\n\n/-! ### About paths -/\n\ninstance [DecidableEq V] {u v : V} (p : G.Walk u v) : Decidable p.IsPath := by\n  rw [isPath_def]\n  infer_instance\n\ntheorem IsPath.length_lt [Fintype V] {u v : V} {p : G.Walk u v} (hp : p.IsPath) :\n    p.length < Fintype.card V := by\n  rw [Nat.lt_iff_add_one_le, \u2190 length_support]\n  exact hp.support_nodup.length_le_card\n#align simple_graph.walk.is_path.length_lt SimpleGraph.Walk.IsPath.length_lt\n\n\n/-! ### Walk decompositions -/\n\nsection WalkDecomp\n\nvariable [DecidableEq V]\n\n/-- Given a vertex in the support of a path, give the path up until (and including) that vertex. -/\ndef takeUntil {v w : V} : \u2200 (p : G.Walk v w) (u : V), u \u2208 p.support \u2192 G.Walk v u\n  | nil, u, h => by rw [mem_support_nil_iff.mp h]\n  | cons r p, u, h =>\n    if hx : v = u then\n      by subst u; exact Walk.nil\n    else\n      cons r (takeUntil p u <| by cases h; exact (hx rfl).elim; assumption)\n#align simple_graph.walk.take_until SimpleGraph.Walk.takeUntil\n\n/-- Given a vertex in the support of a path, give the path from (and including) that vertex to\nthe end. In other words, drop vertices from the front of a path until (and not including)\nthat vertex. -/\ndef dropUntil {v w : V} : \u2200 (p : G.Walk v w) (u : V), u \u2208 p.support \u2192 G.Walk u w\n  | nil, u, h => by rw [mem_support_nil_iff.mp h]\n  | cons r p, u, h =>\n    if hx : v = u then by\n      subst u\n      exact cons r p\n    else dropUntil p u <| by cases h; exact (hx rfl).elim; assumption\n#align simple_graph.walk.drop_until SimpleGraph.Walk.dropUntil\n\n/-- The `takeUntil` and `dropUntil` functions split a walk into two pieces.\nThe lemma `SimpleGraph.Walk.count_support_takeUntil_eq_one` specifies where this split occurs. -/\n@[simp]\ntheorem take_spec {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).append (p.dropUntil u h) = p := by\n  induction p\n  \u00b7 rw [mem_support_nil_iff] at h\n    subst u\n    rfl\n  \u00b7 cases h\n    \u00b7 simp!\n    \u00b7 simp! only\n      split_ifs with h' <;> subst_vars <;> simp [*]\n#align simple_graph.walk.take_spec SimpleGraph.Walk.take_spec\n\ntheorem mem_support_iff_exists_append {V : Type u} {G : SimpleGraph V} {u v w : V}\n    {p : G.Walk u v} : w \u2208 p.support \u2194 \u2203 (q : G.Walk u w) (r : G.Walk w v), p = q.append r := by\n  classical\n  constructor\n  \u00b7 exact fun h => \u27e8_, _, (p.take_spec h).symm\u27e9\n  \u00b7 rintro \u27e8q, r, rfl\u27e9\n    simp only [mem_support_append_iff, end_mem_support, start_mem_support, or_self_iff]\n#align simple_graph.walk.mem_support_iff_exists_append SimpleGraph.Walk.mem_support_iff_exists_append\n\n@[simp]\ntheorem count_support_takeUntil_eq_one {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).support.count u = 1 := by\n  induction p\n  \u00b7 rw [mem_support_nil_iff] at h\n    subst u\n    simp!\n  \u00b7 cases h\n    \u00b7 simp!\n    \u00b7 simp! only\n      split_ifs with h' <;> rw [eq_comm] at h' <;> subst_vars <;> simp! [*, List.count_cons]\n#align simple_graph.walk.count_support_take_until_eq_one SimpleGraph.Walk.count_support_takeUntil_eq_one\n\ntheorem count_edges_takeUntil_le_one {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) (x : V) :\n    (p.takeUntil u h).edges.count s(u, x) \u2264 1 := by\n  induction' p with u' u' v' w' ha p' ih\n  \u00b7 rw [mem_support_nil_iff] at h\n    subst u\n    simp!\n  \u00b7 cases h\n    \u00b7 simp!\n    \u00b7 simp! only\n      split_ifs with h'\n      \u00b7 subst h'\n        simp\n      \u00b7 rw [edges_cons, List.count_cons]\n        split_ifs with h''\n        \u00b7 rw [Sym2.eq_iff] at h''\n          obtain \u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9 := h''\n          \u00b7 exact (h' rfl).elim\n          \u00b7 cases p' <;> simp!\n        \u00b7 apply ih\n#align simple_graph.walk.count_edges_take_until_le_one SimpleGraph.Walk.count_edges_takeUntil_le_one\n\n@[simp]\ntheorem takeUntil_copy {u v w v' w'} (p : G.Walk v w) (hv : v = v') (hw : w = w')\n    (h : u \u2208 (p.copy hv hw).support) :\n    (p.copy hv hw).takeUntil u h = (p.takeUntil u (by subst_vars; exact h)).copy hv rfl := by\n  subst_vars\n  rfl\n#align simple_graph.walk.take_until_copy SimpleGraph.Walk.takeUntil_copy\n\n@[simp]\ntheorem dropUntil_copy {u v w v' w'} (p : G.Walk v w) (hv : v = v') (hw : w = w')\n    (h : u \u2208 (p.copy hv hw).support) :\n    (p.copy hv hw).dropUntil u h = (p.dropUntil u (by subst_vars; exact h)).copy rfl hw := by\n  subst_vars\n  rfl\n#align simple_graph.walk.drop_until_copy SimpleGraph.Walk.dropUntil_copy\n\ntheorem support_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).support \u2286 p.support := fun x hx => by\n  rw [\u2190 take_spec p h, mem_support_append_iff]\n  exact Or.inl hx\n#align simple_graph.walk.support_take_until_subset SimpleGraph.Walk.support_takeUntil_subset\n\ntheorem support_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.dropUntil u h).support \u2286 p.support := fun x hx => by\n  rw [\u2190 take_spec p h, mem_support_append_iff]\n  exact Or.inr hx\n#align simple_graph.walk.support_drop_until_subset SimpleGraph.Walk.support_dropUntil_subset\n\ntheorem darts_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).darts \u2286 p.darts := fun x hx => by\n  rw [\u2190 take_spec p h, darts_append, List.mem_append]\n  exact Or.inl hx\n#align simple_graph.walk.darts_take_until_subset SimpleGraph.Walk.darts_takeUntil_subset\n\ntheorem darts_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.dropUntil u h).darts \u2286 p.darts := fun x hx => by\n  rw [\u2190 take_spec p h, darts_append, List.mem_append]\n  exact Or.inr hx\n#align simple_graph.walk.darts_drop_until_subset SimpleGraph.Walk.darts_dropUntil_subset\n\ntheorem edges_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).edges \u2286 p.edges :=\n  List.map_subset _ (p.darts_takeUntil_subset h)\n#align simple_graph.walk.edges_take_until_subset SimpleGraph.Walk.edges_takeUntil_subset\n\ntheorem edges_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.dropUntil u h).edges \u2286 p.edges :=\n  List.map_subset _ (p.darts_dropUntil_subset h)\n#align simple_graph.walk.edges_drop_until_subset SimpleGraph.Walk.edges_dropUntil_subset\n\ntheorem length_takeUntil_le {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).length \u2264 p.length := by\n  have := congr_arg Walk.length (p.take_spec h)\n  rw [length_append] at this\n  exact Nat.le.intro this\n#align simple_graph.walk.length_take_until_le SimpleGraph.Walk.length_takeUntil_le\n\ntheorem length_dropUntil_le {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.dropUntil u h).length \u2264 p.length := by\n  have := congr_arg Walk.length (p.take_spec h)\n  rw [length_append, add_comm] at this\n  exact Nat.le.intro this\n#align simple_graph.walk.length_drop_until_le SimpleGraph.Walk.length_dropUntil_le\n\nprotected theorem IsTrail.takeUntil {u v w : V} {p : G.Walk v w} (hc : p.IsTrail)\n    (h : u \u2208 p.support) : (p.takeUntil u h).IsTrail :=\n  IsTrail.of_append_left (by rwa [\u2190 take_spec _ h] at hc)\n#align simple_graph.walk.is_trail.take_until SimpleGraph.Walk.IsTrail.takeUntil\n\nprotected theorem IsTrail.dropUntil {u v w : V} {p : G.Walk v w} (hc : p.IsTrail)\n    (h : u \u2208 p.support) : (p.dropUntil u h).IsTrail :=\n  IsTrail.of_append_right (by rwa [\u2190 take_spec _ h] at hc)\n#align simple_graph.walk.is_trail.drop_until SimpleGraph.Walk.IsTrail.dropUntil\n\nprotected theorem IsPath.takeUntil {u v w : V} {p : G.Walk v w} (hc : p.IsPath)\n    (h : u \u2208 p.support) : (p.takeUntil u h).IsPath :=\n  IsPath.of_append_left (by rwa [\u2190 take_spec _ h] at hc)\n#align simple_graph.walk.is_path.take_until SimpleGraph.Walk.IsPath.takeUntil\n\n-- Porting note: p was previously accidentally an explicit argument\nprotected theorem IsPath.dropUntil {u v w : V} {p : G.Walk v w} (hc : p.IsPath)\n    (h : u \u2208 p.support) : (p.dropUntil u h).IsPath :=\n  IsPath.of_append_right (by rwa [\u2190 take_spec _ h] at hc)\n#align simple_graph.walk.is_path.drop_until SimpleGraph.Walk.IsPath.dropUntil\n\n/-- Rotate a loop walk such that it is centered at the given vertex. -/\ndef rotate {u v : V} (c : G.Walk v v) (h : u \u2208 c.support) : G.Walk u u :=\n  (c.dropUntil u h).append (c.takeUntil u h)\n#align simple_graph.walk.rotate SimpleGraph.Walk.rotate\n\n@[simp]\ntheorem support_rotate {u v : V} (c : G.Walk v v) (h : u \u2208 c.support) :\n    (c.rotate h).support.tail ~r c.support.tail := by\n  simp only [rotate, tail_support_append]\n  apply List.IsRotated.trans List.isRotated_append\n  rw [\u2190 tail_support_append, take_spec]\n#align simple_graph.walk.support_rotate SimpleGraph.Walk.support_rotate\n\ntheorem rotate_darts {u v : V} (c : G.Walk v v) (h : u \u2208 c.support) :\n    (c.rotate h).darts ~r c.darts := by\n  simp only [rotate, darts_append]\n  apply List.IsRotated.trans List.isRotated_append\n  rw [\u2190 darts_append, take_spec]\n#align simple_graph.walk.rotate_darts SimpleGraph.Walk.rotate_darts\n\ntheorem rotate_edges {u v : V} (c : G.Walk v v) (h : u \u2208 c.support) :\n    (c.rotate h).edges ~r c.edges :=\n  (rotate_darts c h).map _\n#align simple_graph.walk.rotate_edges SimpleGraph.Walk.rotate_edges\n\nprotected theorem IsTrail.rotate {u v : V} {c : G.Walk v v} (hc : c.IsTrail) (h : u \u2208 c.support) :\n    (c.rotate h).IsTrail := by\n  rw [isTrail_def, (c.rotate_edges h).perm.nodup_iff]\n  exact hc.edges_nodup\n#align simple_graph.walk.is_trail.rotate SimpleGraph.Walk.IsTrail.rotate\n\nprotected theorem IsCircuit.rotate {u v : V} {c : G.Walk v v} (hc : c.IsCircuit)\n    (h : u \u2208 c.support) : (c.rotate h).IsCircuit := by\n  refine \u27e8hc.isTrail.rotate _, ?_\u27e9\n  cases c\n  \u00b7 exact (hc.ne_nil rfl).elim\n  \u00b7 intro hn\n    have hn' := congr_arg length hn\n    rw [rotate, length_append, add_comm, \u2190 length_append, take_spec] at hn'\n    simp at hn'\n#align simple_graph.walk.is_circuit.rotate SimpleGraph.Walk.IsCircuit.rotate\n\nprotected theorem IsCycle.rotate {u v : V} {c : G.Walk v v} (hc : c.IsCycle) (h : u \u2208 c.support) :\n    (c.rotate h).IsCycle := by\n  refine \u27e8hc.isCircuit.rotate _, ?_\u27e9\n  rw [List.IsRotated.nodup_iff (support_rotate _ _)]\n  exact hc.support_nodup\n#align simple_graph.walk.is_cycle.rotate SimpleGraph.Walk.IsCycle.rotate\n\nend WalkDecomp\n\n/-- Given a set `S` and a walk `w` from `u` to `v` such that `u \u2208 S` but `v \u2209 S`,\nthere exists a dart in the walk whose start is in `S` but whose end is not. -/\ntheorem exists_boundary_dart {u v : V} (p : G.Walk u v) (S : Set V) (uS : u \u2208 S) (vS : v \u2209 S) :\n    \u2203 d : G.Dart, d \u2208 p.darts \u2227 d.fst \u2208 S \u2227 d.snd \u2209 S := by\n  induction' p with _ x y w a p' ih\n  \u00b7 cases vS uS\n  \u00b7 by_cases h : y \u2208 S\n    \u00b7 obtain \u27e8d, hd, hcd\u27e9 := ih h vS\n      exact \u27e8d, List.Mem.tail _ hd, hcd\u27e9\n    \u00b7 exact \u27e8\u27e8(x, y), a\u27e9, List.Mem.head _, uS, h\u27e9\n#align simple_graph.walk.exists_boundary_dart SimpleGraph.Walk.exists_boundary_dart\n\nend Walk\n\n\n/-! ### Type of paths -/\n\n/-- The type for paths between two vertices. -/\nabbrev Path (u v : V) := { p : G.Walk u v // p.IsPath }\n#align simple_graph.path SimpleGraph.Path\n\nnamespace Path\n\nvariable {G G'}\n\n@[simp]\nprotected theorem isPath {u v : V} (p : G.Path u v) : (p : G.Walk u v).IsPath := p.property\n#align simple_graph.path.is_path SimpleGraph.Path.isPath\n\n@[simp]\nprotected theorem isTrail {u v : V} (p : G.Path u v) : (p : G.Walk u v).IsTrail :=\n  p.property.isTrail\n#align simple_graph.path.is_trail SimpleGraph.Path.isTrail\n\n/-- The length-0 path at a vertex. -/\n@[refl, simps]\nprotected def nil {u : V} : G.Path u u :=\n  \u27e8Walk.nil, Walk.IsPath.nil\u27e9\n#align simple_graph.path.nil SimpleGraph.Path.nil\n\n/-- The length-1 path between a pair of adjacent vertices. -/\n@[simps]\ndef singleton {u v : V} (h : G.Adj u v) : G.Path u v :=\n  \u27e8Walk.cons h Walk.nil, by simp [h.ne]\u27e9\n#align simple_graph.path.singleton SimpleGraph.Path.singleton\n\ntheorem mk'_mem_edges_singleton {u v : V} (h : G.Adj u v) :\n    s(u, v) \u2208 (singleton h : G.Walk u v).edges := by simp [singleton]\n#align simple_graph.path.mk_mem_edges_singleton SimpleGraph.Path.mk'_mem_edges_singleton\n\n/-- The reverse of a path is another path.  See also `SimpleGraph.Walk.reverse`. -/\n@[symm, simps]\ndef reverse {u v : V} (p : G.Path u v) : G.Path v u :=\n  \u27e8Walk.reverse p, p.property.reverse\u27e9\n#align simple_graph.path.reverse SimpleGraph.Path.reverse\n\ntheorem count_support_eq_one [DecidableEq V] {u v w : V} {p : G.Path u v}\n    (hw : w \u2208 (p : G.Walk u v).support) : (p : G.Walk u v).support.count w = 1 :=\n  List.count_eq_one_of_mem p.property.support_nodup hw\n#align simple_graph.path.count_support_eq_one SimpleGraph.Path.count_support_eq_one\n\ntheorem count_edges_eq_one [DecidableEq V] {u v : V} {p : G.Path u v} (e : Sym2 V)\n    (hw : e \u2208 (p : G.Walk u v).edges) : (p : G.Walk u v).edges.count e = 1 :=\n  List.count_eq_one_of_mem p.property.isTrail.edges_nodup hw\n#align simple_graph.path.count_edges_eq_one SimpleGraph.Path.count_edges_eq_one\n\n@[simp]\ntheorem nodup_support {u v : V} (p : G.Path u v) : (p : G.Walk u v).support.Nodup :=\n  (Walk.isPath_def _).mp p.property\n#align simple_graph.path.nodup_support SimpleGraph.Path.nodup_support\n\ntheorem loop_eq {v : V} (p : G.Path v v) : p = Path.nil := by\n  obtain \u27e8_ | _, h\u27e9 := p\n  \u00b7 rfl\n  \u00b7 simp at h\n#align simple_graph.path.loop_eq SimpleGraph.Path.loop_eq\n\ntheorem not_mem_edges_of_loop {v : V} {e : Sym2 V} {p : G.Path v v} : \u00ace \u2208 (p : G.Walk v v).edges :=\n  by simp [p.loop_eq]\n#align simple_graph.path.not_mem_edges_of_loop SimpleGraph.Path.not_mem_edges_of_loop\n\ntheorem cons_isCycle {u v : V} (p : G.Path v u) (h : G.Adj u v)\n    (he : \u00acs(u, v) \u2208 (p : G.Walk v u).edges) : (Walk.cons h \u2191p).IsCycle := by\n  simp [Walk.isCycle_def, Walk.cons_isTrail_iff, he]\n#align simple_graph.path.cons_is_cycle SimpleGraph.Path.cons_isCycle\n\nend Path\n\n\n/-! ### Walks to paths -/\n\nnamespace Walk\n\nvariable {G} [DecidableEq V]\n\n/-- Given a walk, produces a walk from it by bypassing subwalks between repeated vertices.\nThe result is a path, as shown in `SimpleGraph.Walk.bypass_isPath`.\nThis is packaged up in `SimpleGraph.Walk.toPath`. -/\ndef bypass {u v : V} : G.Walk u v \u2192 G.Walk u v\n  | nil => nil\n  | cons ha p =>\n    let p' := p.bypass\n    if hs : u \u2208 p'.support then\n      p'.dropUntil u hs\n    else\n      cons ha p'\n#align simple_graph.walk.bypass SimpleGraph.Walk.bypass\n\n@[simp]\ntheorem bypass_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).bypass = p.bypass.copy hu hv := by\n  subst_vars\n  rfl\n#align simple_graph.walk.bypass_copy SimpleGraph.Walk.bypass_copy\n\ntheorem bypass_isPath {u v : V} (p : G.Walk u v) : p.bypass.IsPath := by\n  induction p with\n  | nil => simp!\n  | cons _ p' ih =>\n    simp only [bypass]\n    split_ifs with hs\n    \u00b7 exact ih.dropUntil hs\n    \u00b7 simp [*, cons_isPath_iff]\n#align simple_graph.walk.bypass_is_path SimpleGraph.Walk.bypass_isPath\n\ntheorem length_bypass_le {u v : V} (p : G.Walk u v) : p.bypass.length \u2264 p.length := by\n  induction p with\n  | nil => rfl\n  | cons _ _ ih =>\n    simp only [bypass]\n    split_ifs\n    \u00b7 trans\n      apply length_dropUntil_le\n      rw [length_cons]\n      exact le_add_right ih\n    \u00b7 rw [length_cons, length_cons]\n      exact add_le_add_right ih 1\n#align simple_graph.walk.length_bypass_le SimpleGraph.Walk.length_bypass_le\n\n", "theoremStatement": "lemma bypass_eq_self_of_length_le {u v : V} (p : G.Walk u v) (h : p.length \u2264 p.bypass.length) :\n    p.bypass = p", "theoremName": "bypass_eq_self_of_length_le", "fileCreated": {"commit": "67ba3174dc", "date": "2023-03-01"}, "theoremCreated": {"commit": "2e8aeee458", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "positionMetadata": {"lineInFile": 1479, "tokenPositionInFile": 60347, "theoremPositionInFile": 202}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  induction p with\n  | nil => rfl\n  | cons h p ih =>\n    simp only [Walk.bypass]\n    split_ifs with hb\n    \u00b7 exfalso\n      simp only [hb, Walk.bypass, Walk.length_cons, dif_pos] at h\n      apply Nat.not_succ_le_self p.length\n      calc p.length + 1\n        _ \u2264 (p.bypass.dropUntil _ _).length := h\n        _ \u2264 p.bypass.length := Walk.length_dropUntil_le p.bypass hb\n        _ \u2264 p.length := Walk.length_bypass_le _\n    \u00b7 simp only [hb, Walk.bypass, Walk.length_cons, not_false_iff, dif_neg, add_le_add_iff_right]\n       at h\n      rw [ih h]", "proofType": "tactic", "proofLengthLines": 16, "proofLengthTokens": 542}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller, Vincent Beffara\n-/\nimport Mathlib.Combinatorics.SimpleGraph.Connectivity\nimport Mathlib.Data.Nat.Lattice\n\n#align_import combinatorics.simple_graph.metric from \"leanprover-community/mathlib\"@\"352ecfe114946c903338006dd3287cb5a9955ff2\"\n\n/-!\n# Graph metric\n\nThis module defines the `SimpleGraph.dist` function, which takes\npairs of vertices to the length of the shortest walk between them.\n\n## Main definitions\n\n- `SimpleGraph.dist` is the graph metric.\n\n## Todo\n\n- Provide an additional computable version of `SimpleGraph.dist`\n  for when `G` is connected.\n\n- Evaluate `Nat` vs `ENat` for the codomain of `dist`, or potentially\n  having an additional `edist` when the objects under consideration are\n  disconnected graphs.\n\n- When directed graphs exist, a directed notion of distance,\n  likely `ENat`-valued.\n\n## Tags\n\ngraph metric, distance\n\n-/\n\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V)\n\n/-! ## Metric -/\n\n\n/-- The distance between two vertices is the length of the shortest walk between them.\nIf no such walk exists, this uses the junk value of `0`. -/\nnoncomputable def dist (u v : V) : \u2115 :=\n  sInf (Set.range (Walk.length : G.Walk u v \u2192 \u2115))\n#align simple_graph.dist SimpleGraph.dist\n\nvariable {G}\n\nprotected theorem Reachable.exists_walk_of_dist {u v : V} (hr : G.Reachable u v) :\n    \u2203 p : G.Walk u v, p.length = G.dist u v :=\n  Nat.sInf_mem (Set.range_nonempty_iff_nonempty.mpr hr)\n#align simple_graph.reachable.exists_walk_of_dist SimpleGraph.Reachable.exists_walk_of_dist\n\nprotected theorem Connected.exists_walk_of_dist (hconn : G.Connected) (u v : V) :\n    \u2203 p : G.Walk u v, p.length = G.dist u v :=\n  (hconn u v).exists_walk_of_dist\n#align simple_graph.connected.exists_walk_of_dist SimpleGraph.Connected.exists_walk_of_dist\n\ntheorem dist_le {u v : V} (p : G.Walk u v) : G.dist u v \u2264 p.length :=\n  Nat.sInf_le \u27e8p, rfl\u27e9\n#align simple_graph.dist_le SimpleGraph.dist_le\n\n@[simp]\ntheorem dist_eq_zero_iff_eq_or_not_reachable {u v : V} :\n    G.dist u v = 0 \u2194 u = v \u2228 \u00acG.Reachable u v := by simp [dist, Nat.sInf_eq_zero, Reachable]\n#align simple_graph.dist_eq_zero_iff_eq_or_not_reachable SimpleGraph.dist_eq_zero_iff_eq_or_not_reachable\n\ntheorem dist_self {v : V} : dist G v v = 0 := by simp\n#align simple_graph.dist_self SimpleGraph.dist_self\n\nprotected theorem Reachable.dist_eq_zero_iff {u v : V} (hr : G.Reachable u v) :\n    G.dist u v = 0 \u2194 u = v := by simp [hr]\n#align simple_graph.reachable.dist_eq_zero_iff SimpleGraph.Reachable.dist_eq_zero_iff\n\nprotected theorem Reachable.pos_dist_of_ne {u v : V} (h : G.Reachable u v) (hne : u \u2260 v) :\n    0 < G.dist u v :=\n  Nat.pos_of_ne_zero (by simp [h, hne])\n#align simple_graph.reachable.pos_dist_of_ne SimpleGraph.Reachable.pos_dist_of_ne\n\nprotected theorem Connected.dist_eq_zero_iff (hconn : G.Connected) {u v : V} :\n    G.dist u v = 0 \u2194 u = v := by simp [hconn u v]\n#align simple_graph.connected.dist_eq_zero_iff SimpleGraph.Connected.dist_eq_zero_iff\n\nprotected theorem Connected.pos_dist_of_ne {u v : V} (hconn : G.Connected) (hne : u \u2260 v) :\n    0 < G.dist u v :=\n  Nat.pos_of_ne_zero (by intro h; exact False.elim (hne (hconn.dist_eq_zero_iff.mp h)))\n#align simple_graph.connected.pos_dist_of_ne SimpleGraph.Connected.pos_dist_of_ne\n\ntheorem dist_eq_zero_of_not_reachable {u v : V} (h : \u00acG.Reachable u v) : G.dist u v = 0 := by\n  simp [h]\n#align simple_graph.dist_eq_zero_of_not_reachable SimpleGraph.dist_eq_zero_of_not_reachable\n\ntheorem nonempty_of_pos_dist {u v : V} (h : 0 < G.dist u v) :\n    (Set.univ : Set (G.Walk u v)).Nonempty := by\n  simpa [Set.range_nonempty_iff_nonempty, Set.nonempty_iff_univ_nonempty] using\n    Nat.nonempty_of_pos_sInf h\n#align simple_graph.nonempty_of_pos_dist SimpleGraph.nonempty_of_pos_dist\n\nprotected theorem Connected.dist_triangle (hconn : G.Connected) {u v w : V} :\n    G.dist u w \u2264 G.dist u v + G.dist v w := by\n  obtain \u27e8p, hp\u27e9 := hconn.exists_walk_of_dist u v\n  obtain \u27e8q, hq\u27e9 := hconn.exists_walk_of_dist v w\n  rw [\u2190 hp, \u2190 hq, \u2190 Walk.length_append]\n  apply dist_le\n#align simple_graph.connected.dist_triangle SimpleGraph.Connected.dist_triangle\n\nprivate theorem dist_comm_aux {u v : V} (h : G.Reachable u v) : G.dist u v \u2264 G.dist v u := by\n  obtain \u27e8p, hp\u27e9 := h.symm.exists_walk_of_dist\n  rw [\u2190 hp, \u2190 Walk.length_reverse]\n  apply dist_le\n\ntheorem dist_comm {u v : V} : G.dist u v = G.dist v u := by\n  by_cases h : G.Reachable u v\n  \u00b7 apply le_antisymm (dist_comm_aux h) (dist_comm_aux h.symm)\n  \u00b7 have h' : \u00acG.Reachable v u := fun h' => absurd h'.symm h\n    simp [h, h', dist_eq_zero_of_not_reachable]\n#align simple_graph.dist_comm SimpleGraph.dist_comm\n\n", "theoremStatement": "theorem Walk.isPath_of_length_eq_dist {u v : V} (p : G.Walk u v) (hp : p.length = G.dist u v) :\n    p.IsPath", "theoremName": "Walk.isPath_of_length_eq_dist", "fileCreated": {"commit": "c97ad7df79", "date": "2023-03-02"}, "theoremCreated": {"commit": "2e8aeee458", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "positionMetadata": {"lineInFile": 125, "tokenPositionInFile": 4730, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  classical\n  have : p.bypass = p := by\n    apply Walk.bypass_eq_self_of_length_le\n    calc p.length\n      _ = G.dist u v := hp\n      _ \u2264 p.bypass.length := dist_le p.bypass\n  rw [\u2190 this]\n  apply Walk.bypass_isPath", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 217}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller, Vincent Beffara\n-/\nimport Mathlib.Combinatorics.SimpleGraph.Connectivity\nimport Mathlib.Data.Nat.Lattice\n\n#align_import combinatorics.simple_graph.metric from \"leanprover-community/mathlib\"@\"352ecfe114946c903338006dd3287cb5a9955ff2\"\n\n/-!\n# Graph metric\n\nThis module defines the `SimpleGraph.dist` function, which takes\npairs of vertices to the length of the shortest walk between them.\n\n## Main definitions\n\n- `SimpleGraph.dist` is the graph metric.\n\n## Todo\n\n- Provide an additional computable version of `SimpleGraph.dist`\n  for when `G` is connected.\n\n- Evaluate `Nat` vs `ENat` for the codomain of `dist`, or potentially\n  having an additional `edist` when the objects under consideration are\n  disconnected graphs.\n\n- When directed graphs exist, a directed notion of distance,\n  likely `ENat`-valued.\n\n## Tags\n\ngraph metric, distance\n\n-/\n\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V)\n\n/-! ## Metric -/\n\n\n/-- The distance between two vertices is the length of the shortest walk between them.\nIf no such walk exists, this uses the junk value of `0`. -/\nnoncomputable def dist (u v : V) : \u2115 :=\n  sInf (Set.range (Walk.length : G.Walk u v \u2192 \u2115))\n#align simple_graph.dist SimpleGraph.dist\n\nvariable {G}\n\nprotected theorem Reachable.exists_walk_of_dist {u v : V} (hr : G.Reachable u v) :\n    \u2203 p : G.Walk u v, p.length = G.dist u v :=\n  Nat.sInf_mem (Set.range_nonempty_iff_nonempty.mpr hr)\n#align simple_graph.reachable.exists_walk_of_dist SimpleGraph.Reachable.exists_walk_of_dist\n\nprotected theorem Connected.exists_walk_of_dist (hconn : G.Connected) (u v : V) :\n    \u2203 p : G.Walk u v, p.length = G.dist u v :=\n  (hconn u v).exists_walk_of_dist\n#align simple_graph.connected.exists_walk_of_dist SimpleGraph.Connected.exists_walk_of_dist\n\ntheorem dist_le {u v : V} (p : G.Walk u v) : G.dist u v \u2264 p.length :=\n  Nat.sInf_le \u27e8p, rfl\u27e9\n#align simple_graph.dist_le SimpleGraph.dist_le\n\n@[simp]\ntheorem dist_eq_zero_iff_eq_or_not_reachable {u v : V} :\n    G.dist u v = 0 \u2194 u = v \u2228 \u00acG.Reachable u v := by simp [dist, Nat.sInf_eq_zero, Reachable]\n#align simple_graph.dist_eq_zero_iff_eq_or_not_reachable SimpleGraph.dist_eq_zero_iff_eq_or_not_reachable\n\ntheorem dist_self {v : V} : dist G v v = 0 := by simp\n#align simple_graph.dist_self SimpleGraph.dist_self\n\nprotected theorem Reachable.dist_eq_zero_iff {u v : V} (hr : G.Reachable u v) :\n    G.dist u v = 0 \u2194 u = v := by simp [hr]\n#align simple_graph.reachable.dist_eq_zero_iff SimpleGraph.Reachable.dist_eq_zero_iff\n\nprotected theorem Reachable.pos_dist_of_ne {u v : V} (h : G.Reachable u v) (hne : u \u2260 v) :\n    0 < G.dist u v :=\n  Nat.pos_of_ne_zero (by simp [h, hne])\n#align simple_graph.reachable.pos_dist_of_ne SimpleGraph.Reachable.pos_dist_of_ne\n\nprotected theorem Connected.dist_eq_zero_iff (hconn : G.Connected) {u v : V} :\n    G.dist u v = 0 \u2194 u = v := by simp [hconn u v]\n#align simple_graph.connected.dist_eq_zero_iff SimpleGraph.Connected.dist_eq_zero_iff\n\nprotected theorem Connected.pos_dist_of_ne {u v : V} (hconn : G.Connected) (hne : u \u2260 v) :\n    0 < G.dist u v :=\n  Nat.pos_of_ne_zero (by intro h; exact False.elim (hne (hconn.dist_eq_zero_iff.mp h)))\n#align simple_graph.connected.pos_dist_of_ne SimpleGraph.Connected.pos_dist_of_ne\n\ntheorem dist_eq_zero_of_not_reachable {u v : V} (h : \u00acG.Reachable u v) : G.dist u v = 0 := by\n  simp [h]\n#align simple_graph.dist_eq_zero_of_not_reachable SimpleGraph.dist_eq_zero_of_not_reachable\n\ntheorem nonempty_of_pos_dist {u v : V} (h : 0 < G.dist u v) :\n    (Set.univ : Set (G.Walk u v)).Nonempty := by\n  simpa [Set.range_nonempty_iff_nonempty, Set.nonempty_iff_univ_nonempty] using\n    Nat.nonempty_of_pos_sInf h\n#align simple_graph.nonempty_of_pos_dist SimpleGraph.nonempty_of_pos_dist\n\nprotected theorem Connected.dist_triangle (hconn : G.Connected) {u v w : V} :\n    G.dist u w \u2264 G.dist u v + G.dist v w := by\n  obtain \u27e8p, hp\u27e9 := hconn.exists_walk_of_dist u v\n  obtain \u27e8q, hq\u27e9 := hconn.exists_walk_of_dist v w\n  rw [\u2190 hp, \u2190 hq, \u2190 Walk.length_append]\n  apply dist_le\n#align simple_graph.connected.dist_triangle SimpleGraph.Connected.dist_triangle\n\nprivate theorem dist_comm_aux {u v : V} (h : G.Reachable u v) : G.dist u v \u2264 G.dist v u := by\n  obtain \u27e8p, hp\u27e9 := h.symm.exists_walk_of_dist\n  rw [\u2190 hp, \u2190 Walk.length_reverse]\n  apply dist_le\n\ntheorem dist_comm {u v : V} : G.dist u v = G.dist v u := by\n  by_cases h : G.Reachable u v\n  \u00b7 apply le_antisymm (dist_comm_aux h) (dist_comm_aux h.symm)\n  \u00b7 have h' : \u00acG.Reachable v u := fun h' => absurd h'.symm h\n    simp [h, h', dist_eq_zero_of_not_reachable]\n#align simple_graph.dist_comm SimpleGraph.dist_comm\n\ntheorem Walk.isPath_of_length_eq_dist {u v : V} (p : G.Walk u v) (hp : p.length = G.dist u v) :\n    p.IsPath := by\n  classical\n  have : p.bypass = p := by\n    apply Walk.bypass_eq_self_of_length_le\n    calc p.length\n      _ = G.dist u v := hp\n      _ \u2264 p.bypass.length := dist_le p.bypass\n  rw [\u2190 this]\n  apply Walk.bypass_isPath\n\n", "theoremStatement": "lemma Reachable.exists_path_of_dist {u v : V} (hr : G.Reachable u v) :\n    \u2203 (p : G.Walk u v), p.IsPath \u2227 p.length = G.dist u v", "theoremName": "Reachable.exists_path_of_dist", "fileCreated": {"commit": "c97ad7df79", "date": "2023-03-02"}, "theoremCreated": {"commit": "2e8aeee458", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "positionMetadata": {"lineInFile": 136, "tokenPositionInFile": 5061, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8p, h\u27e9 := hr.exists_walk_of_dist\n  exact \u27e8p, p.isPath_of_length_eq_dist h, h\u27e9", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 89}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller, Vincent Beffara\n-/\nimport Mathlib.Combinatorics.SimpleGraph.Connectivity\nimport Mathlib.Data.Nat.Lattice\n\n#align_import combinatorics.simple_graph.metric from \"leanprover-community/mathlib\"@\"352ecfe114946c903338006dd3287cb5a9955ff2\"\n\n/-!\n# Graph metric\n\nThis module defines the `SimpleGraph.dist` function, which takes\npairs of vertices to the length of the shortest walk between them.\n\n## Main definitions\n\n- `SimpleGraph.dist` is the graph metric.\n\n## Todo\n\n- Provide an additional computable version of `SimpleGraph.dist`\n  for when `G` is connected.\n\n- Evaluate `Nat` vs `ENat` for the codomain of `dist`, or potentially\n  having an additional `edist` when the objects under consideration are\n  disconnected graphs.\n\n- When directed graphs exist, a directed notion of distance,\n  likely `ENat`-valued.\n\n## Tags\n\ngraph metric, distance\n\n-/\n\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V)\n\n/-! ## Metric -/\n\n\n/-- The distance between two vertices is the length of the shortest walk between them.\nIf no such walk exists, this uses the junk value of `0`. -/\nnoncomputable def dist (u v : V) : \u2115 :=\n  sInf (Set.range (Walk.length : G.Walk u v \u2192 \u2115))\n#align simple_graph.dist SimpleGraph.dist\n\nvariable {G}\n\nprotected theorem Reachable.exists_walk_of_dist {u v : V} (hr : G.Reachable u v) :\n    \u2203 p : G.Walk u v, p.length = G.dist u v :=\n  Nat.sInf_mem (Set.range_nonempty_iff_nonempty.mpr hr)\n#align simple_graph.reachable.exists_walk_of_dist SimpleGraph.Reachable.exists_walk_of_dist\n\nprotected theorem Connected.exists_walk_of_dist (hconn : G.Connected) (u v : V) :\n    \u2203 p : G.Walk u v, p.length = G.dist u v :=\n  (hconn u v).exists_walk_of_dist\n#align simple_graph.connected.exists_walk_of_dist SimpleGraph.Connected.exists_walk_of_dist\n\ntheorem dist_le {u v : V} (p : G.Walk u v) : G.dist u v \u2264 p.length :=\n  Nat.sInf_le \u27e8p, rfl\u27e9\n#align simple_graph.dist_le SimpleGraph.dist_le\n\n@[simp]\ntheorem dist_eq_zero_iff_eq_or_not_reachable {u v : V} :\n    G.dist u v = 0 \u2194 u = v \u2228 \u00acG.Reachable u v := by simp [dist, Nat.sInf_eq_zero, Reachable]\n#align simple_graph.dist_eq_zero_iff_eq_or_not_reachable SimpleGraph.dist_eq_zero_iff_eq_or_not_reachable\n\ntheorem dist_self {v : V} : dist G v v = 0 := by simp\n#align simple_graph.dist_self SimpleGraph.dist_self\n\nprotected theorem Reachable.dist_eq_zero_iff {u v : V} (hr : G.Reachable u v) :\n    G.dist u v = 0 \u2194 u = v := by simp [hr]\n#align simple_graph.reachable.dist_eq_zero_iff SimpleGraph.Reachable.dist_eq_zero_iff\n\nprotected theorem Reachable.pos_dist_of_ne {u v : V} (h : G.Reachable u v) (hne : u \u2260 v) :\n    0 < G.dist u v :=\n  Nat.pos_of_ne_zero (by simp [h, hne])\n#align simple_graph.reachable.pos_dist_of_ne SimpleGraph.Reachable.pos_dist_of_ne\n\nprotected theorem Connected.dist_eq_zero_iff (hconn : G.Connected) {u v : V} :\n    G.dist u v = 0 \u2194 u = v := by simp [hconn u v]\n#align simple_graph.connected.dist_eq_zero_iff SimpleGraph.Connected.dist_eq_zero_iff\n\nprotected theorem Connected.pos_dist_of_ne {u v : V} (hconn : G.Connected) (hne : u \u2260 v) :\n    0 < G.dist u v :=\n  Nat.pos_of_ne_zero (by intro h; exact False.elim (hne (hconn.dist_eq_zero_iff.mp h)))\n#align simple_graph.connected.pos_dist_of_ne SimpleGraph.Connected.pos_dist_of_ne\n\ntheorem dist_eq_zero_of_not_reachable {u v : V} (h : \u00acG.Reachable u v) : G.dist u v = 0 := by\n  simp [h]\n#align simple_graph.dist_eq_zero_of_not_reachable SimpleGraph.dist_eq_zero_of_not_reachable\n\ntheorem nonempty_of_pos_dist {u v : V} (h : 0 < G.dist u v) :\n    (Set.univ : Set (G.Walk u v)).Nonempty := by\n  simpa [Set.range_nonempty_iff_nonempty, Set.nonempty_iff_univ_nonempty] using\n    Nat.nonempty_of_pos_sInf h\n#align simple_graph.nonempty_of_pos_dist SimpleGraph.nonempty_of_pos_dist\n\nprotected theorem Connected.dist_triangle (hconn : G.Connected) {u v w : V} :\n    G.dist u w \u2264 G.dist u v + G.dist v w := by\n  obtain \u27e8p, hp\u27e9 := hconn.exists_walk_of_dist u v\n  obtain \u27e8q, hq\u27e9 := hconn.exists_walk_of_dist v w\n  rw [\u2190 hp, \u2190 hq, \u2190 Walk.length_append]\n  apply dist_le\n#align simple_graph.connected.dist_triangle SimpleGraph.Connected.dist_triangle\n\nprivate theorem dist_comm_aux {u v : V} (h : G.Reachable u v) : G.dist u v \u2264 G.dist v u := by\n  obtain \u27e8p, hp\u27e9 := h.symm.exists_walk_of_dist\n  rw [\u2190 hp, \u2190 Walk.length_reverse]\n  apply dist_le\n\ntheorem dist_comm {u v : V} : G.dist u v = G.dist v u := by\n  by_cases h : G.Reachable u v\n  \u00b7 apply le_antisymm (dist_comm_aux h) (dist_comm_aux h.symm)\n  \u00b7 have h' : \u00acG.Reachable v u := fun h' => absurd h'.symm h\n    simp [h, h', dist_eq_zero_of_not_reachable]\n#align simple_graph.dist_comm SimpleGraph.dist_comm\n\ntheorem Walk.isPath_of_length_eq_dist {u v : V} (p : G.Walk u v) (hp : p.length = G.dist u v) :\n    p.IsPath := by\n  classical\n  have : p.bypass = p := by\n    apply Walk.bypass_eq_self_of_length_le\n    calc p.length\n      _ = G.dist u v := hp\n      _ \u2264 p.bypass.length := dist_le p.bypass\n  rw [\u2190 this]\n  apply Walk.bypass_isPath\n\nlemma Reachable.exists_path_of_dist {u v : V} (hr : G.Reachable u v) :\n    \u2203 (p : G.Walk u v), p.IsPath \u2227 p.length = G.dist u v := by\n  obtain \u27e8p, h\u27e9 := hr.exists_walk_of_dist\n  exact \u27e8p, p.isPath_of_length_eq_dist h, h\u27e9\n\n", "theoremStatement": "lemma Connected.exists_path_of_dist (hconn : G.Connected) (u v : V) :\n    \u2203 (p : G.Walk u v), p.IsPath \u2227 p.length = G.dist u v", "theoremName": "Connected.exists_path_of_dist", "fileCreated": {"commit": "c97ad7df79", "date": "2023-03-02"}, "theoremCreated": {"commit": "2e8aeee458", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Combinatorics/SimpleGraph/Metric.lean", "positionMetadata": {"lineInFile": 141, "tokenPositionInFile": 5283, "theoremPositionInFile": 17}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8p, h\u27e9 := hconn.exists_walk_of_dist u v\n  exact \u27e8p, p.isPath_of_length_eq_dist h, h\u27e9", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 96}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp, Yury Kudryashov\n-/\nimport Mathlib.Analysis.Convex.Combination\nimport Mathlib.Analysis.Convex.Strict\nimport Mathlib.Topology.Connected.PathConnected\nimport Mathlib.Topology.Algebra.Affine\nimport Mathlib.Topology.Algebra.Module.Basic\n\n#align_import analysis.convex.topology from \"leanprover-community/mathlib\"@\"0e3aacdc98d25e0afe035c452d876d28cbffaa7e\"\n\n/-!\n# Topological properties of convex sets\n\nWe prove the following facts:\n\n* `Convex.interior` : interior of a convex set is convex;\n* `Convex.closure` : closure of a convex set is convex;\n* `Set.Finite.isCompact_convexHull` : convex hull of a finite set is compact;\n* `Set.Finite.isClosed_convexHull` : convex hull of a finite set is closed.\n-/\n\nassert_not_exists Norm\n\nopen Metric Bornology Set Pointwise Convex\n\nvariable {\u03b9 \ud835\udd5c E : Type*}\n\ntheorem Real.convex_iff_isPreconnected {s : Set \u211d} : Convex \u211d s \u2194 IsPreconnected s :=\n  convex_iff_ordConnected.trans isPreconnected_iff_ordConnected.symm\n#align real.convex_iff_is_preconnected Real.convex_iff_isPreconnected\n\nalias \u27e8_, IsPreconnected.convex\u27e9 := Real.convex_iff_isPreconnected\n#align is_preconnected.convex IsPreconnected.convex\n\n/-! ### Standard simplex -/\n\n\nsection stdSimplex\n\nvariable [Fintype \u03b9]\n\n/-- Every vector in `stdSimplex \ud835\udd5c \u03b9` has `max`-norm at most `1`. -/\ntheorem stdSimplex_subset_closedBall : stdSimplex \u211d \u03b9 \u2286 Metric.closedBall 0 1 := fun f hf \u21a6 by\n  rw [Metric.mem_closedBall, dist_pi_le_iff zero_le_one]\n  intro x\n  rw [Pi.zero_apply, Real.dist_0_eq_abs, abs_of_nonneg <| hf.1 x]\n  exact (mem_Icc_of_mem_stdSimplex hf x).2\n#align std_simplex_subset_closed_ball stdSimplex_subset_closedBall\n\nvariable (\u03b9)\n\n/-- `stdSimplex \u211d \u03b9` is bounded. -/\ntheorem bounded_stdSimplex : IsBounded (stdSimplex \u211d \u03b9) :=\n  (Metric.isBounded_iff_subset_closedBall 0).2 \u27e81, stdSimplex_subset_closedBall\u27e9\n#align bounded_std_simplex bounded_stdSimplex\n\n/-- `stdSimplex \u211d \u03b9` is closed. -/\ntheorem isClosed_stdSimplex : IsClosed (stdSimplex \u211d \u03b9) :=\n  (stdSimplex_eq_inter \u211d \u03b9).symm \u25b8\n    IsClosed.inter (isClosed_iInter fun i => isClosed_le continuous_const (continuous_apply i))\n      (isClosed_eq (continuous_finset_sum _ fun x _ => continuous_apply x) continuous_const)\n#align is_closed_std_simplex isClosed_stdSimplex\n\n/-- `stdSimplex \u211d \u03b9` is compact. -/\ntheorem isCompact_stdSimplex : IsCompact (stdSimplex \u211d \u03b9) :=\n  Metric.isCompact_iff_isClosed_bounded.2 \u27e8isClosed_stdSimplex \u03b9, bounded_stdSimplex \u03b9\u27e9\n#align is_compact_std_simplex isCompact_stdSimplex\n\ninstance stdSimplex.instCompactSpace_coe : CompactSpace \u21a5(stdSimplex \u211d \u03b9) :=\n  isCompact_iff_compactSpace.mp <| isCompact_stdSimplex _\n\n/-- The standard one-dimensional simplex in `\u211d\u00b2 = Fin 2 \u2192 \u211d`\nis homeomorphic to the unit interval. -/\n@[simps! (config := .asFn)]\ndef stdSimplexHomeomorphUnitInterval : stdSimplex \u211d (Fin 2) \u2243\u209c unitInterval where\n  toEquiv := stdSimplexEquivIcc \u211d\n  continuous_toFun := .subtype_mk ((continuous_apply 0).comp continuous_subtype_val) _\n  continuous_invFun := by\n    apply Continuous.subtype_mk\n    exact (continuous_pi <| Fin.forall_fin_two.2\n      \u27e8continuous_subtype_val, continuous_const.sub continuous_subtype_val\u27e9)\n\nend stdSimplex\n\n/-! ### Topological vector spaces -/\nsection TopologicalSpace\n\nvariable [LinearOrderedRing \ud835\udd5c] [DenselyOrdered \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]\n  [AddCommGroup E] [TopologicalSpace E] [ContinuousAdd E] [Module \ud835\udd5c E] [ContinuousSMul \ud835\udd5c E]\n  {x y : E}\n\ntheorem segment_subset_closure_openSegment : [x -[\ud835\udd5c] y] \u2286 closure (openSegment \ud835\udd5c x y) := by\n  rw [segment_eq_image, openSegment_eq_image, \u2190 closure_Ioo (zero_ne_one' \ud835\udd5c)]\n  exact image_closure_subset_closure_image (by continuity)\n#align segment_subset_closure_open_segment segment_subset_closure_openSegment\n\nend TopologicalSpace\n\nsection PseudoMetricSpace\n\nvariable [LinearOrderedRing \ud835\udd5c] [DenselyOrdered \ud835\udd5c] [PseudoMetricSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]\n  [ProperSpace \ud835\udd5c] [CompactIccSpace \ud835\udd5c] [AddCommGroup E] [TopologicalSpace E] [T2Space E]\n  [ContinuousAdd E] [Module \ud835\udd5c E] [ContinuousSMul \ud835\udd5c E]\n\n@[simp]\ntheorem closure_openSegment (x y : E) : closure (openSegment \ud835\udd5c x y) = [x -[\ud835\udd5c] y] := by\n  rw [segment_eq_image, openSegment_eq_image, \u2190 closure_Ioo (zero_ne_one' \ud835\udd5c)]\n  exact (image_closure_of_isCompact (isBounded_Ioo _ _).isCompact_closure <|\n    Continuous.continuousOn <| by continuity).symm\n#align closure_open_segment closure_openSegment\n\nend PseudoMetricSpace\n\nsection ContinuousConstSMul\n\nvariable [LinearOrderedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]\n  [TopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]\n\n/-- If `s` is a convex set, then `a \u2022 interior s + b \u2022 closure s \u2286 interior s` for all `0 < a`,\n`0 \u2264 b`, `a + b = 1`. See also `Convex.combo_interior_self_subset_interior` for a weaker version. -/\ntheorem Convex.combo_interior_closure_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) : a \u2022 interior s + b \u2022 closure s \u2286 interior s :=\n  interior_smul\u2080 ha.ne' s \u25b8\n    calc\n      interior (a \u2022 s) + b \u2022 closure s \u2286 interior (a \u2022 s) + closure (b \u2022 s) :=\n        add_subset_add Subset.rfl (smul_closure_subset b s)\n      _ = interior (a \u2022 s) + b \u2022 s := by rw [isOpen_interior.add_closure (b \u2022 s)]\n      _ \u2286 interior (a \u2022 s + b \u2022 s) := subset_interior_add_left\n      _ \u2286 interior s := interior_mono <| hs.set_combo_subset ha.le hb hab\n\n#align convex.combo_interior_closure_subset_interior Convex.combo_interior_closure_subset_interior\n\n/-- If `s` is a convex set, then `a \u2022 interior s + b \u2022 s \u2286 interior s` for all `0 < a`, `0 \u2264 b`,\n`a + b = 1`. See also `Convex.combo_interior_closure_subset_interior` for a stronger version. -/\ntheorem Convex.combo_interior_self_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) : a \u2022 interior s + b \u2022 s \u2286 interior s :=\n  calc\n    a \u2022 interior s + b \u2022 s \u2286 a \u2022 interior s + b \u2022 closure s :=\n      add_subset_add Subset.rfl <| image_subset _ subset_closure\n    _ \u2286 interior s := hs.combo_interior_closure_subset_interior ha hb hab\n\n#align convex.combo_interior_self_subset_interior Convex.combo_interior_self_subset_interior\n\n/-- If `s` is a convex set, then `a \u2022 closure s + b \u2022 interior s \u2286 interior s` for all `0 \u2264 a`,\n`0 < b`, `a + b = 1`. See also `Convex.combo_self_interior_subset_interior` for a weaker version. -/\ntheorem Convex.combo_closure_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) : a \u2022 closure s + b \u2022 interior s \u2286 interior s := by\n  rw [add_comm]\n  exact hs.combo_interior_closure_subset_interior hb ha (add_comm a b \u25b8 hab)\n#align convex.combo_closure_interior_subset_interior Convex.combo_closure_interior_subset_interior\n\n/-- If `s` is a convex set, then `a \u2022 s + b \u2022 interior s \u2286 interior s` for all `0 \u2264 a`, `0 < b`,\n`a + b = 1`. See also `Convex.combo_closure_interior_subset_interior` for a stronger version. -/\ntheorem Convex.combo_self_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) : a \u2022 s + b \u2022 interior s \u2286 interior s := by\n  rw [add_comm]\n  exact hs.combo_interior_self_subset_interior hb ha (add_comm a b \u25b8 hab)\n#align convex.combo_self_interior_subset_interior Convex.combo_self_interior_subset_interior\n\ntheorem Convex.combo_interior_closure_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 closure s) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b)\n    (hab : a + b = 1) : a \u2022 x + b \u2022 y \u2208 interior s :=\n  hs.combo_interior_closure_subset_interior ha hb hab <|\n    add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n#align convex.combo_interior_closure_mem_interior Convex.combo_interior_closure_mem_interior\n\ntheorem Convex.combo_interior_self_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 s) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n    a \u2022 x + b \u2022 y \u2208 interior s :=\n  hs.combo_interior_closure_mem_interior hx (subset_closure hy) ha hb hab\n#align convex.combo_interior_self_mem_interior Convex.combo_interior_self_mem_interior\n\ntheorem Convex.combo_closure_interior_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 < b)\n    (hab : a + b = 1) : a \u2022 x + b \u2022 y \u2208 interior s :=\n  hs.combo_closure_interior_subset_interior ha hb hab <|\n    add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n#align convex.combo_closure_interior_mem_interior Convex.combo_closure_interior_mem_interior\n\ntheorem Convex.combo_self_interior_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s)\n    (hy : y \u2208 interior s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) :\n    a \u2022 x + b \u2022 y \u2208 interior s :=\n  hs.combo_closure_interior_mem_interior (subset_closure hx) hy ha hb hab\n#align convex.combo_self_interior_mem_interior Convex.combo_self_interior_mem_interior\n\ntheorem Convex.openSegment_interior_closure_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 closure s) : openSegment \ud835\udd5c x y \u2286 interior s := by\n  rintro _ \u27e8a, b, ha, hb, hab, rfl\u27e9\n  exact hs.combo_interior_closure_mem_interior hx hy ha hb.le hab\n#align convex.open_segment_interior_closure_subset_interior Convex.openSegment_interior_closure_subset_interior\n\ntheorem Convex.openSegment_interior_self_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 s) : openSegment \ud835\udd5c x y \u2286 interior s :=\n  hs.openSegment_interior_closure_subset_interior hx (subset_closure hy)\n#align convex.open_segment_interior_self_subset_interior Convex.openSegment_interior_self_subset_interior\n\ntheorem Convex.openSegment_closure_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) : openSegment \ud835\udd5c x y \u2286 interior s := by\n  rintro _ \u27e8a, b, ha, hb, hab, rfl\u27e9\n  exact hs.combo_closure_interior_mem_interior hx hy ha.le hb hab\n#align convex.open_segment_closure_interior_subset_interior Convex.openSegment_closure_interior_subset_interior\n\ntheorem Convex.openSegment_self_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 s) (hy : y \u2208 interior s) : openSegment \ud835\udd5c x y \u2286 interior s :=\n  hs.openSegment_closure_interior_subset_interior (subset_closure hx) hy\n#align convex.open_segment_self_interior_subset_interior Convex.openSegment_self_interior_subset_interior\n\n/-- If `x \u2208 closure s` and `y \u2208 interior s`, then the segment `(x, y]` is included in `interior s`.\n-/\ntheorem Convex.add_smul_sub_mem_interior' {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) :\n    x + t \u2022 (y - x) \u2208 interior s := by\n  simpa only [sub_smul, smul_sub, one_smul, add_sub, add_comm] using\n    hs.combo_interior_closure_mem_interior hy hx ht.1 (sub_nonneg.mpr ht.2)\n      (add_sub_cancel _ _)\n#align convex.add_smul_sub_mem_interior' Convex.add_smul_sub_mem_interior'\n\n/-- If `x \u2208 s` and `y \u2208 interior s`, then the segment `(x, y]` is included in `interior s`. -/\ntheorem Convex.add_smul_sub_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s)\n    (hy : y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) : x + t \u2022 (y - x) \u2208 interior s :=\n  hs.add_smul_sub_mem_interior' (subset_closure hx) hy ht\n#align convex.add_smul_sub_mem_interior Convex.add_smul_sub_mem_interior\n\n/-- If `x \u2208 closure s` and `x + y \u2208 interior s`, then `x + t y \u2208 interior s` for `t \u2208 (0, 1]`. -/\ntheorem Convex.add_smul_mem_interior' {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 closure s)\n    (hy : x + y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) : x + t \u2022 y \u2208 interior s := by\n  simpa only [add_sub_cancel_left] using hs.add_smul_sub_mem_interior' hx hy ht\n#align convex.add_smul_mem_interior' Convex.add_smul_mem_interior'\n\n/-- If `x \u2208 s` and `x + y \u2208 interior s`, then `x + t y \u2208 interior s` for `t \u2208 (0, 1]`. -/\ntheorem Convex.add_smul_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s)\n    (hy : x + y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) : x + t \u2022 y \u2208 interior s :=\n  hs.add_smul_mem_interior' (subset_closure hx) hy ht\n#align convex.add_smul_mem_interior Convex.add_smul_mem_interior\n\n/-- In a topological vector space, the interior of a convex set is convex. -/\nprotected theorem Convex.interior {s : Set E} (hs : Convex \ud835\udd5c s) : Convex \ud835\udd5c (interior s) :=\n  convex_iff_openSegment_subset.mpr fun _ hx _ hy =>\n    hs.openSegment_closure_interior_subset_interior (interior_subset_closure hx) hy\n#align convex.interior Convex.interior\n\n/-- In a topological vector space, the closure of a convex set is convex. -/\nprotected theorem Convex.closure {s : Set E} (hs : Convex \ud835\udd5c s) : Convex \ud835\udd5c (closure s) :=\n  fun x hx y hy a b ha hb hab =>\n  let f : E \u2192 E \u2192 E := fun x' y' => a \u2022 x' + b \u2022 y'\n  have hf : Continuous (Function.uncurry f) :=\n    (continuous_fst.const_smul _).add (continuous_snd.const_smul _)\n  show f x y \u2208 closure s from map_mem_closure\u2082 hf hx hy fun _ hx' _ hy' => hs hx' hy' ha hb hab\n#align convex.closure Convex.closure\n\nopen AffineMap\n\n/-- A convex set `s` is strictly convex provided that for any two distinct points of\n`s \\ interior s`, the line passing through these points has nonempty intersection with\n`interior s`. -/\nprotected theorem Convex.strictConvex' {s : Set E} (hs : Convex \ud835\udd5c s)\n    (h : (s \\ interior s).Pairwise fun x y => \u2203 c : \ud835\udd5c, lineMap x y c \u2208 interior s) :\n    StrictConvex \ud835\udd5c s := by\n  refine' strictConvex_iff_openSegment_subset.2 _\n  intro x hx y hy hne\n  by_cases hx' : x \u2208 interior s\n  \u00b7 exact hs.openSegment_interior_self_subset_interior hx' hy\n  by_cases hy' : y \u2208 interior s\n  \u00b7 exact hs.openSegment_self_interior_subset_interior hx hy'\n  rcases h \u27e8hx, hx'\u27e9 \u27e8hy, hy'\u27e9 hne with \u27e8c, hc\u27e9\n  refine' (openSegment_subset_union x y \u27e8c, rfl\u27e9).trans (insert_subset_iff.2 \u27e8hc, union_subset _ _\u27e9)\n  exacts [hs.openSegment_self_interior_subset_interior hx hc,\n    hs.openSegment_interior_self_subset_interior hc hy]\n#align convex.strict_convex' Convex.strictConvex'\n\n/-- A convex set `s` is strictly convex provided that for any two distinct points `x`, `y` of\n`s \\ interior s`, the segment with endpoints `x`, `y` has nonempty intersection with\n`interior s`. -/\nprotected theorem Convex.strictConvex {s : Set E} (hs : Convex \ud835\udd5c s)\n    (h : (s \\ interior s).Pairwise fun x y => ([x -[\ud835\udd5c] y] \\ frontier s).Nonempty) :\n    StrictConvex \ud835\udd5c s := by\n  refine' hs.strictConvex' <| h.imp_on fun x hx y hy _ => _\n  simp only [segment_eq_image_lineMap, \u2190 self_diff_frontier]\n  rintro \u27e8_, \u27e8\u27e8c, hc, rfl\u27e9, hcs\u27e9\u27e9\n  refine' \u27e8c, hs.segment_subset hx.1 hy.1 _, hcs\u27e9\n  exact (segment_eq_image_lineMap \ud835\udd5c x y).symm \u25b8 mem_image_of_mem _ hc\n#align convex.strict_convex Convex.strictConvex\n\nend ContinuousConstSMul\n\nsection ContinuousSMul\n\nvariable [AddCommGroup E] [Module \u211d E] [TopologicalSpace E] [TopologicalAddGroup E]\n  [ContinuousSMul \u211d E]\n\n/-- Convex hull of a finite set is compact. -/\ntheorem Set.Finite.isCompact_convexHull {s : Set E} (hs : s.Finite) :\n    IsCompact (convexHull \u211d s) := by\n  rw [hs.convexHull_eq_image]\n  apply (@isCompact_stdSimplex _ hs.fintype).image\n  haveI := hs.fintype\n  apply LinearMap.continuous_on_pi\n#align set.finite.compact_convex_hull Set.Finite.isCompact_convexHull\n\n/-- Convex hull of a finite set is closed. -/\ntheorem Set.Finite.isClosed_convexHull [T2Space E] {s : Set E} (hs : s.Finite) :\n    IsClosed (convexHull \u211d s) :=\n  hs.isCompact_convexHull.isClosed\n#align set.finite.is_closed_convex_hull Set.Finite.isClosed_convexHull\n\nopen AffineMap\n\n/-- If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.closure_subset_image_homothety_interior_of_one_lt {s : Set E} (hs : Convex \u211d s)\n    {x : E} (hx : x \u2208 interior s) (t : \u211d) (ht : 1 < t) :\n    closure s \u2286 homothety x t '' interior s := by\n  intro y hy\n  have hne : t \u2260 0 := (one_pos.trans ht).ne'\n  refine'\n    \u27e8homothety x t\u207b\u00b9 y, hs.openSegment_interior_closure_subset_interior hx hy _,\n      (AffineEquiv.homothetyUnitsMulHom x (Units.mk0 t hne)).apply_symm_apply y\u27e9\n  rw [openSegment_eq_image_lineMap, \u2190 inv_one, \u2190 inv_Ioi (zero_lt_one' \u211d), \u2190 image_inv, image_image,\n    homothety_eq_lineMap]\n  exact mem_image_of_mem _ ht\n#align convex.closure_subset_image_homothety_interior_of_one_lt Convex.closure_subset_image_homothety_interior_of_one_lt\n\n/-- If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.closure_subset_interior_image_homothety_of_one_lt {s : Set E} (hs : Convex \u211d s)\n    {x : E} (hx : x \u2208 interior s) (t : \u211d) (ht : 1 < t) :\n    closure s \u2286 interior (homothety x t '' s) :=\n  (hs.closure_subset_image_homothety_interior_of_one_lt hx t ht).trans <|\n    (homothety_isOpenMap x t (one_pos.trans ht).ne').image_interior_subset _\n#align convex.closure_subset_interior_image_homothety_of_one_lt Convex.closure_subset_interior_image_homothety_of_one_lt\n\n/-- If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. -/\ntheorem Convex.subset_interior_image_homothety_of_one_lt {s : Set E} (hs : Convex \u211d s) {x : E}\n    (hx : x \u2208 interior s) (t : \u211d) (ht : 1 < t) : s \u2286 interior (homothety x t '' s) :=\n  subset_closure.trans <| hs.closure_subset_interior_image_homothety_of_one_lt hx t ht\n#align convex.subset_interior_image_homothety_of_one_lt Convex.subset_interior_image_homothety_of_one_lt\n\ntheorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module \u211d E]\n    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \u211d E]\n    {x y : E} {s : Set E} (h : [x -[\u211d] y] \u2286 s) : JoinedIn s x y := by\n  have A : Continuous (fun t \u21a6 (1 - t) \u2022 x + t \u2022 y : \u211d \u2192 E) := by continuity\n  apply JoinedIn.ofLine A.continuousOn (by simp) (by simp)\n  convert h\n  rw [segment_eq_image \u211d x y]\n\n/-- A nonempty convex set is path connected. -/\nprotected theorem Convex.isPathConnected {s : Set E} (hconv : Convex \u211d s) (hne : s.Nonempty) :\n    IsPathConnected s := by\n  refine' isPathConnected_iff.mpr \u27e8hne, _\u27e9\n  intro x x_in y y_in\n  exact JoinedIn.of_segment_subset ((segment_subset_iff \u211d).2 (hconv x_in y_in))\n#align convex.is_path_connected Convex.isPathConnected\n\n/-- A nonempty convex set is connected. -/\nprotected theorem Convex.isConnected {s : Set E} (h : Convex \u211d s) (hne : s.Nonempty) :\n    IsConnected s :=\n  (h.isPathConnected hne).isConnected\n#align convex.is_connected Convex.isConnected\n\n/-- A convex set is preconnected. -/\nprotected theorem Convex.isPreconnected {s : Set E} (h : Convex \u211d s) : IsPreconnected s :=\n  s.eq_empty_or_nonempty.elim (fun h => h.symm \u25b8 isPreconnected_empty) fun hne =>\n    (h.isConnected hne).isPreconnected\n#align convex.is_preconnected Convex.isPreconnected\n\n/-- Every topological vector space over \u211d is path connected.\n\nNot an instance, because it creates enormous TC subproblems (turn on `pp.all`).\n-/\nprotected theorem TopologicalAddGroup.pathConnectedSpace : PathConnectedSpace E :=\n  pathConnectedSpace_iff_univ.mpr <| convex_univ.isPathConnected \u27e8(0 : E), trivial\u27e9\n#align topological_add_group.path_connected TopologicalAddGroup.pathConnectedSpace\n\nend ContinuousSMul\n\nsection ComplementsConnected\n\nvariable {E : Type*} [AddCommGroup E] [Module \u211d E] [TopologicalSpace E] [TopologicalAddGroup E]\n\nlocal notation \"\u03c0\" => Submodule.linearProjOfIsCompl _ _\n\nattribute [local instance 100] TopologicalAddGroup.pathConnectedSpace\n\n/-- Given two complementary subspaces `p` and `q` in `E`, if the complement of `{0}`\nis path connected in `p` then the complement of `q` is path connected in `E`. -/\n", "theoremStatement": "theorem isPathConnected_compl_of_isPathConnected_compl_zero [ContinuousSMul \u211d E]\n    {p q : Submodule \u211d E} (hpq : IsCompl p q) (hpc : IsPathConnected ({0}\u1d9c : Set p)) :\n    IsPathConnected (q\u1d9c : Set E)", "theoremName": "isPathConnected_compl_of_isPathConnected_compl_zero", "fileCreated": {"commit": "0993683f2d", "date": "2023-04-24"}, "theoremCreated": {"commit": "6efcbba115", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Analysis/Convex/Topology.lean", "positionMetadata": {"lineInFile": 396, "tokenPositionInFile": 20058, "theoremPositionInFile": 42}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [isPathConnected_iff] at hpc \u22a2\n  constructor\n  \u00b7 rcases hpc.1 with \u27e8a, ha\u27e9\n    exact \u27e8a, mt (Submodule.eq_zero_of_coe_mem_of_disjoint hpq.disjoint) ha\u27e9\n  \u00b7 intro x hx y hy\n    have : \u03c0 hpq x \u2260 0 \u2227 \u03c0 hpq y \u2260 0 := by\n      constructor <;> intro h <;> rw [Submodule.linearProjOfIsCompl_apply_eq_zero_iff hpq] at h <;>\n        [exact hx h; exact hy h]\n    rcases hpc.2 (\u03c0 hpq x) this.1 (\u03c0 hpq y) this.2 with \u27e8\u03b3\u2081, h\u03b3\u2081\u27e9\n    let \u03b3\u2082 := PathConnectedSpace.somePath (\u03c0 hpq.symm x) (\u03c0 hpq.symm y)\n    let \u03b3\u2081' : Path (_ : E) _ := \u03b3\u2081.map continuous_subtype_val\n    let \u03b3\u2082' : Path (_ : E) _ := \u03b3\u2082.map continuous_subtype_val\n    refine \u27e8(\u03b3\u2081'.add \u03b3\u2082').cast (Submodule.linear_proj_add_linearProjOfIsCompl_eq_self hpq x).symm\n      (Submodule.linear_proj_add_linearProjOfIsCompl_eq_self hpq y).symm, fun t \u21a6 ?_\u27e9\n    rw [Path.cast_coe, Path.add_apply]\n    change \u03b3\u2081 t + (\u03b3\u2082 t : E) \u2209 q\n    rw [\u2190 Submodule.linearProjOfIsCompl_apply_eq_zero_iff hpq, LinearMap.map_add,\n      Submodule.linearProjOfIsCompl_apply_right, add_zero,\n      Submodule.linearProjOfIsCompl_apply_eq_zero_iff]\n    exact mt (Submodule.eq_zero_of_coe_mem_of_disjoint hpq.disjoint) (h\u03b3\u2081 t)", "proofType": "tactic", "proofLengthLines": 21, "proofLengthTokens": 1146}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2023 S\u00e9bastien Gou\u00ebzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S\u00e9bastien Gou\u00ebzel\n-/\nimport Mathlib.Analysis.Convex.Topology\nimport Mathlib.LinearAlgebra.Dimension.DivisionRing\nimport Mathlib.Topology.Algebra.Module.Cardinality\n\n/-!\n# Connectedness of subsets of vector spaces\n\nWe show several results related to the (path)-connectedness of subsets of real vector spaces:\n* `Set.Countable.isPathConnected_compl_of_one_lt_rank` asserts that the complement of a countable\n  set is path-connected in a space of dimension `> 1`.\n* `isPathConnected_compl_singleton_of_one_lt_rank` is the special case of the complement of a\n  singleton.\n* `isPathConnected_sphere` shows that any sphere is path-connected in dimension `> 1`.\n* `isPathConnected_compl_of_one_lt_codim` shows that the complement of a subspace\n  of codimension `> 1` is path-connected.\n\nStatements with connectedness instead of path-connectedness are also given.\n-/\n\nopen Convex Set Metric\n\nsection TopologicalVectorSpace\n\nvariable {E : Type*} [AddCommGroup E] [Module \u211d E]\n  [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \u211d E]\n\n/-- In a real vector space of dimension `> 1`, the complement of any countable set is path\nconnected. -/\ntheorem Set.Countable.isPathConnected_compl_of_one_lt_rank\n    (h : 1 < Module.rank \u211d E) {s : Set E} (hs : s.Countable) :\n    IsPathConnected s\u1d9c := by\n  have : Nontrivial E := (rank_pos_iff_nontrivial (R := \u211d)).1 (zero_lt_one.trans h)\n  -- the set `s\u1d9c` is dense, therefore nonempty. Pick `a \u2208 s\u1d9c`. We have to show that any\n  -- `b \u2208 s\u1d9c` can be joined to `a`.\n  obtain \u27e8a, ha\u27e9 : s\u1d9c.Nonempty := (hs.dense_compl \u211d).nonempty\n  refine \u27e8a, ha, ?_\u27e9\n  intro b hb\n  rcases eq_or_ne a b with rfl|hab\n  \u00b7 exact JoinedIn.refl ha\n  /- Assume `b \u2260 a`. Write `a = c - x` and `b = c + x` for some nonzero `x`. Choose `y` which\n  is linearly independent from `x`. Then the segments joining `a = c - x` to `c + ty` are pairwise\n  disjoint for varying `t` (except for the endpoint `a`) so only countably many of them can\n  intersect `s`. In the same way, there are countably many `t`s for which the segment\n  from `b = c + x` to `c + ty` intersects `s`. Choosing `t` outside of these countable exceptions,\n  one gets a path in the complement of `s` from `a` to `z = c + ty` and then to `b`.\n  -/\n  let c := (2 : \u211d)\u207b\u00b9 \u2022 (a + b)\n  let x := (2 : \u211d)\u207b\u00b9 \u2022 (b - a)\n  have Ia : c - x = a := by\n    simp only [c, x, smul_add, smul_sub]\n    abel_nf\n    simp [zsmul_eq_smul_cast \u211d 2]\n  have Ib : c + x = b := by\n    simp only [c, x, smul_add, smul_sub]\n    abel_nf\n    simp [zsmul_eq_smul_cast \u211d 2]\n  have x_ne_zero : x \u2260 0 := by simpa [x] using sub_ne_zero.2 hab.symm\n  obtain \u27e8y, hy\u27e9 : \u2203 y, LinearIndependent \u211d ![x, y] :=\n    exists_linearIndependent_pair_of_one_lt_rank h x_ne_zero\n  have A : Set.Countable {t : \u211d | ([c + x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty} := by\n    apply countable_setOf_nonempty_of_disjoint _ (fun t \u21a6 inter_subset_right _ _) hs\n    intro t t' htt'\n    apply disjoint_iff_inter_eq_empty.2\n    have N : {c + x} \u2229 s = \u2205 := by\n      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ib] using hb\n    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, \u2190 inter_assoc, \u2190 subset_empty_iff, \u2190 N]\n    apply inter_subset_inter_left\n    apply Eq.subset\n    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne hy htt'.symm\n  have B : Set.Countable {t : \u211d | ([c - x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty} := by\n    apply countable_setOf_nonempty_of_disjoint _ (fun t \u21a6 inter_subset_right _ _) hs\n    intro t t' htt'\n    apply disjoint_iff_inter_eq_empty.2\n    have N : {c - x} \u2229 s = \u2205 := by\n      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ia] using ha\n    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, \u2190 inter_assoc, \u2190 subset_empty_iff, \u2190 N]\n    apply inter_subset_inter_left\n    rw [sub_eq_add_neg _ x]\n    apply Eq.subset\n    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne _ htt'.symm\n    convert hy.units_smul ![-1, 1]\n    simp [\u2190 List.ofFn_inj]\n  obtain \u27e8t, ht\u27e9 : Set.Nonempty ({t : \u211d | ([c + x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty}\n      \u222a {t : \u211d | ([c - x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty})\u1d9c := ((A.union B).dense_compl \u211d).nonempty\n  let z := c + t \u2022 y\n  simp only [compl_union, mem_inter_iff, mem_compl_iff, mem_setOf_eq, not_nonempty_iff_eq_empty]\n    at ht\n  have JA : JoinedIn s\u1d9c a z := by\n    apply JoinedIn.of_segment_subset\n    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]\n    convert ht.2\n    exact Ia.symm\n  have JB : JoinedIn s\u1d9c b z := by\n    apply JoinedIn.of_segment_subset\n    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]\n    convert ht.1\n    exact Ib.symm\n  exact JA.trans JB.symm\n\n/-- In a real vector space of dimension `> 1`, the complement of any countable set is\nconnected. -/\ntheorem Set.Countable.isConnected_compl_of_one_lt_rank (h : 1 < Module.rank \u211d E) {s : Set E}\n    (hs : s.Countable) : IsConnected s\u1d9c :=\n  (hs.isPathConnected_compl_of_one_lt_rank h).isConnected\n\n/-- In a real vector space of dimension `> 1`, the complement of any singleton is path-connected. -/\ntheorem isPathConnected_compl_singleton_of_one_lt_rank (h : 1 < Module.rank \u211d E) (x : E) :\n    IsPathConnected {x}\u1d9c :=\n  Set.Countable.isPathConnected_compl_of_one_lt_rank h (countable_singleton x)\n\n/-- In a real vector space of dimension `> 1`, the complement of a singleton is connected. -/\ntheorem isConnected_compl_singleton_of_one_lt_rank (h : 1 < Module.rank \u211d E) (x : E) :\n    IsConnected {x}\u1d9c :=\n  (isPathConnected_compl_singleton_of_one_lt_rank h x).isConnected\n\nend TopologicalVectorSpace\n\nsection NormedSpace\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n\n/-- In a real vector space of dimension `> 1`, any sphere of nonnegative radius is\npath connected. -/\ntheorem isPathConnected_sphere (h : 1 < Module.rank \u211d E) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    IsPathConnected (sphere x r) := by\n  /- when `r > 0`, we write the sphere as the image of `{0}\u1d9c` under the map\n  `y \u21a6 x + (r * \u2016y\u2016\u207b\u00b9) \u2022 y`. Since the image under a continuous map of a path connected set\n  is path connected, this concludes the proof. -/\n  rcases hr.eq_or_lt with rfl|rpos\n  \u00b7 simpa using isPathConnected_singleton x\n  let f : E \u2192 E := fun y \u21a6 x + (r * \u2016y\u2016\u207b\u00b9) \u2022 y\n  have A : ContinuousOn f {0}\u1d9c := by\n    intro y hy\n    apply (continuousAt_const.add _).continuousWithinAt\n    apply (continuousAt_const.mul (ContinuousAt.inv\u2080 continuousAt_id.norm ?_)).smul continuousAt_id\n    simpa using hy\n  have B : IsPathConnected ({0}\u1d9c : Set E) := isPathConnected_compl_singleton_of_one_lt_rank h 0\n  have C : IsPathConnected (f '' {0}\u1d9c) := B.image' A\n  have : f '' {0}\u1d9c = sphere x r := by\n    apply Subset.antisymm\n    \u00b7 rintro - \u27e8y, hy, rfl\u27e9\n      have : \u2016y\u2016 \u2260 0 := by simpa using hy\n      simp [f, norm_smul, abs_of_nonneg hr, mul_assoc, inv_mul_cancel this]\n    \u00b7 intro y hy\n      refine \u27e8y - x, ?_, ?_\u27e9\n      \u00b7 intro H\n        simp only [mem_singleton_iff, sub_eq_zero] at H\n        simp only [H, mem_sphere_iff_norm, sub_self, norm_zero] at hy\n        exact rpos.ne hy\n      \u00b7 simp [f, mem_sphere_iff_norm.1 hy, mul_inv_cancel rpos.ne']\n  rwa [this] at C\n\n/-- In a real vector space of dimension `> 1`, any sphere of nonnegative radius is connected. -/\ntheorem isConnected_sphere (h : 1 < Module.rank \u211d E) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    IsConnected (sphere x r) :=\n  (isPathConnected_sphere h x hr).isConnected\n\n/-- In a real vector space of dimension `> 1`, any sphere is preconnected. -/\ntheorem isPreconnected_sphere (h : 1 < Module.rank \u211d E) (x : E) (r : \u211d) :\n    IsPreconnected (sphere x r) := by\n  rcases le_or_lt 0 r with hr|hr\n  \u00b7 exact (isConnected_sphere h x hr).isPreconnected\n  \u00b7 simpa [hr] using isPreconnected_empty\n\nend NormedSpace\n\nsection\n\nvariable {F : Type*} [AddCommGroup F] [Module \u211d F] [TopologicalSpace F]\n  [TopologicalAddGroup F] [ContinuousSMul \u211d F]\n\n/-- Let `E` be a linear subspace in a real vector space.\nIf `E` has codimension at least two, its complement is path-connected. -/\n", "theoremStatement": "theorem isPathConnected_compl_of_one_lt_codim {E : Submodule \u211d F}\n    (hcodim : 1 < Module.rank \u211d (F \u29f8 E)) : IsPathConnected (E\u1d9c : Set F)", "theoremName": "isPathConnected_compl_of_one_lt_codim", "fileCreated": {"commit": "23550c1e3b", "date": "2023-08-31"}, "theoremCreated": {"commit": "6efcbba115", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Analysis/NormedSpace/Connected.lean", "positionMetadata": {"lineInFile": 179, "tokenPositionInFile": 8020, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rcases E.exists_isCompl with \u27e8E', hE'\u27e9\n  refine isPathConnected_compl_of_isPathConnected_compl_zero hE'.symm\n    (isPathConnected_compl_singleton_of_one_lt_rank ?_ 0)\n  rwa [\u2190 (E.quotientEquivOfIsCompl E' hE').rank_eq]", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 223}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2023 S\u00e9bastien Gou\u00ebzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S\u00e9bastien Gou\u00ebzel\n-/\nimport Mathlib.Analysis.Convex.Topology\nimport Mathlib.LinearAlgebra.Dimension.DivisionRing\nimport Mathlib.Topology.Algebra.Module.Cardinality\n\n/-!\n# Connectedness of subsets of vector spaces\n\nWe show several results related to the (path)-connectedness of subsets of real vector spaces:\n* `Set.Countable.isPathConnected_compl_of_one_lt_rank` asserts that the complement of a countable\n  set is path-connected in a space of dimension `> 1`.\n* `isPathConnected_compl_singleton_of_one_lt_rank` is the special case of the complement of a\n  singleton.\n* `isPathConnected_sphere` shows that any sphere is path-connected in dimension `> 1`.\n* `isPathConnected_compl_of_one_lt_codim` shows that the complement of a subspace\n  of codimension `> 1` is path-connected.\n\nStatements with connectedness instead of path-connectedness are also given.\n-/\n\nopen Convex Set Metric\n\nsection TopologicalVectorSpace\n\nvariable {E : Type*} [AddCommGroup E] [Module \u211d E]\n  [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \u211d E]\n\n/-- In a real vector space of dimension `> 1`, the complement of any countable set is path\nconnected. -/\ntheorem Set.Countable.isPathConnected_compl_of_one_lt_rank\n    (h : 1 < Module.rank \u211d E) {s : Set E} (hs : s.Countable) :\n    IsPathConnected s\u1d9c := by\n  have : Nontrivial E := (rank_pos_iff_nontrivial (R := \u211d)).1 (zero_lt_one.trans h)\n  -- the set `s\u1d9c` is dense, therefore nonempty. Pick `a \u2208 s\u1d9c`. We have to show that any\n  -- `b \u2208 s\u1d9c` can be joined to `a`.\n  obtain \u27e8a, ha\u27e9 : s\u1d9c.Nonempty := (hs.dense_compl \u211d).nonempty\n  refine \u27e8a, ha, ?_\u27e9\n  intro b hb\n  rcases eq_or_ne a b with rfl|hab\n  \u00b7 exact JoinedIn.refl ha\n  /- Assume `b \u2260 a`. Write `a = c - x` and `b = c + x` for some nonzero `x`. Choose `y` which\n  is linearly independent from `x`. Then the segments joining `a = c - x` to `c + ty` are pairwise\n  disjoint for varying `t` (except for the endpoint `a`) so only countably many of them can\n  intersect `s`. In the same way, there are countably many `t`s for which the segment\n  from `b = c + x` to `c + ty` intersects `s`. Choosing `t` outside of these countable exceptions,\n  one gets a path in the complement of `s` from `a` to `z = c + ty` and then to `b`.\n  -/\n  let c := (2 : \u211d)\u207b\u00b9 \u2022 (a + b)\n  let x := (2 : \u211d)\u207b\u00b9 \u2022 (b - a)\n  have Ia : c - x = a := by\n    simp only [c, x, smul_add, smul_sub]\n    abel_nf\n    simp [zsmul_eq_smul_cast \u211d 2]\n  have Ib : c + x = b := by\n    simp only [c, x, smul_add, smul_sub]\n    abel_nf\n    simp [zsmul_eq_smul_cast \u211d 2]\n  have x_ne_zero : x \u2260 0 := by simpa [x] using sub_ne_zero.2 hab.symm\n  obtain \u27e8y, hy\u27e9 : \u2203 y, LinearIndependent \u211d ![x, y] :=\n    exists_linearIndependent_pair_of_one_lt_rank h x_ne_zero\n  have A : Set.Countable {t : \u211d | ([c + x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty} := by\n    apply countable_setOf_nonempty_of_disjoint _ (fun t \u21a6 inter_subset_right _ _) hs\n    intro t t' htt'\n    apply disjoint_iff_inter_eq_empty.2\n    have N : {c + x} \u2229 s = \u2205 := by\n      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ib] using hb\n    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, \u2190 inter_assoc, \u2190 subset_empty_iff, \u2190 N]\n    apply inter_subset_inter_left\n    apply Eq.subset\n    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne hy htt'.symm\n  have B : Set.Countable {t : \u211d | ([c - x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty} := by\n    apply countable_setOf_nonempty_of_disjoint _ (fun t \u21a6 inter_subset_right _ _) hs\n    intro t t' htt'\n    apply disjoint_iff_inter_eq_empty.2\n    have N : {c - x} \u2229 s = \u2205 := by\n      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ia] using ha\n    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, \u2190 inter_assoc, \u2190 subset_empty_iff, \u2190 N]\n    apply inter_subset_inter_left\n    rw [sub_eq_add_neg _ x]\n    apply Eq.subset\n    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne _ htt'.symm\n    convert hy.units_smul ![-1, 1]\n    simp [\u2190 List.ofFn_inj]\n  obtain \u27e8t, ht\u27e9 : Set.Nonempty ({t : \u211d | ([c + x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty}\n      \u222a {t : \u211d | ([c - x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty})\u1d9c := ((A.union B).dense_compl \u211d).nonempty\n  let z := c + t \u2022 y\n  simp only [compl_union, mem_inter_iff, mem_compl_iff, mem_setOf_eq, not_nonempty_iff_eq_empty]\n    at ht\n  have JA : JoinedIn s\u1d9c a z := by\n    apply JoinedIn.of_segment_subset\n    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]\n    convert ht.2\n    exact Ia.symm\n  have JB : JoinedIn s\u1d9c b z := by\n    apply JoinedIn.of_segment_subset\n    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]\n    convert ht.1\n    exact Ib.symm\n  exact JA.trans JB.symm\n\n/-- In a real vector space of dimension `> 1`, the complement of any countable set is\nconnected. -/\ntheorem Set.Countable.isConnected_compl_of_one_lt_rank (h : 1 < Module.rank \u211d E) {s : Set E}\n    (hs : s.Countable) : IsConnected s\u1d9c :=\n  (hs.isPathConnected_compl_of_one_lt_rank h).isConnected\n\n/-- In a real vector space of dimension `> 1`, the complement of any singleton is path-connected. -/\ntheorem isPathConnected_compl_singleton_of_one_lt_rank (h : 1 < Module.rank \u211d E) (x : E) :\n    IsPathConnected {x}\u1d9c :=\n  Set.Countable.isPathConnected_compl_of_one_lt_rank h (countable_singleton x)\n\n/-- In a real vector space of dimension `> 1`, the complement of a singleton is connected. -/\ntheorem isConnected_compl_singleton_of_one_lt_rank (h : 1 < Module.rank \u211d E) (x : E) :\n    IsConnected {x}\u1d9c :=\n  (isPathConnected_compl_singleton_of_one_lt_rank h x).isConnected\n\nend TopologicalVectorSpace\n\nsection NormedSpace\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n\n/-- In a real vector space of dimension `> 1`, any sphere of nonnegative radius is\npath connected. -/\ntheorem isPathConnected_sphere (h : 1 < Module.rank \u211d E) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    IsPathConnected (sphere x r) := by\n  /- when `r > 0`, we write the sphere as the image of `{0}\u1d9c` under the map\n  `y \u21a6 x + (r * \u2016y\u2016\u207b\u00b9) \u2022 y`. Since the image under a continuous map of a path connected set\n  is path connected, this concludes the proof. -/\n  rcases hr.eq_or_lt with rfl|rpos\n  \u00b7 simpa using isPathConnected_singleton x\n  let f : E \u2192 E := fun y \u21a6 x + (r * \u2016y\u2016\u207b\u00b9) \u2022 y\n  have A : ContinuousOn f {0}\u1d9c := by\n    intro y hy\n    apply (continuousAt_const.add _).continuousWithinAt\n    apply (continuousAt_const.mul (ContinuousAt.inv\u2080 continuousAt_id.norm ?_)).smul continuousAt_id\n    simpa using hy\n  have B : IsPathConnected ({0}\u1d9c : Set E) := isPathConnected_compl_singleton_of_one_lt_rank h 0\n  have C : IsPathConnected (f '' {0}\u1d9c) := B.image' A\n  have : f '' {0}\u1d9c = sphere x r := by\n    apply Subset.antisymm\n    \u00b7 rintro - \u27e8y, hy, rfl\u27e9\n      have : \u2016y\u2016 \u2260 0 := by simpa using hy\n      simp [f, norm_smul, abs_of_nonneg hr, mul_assoc, inv_mul_cancel this]\n    \u00b7 intro y hy\n      refine \u27e8y - x, ?_, ?_\u27e9\n      \u00b7 intro H\n        simp only [mem_singleton_iff, sub_eq_zero] at H\n        simp only [H, mem_sphere_iff_norm, sub_self, norm_zero] at hy\n        exact rpos.ne hy\n      \u00b7 simp [f, mem_sphere_iff_norm.1 hy, mul_inv_cancel rpos.ne']\n  rwa [this] at C\n\n/-- In a real vector space of dimension `> 1`, any sphere of nonnegative radius is connected. -/\ntheorem isConnected_sphere (h : 1 < Module.rank \u211d E) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    IsConnected (sphere x r) :=\n  (isPathConnected_sphere h x hr).isConnected\n\n/-- In a real vector space of dimension `> 1`, any sphere is preconnected. -/\ntheorem isPreconnected_sphere (h : 1 < Module.rank \u211d E) (x : E) (r : \u211d) :\n    IsPreconnected (sphere x r) := by\n  rcases le_or_lt 0 r with hr|hr\n  \u00b7 exact (isConnected_sphere h x hr).isPreconnected\n  \u00b7 simpa [hr] using isPreconnected_empty\n\nend NormedSpace\n\nsection\n\nvariable {F : Type*} [AddCommGroup F] [Module \u211d F] [TopologicalSpace F]\n  [TopologicalAddGroup F] [ContinuousSMul \u211d F]\n\n/-- Let `E` be a linear subspace in a real vector space.\nIf `E` has codimension at least two, its complement is path-connected. -/\ntheorem isPathConnected_compl_of_one_lt_codim {E : Submodule \u211d F}\n    (hcodim : 1 < Module.rank \u211d (F \u29f8 E)) : IsPathConnected (E\u1d9c : Set F) := by\n  rcases E.exists_isCompl with \u27e8E', hE'\u27e9\n  refine isPathConnected_compl_of_isPathConnected_compl_zero hE'.symm\n    (isPathConnected_compl_singleton_of_one_lt_rank ?_ 0)\n  rwa [\u2190 (E.quotientEquivOfIsCompl E' hE').rank_eq]\n\n/-- Let `E` be a linear subspace in a real vector space.\nIf `E` has codimension at least two, its complement is connected. -/\n", "theoremStatement": "theorem isConnected_compl_of_one_lt_codim {E : Submodule \u211d F} (hcodim : 1 < Module.rank \u211d (F \u29f8 E)) :\n    IsConnected (E\u1d9c : Set F)", "theoremName": "isConnected_compl_of_one_lt_codim", "fileCreated": {"commit": "23550c1e3b", "date": "2023-08-31"}, "theoremCreated": {"commit": "6efcbba115", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Analysis/NormedSpace/Connected.lean", "positionMetadata": {"lineInFile": 188, "tokenPositionInFile": 8512, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "(isPathConnected_compl_of_one_lt_codim hcodim).isConnected", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 58}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2023 S\u00e9bastien Gou\u00ebzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S\u00e9bastien Gou\u00ebzel\n-/\nimport Mathlib.Analysis.Convex.Topology\nimport Mathlib.LinearAlgebra.Dimension.DivisionRing\nimport Mathlib.Topology.Algebra.Module.Cardinality\n\n/-!\n# Connectedness of subsets of vector spaces\n\nWe show several results related to the (path)-connectedness of subsets of real vector spaces:\n* `Set.Countable.isPathConnected_compl_of_one_lt_rank` asserts that the complement of a countable\n  set is path-connected in a space of dimension `> 1`.\n* `isPathConnected_compl_singleton_of_one_lt_rank` is the special case of the complement of a\n  singleton.\n* `isPathConnected_sphere` shows that any sphere is path-connected in dimension `> 1`.\n* `isPathConnected_compl_of_one_lt_codim` shows that the complement of a subspace\n  of codimension `> 1` is path-connected.\n\nStatements with connectedness instead of path-connectedness are also given.\n-/\n\nopen Convex Set Metric\n\nsection TopologicalVectorSpace\n\nvariable {E : Type*} [AddCommGroup E] [Module \u211d E]\n  [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \u211d E]\n\n/-- In a real vector space of dimension `> 1`, the complement of any countable set is path\nconnected. -/\ntheorem Set.Countable.isPathConnected_compl_of_one_lt_rank\n    (h : 1 < Module.rank \u211d E) {s : Set E} (hs : s.Countable) :\n    IsPathConnected s\u1d9c := by\n  have : Nontrivial E := (rank_pos_iff_nontrivial (R := \u211d)).1 (zero_lt_one.trans h)\n  -- the set `s\u1d9c` is dense, therefore nonempty. Pick `a \u2208 s\u1d9c`. We have to show that any\n  -- `b \u2208 s\u1d9c` can be joined to `a`.\n  obtain \u27e8a, ha\u27e9 : s\u1d9c.Nonempty := (hs.dense_compl \u211d).nonempty\n  refine \u27e8a, ha, ?_\u27e9\n  intro b hb\n  rcases eq_or_ne a b with rfl|hab\n  \u00b7 exact JoinedIn.refl ha\n  /- Assume `b \u2260 a`. Write `a = c - x` and `b = c + x` for some nonzero `x`. Choose `y` which\n  is linearly independent from `x`. Then the segments joining `a = c - x` to `c + ty` are pairwise\n  disjoint for varying `t` (except for the endpoint `a`) so only countably many of them can\n  intersect `s`. In the same way, there are countably many `t`s for which the segment\n  from `b = c + x` to `c + ty` intersects `s`. Choosing `t` outside of these countable exceptions,\n  one gets a path in the complement of `s` from `a` to `z = c + ty` and then to `b`.\n  -/\n  let c := (2 : \u211d)\u207b\u00b9 \u2022 (a + b)\n  let x := (2 : \u211d)\u207b\u00b9 \u2022 (b - a)\n  have Ia : c - x = a := by\n    simp only [c, x, smul_add, smul_sub]\n    abel_nf\n    simp [zsmul_eq_smul_cast \u211d 2]\n  have Ib : c + x = b := by\n    simp only [c, x, smul_add, smul_sub]\n    abel_nf\n    simp [zsmul_eq_smul_cast \u211d 2]\n  have x_ne_zero : x \u2260 0 := by simpa [x] using sub_ne_zero.2 hab.symm\n  obtain \u27e8y, hy\u27e9 : \u2203 y, LinearIndependent \u211d ![x, y] :=\n    exists_linearIndependent_pair_of_one_lt_rank h x_ne_zero\n  have A : Set.Countable {t : \u211d | ([c + x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty} := by\n    apply countable_setOf_nonempty_of_disjoint _ (fun t \u21a6 inter_subset_right _ _) hs\n    intro t t' htt'\n    apply disjoint_iff_inter_eq_empty.2\n    have N : {c + x} \u2229 s = \u2205 := by\n      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ib] using hb\n    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, \u2190 inter_assoc, \u2190 subset_empty_iff, \u2190 N]\n    apply inter_subset_inter_left\n    apply Eq.subset\n    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne hy htt'.symm\n  have B : Set.Countable {t : \u211d | ([c - x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty} := by\n    apply countable_setOf_nonempty_of_disjoint _ (fun t \u21a6 inter_subset_right _ _) hs\n    intro t t' htt'\n    apply disjoint_iff_inter_eq_empty.2\n    have N : {c - x} \u2229 s = \u2205 := by\n      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ia] using ha\n    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, \u2190 inter_assoc, \u2190 subset_empty_iff, \u2190 N]\n    apply inter_subset_inter_left\n    rw [sub_eq_add_neg _ x]\n    apply Eq.subset\n    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne _ htt'.symm\n    convert hy.units_smul ![-1, 1]\n    simp [\u2190 List.ofFn_inj]\n  obtain \u27e8t, ht\u27e9 : Set.Nonempty ({t : \u211d | ([c + x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty}\n      \u222a {t : \u211d | ([c - x -[\u211d] c + t \u2022 y] \u2229 s).Nonempty})\u1d9c := ((A.union B).dense_compl \u211d).nonempty\n  let z := c + t \u2022 y\n  simp only [compl_union, mem_inter_iff, mem_compl_iff, mem_setOf_eq, not_nonempty_iff_eq_empty]\n    at ht\n  have JA : JoinedIn s\u1d9c a z := by\n    apply JoinedIn.of_segment_subset\n    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]\n    convert ht.2\n    exact Ia.symm\n  have JB : JoinedIn s\u1d9c b z := by\n    apply JoinedIn.of_segment_subset\n    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]\n    convert ht.1\n    exact Ib.symm\n  exact JA.trans JB.symm\n\n/-- In a real vector space of dimension `> 1`, the complement of any countable set is\nconnected. -/\ntheorem Set.Countable.isConnected_compl_of_one_lt_rank (h : 1 < Module.rank \u211d E) {s : Set E}\n    (hs : s.Countable) : IsConnected s\u1d9c :=\n  (hs.isPathConnected_compl_of_one_lt_rank h).isConnected\n\n/-- In a real vector space of dimension `> 1`, the complement of any singleton is path-connected. -/\ntheorem isPathConnected_compl_singleton_of_one_lt_rank (h : 1 < Module.rank \u211d E) (x : E) :\n    IsPathConnected {x}\u1d9c :=\n  Set.Countable.isPathConnected_compl_of_one_lt_rank h (countable_singleton x)\n\n/-- In a real vector space of dimension `> 1`, the complement of a singleton is connected. -/\ntheorem isConnected_compl_singleton_of_one_lt_rank (h : 1 < Module.rank \u211d E) (x : E) :\n    IsConnected {x}\u1d9c :=\n  (isPathConnected_compl_singleton_of_one_lt_rank h x).isConnected\n\nend TopologicalVectorSpace\n\nsection NormedSpace\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n\n/-- In a real vector space of dimension `> 1`, any sphere of nonnegative radius is\npath connected. -/\ntheorem isPathConnected_sphere (h : 1 < Module.rank \u211d E) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    IsPathConnected (sphere x r) := by\n  /- when `r > 0`, we write the sphere as the image of `{0}\u1d9c` under the map\n  `y \u21a6 x + (r * \u2016y\u2016\u207b\u00b9) \u2022 y`. Since the image under a continuous map of a path connected set\n  is path connected, this concludes the proof. -/\n  rcases hr.eq_or_lt with rfl|rpos\n  \u00b7 simpa using isPathConnected_singleton x\n  let f : E \u2192 E := fun y \u21a6 x + (r * \u2016y\u2016\u207b\u00b9) \u2022 y\n  have A : ContinuousOn f {0}\u1d9c := by\n    intro y hy\n    apply (continuousAt_const.add _).continuousWithinAt\n    apply (continuousAt_const.mul (ContinuousAt.inv\u2080 continuousAt_id.norm ?_)).smul continuousAt_id\n    simpa using hy\n  have B : IsPathConnected ({0}\u1d9c : Set E) := isPathConnected_compl_singleton_of_one_lt_rank h 0\n  have C : IsPathConnected (f '' {0}\u1d9c) := B.image' A\n  have : f '' {0}\u1d9c = sphere x r := by\n    apply Subset.antisymm\n    \u00b7 rintro - \u27e8y, hy, rfl\u27e9\n      have : \u2016y\u2016 \u2260 0 := by simpa using hy\n      simp [f, norm_smul, abs_of_nonneg hr, mul_assoc, inv_mul_cancel this]\n    \u00b7 intro y hy\n      refine \u27e8y - x, ?_, ?_\u27e9\n      \u00b7 intro H\n        simp only [mem_singleton_iff, sub_eq_zero] at H\n        simp only [H, mem_sphere_iff_norm, sub_self, norm_zero] at hy\n        exact rpos.ne hy\n      \u00b7 simp [f, mem_sphere_iff_norm.1 hy, mul_inv_cancel rpos.ne']\n  rwa [this] at C\n\n/-- In a real vector space of dimension `> 1`, any sphere of nonnegative radius is connected. -/\ntheorem isConnected_sphere (h : 1 < Module.rank \u211d E) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    IsConnected (sphere x r) :=\n  (isPathConnected_sphere h x hr).isConnected\n\n/-- In a real vector space of dimension `> 1`, any sphere is preconnected. -/\ntheorem isPreconnected_sphere (h : 1 < Module.rank \u211d E) (x : E) (r : \u211d) :\n    IsPreconnected (sphere x r) := by\n  rcases le_or_lt 0 r with hr|hr\n  \u00b7 exact (isConnected_sphere h x hr).isPreconnected\n  \u00b7 simpa [hr] using isPreconnected_empty\n\nend NormedSpace\n\nsection\n\nvariable {F : Type*} [AddCommGroup F] [Module \u211d F] [TopologicalSpace F]\n  [TopologicalAddGroup F] [ContinuousSMul \u211d F]\n\n/-- Let `E` be a linear subspace in a real vector space.\nIf `E` has codimension at least two, its complement is path-connected. -/\ntheorem isPathConnected_compl_of_one_lt_codim {E : Submodule \u211d F}\n    (hcodim : 1 < Module.rank \u211d (F \u29f8 E)) : IsPathConnected (E\u1d9c : Set F) := by\n  rcases E.exists_isCompl with \u27e8E', hE'\u27e9\n  refine isPathConnected_compl_of_isPathConnected_compl_zero hE'.symm\n    (isPathConnected_compl_singleton_of_one_lt_rank ?_ 0)\n  rwa [\u2190 (E.quotientEquivOfIsCompl E' hE').rank_eq]\n\n/-- Let `E` be a linear subspace in a real vector space.\nIf `E` has codimension at least two, its complement is connected. -/\ntheorem isConnected_compl_of_one_lt_codim {E : Submodule \u211d F} (hcodim : 1 < Module.rank \u211d (F \u29f8 E)) :\n    IsConnected (E\u1d9c : Set F) :=\n  (isPathConnected_compl_of_one_lt_codim hcodim).isConnected\n\n", "theoremStatement": "theorem Submodule.connectedComponentIn_eq_self_of_one_lt_codim (E : Submodule \u211d F)\n    (hcodim : 1 < Module.rank \u211d (F \u29f8 E)) {x : F} (hx : x \u2209 E) :\n    connectedComponentIn ((E : Set F)\u1d9c) x = (E : Set F)\u1d9c", "theoremName": "Submodule.connectedComponentIn_eq_self_of_one_lt_codim", "fileCreated": {"commit": "23550c1e3b", "date": "2023-08-31"}, "theoremCreated": {"commit": "6efcbba115", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Analysis/NormedSpace/Connected.lean", "positionMetadata": {"lineInFile": 192, "tokenPositionInFile": 8707, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "(isConnected_compl_of_one_lt_codim hcodim).2.connectedComponentIn hx", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 68}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2017 Johannes H\u00f6lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H\u00f6lzl, Yury Kudryashov\n-/\nimport Mathlib.Analysis.Normed.Group.Basic\nimport Mathlib.MeasureTheory.Function.AEMeasurableSequence\nimport Mathlib.MeasureTheory.Group.Arithmetic\nimport Mathlib.MeasureTheory.Order.Lattice\nimport Mathlib.Topology.Instances.EReal\nimport Mathlib.Topology.MetricSpace.Thickening\nimport Mathlib.Topology.GDelta\nimport Mathlib.Topology.Order.Lattice\nimport Mathlib.Topology.Semicontinuous\n\n#align_import measure_theory.constructions.borel_space.basic from \"leanprover-community/mathlib\"@\"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce\"\n\n/-!\n# Borel (measurable) space\n\n## Main definitions\n\n* `borel \u03b1` : the least `\u03c3`-algebra that contains all open sets;\n* `class BorelSpace` : a space with `TopologicalSpace` and `MeasurableSpace` structures\n  such that `\u2039MeasurableSpace \u03b1\u203a = borel \u03b1`;\n* `class OpensMeasurableSpace` : a space with `TopologicalSpace` and `MeasurableSpace`\n  structures such that all open sets are measurable; equivalently, `borel \u03b1 \u2264 \u2039MeasurableSpace \u03b1\u203a`.\n* `BorelSpace` instances on `Empty`, `Unit`, `Bool`, `Nat`, `Int`, `Rat`;\n* `MeasurableSpace` and `BorelSpace` instances on `\u211d`, `\u211d\u22650`, `\u211d\u22650\u221e`.\n\n## Main statements\n\n* `IsOpen.measurableSet`, `IsClosed.measurableSet`: open and closed sets are measurable;\n* `Continuous.measurable` : a continuous function is measurable;\n* `Continuous.measurable2` : if `f : \u03b1 \u2192 \u03b2` and `g : \u03b1 \u2192 \u03b3` are measurable and `op : \u03b2 \u00d7 \u03b3 \u2192 \u03b4`\n  is continuous, then `fun x => op (f x, g y)` is measurable;\n* `Measurable.add` etc : dot notation for arithmetic operations on `Measurable` predicates,\n  and similarly for `dist` and `edist`;\n* `AEMeasurable.add` : similar dot notation for almost everywhere measurable functions;\n* `Measurable.ennreal*` : special cases for arithmetic operations on `\u211d\u22650\u221e`.\n-/\n\n\nnoncomputable section\n\nopen Set Filter MeasureTheory\n\nopen scoped Classical BigOperators Topology NNReal ENNReal MeasureTheory\n\nuniverse u v w x y\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b3\u2082 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}\n\nopen MeasurableSpace TopologicalSpace\n\n/-- `MeasurableSpace` structure generated by `TopologicalSpace`. -/\ndef borel (\u03b1 : Type u) [TopologicalSpace \u03b1] : MeasurableSpace \u03b1 :=\n  generateFrom { s : Set \u03b1 | IsOpen s }\n#align borel borel\n\ntheorem borel_anti : Antitone (@borel \u03b1) := fun _ _ h =>\n  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)\n#align borel_anti borel_anti\n\ntheorem borel_eq_top_of_discrete [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] : borel \u03b1 = \u22a4 :=\n  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)\n#align borel_eq_top_of_discrete borel_eq_top_of_discrete\n\ntheorem borel_eq_top_of_countable [TopologicalSpace \u03b1] [T1Space \u03b1] [Countable \u03b1] : borel \u03b1 = \u22a4 := by\n  refine' top_le_iff.1 fun s _ => biUnion_of_singleton s \u25b8 _\n  apply MeasurableSet.biUnion s.to_countable\n  intro x _\n  apply MeasurableSet.of_compl\n  apply GenerateMeasurable.basic\n  exact isClosed_singleton.isOpen_compl\n#align borel_eq_top_of_countable borel_eq_top_of_countable\n\ntheorem borel_eq_generateFrom_of_subbasis {s : Set (Set \u03b1)} [t : TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] (hs : t = .generateFrom s) : borel \u03b1 = .generateFrom s :=\n  le_antisymm\n    (generateFrom_le fun u (hu : t.IsOpen u) => by\n      rw [hs] at hu\n      induction hu with\n      | basic u hu => exact GenerateMeasurable.basic u hu\n      | univ => exact @MeasurableSet.univ \u03b1 (generateFrom s)\n      | inter s\u2081 s\u2082 _ _ hs\u2081 hs\u2082 => exact @MeasurableSet.inter \u03b1 (generateFrom s) _ _ hs\u2081 hs\u2082\n      | sUnion f hf ih =>\n        rcases isOpen_sUnion_countable f (by rwa [hs]) with \u27e8v, hv, vf, vu\u27e9\n        rw [\u2190 vu]\n        exact @MeasurableSet.sUnion \u03b1 (generateFrom s) _ hv fun x xv => ih _ (vf xv))\n    (generateFrom_le fun u hu =>\n      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)\n#align borel_eq_generate_from_of_subbasis borel_eq_generateFrom_of_subbasis\n\ntheorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] {s : Set (Set \u03b1)} (hs : IsTopologicalBasis s) :\n    borel \u03b1 = .generateFrom s :=\n  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom\n#align topological_space.is_topological_basis.borel_eq_generate_from TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom\n\ntheorem isPiSystem_isOpen [TopologicalSpace \u03b1] : IsPiSystem ({s : Set \u03b1 | IsOpen s}) :=\n  fun _s hs _t ht _ => IsOpen.inter hs ht\n#align is_pi_system_is_open isPiSystem_isOpen\n\nlemma isPiSystem_isClosed [TopologicalSpace \u03b1] : IsPiSystem ({s : Set \u03b1 | IsClosed s}) :=\n  fun _s hs _t ht _ \u21a6 IsClosed.inter hs ht\n\ntheorem borel_eq_generateFrom_isClosed [TopologicalSpace \u03b1] :\n    borel \u03b1 = .generateFrom { s | IsClosed s } :=\n  le_antisymm\n    (generateFrom_le fun _t ht =>\n      @MeasurableSet.of_compl \u03b1 _ (generateFrom { s | IsClosed s })\n        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))\n    (generateFrom_le fun _t ht =>\n      @MeasurableSet.of_compl \u03b1 _ (borel \u03b1) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))\n#align borel_eq_generate_from_is_closed borel_eq_generateFrom_isClosed\n\nsection OrderTopology\n\nvariable (\u03b1)\nvariable [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]\n\ntheorem borel_eq_generateFrom_Iio : borel \u03b1 = .generateFrom (range Iio) := by\n  refine' le_antisymm _ (generateFrom_le _)\n  \u00b7 rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals \u03b1 _ _ _)]\n    letI : MeasurableSpace \u03b1 := MeasurableSpace.generateFrom (range Iio)\n    have H : \u2200 a : \u03b1, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ \u27e8_, rfl\u27e9\n    refine' generateFrom_le _\n    rintro _ \u27e8a, rfl | rfl\u27e9\n    \u00b7 rcases em (\u2203 b, a \u22d6 b) with \u27e8b, hb\u27e9 | hcovBy\n      \u00b7 rw [hb.Ioi_eq, \u2190 compl_Iio]\n        exact (H _).compl\n      \u00b7 rcases isOpen_biUnion_countable (Ioi a) Ioi fun _ _ \u21a6 isOpen_Ioi with \u27e8t, hat, htc, htU\u27e9\n        have : Ioi a = \u22c3 b \u2208 t, Ici b := by\n          refine Subset.antisymm ?_ <| iUnion\u2082_subset fun b hb \u21a6 Ici_subset_Ioi.2 (hat hb)\n          refine Subset.trans ?_ <| iUnion\u2082_mono fun _ _ \u21a6 Ioi_subset_Ici_self\n          simpa [CovBy, htU, subset_def] using hcovBy\n        simp only [this, \u2190 compl_Iio]\n        exact .biUnion htc <| fun _ _ \u21a6 (H _).compl\n    \u00b7 apply H\n  \u00b7 rw [forall_mem_range]\n    intro a\n    exact GenerateMeasurable.basic _ isOpen_Iio\n#align borel_eq_generate_from_Iio borel_eq_generateFrom_Iio\n\ntheorem borel_eq_generateFrom_Ioi : borel \u03b1 = .generateFrom (range Ioi) :=\n  @borel_eq_generateFrom_Iio \u03b1\u1d52\u1d48 _ (by infer_instance : SecondCountableTopology \u03b1) _ _\n#align borel_eq_generate_from_Ioi borel_eq_generateFrom_Ioi\n\ntheorem borel_eq_generateFrom_Iic :\n    borel \u03b1 = MeasurableSpace.generateFrom (range Iic) := by\n  rw [borel_eq_generateFrom_Ioi]\n  refine' le_antisymm _ _\n  \u00b7 refine' MeasurableSpace.generateFrom_le fun t ht => _\n    obtain \u27e8u, rfl\u27e9 := ht\n    rw [\u2190 compl_Iic]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr \u27e8u, rfl\u27e9)).compl\n  \u00b7 refine' MeasurableSpace.generateFrom_le fun t ht => _\n    obtain \u27e8u, rfl\u27e9 := ht\n    rw [\u2190 compl_Ioi]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr \u27e8u, rfl\u27e9)).compl\n#align borel_eq_generate_from_Iic borel_eq_generateFrom_Iic\n\ntheorem borel_eq_generateFrom_Ici : borel \u03b1 = MeasurableSpace.generateFrom (range Ici) :=\n  @borel_eq_generateFrom_Iic \u03b1\u1d52\u1d48 _ _ _ _\n#align borel_eq_generate_from_Ici borel_eq_generateFrom_Ici\n\nend OrderTopology\n\ntheorem borel_comap {f : \u03b1 \u2192 \u03b2} {t : TopologicalSpace \u03b2} :\n    @borel \u03b1 (t.induced f) = (@borel \u03b2 t).comap f :=\n  comap_generateFrom.symm\n#align borel_comap borel_comap\n\ntheorem Continuous.borel_measurable [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Continuous f) : @Measurable \u03b1 \u03b2 (borel \u03b1) (borel \u03b2) f :=\n  Measurable.of_le_map <|\n    generateFrom_le fun s hs => GenerateMeasurable.basic (f \u207b\u00b9' s) (hs.preimage hf)\n#align continuous.borel_measurable Continuous.borel_measurable\n\n/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that\nall open sets are measurable. -/\nclass OpensMeasurableSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [h : MeasurableSpace \u03b1] : Prop where\n  /-- Borel-measurable sets are measurable. -/\n  borel_le : borel \u03b1 \u2264 h\n#align opens_measurable_space OpensMeasurableSpace\n#align opens_measurable_space.borel_le OpensMeasurableSpace.borel_le\n\n/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that\nthe `\u03c3`-algebra of measurable sets is exactly the `\u03c3`-algebra generated by open sets. -/\nclass BorelSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] : Prop where\n  /-- The measurable sets are exactly the Borel-measurable sets. -/\n  measurable_eq : \u2039MeasurableSpace \u03b1\u203a = borel \u03b1\n#align borel_space BorelSpace\n#align borel_space.measurable_eq BorelSpace.measurable_eq\n\nnamespace Mathlib.Tactic.Borelize\n\nopen Lean Elab Term Tactic Meta\n\n/-- The behaviour of `borelize \u03b1` depends on the existing assumptions on `\u03b1`.\n\n- if `\u03b1` is a topological space with instances `[MeasurableSpace \u03b1] [BorelSpace \u03b1]`, then\n  `borelize \u03b1` replaces the former instance by `borel \u03b1`;\n- otherwise, `borelize \u03b1` adds instances `borel \u03b1 : MeasurableSpace \u03b1` and `\u27e8rfl\u27e9 : BorelSpace \u03b1`.\n\nFinally, `borelize \u03b1 \u03b2 \u03b3` runs `borelize \u03b1; borelize \u03b2; borelize \u03b3`.\n-/\nsyntax \"borelize\" (ppSpace colGt term:max)* : tactic\n\n/-- Add instances `borel e : MeasurableSpace e` and `\u27e8rfl\u27e9 : BorelSpace e`. -/\ndef addBorelInstance (e : Expr) : TacticM Unit := do\n  let t \u2190 Lean.Elab.Term.exprToSyntax e\n  evalTactic <| \u2190 `(tactic|\n    refine_lift\n      letI : MeasurableSpace $t := borel $t\n      haveI : BorelSpace $t := \u27e8rfl\u27e9\n      ?_)\n\n/-- Given a type `e`, an assumption `i : MeasurableSpace e`, and an instance `[BorelSpace e]`,\nreplace `i` with `borel e`. -/\ndef borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do\n  let te \u2190 Lean.Elab.Term.exprToSyntax e\n  evalTactic <| \u2190 `(tactic|\n    have := @BorelSpace.measurable_eq $te _ _ _)\n  try\n    liftMetaTactic fun m => return [\u2190 subst m i]\n  catch _ =>\n    let et \u2190 synthInstance (\u2190 mkAppOptM ``TopologicalSpace #[e])\n    throwError m!\"\\\n      `\u2039TopologicalSpace {e}\u203a := {et}\\n\\\n      depends on\\n\\\n      {Expr.fvar i} : MeasurableSpace {e}`\\n\\\n      so `borelize` isn't avaliable\"\n  evalTactic <| \u2190 `(tactic|\n    refine_lift\n      letI : MeasurableSpace $te := borel $te\n      ?_)\n\n/-- Given a type `$t`, if there is an assumption `[i : MeasurableSpace $t]`, then try to prove\n`[BorelSpace $t]` and replace `i` with `borel $t`. Otherwise, add instances\n`borel $t : MeasurableSpace $t` and `\u27e8rfl\u27e9 : BorelSpace $t`. -/\ndef borelize (t : Term) : TacticM Unit := withMainContext <| do\n  let u \u2190 mkFreshLevelMVar\n  let e \u2190 withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))\n  let i? \u2190 findLocalDeclWithType? (\u2190 mkAppOptM ``MeasurableSpace #[e])\n  i?.elim (addBorelInstance e) (borelToRefl e)\n\nelab_rules : tactic\n  | `(tactic| borelize $[$t:term]*) => t.forM borelize\n\nend Mathlib.Tactic.Borelize\n\ninstance (priority := 100) OrderDual.opensMeasurableSpace {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [h : OpensMeasurableSpace \u03b1] : OpensMeasurableSpace \u03b1\u1d52\u1d48 where\n  borel_le := h.borel_le\n#align order_dual.opens_measurable_space OrderDual.opensMeasurableSpace\n\ninstance (priority := 100) OrderDual.borelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [h : BorelSpace \u03b1] : BorelSpace \u03b1\u1d52\u1d48 where\n  measurable_eq := h.measurable_eq\n#align order_dual.borel_space OrderDual.borelSpace\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ninstance (priority := 100) BorelSpace.opensMeasurable {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [BorelSpace \u03b1] : OpensMeasurableSpace \u03b1 :=\n  \u27e8ge_of_eq <| BorelSpace.measurable_eq\u27e9\n#align borel_space.opens_measurable BorelSpace.opensMeasurable\n\ninstance Subtype.borelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [MeasurableSpace \u03b1]\n    [h\u03b1 : BorelSpace \u03b1] (s : Set \u03b1) : BorelSpace s :=\n  \u27e8by borelize \u03b1; symm; apply borel_comap\u27e9\n#align subtype.borel_space Subtype.borelSpace\n\ninstance Countable.instBorelSpace [Countable \u03b1] [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1]\n    [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] : BorelSpace \u03b1 := by\n  have : \u2200 s, @MeasurableSet \u03b1 inferInstance s := fun s \u21a6 s.to_countable.measurableSet\n  have : \u2200 s, @MeasurableSet \u03b1 (borel \u03b1) s := fun s \u21a6 measurableSet_generateFrom (isOpen_discrete s)\n  exact \u27e8by aesop\u27e9\n\ninstance Subtype.opensMeasurableSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [MeasurableSpace \u03b1]\n    [h : OpensMeasurableSpace \u03b1] (s : Set \u03b1) : OpensMeasurableSpace s :=\n  \u27e8by\n    rw [borel_comap]\n    exact comap_mono h.1\u27e9\n#align subtype.opens_measurable_space Subtype.opensMeasurableSpace\n\nlemma opensMeasurableSpace_iff_forall_measurableSet\n    [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] :\n    OpensMeasurableSpace \u03b1 \u2194  (\u2200 (s : Set \u03b1), IsOpen s \u2192 MeasurableSet s) := by\n  refine \u27e8fun h s hs \u21a6 ?_, fun h \u21a6 \u27e8generateFrom_le h\u27e9\u27e9\n  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs\n\ninstance (priority := 100) BorelSpace.countablyGenerated {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [BorelSpace \u03b1] [SecondCountableTopology \u03b1] : CountablyGenerated \u03b1 := by\n  obtain \u27e8b, bct, -, hb\u27e9 := exists_countable_basis \u03b1\n  refine' \u27e8\u27e8b, bct, _\u27e9\u27e9\n  borelize \u03b1\n  exact hb.borel_eq_generateFrom\n#align borel_space.countably_generated BorelSpace.countablyGenerated\n\ntheorem MeasurableSet.induction_on_open [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1]\n    {C : Set \u03b1 \u2192 Prop} (h_open : \u2200 U, IsOpen U \u2192 C U)\n    (h_compl : \u2200 t, MeasurableSet t \u2192 C t \u2192 C t\u1d9c)\n    (h_union :\n      \u2200 f : \u2115 \u2192 Set \u03b1,\n        Pairwise (Disjoint on f) \u2192 (\u2200 i, MeasurableSet (f i)) \u2192 (\u2200 i, C (f i)) \u2192 C (\u22c3 i, f i)) :\n    \u2200 \u2983t\u2984, MeasurableSet t \u2192 C t :=\n  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen\n    (h_open _ isOpen_empty) h_open h_compl h_union\n#align measurable_set.induction_on_open MeasurableSet.induction_on_open\n\nsection\n\nvariable [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1] [TopologicalSpace \u03b2]\n  [MeasurableSpace \u03b2] [OpensMeasurableSpace \u03b2] [TopologicalSpace \u03b3] [MeasurableSpace \u03b3]\n  [BorelSpace \u03b3] [TopologicalSpace \u03b3\u2082] [MeasurableSpace \u03b3\u2082] [BorelSpace \u03b3\u2082] [MeasurableSpace \u03b4]\n\ntheorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=\n  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h\n#align is_open.measurable_set IsOpen.measurableSet\n\ninstance (priority := 500) {s : Set \u03b1} [HasCountableSeparatingOn \u03b1 IsOpen s] :\n    HasCountableSeparatingOn \u03b1 MeasurableSet s :=\n  .mono (fun _ \u21a6 IsOpen.measurableSet) Subset.rfl\n\n@[measurability]\ntheorem measurableSet_interior : MeasurableSet (interior s) :=\n  isOpen_interior.measurableSet\n#align measurable_set_interior measurableSet_interior\n\ntheorem IsG\u03b4.measurableSet (h : IsG\u03b4 s) : MeasurableSet s := by\n  rcases h with \u27e8S, hSo, hSc, rfl\u27e9\n  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet\nset_option linter.uppercaseLean3 false in\n#align is_G\u03b4.measurable_set IsG\u03b4.measurableSet\n\ntheorem measurableSet_of_continuousAt {\u03b2} [EMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    MeasurableSet { x | ContinuousAt f x } :=\n  (IsG\u03b4.setOf_continuousAt f).measurableSet\n#align measurable_set_of_continuous_at measurableSet_of_continuousAt\n\ntheorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=\n  h.isOpen_compl.measurableSet.of_compl\n#align is_closed.measurable_set IsClosed.measurableSet\n\ntheorem IsCompact.measurableSet [T2Space \u03b1] (h : IsCompact s) : MeasurableSet s :=\n  h.isClosed.measurableSet\n#align is_compact.measurable_set IsCompact.measurableSet\n\n/-- If two points are topologically inseparable,\nthen they can't be separated by a Borel measurable set. -/\ntheorem Inseparable.mem_measurableSet_iff {x y : \u03b3} (h : Inseparable x y) {s : Set \u03b3}\n    (hs : MeasurableSet s) : x \u2208 s \u2194 y \u2208 s :=\n  hs.induction_on_open (C := fun s \u21a6 (x \u2208 s \u2194 y \u2208 s)) (fun _ \u21a6 h.mem_open_iff) (fun s _ hs \u21a6 hs.not)\n    fun _ _ _ h \u21a6 by simp [h]\n\n/-- If `K` is a compact set in an R\u2081 space and `s \u2287 K` is a Borel measurable superset,\nthen `s` includes the closure of `K` as well. -/\ntheorem IsCompact.closure_subset_measurableSet [R1Space \u03b3] {K s : Set \u03b3} (hK : IsCompact K)\n    (hs : MeasurableSet s) (hKs : K \u2286 s) : closure K \u2286 s := by\n  rw [hK.closure_eq_biUnion_inseparable, iUnion\u2082_subset_iff]\n  exact fun x hx y hy \u21a6 (hy.mem_measurableSet_iff hs).1 (hKs hx)\n\n/-- In an R\u2081 topological space with Borel measure `\u03bc`,\nthe measure of the closure of a compact set `K` is equal to the measure of `K`.\n\nSee also `MeasureTheory.Measure.OuterRegular.measure_closure_eq_of_isCompact`\nfor a version that assumes `\u03bc` to be outer regular\nbut does not assume the `\u03c3`-algebra to be Borel.  -/\ntheorem IsCompact.measure_closure [R1Space \u03b3] {K : Set \u03b3} (hK : IsCompact K) (\u03bc : Measure \u03b3) :\n    \u03bc (closure K) = \u03bc K := by\n  refine le_antisymm ?_ (measure_mono subset_closure)\n  calc\n    \u03bc (closure K) \u2264 \u03bc (toMeasurable \u03bc K) := measure_mono <|\n      hK.closure_subset_measurableSet (measurableSet_toMeasurable ..) (subset_toMeasurable ..)\n    _ = \u03bc K := measure_toMeasurable ..\n\n@[measurability]\ntheorem measurableSet_closure : MeasurableSet (closure s) :=\n  isClosed_closure.measurableSet\n#align measurable_set_closure measurableSet_closure\n\ntheorem measurable_of_isOpen {f : \u03b4 \u2192 \u03b3} (hf : \u2200 s, IsOpen s \u2192 MeasurableSet (f \u207b\u00b9' s)) :\n    Measurable f := by\n  rw [\u2039BorelSpace \u03b3\u203a.measurable_eq]\n  exact measurable_generateFrom hf\n#align measurable_of_is_open measurable_of_isOpen\n\ntheorem measurable_of_isClosed {f : \u03b4 \u2192 \u03b3} (hf : \u2200 s, IsClosed s \u2192 MeasurableSet (f \u207b\u00b9' s)) :\n    Measurable f := by\n  apply measurable_of_isOpen; intro s hs\n  rw [\u2190 MeasurableSet.compl_iff, \u2190 preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs\n#align measurable_of_is_closed measurable_of_isClosed\n\ntheorem measurable_of_isClosed' {f : \u03b4 \u2192 \u03b3}\n    (hf : \u2200 s, IsClosed s \u2192 s.Nonempty \u2192 s \u2260 univ \u2192 MeasurableSet (f \u207b\u00b9' s)) : Measurable f := by\n  apply measurable_of_isClosed; intro s hs\n  rcases eq_empty_or_nonempty s with h1 | h1\n  \u00b7 simp [h1]\n  by_cases h2 : s = univ\n  \u00b7 simp [h2]\n  exact hf s hs h1 h2\n#align measurable_of_is_closed' measurable_of_isClosed'\n\ninstance nhds_isMeasurablyGenerated (a : \u03b1) : (\ud835\udcdd a).IsMeasurablyGenerated := by\n  rw [nhds, iInf_subtype']\n  refine' @Filter.iInf_isMeasurablyGenerated \u03b1 _ _ _ fun i => _\n  exact i.2.2.measurableSet.principal_isMeasurablyGenerated\n#align nhds_is_measurably_generated nhds_isMeasurablyGenerated\n\n/-- If `s` is a measurable set, then `\ud835\udcdd[s] a` is a measurably generated filter for\neach `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.\n-/\ntheorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set \u03b1} (hs : MeasurableSet s) (a : \u03b1) :\n    (\ud835\udcdd[s] a).IsMeasurablyGenerated :=\n  haveI := hs.principal_isMeasurablyGenerated\n  Filter.inf_isMeasurablyGenerated _ _\n#align measurable_set.nhds_within_is_measurably_generated MeasurableSet.nhdsWithin_isMeasurablyGenerated\n\n", "theoremStatement": "instance (priority := 100) OpensMeasurableSpace.separatesPoints [T0Space \u03b1] :\n    SeparatesPoints \u03b1", "theoremName": null, "fileCreated": {"commit": "11332d53f1", "date": "2023-05-21"}, "theoremCreated": {"commit": "726f2a5ff9", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "positionMetadata": {"lineInFile": 421, "tokenPositionInFile": 19055, "theoremPositionInFile": 47}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [separatesPoints_iff]\n  intro x y hxy\n  apply Inseparable.eq\n  rw [inseparable_iff_forall_open]\n  exact fun s hs => hxy _ hs.measurableSet", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 146}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2017 Johannes H\u00f6lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H\u00f6lzl, Yury Kudryashov\n-/\nimport Mathlib.Analysis.Normed.Group.Basic\nimport Mathlib.MeasureTheory.Function.AEMeasurableSequence\nimport Mathlib.MeasureTheory.Group.Arithmetic\nimport Mathlib.MeasureTheory.Order.Lattice\nimport Mathlib.Topology.Instances.EReal\nimport Mathlib.Topology.MetricSpace.Thickening\nimport Mathlib.Topology.GDelta\nimport Mathlib.Topology.Order.Lattice\nimport Mathlib.Topology.Semicontinuous\n\n#align_import measure_theory.constructions.borel_space.basic from \"leanprover-community/mathlib\"@\"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce\"\n\n/-!\n# Borel (measurable) space\n\n## Main definitions\n\n* `borel \u03b1` : the least `\u03c3`-algebra that contains all open sets;\n* `class BorelSpace` : a space with `TopologicalSpace` and `MeasurableSpace` structures\n  such that `\u2039MeasurableSpace \u03b1\u203a = borel \u03b1`;\n* `class OpensMeasurableSpace` : a space with `TopologicalSpace` and `MeasurableSpace`\n  structures such that all open sets are measurable; equivalently, `borel \u03b1 \u2264 \u2039MeasurableSpace \u03b1\u203a`.\n* `BorelSpace` instances on `Empty`, `Unit`, `Bool`, `Nat`, `Int`, `Rat`;\n* `MeasurableSpace` and `BorelSpace` instances on `\u211d`, `\u211d\u22650`, `\u211d\u22650\u221e`.\n\n## Main statements\n\n* `IsOpen.measurableSet`, `IsClosed.measurableSet`: open and closed sets are measurable;\n* `Continuous.measurable` : a continuous function is measurable;\n* `Continuous.measurable2` : if `f : \u03b1 \u2192 \u03b2` and `g : \u03b1 \u2192 \u03b3` are measurable and `op : \u03b2 \u00d7 \u03b3 \u2192 \u03b4`\n  is continuous, then `fun x => op (f x, g y)` is measurable;\n* `Measurable.add` etc : dot notation for arithmetic operations on `Measurable` predicates,\n  and similarly for `dist` and `edist`;\n* `AEMeasurable.add` : similar dot notation for almost everywhere measurable functions;\n* `Measurable.ennreal*` : special cases for arithmetic operations on `\u211d\u22650\u221e`.\n-/\n\n\nnoncomputable section\n\nopen Set Filter MeasureTheory\n\nopen scoped Classical BigOperators Topology NNReal ENNReal MeasureTheory\n\nuniverse u v w x y\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b3\u2082 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}\n\nopen MeasurableSpace TopologicalSpace\n\n/-- `MeasurableSpace` structure generated by `TopologicalSpace`. -/\ndef borel (\u03b1 : Type u) [TopologicalSpace \u03b1] : MeasurableSpace \u03b1 :=\n  generateFrom { s : Set \u03b1 | IsOpen s }\n#align borel borel\n\ntheorem borel_anti : Antitone (@borel \u03b1) := fun _ _ h =>\n  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)\n#align borel_anti borel_anti\n\ntheorem borel_eq_top_of_discrete [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] : borel \u03b1 = \u22a4 :=\n  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)\n#align borel_eq_top_of_discrete borel_eq_top_of_discrete\n\ntheorem borel_eq_top_of_countable [TopologicalSpace \u03b1] [T1Space \u03b1] [Countable \u03b1] : borel \u03b1 = \u22a4 := by\n  refine' top_le_iff.1 fun s _ => biUnion_of_singleton s \u25b8 _\n  apply MeasurableSet.biUnion s.to_countable\n  intro x _\n  apply MeasurableSet.of_compl\n  apply GenerateMeasurable.basic\n  exact isClosed_singleton.isOpen_compl\n#align borel_eq_top_of_countable borel_eq_top_of_countable\n\ntheorem borel_eq_generateFrom_of_subbasis {s : Set (Set \u03b1)} [t : TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] (hs : t = .generateFrom s) : borel \u03b1 = .generateFrom s :=\n  le_antisymm\n    (generateFrom_le fun u (hu : t.IsOpen u) => by\n      rw [hs] at hu\n      induction hu with\n      | basic u hu => exact GenerateMeasurable.basic u hu\n      | univ => exact @MeasurableSet.univ \u03b1 (generateFrom s)\n      | inter s\u2081 s\u2082 _ _ hs\u2081 hs\u2082 => exact @MeasurableSet.inter \u03b1 (generateFrom s) _ _ hs\u2081 hs\u2082\n      | sUnion f hf ih =>\n        rcases isOpen_sUnion_countable f (by rwa [hs]) with \u27e8v, hv, vf, vu\u27e9\n        rw [\u2190 vu]\n        exact @MeasurableSet.sUnion \u03b1 (generateFrom s) _ hv fun x xv => ih _ (vf xv))\n    (generateFrom_le fun u hu =>\n      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)\n#align borel_eq_generate_from_of_subbasis borel_eq_generateFrom_of_subbasis\n\ntheorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] {s : Set (Set \u03b1)} (hs : IsTopologicalBasis s) :\n    borel \u03b1 = .generateFrom s :=\n  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom\n#align topological_space.is_topological_basis.borel_eq_generate_from TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom\n\ntheorem isPiSystem_isOpen [TopologicalSpace \u03b1] : IsPiSystem ({s : Set \u03b1 | IsOpen s}) :=\n  fun _s hs _t ht _ => IsOpen.inter hs ht\n#align is_pi_system_is_open isPiSystem_isOpen\n\nlemma isPiSystem_isClosed [TopologicalSpace \u03b1] : IsPiSystem ({s : Set \u03b1 | IsClosed s}) :=\n  fun _s hs _t ht _ \u21a6 IsClosed.inter hs ht\n\ntheorem borel_eq_generateFrom_isClosed [TopologicalSpace \u03b1] :\n    borel \u03b1 = .generateFrom { s | IsClosed s } :=\n  le_antisymm\n    (generateFrom_le fun _t ht =>\n      @MeasurableSet.of_compl \u03b1 _ (generateFrom { s | IsClosed s })\n        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))\n    (generateFrom_le fun _t ht =>\n      @MeasurableSet.of_compl \u03b1 _ (borel \u03b1) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))\n#align borel_eq_generate_from_is_closed borel_eq_generateFrom_isClosed\n\nsection OrderTopology\n\nvariable (\u03b1)\nvariable [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]\n\ntheorem borel_eq_generateFrom_Iio : borel \u03b1 = .generateFrom (range Iio) := by\n  refine' le_antisymm _ (generateFrom_le _)\n  \u00b7 rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals \u03b1 _ _ _)]\n    letI : MeasurableSpace \u03b1 := MeasurableSpace.generateFrom (range Iio)\n    have H : \u2200 a : \u03b1, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ \u27e8_, rfl\u27e9\n    refine' generateFrom_le _\n    rintro _ \u27e8a, rfl | rfl\u27e9\n    \u00b7 rcases em (\u2203 b, a \u22d6 b) with \u27e8b, hb\u27e9 | hcovBy\n      \u00b7 rw [hb.Ioi_eq, \u2190 compl_Iio]\n        exact (H _).compl\n      \u00b7 rcases isOpen_biUnion_countable (Ioi a) Ioi fun _ _ \u21a6 isOpen_Ioi with \u27e8t, hat, htc, htU\u27e9\n        have : Ioi a = \u22c3 b \u2208 t, Ici b := by\n          refine Subset.antisymm ?_ <| iUnion\u2082_subset fun b hb \u21a6 Ici_subset_Ioi.2 (hat hb)\n          refine Subset.trans ?_ <| iUnion\u2082_mono fun _ _ \u21a6 Ioi_subset_Ici_self\n          simpa [CovBy, htU, subset_def] using hcovBy\n        simp only [this, \u2190 compl_Iio]\n        exact .biUnion htc <| fun _ _ \u21a6 (H _).compl\n    \u00b7 apply H\n  \u00b7 rw [forall_mem_range]\n    intro a\n    exact GenerateMeasurable.basic _ isOpen_Iio\n#align borel_eq_generate_from_Iio borel_eq_generateFrom_Iio\n\ntheorem borel_eq_generateFrom_Ioi : borel \u03b1 = .generateFrom (range Ioi) :=\n  @borel_eq_generateFrom_Iio \u03b1\u1d52\u1d48 _ (by infer_instance : SecondCountableTopology \u03b1) _ _\n#align borel_eq_generate_from_Ioi borel_eq_generateFrom_Ioi\n\ntheorem borel_eq_generateFrom_Iic :\n    borel \u03b1 = MeasurableSpace.generateFrom (range Iic) := by\n  rw [borel_eq_generateFrom_Ioi]\n  refine' le_antisymm _ _\n  \u00b7 refine' MeasurableSpace.generateFrom_le fun t ht => _\n    obtain \u27e8u, rfl\u27e9 := ht\n    rw [\u2190 compl_Iic]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr \u27e8u, rfl\u27e9)).compl\n  \u00b7 refine' MeasurableSpace.generateFrom_le fun t ht => _\n    obtain \u27e8u, rfl\u27e9 := ht\n    rw [\u2190 compl_Ioi]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr \u27e8u, rfl\u27e9)).compl\n#align borel_eq_generate_from_Iic borel_eq_generateFrom_Iic\n\ntheorem borel_eq_generateFrom_Ici : borel \u03b1 = MeasurableSpace.generateFrom (range Ici) :=\n  @borel_eq_generateFrom_Iic \u03b1\u1d52\u1d48 _ _ _ _\n#align borel_eq_generate_from_Ici borel_eq_generateFrom_Ici\n\nend OrderTopology\n\ntheorem borel_comap {f : \u03b1 \u2192 \u03b2} {t : TopologicalSpace \u03b2} :\n    @borel \u03b1 (t.induced f) = (@borel \u03b2 t).comap f :=\n  comap_generateFrom.symm\n#align borel_comap borel_comap\n\ntheorem Continuous.borel_measurable [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Continuous f) : @Measurable \u03b1 \u03b2 (borel \u03b1) (borel \u03b2) f :=\n  Measurable.of_le_map <|\n    generateFrom_le fun s hs => GenerateMeasurable.basic (f \u207b\u00b9' s) (hs.preimage hf)\n#align continuous.borel_measurable Continuous.borel_measurable\n\n/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that\nall open sets are measurable. -/\nclass OpensMeasurableSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [h : MeasurableSpace \u03b1] : Prop where\n  /-- Borel-measurable sets are measurable. -/\n  borel_le : borel \u03b1 \u2264 h\n#align opens_measurable_space OpensMeasurableSpace\n#align opens_measurable_space.borel_le OpensMeasurableSpace.borel_le\n\n/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that\nthe `\u03c3`-algebra of measurable sets is exactly the `\u03c3`-algebra generated by open sets. -/\nclass BorelSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] : Prop where\n  /-- The measurable sets are exactly the Borel-measurable sets. -/\n  measurable_eq : \u2039MeasurableSpace \u03b1\u203a = borel \u03b1\n#align borel_space BorelSpace\n#align borel_space.measurable_eq BorelSpace.measurable_eq\n\nnamespace Mathlib.Tactic.Borelize\n\nopen Lean Elab Term Tactic Meta\n\n/-- The behaviour of `borelize \u03b1` depends on the existing assumptions on `\u03b1`.\n\n- if `\u03b1` is a topological space with instances `[MeasurableSpace \u03b1] [BorelSpace \u03b1]`, then\n  `borelize \u03b1` replaces the former instance by `borel \u03b1`;\n- otherwise, `borelize \u03b1` adds instances `borel \u03b1 : MeasurableSpace \u03b1` and `\u27e8rfl\u27e9 : BorelSpace \u03b1`.\n\nFinally, `borelize \u03b1 \u03b2 \u03b3` runs `borelize \u03b1; borelize \u03b2; borelize \u03b3`.\n-/\nsyntax \"borelize\" (ppSpace colGt term:max)* : tactic\n\n/-- Add instances `borel e : MeasurableSpace e` and `\u27e8rfl\u27e9 : BorelSpace e`. -/\ndef addBorelInstance (e : Expr) : TacticM Unit := do\n  let t \u2190 Lean.Elab.Term.exprToSyntax e\n  evalTactic <| \u2190 `(tactic|\n    refine_lift\n      letI : MeasurableSpace $t := borel $t\n      haveI : BorelSpace $t := \u27e8rfl\u27e9\n      ?_)\n\n/-- Given a type `e`, an assumption `i : MeasurableSpace e`, and an instance `[BorelSpace e]`,\nreplace `i` with `borel e`. -/\ndef borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do\n  let te \u2190 Lean.Elab.Term.exprToSyntax e\n  evalTactic <| \u2190 `(tactic|\n    have := @BorelSpace.measurable_eq $te _ _ _)\n  try\n    liftMetaTactic fun m => return [\u2190 subst m i]\n  catch _ =>\n    let et \u2190 synthInstance (\u2190 mkAppOptM ``TopologicalSpace #[e])\n    throwError m!\"\\\n      `\u2039TopologicalSpace {e}\u203a := {et}\\n\\\n      depends on\\n\\\n      {Expr.fvar i} : MeasurableSpace {e}`\\n\\\n      so `borelize` isn't avaliable\"\n  evalTactic <| \u2190 `(tactic|\n    refine_lift\n      letI : MeasurableSpace $te := borel $te\n      ?_)\n\n/-- Given a type `$t`, if there is an assumption `[i : MeasurableSpace $t]`, then try to prove\n`[BorelSpace $t]` and replace `i` with `borel $t`. Otherwise, add instances\n`borel $t : MeasurableSpace $t` and `\u27e8rfl\u27e9 : BorelSpace $t`. -/\ndef borelize (t : Term) : TacticM Unit := withMainContext <| do\n  let u \u2190 mkFreshLevelMVar\n  let e \u2190 withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))\n  let i? \u2190 findLocalDeclWithType? (\u2190 mkAppOptM ``MeasurableSpace #[e])\n  i?.elim (addBorelInstance e) (borelToRefl e)\n\nelab_rules : tactic\n  | `(tactic| borelize $[$t:term]*) => t.forM borelize\n\nend Mathlib.Tactic.Borelize\n\ninstance (priority := 100) OrderDual.opensMeasurableSpace {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [h : OpensMeasurableSpace \u03b1] : OpensMeasurableSpace \u03b1\u1d52\u1d48 where\n  borel_le := h.borel_le\n#align order_dual.opens_measurable_space OrderDual.opensMeasurableSpace\n\ninstance (priority := 100) OrderDual.borelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [h : BorelSpace \u03b1] : BorelSpace \u03b1\u1d52\u1d48 where\n  measurable_eq := h.measurable_eq\n#align order_dual.borel_space OrderDual.borelSpace\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ninstance (priority := 100) BorelSpace.opensMeasurable {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [BorelSpace \u03b1] : OpensMeasurableSpace \u03b1 :=\n  \u27e8ge_of_eq <| BorelSpace.measurable_eq\u27e9\n#align borel_space.opens_measurable BorelSpace.opensMeasurable\n\ninstance Subtype.borelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [MeasurableSpace \u03b1]\n    [h\u03b1 : BorelSpace \u03b1] (s : Set \u03b1) : BorelSpace s :=\n  \u27e8by borelize \u03b1; symm; apply borel_comap\u27e9\n#align subtype.borel_space Subtype.borelSpace\n\ninstance Countable.instBorelSpace [Countable \u03b1] [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1]\n    [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] : BorelSpace \u03b1 := by\n  have : \u2200 s, @MeasurableSet \u03b1 inferInstance s := fun s \u21a6 s.to_countable.measurableSet\n  have : \u2200 s, @MeasurableSet \u03b1 (borel \u03b1) s := fun s \u21a6 measurableSet_generateFrom (isOpen_discrete s)\n  exact \u27e8by aesop\u27e9\n\ninstance Subtype.opensMeasurableSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [MeasurableSpace \u03b1]\n    [h : OpensMeasurableSpace \u03b1] (s : Set \u03b1) : OpensMeasurableSpace s :=\n  \u27e8by\n    rw [borel_comap]\n    exact comap_mono h.1\u27e9\n#align subtype.opens_measurable_space Subtype.opensMeasurableSpace\n\nlemma opensMeasurableSpace_iff_forall_measurableSet\n    [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] :\n    OpensMeasurableSpace \u03b1 \u2194  (\u2200 (s : Set \u03b1), IsOpen s \u2192 MeasurableSet s) := by\n  refine \u27e8fun h s hs \u21a6 ?_, fun h \u21a6 \u27e8generateFrom_le h\u27e9\u27e9\n  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs\n\ninstance (priority := 100) BorelSpace.countablyGenerated {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [BorelSpace \u03b1] [SecondCountableTopology \u03b1] : CountablyGenerated \u03b1 := by\n  obtain \u27e8b, bct, -, hb\u27e9 := exists_countable_basis \u03b1\n  refine' \u27e8\u27e8b, bct, _\u27e9\u27e9\n  borelize \u03b1\n  exact hb.borel_eq_generateFrom\n#align borel_space.countably_generated BorelSpace.countablyGenerated\n\ntheorem MeasurableSet.induction_on_open [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1]\n    {C : Set \u03b1 \u2192 Prop} (h_open : \u2200 U, IsOpen U \u2192 C U)\n    (h_compl : \u2200 t, MeasurableSet t \u2192 C t \u2192 C t\u1d9c)\n    (h_union :\n      \u2200 f : \u2115 \u2192 Set \u03b1,\n        Pairwise (Disjoint on f) \u2192 (\u2200 i, MeasurableSet (f i)) \u2192 (\u2200 i, C (f i)) \u2192 C (\u22c3 i, f i)) :\n    \u2200 \u2983t\u2984, MeasurableSet t \u2192 C t :=\n  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen\n    (h_open _ isOpen_empty) h_open h_compl h_union\n#align measurable_set.induction_on_open MeasurableSet.induction_on_open\n\nsection\n\nvariable [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1] [TopologicalSpace \u03b2]\n  [MeasurableSpace \u03b2] [OpensMeasurableSpace \u03b2] [TopologicalSpace \u03b3] [MeasurableSpace \u03b3]\n  [BorelSpace \u03b3] [TopologicalSpace \u03b3\u2082] [MeasurableSpace \u03b3\u2082] [BorelSpace \u03b3\u2082] [MeasurableSpace \u03b4]\n\ntheorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=\n  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h\n#align is_open.measurable_set IsOpen.measurableSet\n\ninstance (priority := 500) {s : Set \u03b1} [HasCountableSeparatingOn \u03b1 IsOpen s] :\n    HasCountableSeparatingOn \u03b1 MeasurableSet s :=\n  .mono (fun _ \u21a6 IsOpen.measurableSet) Subset.rfl\n\n@[measurability]\ntheorem measurableSet_interior : MeasurableSet (interior s) :=\n  isOpen_interior.measurableSet\n#align measurable_set_interior measurableSet_interior\n\ntheorem IsG\u03b4.measurableSet (h : IsG\u03b4 s) : MeasurableSet s := by\n  rcases h with \u27e8S, hSo, hSc, rfl\u27e9\n  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet\nset_option linter.uppercaseLean3 false in\n#align is_G\u03b4.measurable_set IsG\u03b4.measurableSet\n\ntheorem measurableSet_of_continuousAt {\u03b2} [EMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    MeasurableSet { x | ContinuousAt f x } :=\n  (IsG\u03b4.setOf_continuousAt f).measurableSet\n#align measurable_set_of_continuous_at measurableSet_of_continuousAt\n\ntheorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=\n  h.isOpen_compl.measurableSet.of_compl\n#align is_closed.measurable_set IsClosed.measurableSet\n\ntheorem IsCompact.measurableSet [T2Space \u03b1] (h : IsCompact s) : MeasurableSet s :=\n  h.isClosed.measurableSet\n#align is_compact.measurable_set IsCompact.measurableSet\n\n/-- If two points are topologically inseparable,\nthen they can't be separated by a Borel measurable set. -/\ntheorem Inseparable.mem_measurableSet_iff {x y : \u03b3} (h : Inseparable x y) {s : Set \u03b3}\n    (hs : MeasurableSet s) : x \u2208 s \u2194 y \u2208 s :=\n  hs.induction_on_open (C := fun s \u21a6 (x \u2208 s \u2194 y \u2208 s)) (fun _ \u21a6 h.mem_open_iff) (fun s _ hs \u21a6 hs.not)\n    fun _ _ _ h \u21a6 by simp [h]\n\n/-- If `K` is a compact set in an R\u2081 space and `s \u2287 K` is a Borel measurable superset,\nthen `s` includes the closure of `K` as well. -/\ntheorem IsCompact.closure_subset_measurableSet [R1Space \u03b3] {K s : Set \u03b3} (hK : IsCompact K)\n    (hs : MeasurableSet s) (hKs : K \u2286 s) : closure K \u2286 s := by\n  rw [hK.closure_eq_biUnion_inseparable, iUnion\u2082_subset_iff]\n  exact fun x hx y hy \u21a6 (hy.mem_measurableSet_iff hs).1 (hKs hx)\n\n/-- In an R\u2081 topological space with Borel measure `\u03bc`,\nthe measure of the closure of a compact set `K` is equal to the measure of `K`.\n\nSee also `MeasureTheory.Measure.OuterRegular.measure_closure_eq_of_isCompact`\nfor a version that assumes `\u03bc` to be outer regular\nbut does not assume the `\u03c3`-algebra to be Borel.  -/\ntheorem IsCompact.measure_closure [R1Space \u03b3] {K : Set \u03b3} (hK : IsCompact K) (\u03bc : Measure \u03b3) :\n    \u03bc (closure K) = \u03bc K := by\n  refine le_antisymm ?_ (measure_mono subset_closure)\n  calc\n    \u03bc (closure K) \u2264 \u03bc (toMeasurable \u03bc K) := measure_mono <|\n      hK.closure_subset_measurableSet (measurableSet_toMeasurable ..) (subset_toMeasurable ..)\n    _ = \u03bc K := measure_toMeasurable ..\n\n@[measurability]\ntheorem measurableSet_closure : MeasurableSet (closure s) :=\n  isClosed_closure.measurableSet\n#align measurable_set_closure measurableSet_closure\n\ntheorem measurable_of_isOpen {f : \u03b4 \u2192 \u03b3} (hf : \u2200 s, IsOpen s \u2192 MeasurableSet (f \u207b\u00b9' s)) :\n    Measurable f := by\n  rw [\u2039BorelSpace \u03b3\u203a.measurable_eq]\n  exact measurable_generateFrom hf\n#align measurable_of_is_open measurable_of_isOpen\n\ntheorem measurable_of_isClosed {f : \u03b4 \u2192 \u03b3} (hf : \u2200 s, IsClosed s \u2192 MeasurableSet (f \u207b\u00b9' s)) :\n    Measurable f := by\n  apply measurable_of_isOpen; intro s hs\n  rw [\u2190 MeasurableSet.compl_iff, \u2190 preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs\n#align measurable_of_is_closed measurable_of_isClosed\n\ntheorem measurable_of_isClosed' {f : \u03b4 \u2192 \u03b3}\n    (hf : \u2200 s, IsClosed s \u2192 s.Nonempty \u2192 s \u2260 univ \u2192 MeasurableSet (f \u207b\u00b9' s)) : Measurable f := by\n  apply measurable_of_isClosed; intro s hs\n  rcases eq_empty_or_nonempty s with h1 | h1\n  \u00b7 simp [h1]\n  by_cases h2 : s = univ\n  \u00b7 simp [h2]\n  exact hf s hs h1 h2\n#align measurable_of_is_closed' measurable_of_isClosed'\n\ninstance nhds_isMeasurablyGenerated (a : \u03b1) : (\ud835\udcdd a).IsMeasurablyGenerated := by\n  rw [nhds, iInf_subtype']\n  refine' @Filter.iInf_isMeasurablyGenerated \u03b1 _ _ _ fun i => _\n  exact i.2.2.measurableSet.principal_isMeasurablyGenerated\n#align nhds_is_measurably_generated nhds_isMeasurablyGenerated\n\n/-- If `s` is a measurable set, then `\ud835\udcdd[s] a` is a measurably generated filter for\neach `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.\n-/\ntheorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set \u03b1} (hs : MeasurableSet s) (a : \u03b1) :\n    (\ud835\udcdd[s] a).IsMeasurablyGenerated :=\n  haveI := hs.principal_isMeasurablyGenerated\n  Filter.inf_isMeasurablyGenerated _ _\n#align measurable_set.nhds_within_is_measurably_generated MeasurableSet.nhdsWithin_isMeasurablyGenerated\n\ninstance (priority := 100) OpensMeasurableSpace.separatesPoints [T0Space \u03b1] :\n    SeparatesPoints \u03b1 := by\n  rw [separatesPoints_iff]\n  intro x y hxy\n  apply Inseparable.eq\n  rw [inseparable_iff_forall_open]\n  exact fun s hs => hxy _ hs.measurableSet\n\n-- see Note [lower instance priority]\ninstance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space \u03b1] :\n    MeasurableSingletonClass \u03b1 :=\n  \u27e8fun _ => isClosed_singleton.measurableSet\u27e9\n#align opens_measurable_space.to_measurable_singleton_class OpensMeasurableSpace.toMeasurableSingletonClass\n48\ninstance Pi.opensMeasurableSpace {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [Countable \u03b9]\n    [t' : \u2200 i, TopologicalSpace (\u03c0 i)] [\u2200 i, MeasurableSpace (\u03c0 i)]\n    [\u2200 i, SecondCountableTopology (\u03c0 i)] [\u2200 i, OpensMeasurableSpace (\u03c0 i)] :\n    OpensMeasurableSpace (\u2200 i, \u03c0 i) := by\n  constructor\n  have : Pi.topologicalSpace = .generateFrom { t | \u2203 (s : \u2200 a, Set (\u03c0 a)) (i : Finset \u03b9),\n      (\u2200 a \u2208 i, s a \u2208 countableBasis (\u03c0 a)) \u2227 t = pi (\u2191i) s } := by\n    rw [funext fun a => @eq_generateFrom_countableBasis (\u03c0 a) _ _, pi_generateFrom_eq]\n  rw [borel_eq_generateFrom_of_subbasis this]\n  apply generateFrom_le\n  rintro _ \u27e8s, i, hi, rfl\u27e9\n  refine' MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet _\n  rw [eq_generateFrom_countableBasis (\u03c0 a)]\n  exact .basic _ (hi a ha)\n#align pi.opens_measurable_space Pi.opensMeasurableSpace\n\n/-- The typeclass `SecondCountableTopologyEither \u03b1 \u03b2` registers the fact that at least one of\nthe two spaces has second countable topology. This is the right assumption to ensure that continuous\nmaps from `\u03b1` to `\u03b2` are strongly measurable. -/\nclass SecondCountableTopologyEither (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] :\n  Prop where\n  /-- The projection out of `SecondCountableTopologyEither` -/\n  out : SecondCountableTopology \u03b1 \u2228 SecondCountableTopology \u03b2\n#align second_countable_topology_either SecondCountableTopologyEither\n\ninstance (priority := 100) secondCountableTopologyEither_of_left (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1]\n    [TopologicalSpace \u03b2] [SecondCountableTopology \u03b1] : SecondCountableTopologyEither \u03b1 \u03b2 where\n  out := Or.inl (by infer_instance)\n#align second_countable_topology_either_of_left secondCountableTopologyEither_of_left\n\ninstance (priority := 100) secondCountableTopologyEither_of_right (\u03b1 \u03b2 : Type*)\n    [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [SecondCountableTopology \u03b2] :\n    SecondCountableTopologyEither \u03b1 \u03b2 where\n  out := Or.inr (by infer_instance)\n#align second_countable_topology_either_of_right secondCountableTopologyEither_of_right\n\n/-- If either `\u03b1` or `\u03b2` has second-countable topology, then the open sets in `\u03b1 \u00d7 \u03b2` belong to the\nproduct sigma-algebra. -/\ninstance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither \u03b1 \u03b2] :\n    OpensMeasurableSpace (\u03b1 \u00d7 \u03b2) := by\n  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs \u21a6 ?_)\n  rcases h.out with h\u03b1|h\u03b2\n  \u00b7 let F : Set \u03b1 \u2192 Set \u03b2 := fun a \u21a6 {y | \u2203 b, IsOpen b \u2227 y \u2208 b \u2227 a \u00d7\u02e2 b \u2286 s}\n    have A : \u2200 a, IsOpen (F a) := by\n      intro a\n      apply isOpen_iff_forall_mem_open.2\n      rintro y \u27e8b, b_open, yb, hb\u27e9\n      exact \u27e8b, fun z zb \u21a6 \u27e8b, b_open, zb, hb\u27e9, b_open, yb\u27e9\n    have : s = \u22c3 a \u2208 countableBasis \u03b1, a \u00d7\u02e2 F a := by\n      apply Subset.antisymm\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        rcases isOpen_prod_iff.1 hs y1 y2 hy with \u27e8u, v, u_open, v_open, yu, yv, huv\u27e9\n        obtain \u27e8a, ha, ya, au\u27e9 : \u2203 a \u2208 countableBasis \u03b1, y1 \u2208 a \u2227 a \u2286 u :=\n          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis \u03b1) yu u_open\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]\n        exact \u27e8a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huv\u27e9\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy\n        rcases hy with \u27e8a, ya, -, b, -, yb, hb\u27e9\n        exact hb (mem_prod.2 \u27e8ya, yb\u27e9)\n    rw [this]\n    apply MeasurableSet.biUnion (countable_countableBasis \u03b1) (fun a ha \u21a6 ?_)\n    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet\n  \u00b7 let F : Set \u03b2 \u2192 Set \u03b1 := fun a \u21a6 {y | \u2203 b, IsOpen b \u2227 y \u2208 b \u2227 b \u00d7\u02e2 a \u2286 s}\n    have A : \u2200 a, IsOpen (F a) := by\n      intro a\n      apply isOpen_iff_forall_mem_open.2\n      rintro y \u27e8b, b_open, yb, hb\u27e9\n      exact \u27e8b, fun z zb \u21a6 \u27e8b, b_open, zb, hb\u27e9, b_open, yb\u27e9\n    have : s = \u22c3 a \u2208 countableBasis \u03b2, F a \u00d7\u02e2 a := by\n      apply Subset.antisymm\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        rcases isOpen_prod_iff.1 hs y1 y2 hy with \u27e8u, v, u_open, v_open, yu, yv, huv\u27e9\n        obtain \u27e8a, ha, ya, au\u27e9 : \u2203 a \u2208 countableBasis \u03b2, y2 \u2208 a \u2227 a \u2286 v :=\n          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis \u03b2) yv v_open\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]\n        exact \u27e8a, \u27e8u, u_open, yu, (Set.prod_mono_right au).trans huv\u27e9, ha, ya\u27e9\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy\n        rcases hy with \u27e8a, \u27e8b, -, yb, hb\u27e9, -, ya\u27e9\n        exact hb (mem_prod.2 \u27e8yb, ya\u27e9)\n    rw [this]\n    apply MeasurableSet.biUnion (countable_countableBasis \u03b2) (fun a ha \u21a6 ?_)\n    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet\n\nvariable {\u03b1' : Type*} [TopologicalSpace \u03b1'] [MeasurableSpace \u03b1']\n\ntheorem interior_ae_eq_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    interior s =\u1d50[\u03bc] s :=\n  interior_subset.eventuallyLE.antisymm <| subset_closure.eventuallyLE.trans (ae_le_set.2 h)\n#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier\n\ntheorem measure_interior_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    \u03bc (interior s) = \u03bc s :=\n  measure_congr (interior_ae_eq_of_null_frontier h)\n#align measure_interior_of_null_frontier measure_interior_of_null_frontier\n\ntheorem nullMeasurableSet_of_null_frontier {s : Set \u03b1} {\u03bc : Measure \u03b1} (h : \u03bc (frontier s) = 0) :\n    NullMeasurableSet s \u03bc :=\n  \u27e8interior s, isOpen_interior.measurableSet, (interior_ae_eq_of_null_frontier h).symm\u27e9\n#align null_measurable_set_of_null_frontier nullMeasurableSet_of_null_frontier\n\ntheorem closure_ae_eq_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    closure s =\u1d50[\u03bc] s :=\n  ((ae_le_set.2 h).trans interior_subset.eventuallyLE).antisymm <| subset_closure.eventuallyLE\n#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier\n\ntheorem measure_closure_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    \u03bc (closure s) = \u03bc s :=\n  measure_congr (closure_ae_eq_of_null_frontier h)\n#align measure_closure_of_null_frontier measure_closure_of_null_frontier\n\nsection Preorder\n\nvariable [Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1}\n\n@[simp, measurability]\ntheorem measurableSet_Ici : MeasurableSet (Ici a) :=\n  isClosed_Ici.measurableSet\n#align measurable_set_Ici measurableSet_Ici\n\n@[simp, measurability]\ntheorem measurableSet_Iic : MeasurableSet (Iic a) :=\n  isClosed_Iic.measurableSet\n#align measurable_set_Iic measurableSet_Iic\n\n@[simp, measurability]\ntheorem measurableSet_Icc : MeasurableSet (Icc a b) :=\n  isClosed_Icc.measurableSet\n#align measurable_set_Icc measurableSet_Icc\n\ninstance nhdsWithin_Ici_isMeasurablyGenerated : (\ud835\udcdd[Ici b] a).IsMeasurablyGenerated :=\n  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _\n#align nhds_within_Ici_is_measurably_generated nhdsWithin_Ici_isMeasurablyGenerated\n\ninstance nhdsWithin_Iic_isMeasurablyGenerated : (\ud835\udcdd[Iic b] a).IsMeasurablyGenerated :=\n  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _\n#align nhds_within_Iic_is_measurably_generated nhdsWithin_Iic_isMeasurablyGenerated\n\ninstance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (\ud835\udcdd[Icc a b] x) := by\n  rw [\u2190 Ici_inter_Iic, nhdsWithin_inter]\n  infer_instance\n#align nhds_within_Icc_is_measurably_generated nhdsWithin_Icc_isMeasurablyGenerated\n\ninstance atTop_isMeasurablyGenerated : (Filter.atTop : Filter \u03b1).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated\n#align at_top_is_measurably_generated atTop_isMeasurablyGenerated\n\ninstance atBot_isMeasurablyGenerated : (Filter.atBot : Filter \u03b1).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated\n#align at_bot_is_measurably_generated atBot_isMeasurablyGenerated\n\ninstance [R1Space \u03b1] : IsMeasurablyGenerated (cocompact \u03b1) where\n  exists_measurable_subset := by\n    intro _ hs\n    obtain \u27e8t, ht, hts\u27e9 := mem_cocompact.mp hs\n    exact \u27e8(closure t)\u1d9c, ht.closure.compl_mem_cocompact, isClosed_closure.measurableSet.compl,\n      (compl_subset_compl.2 subset_closure).trans hts\u27e9\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}\n\n@[measurability]\ntheorem measurableSet_le' : MeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 \u2264 p.2 } :=\n  OrderClosedTopology.isClosed_le'.measurableSet\n#align measurable_set_le' measurableSet_le'\n\n@[measurability]\ntheorem measurableSet_le {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    MeasurableSet { a | f a \u2264 g a } :=\n  hf.prod_mk hg measurableSet_le'\n#align measurable_set_le measurableSet_le\n\nend PartialOrder\n\nsection LinearOrder\n\nvariable [LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1}\n\n-- we open this locale only here to avoid issues with list being treated as intervals above\nopen Interval\n\n@[simp, measurability]\ntheorem measurableSet_Iio : MeasurableSet (Iio a) :=\n  isOpen_Iio.measurableSet\n#align measurable_set_Iio measurableSet_Iio\n\n@[simp, measurability]\ntheorem measurableSet_Ioi : MeasurableSet (Ioi a) :=\n  isOpen_Ioi.measurableSet\n#align measurable_set_Ioi measurableSet_Ioi\n\n@[simp, measurability]\ntheorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=\n  isOpen_Ioo.measurableSet\n#align measurable_set_Ioo measurableSet_Ioo\n\n@[simp, measurability]\ntheorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=\n  measurableSet_Ioi.inter measurableSet_Iic\n#align measurable_set_Ioc measurableSet_Ioc\n\n@[simp, measurability]\ntheorem measurableSet_Ico : MeasurableSet (Ico a b) :=\n  measurableSet_Ici.inter measurableSet_Iio\n#align measurable_set_Ico measurableSet_Ico\n\ninstance nhdsWithin_Ioi_isMeasurablyGenerated : (\ud835\udcdd[Ioi b] a).IsMeasurablyGenerated :=\n  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _\n#align nhds_within_Ioi_is_measurably_generated nhdsWithin_Ioi_isMeasurablyGenerated\n\ninstance nhdsWithin_Iio_isMeasurablyGenerated : (\ud835\udcdd[Iio b] a).IsMeasurablyGenerated :=\n  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _\n#align nhds_within_Iio_is_measurably_generated nhdsWithin_Iio_isMeasurablyGenerated\n\ninstance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (\ud835\udcdd[[[a, b]]] x) :=\n  nhdsWithin_Icc_isMeasurablyGenerated\n#align nhds_within_uIcc_is_measurably_generated nhdsWithin_uIcc_isMeasurablyGenerated\n\n@[measurability]\ntheorem measurableSet_lt' [SecondCountableTopology \u03b1] : MeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 } :=\n  (isOpen_lt continuous_fst continuous_snd).measurableSet\n#align measurable_set_lt' measurableSet_lt'\n\n@[measurability]\ntheorem measurableSet_lt [SecondCountableTopology \u03b1] {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=\n  hf.prod_mk hg measurableSet_lt'\n#align measurable_set_lt measurableSet_lt\n\ntheorem nullMeasurableSet_lt [SecondCountableTopology \u03b1] {\u03bc : Measure \u03b4} {f g : \u03b4 \u2192 \u03b1}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) : NullMeasurableSet { a | f a < g a } \u03bc :=\n  (hf.prod_mk hg).nullMeasurable measurableSet_lt'\n#align null_measurable_set_lt nullMeasurableSet_lt\n\ntheorem nullMeasurableSet_lt' [SecondCountableTopology \u03b1] {\u03bc : Measure (\u03b1 \u00d7 \u03b1)} :\n    NullMeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 } \u03bc :=\n  measurableSet_lt'.nullMeasurableSet\n\ntheorem nullMeasurableSet_le [SecondCountableTopology \u03b1] {\u03bc : Measure \u03b4}\n    {f g : \u03b4 \u2192 \u03b1} (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    NullMeasurableSet { a | f a \u2264 g a } \u03bc :=\n  (hf.prod_mk hg).nullMeasurable measurableSet_le'\n\ntheorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by\n  let u := \u22c3 (x \u2208 s) (y \u2208 s), Ioo x y\n  have huopen : IsOpen u := isOpen_biUnion fun _ _ => isOpen_biUnion fun _ _ => isOpen_Ioo\n  have humeas : MeasurableSet u := huopen.measurableSet\n  have hfinite : (s \\ u).Finite := s.finite_diff_iUnion_Ioo\n  have : u \u2286 s := iUnion\u2082_subset fun x hx => iUnion\u2082_subset fun y hy =>\n    Ioo_subset_Icc_self.trans (h.out hx hy)\n  rw [\u2190 union_diff_cancel this]\n  exact humeas.union hfinite.measurableSet\n#align set.ord_connected.measurable_set Set.OrdConnected.measurableSet\n\ntheorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=\n  h.ordConnected.measurableSet\n#align is_preconnected.measurable_set IsPreconnected.measurableSet\n\ntheorem generateFrom_Ico_mem_le_borel {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderClosedTopology \u03b1] (s t : Set \u03b1) :\n    MeasurableSpace.generateFrom { S | \u2203 l \u2208 s, \u2203 u \u2208 t, l < u \u2227 Ico l u = S }\n      \u2264 borel \u03b1 := by\n  apply generateFrom_le\n  borelize \u03b1\n  rintro _ \u27e8a, -, b, -, -, rfl\u27e9\n  exact measurableSet_Ico\n#align generate_from_Ico_mem_le_borel generateFrom_Ico_mem_le_borel\n\ntheorem Dense.borel_eq_generateFrom_Ico_mem_aux {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] {s : Set \u03b1} (hd : Dense s)\n    (hbot : \u2200 x, IsBot x \u2192 x \u2208 s) (hIoo : \u2200 x y : \u03b1, x < y \u2192 Ioo x y = \u2205 \u2192 y \u2208 s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ico l u = S } := by\n  set S : Set (Set \u03b1) := { S | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ico l u = S }\n  refine' le_antisymm _ (generateFrom_Ico_mem_le_borel _ _)\n  letI : MeasurableSpace \u03b1 := generateFrom S\n  rw [borel_eq_generateFrom_Iio]\n  refine' generateFrom_le (forall_mem_range.2 fun a => _)\n  rcases hd.exists_countable_dense_subset_bot_top with \u27e8t, hts, hc, htd, htb, -\u27e9\n  by_cases ha : \u2200 b < a, (Ioo b a).Nonempty\n  \u00b7 convert_to MeasurableSet (\u22c3 (l \u2208 t) (u \u2208 t) (_ : l < u) (_ : u \u2264 a), Ico l u)\n    \u00b7 ext y\n      simp only [mem_iUnion, mem_Iio, mem_Ico]\n      constructor\n      \u00b7 intro hy\n        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with \u27e8l, hlt, hly\u27e9\n        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with \u27e8u, hut, hyu, hua\u27e9\n        exact \u27e8l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu\u27e9\n      \u00b7 rintro \u27e8l, -, u, -, -, hua, -, hyu\u27e9\n        exact hyu.trans_le hua\n    \u00b7 refine' MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => _\n      refine' MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun _ => _\n      exact .basic _ \u27e8a, hts ha, b, hts hb, hab, mem_singleton _\u27e9\n  \u00b7 simp only [not_forall, not_nonempty_iff_eq_empty] at ha\n    replace ha : a \u2208 s := hIoo ha.choose a ha.choose_spec.fst ha.choose_spec.snd\n    convert_to MeasurableSet (\u22c3 (l \u2208 t) (_ : l < a), Ico l a)\n    \u00b7 symm\n      simp only [\u2190 Ici_inter_Iio, \u2190 iUnion_inter, inter_eq_right, subset_def, mem_iUnion,\n        mem_Ici, mem_Iio]\n      intro x hx\n      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with \u27e8z, hzt, hzx\u27e9\n      exact \u27e8z, hzt, hzx.trans_lt hx, hzx\u27e9\n    \u00b7 refine' .biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => _\n      exact .basic _ \u27e8x, hts hx, a, ha, hlt, mem_singleton _\u27e9\n#align dense.borel_eq_generate_from_Ico_mem_aux Dense.borel_eq_generateFrom_Ico_mem_aux\n\ntheorem Dense.borel_eq_generateFrom_Ico_mem {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] [DenselyOrdered \u03b1] [NoMinOrder \u03b1] {s : Set \u03b1}\n    (hd : Dense s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ico l u = S } :=\n  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun x y hxy H =>\n    ((nonempty_Ioo.2 hxy).ne_empty H).elim\n#align dense.borel_eq_generate_from_Ico_mem Dense.borel_eq_generateFrom_Ico_mem\n\ntheorem borel_eq_generateFrom_Ico (\u03b1 : Type*) [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [LinearOrder \u03b1] [OrderTopology \u03b1] :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 (l u : \u03b1), l < u \u2227 Ico l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and_iff] using\n    (@dense_univ \u03b1 _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n#align borel_eq_generate_from_Ico borel_eq_generateFrom_Ico\n\ntheorem Dense.borel_eq_generateFrom_Ioc_mem_aux {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] {s : Set \u03b1} (hd : Dense s)\n    (hbot : \u2200 x, IsTop x \u2192 x \u2208 s) (hIoo : \u2200 x y : \u03b1, x < y \u2192 Ioo x y = \u2205 \u2192 x \u2208 s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ioc l u = S } := by\n  convert hd.orderDual.borel_eq_generateFrom_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _\n    using 2\n  \u00b7 ext s\n    constructor <;> rintro \u27e8l, hl, u, hu, hlt, rfl\u27e9\n    exacts [\u27e8u, hu, l, hl, hlt, dual_Ico\u27e9, \u27e8u, hu, l, hl, hlt, dual_Ioc\u27e9]\n  \u00b7 erw [dual_Ioo]\n    exact he\n#align dense.borel_eq_generate_from_Ioc_mem_aux Dense.borel_eq_generateFrom_Ioc_mem_aux\n\ntheorem Dense.borel_eq_generateFrom_Ioc_mem {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] [DenselyOrdered \u03b1] [NoMaxOrder \u03b1] {s : Set \u03b1}\n    (hd : Dense s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ioc l u = S } :=\n  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun x y hxy H =>\n    ((nonempty_Ioo.2 hxy).ne_empty H).elim\n#align dense.borel_eq_generate_from_Ioc_mem Dense.borel_eq_generateFrom_Ioc_mem\n\ntheorem borel_eq_generateFrom_Ioc (\u03b1 : Type*) [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [LinearOrder \u03b1] [OrderTopology \u03b1] :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l u, l < u \u2227 Ioc l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and_iff] using\n    (@dense_univ \u03b1 _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n#align borel_eq_generate_from_Ioc borel_eq_generateFrom_Ioc\n\nnamespace MeasureTheory.Measure\n\n/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If\n`\u03b1` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `\u03bc` and\n`\u03bd`. -/\ntheorem ext_of_Ico_finite {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u03bc univ = \u03bd univ) (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) :\n    \u03bc = \u03bd := by\n  refine'\n    ext_of_generate_finite _ (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico \u03b1))\n      (isPiSystem_Ico (id : \u03b1 \u2192 \u03b1) id) _ h\u03bc\u03bd\n  \u00b7 rintro - \u27e8a, b, hlt, rfl\u27e9\n    exact h hlt\n#align measure_theory.measure.ext_of_Ico_finite MeasureTheory.Measure.ext_of_Ico_finite\n\n/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If\n`\u03b1` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ioc` is an extensionality lemma with weaker assumptions on `\u03bc` and\n`\u03bd`. -/\ntheorem ext_of_Ioc_finite {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u03bc univ = \u03bd univ) (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) :\n    \u03bc = \u03bd := by\n  refine' @ext_of_Ico_finite \u03b1\u1d52\u1d48 _ _ _ _ _ \u2039_\u203a \u03bc \u03bd _ h\u03bc\u03bd fun a b hab => _\n  erw [dual_Ico (\u03b1 := \u03b1)]\n  exact h hab\n#align measure_theory.measure.ext_of_Ioc_finite MeasureTheory.Measure.ext_of_Ioc_finite\n\n/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico' {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] [NoMaxOrder \u03b1]\n    (\u03bc \u03bd : Measure \u03b1) (h\u03bc : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) \u2260 \u221e)\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) : \u03bc = \u03bd := by\n  rcases exists_countable_dense_bot_top \u03b1 with \u27e8s, hsc, hsd, hsb, _\u27e9\n  have : (\u22c3 (l \u2208 s) (u \u2208 s) (_ : l < u), {Ico l u} : Set (Set \u03b1)).Countable :=\n    hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _\n  simp only [\u2190 setOf_eq_eq_singleton, \u2190 setOf_exists] at this\n  refine'\n    Measure.ext_of_generateFrom_of_cover_subset\n      (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico \u03b1)) (isPiSystem_Ico id id) _ this\n      _ _ _\n  \u00b7 rintro _ \u27e8l, -, u, -, h, rfl\u27e9\n    exact \u27e8l, u, h, rfl\u27e9\n  \u00b7 refine' sUnion_eq_univ_iff.2 fun x => _\n    rcases hsd.exists_le' hsb x with \u27e8l, hls, hlx\u27e9\n    rcases hsd.exists_gt x with \u27e8u, hus, hxu\u27e9\n    exact \u27e8_, \u27e8l, hls, u, hus, hlx.trans_lt hxu, rfl\u27e9, hlx, hxu\u27e9\n  \u00b7 rintro _ \u27e8l, -, u, -, hlt, rfl\u27e9\n    exact h\u03bc hlt\n  \u00b7 rintro _ \u27e8l, u, hlt, rfl\u27e9\n    exact h hlt\n#align measure_theory.measure.ext_of_Ico' MeasureTheory.Measure.ext_of_Ico'\n\n/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc' {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] [NoMinOrder \u03b1]\n    (\u03bc \u03bd : Measure \u03b1) (h\u03bc : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) \u2260 \u221e)\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) : \u03bc = \u03bd := by\n  refine' @ext_of_Ico' \u03b1\u1d52\u1d48 _ _ _ _ _ \u2039_\u203a _ \u03bc \u03bd _ _ <;> intro a b hab <;> erw [dual_Ico (\u03b1 := \u03b1)]\n  exacts [h\u03bc hab, h hab]\n#align measure_theory.measure.ext_of_Ioc' MeasureTheory.Measure.ext_of_Ioc'\n\n/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico {\u03b1 : Type*} [TopologicalSpace \u03b1] {_m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [BorelSpace \u03b1] [NoMaxOrder \u03b1] (\u03bc \u03bd : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc]\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) : \u03bc = \u03bd :=\n  \u03bc.ext_of_Ico' \u03bd (fun _ _ _ => measure_Ico_lt_top.ne) h\n#align measure_theory.measure.ext_of_Ico MeasureTheory.Measure.ext_of_Ico\n\n/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc {\u03b1 : Type*} [TopologicalSpace \u03b1] {_m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [BorelSpace \u03b1] [NoMinOrder \u03b1] (\u03bc \u03bd : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc]\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) : \u03bc = \u03bd :=\n  \u03bc.ext_of_Ioc' \u03bd (fun _ _ _ => measure_Ioc_lt_top.ne) h\n#align measure_theory.measure.ext_of_Ioc MeasureTheory.Measure.ext_of_Ioc\n\n/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed\nintervals. -/\ntheorem ext_of_Iic {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h : \u2200 a, \u03bc (Iic a) = \u03bd (Iic a)) : \u03bc = \u03bd := by\n  refine' ext_of_Ioc_finite \u03bc \u03bd _ fun a b hlt => _\n  \u00b7 rcases exists_countable_dense_bot_top \u03b1 with \u27e8s, hsc, hsd, -, hst\u27e9\n    have : DirectedOn (\u00b7 \u2264 \u00b7) s := directedOn_iff_directed.2 (Subtype.mono_coe _).directed_le\n    simp only [\u2190 biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]\n  rw [\u2190 Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic,\n    measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic, h a, h b]\n  \u00b7 rw [\u2190 h a]\n    exact (measure_lt_top \u03bc _).ne\n  \u00b7 exact (measure_lt_top \u03bc _).ne\n#align measure_theory.measure.ext_of_Iic MeasureTheory.Measure.ext_of_Iic\n\n/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite\nintervals. -/\ntheorem ext_of_Ici {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h : \u2200 a, \u03bc (Ici a) = \u03bd (Ici a)) : \u03bc = \u03bd :=\n  @ext_of_Iic \u03b1\u1d52\u1d48 _ _ _ _ _ \u2039_\u203a _ _ _ h\n#align measure_theory.measure.ext_of_Ici MeasureTheory.Measure.ext_of_Ici\n\nend MeasureTheory.Measure\n\nend LinearOrder\n\nsection LinearOrder\n\nvariable [LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b : \u03b1}\n\n@[measurability]\ntheorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=\n  measurableSet_Icc\n#align measurable_set_uIcc measurableSet_uIcc\n\n@[measurability]\ntheorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=\n  measurableSet_Ioc\n#align measurable_set_uIoc measurableSet_uIoc\n\nvariable [SecondCountableTopology \u03b1]\n\n@[measurability]\ntheorem Measurable.max {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => max (f a) (g a) := by\n  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg\n#align measurable.max Measurable.max\n\n@[measurability]\nnonrec theorem AEMeasurable.max {f g : \u03b4 \u2192 \u03b1} {\u03bc : Measure \u03b4} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => max (f a) (g a)) \u03bc :=\n  \u27e8fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,\n    EventuallyEq.comp\u2082 hf.ae_eq_mk _ hg.ae_eq_mk\u27e9\n#align ae_measurable.max AEMeasurable.max\n\n@[measurability]\ntheorem Measurable.min {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => min (f a) (g a) := by\n  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg\n#align measurable.min Measurable.min\n\n@[measurability]\nnonrec theorem AEMeasurable.min {f g : \u03b4 \u2192 \u03b1} {\u03bc : Measure \u03b4} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => min (f a) (g a)) \u03bc :=\n  \u27e8fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,\n    EventuallyEq.comp\u2082 hf.ae_eq_mk _ hg.ae_eq_mk\u27e9\n#align ae_measurable.min AEMeasurable.min\n\nend LinearOrder\n\n/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`\nis measurable. -/\ntheorem Continuous.measurable {f : \u03b1 \u2192 \u03b3} (hf : Continuous f) : Measurable f :=\n  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)\n#align continuous.measurable Continuous.measurable\n\n/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`\nis ae-measurable. -/\ntheorem Continuous.aemeasurable {f : \u03b1 \u2192 \u03b3} (h : Continuous f) {\u03bc : Measure \u03b1} : AEMeasurable f \u03bc :=\n  h.measurable.aemeasurable\n#align continuous.ae_measurable Continuous.aemeasurable\n\ntheorem ClosedEmbedding.measurable {f : \u03b1 \u2192 \u03b3} (hf : ClosedEmbedding f) : Measurable f :=\n  hf.continuous.measurable\n#align closed_embedding.measurable ClosedEmbedding.measurable\n\n/-- If a function is defined piecewise in terms of functions which are continuous on their\nrespective pieces, then it is measurable. -/\ntheorem ContinuousOn.measurable_piecewise {f g : \u03b1 \u2192 \u03b3} {s : Set \u03b1} [\u2200 j : \u03b1, Decidable (j \u2208 s)]\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s\u1d9c) (hs : MeasurableSet s) :\n    Measurable (s.piecewise f g) := by\n  refine' measurable_of_isOpen fun t ht => _\n  rw [piecewise_preimage, Set.ite]\n  apply MeasurableSet.union\n  \u00b7 rcases _root_.continuousOn_iff'.1 hf t ht with \u27e8u, u_open, hu\u27e9\n    rw [hu]\n    exact u_open.measurableSet.inter hs\n  \u00b7 rcases _root_.continuousOn_iff'.1 hg t ht with \u27e8u, u_open, hu\u27e9\n    rw [diff_eq_compl_inter, inter_comm, hu]\n    exact u_open.measurableSet.inter hs.compl\n#align continuous_on.measurable_piecewise ContinuousOn.measurable_piecewise\n\n@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul [Mul \u03b3] [ContinuousMul \u03b3] :\n    MeasurableMul \u03b3 where\n  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable\n  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable\n#align has_continuous_mul.has_measurable_mul ContinuousMul.measurableMul\n#align has_continuous_add.has_measurable_add ContinuousAdd.measurableAdd\n\ninstance (priority := 100) ContinuousSub.measurableSub [Sub \u03b3] [ContinuousSub \u03b3] :\n    MeasurableSub \u03b3 where\n  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable\n  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable\n#align has_continuous_sub.has_measurable_sub ContinuousSub.measurableSub\n\n@[to_additive]\ninstance (priority := 100) TopologicalGroup.measurableInv [Group \u03b3] [TopologicalGroup \u03b3] :\n    MeasurableInv \u03b3 :=\n  \u27e8continuous_inv.measurable\u27e9\n#align topological_group.has_measurable_inv TopologicalGroup.measurableInv\n#align topological_add_group.has_measurable_neg TopologicalAddGroup.measurableNeg\n\ninstance (priority := 100) ContinuousSMul.measurableSMul {M \u03b1} [TopologicalSpace M]\n    [TopologicalSpace \u03b1] [MeasurableSpace M] [MeasurableSpace \u03b1] [OpensMeasurableSpace M]\n    [BorelSpace \u03b1] [SMul M \u03b1] [ContinuousSMul M \u03b1] : MeasurableSMul M \u03b1 :=\n  \u27e8fun _ => (continuous_const_smul _).measurable, fun _ =>\n    (continuous_id.smul continuous_const).measurable\u27e9\n#align has_continuous_smul.has_measurable_smul ContinuousSMul.measurableSMul\n\nsection Lattice\n\ninstance (priority := 100) ContinuousSup.measurableSup [Sup \u03b3] [ContinuousSup \u03b3] :\n    MeasurableSup \u03b3 where\n  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable\n  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable\n#align has_continuous_sup.has_measurable_sup ContinuousSup.measurableSup\n\ninstance (priority := 100) ContinuousSup.measurableSup\u2082 [SecondCountableTopology \u03b3] [Sup \u03b3]\n    [ContinuousSup \u03b3] : MeasurableSup\u2082 \u03b3 :=\n  \u27e8continuous_sup.measurable\u27e9\n#align has_continuous_sup.has_measurable_sup\u2082 ContinuousSup.measurableSup\u2082\n\ninstance (priority := 100) ContinuousInf.measurableInf [Inf \u03b3] [ContinuousInf \u03b3] :\n    MeasurableInf \u03b3 where\n  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable\n  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable\n#align has_continuous_inf.has_measurable_inf ContinuousInf.measurableInf\n\ninstance (priority := 100) ContinuousInf.measurableInf\u2082 [SecondCountableTopology \u03b3] [Inf \u03b3]\n    [ContinuousInf \u03b3] : MeasurableInf\u2082 \u03b3 :=\n  \u27e8continuous_inf.measurable\u27e9\n#align has_continuous_inf.has_measurable_inf\u2082 ContinuousInf.measurableInf\u2082\n\nend Lattice\n\nsection Homeomorph\n\n@[measurability]\nprotected theorem Homeomorph.measurable (h : \u03b1 \u2243\u209c \u03b3) : Measurable h :=\n  h.continuous.measurable\n#align homeomorph.measurable Homeomorph.measurable\n\n/-- A homeomorphism between two Borel spaces is a measurable equivalence. -/\ndef Homeomorph.toMeasurableEquiv (h : \u03b3 \u2243\u209c \u03b3\u2082) : \u03b3 \u2243\u1d50 \u03b3\u2082 where\n  measurable_toFun := h.measurable\n  measurable_invFun := h.symm.measurable\n  toEquiv := h.toEquiv\n#align homeomorph.to_measurable_equiv Homeomorph.toMeasurableEquiv\n\nlemma Homeomorph.measurableEmbedding (h : \u03b3 \u2243\u209c \u03b3\u2082) : MeasurableEmbedding h :=\n  h.toMeasurableEquiv.measurableEmbedding\n\n@[simp]\ntheorem Homeomorph.toMeasurableEquiv_coe (h : \u03b3 \u2243\u209c \u03b3\u2082) : (h.toMeasurableEquiv : \u03b3 \u2192 \u03b3\u2082) = h :=\n  rfl\n#align homeomorph.to_measurable_equiv_coe Homeomorph.toMeasurableEquiv_coe\n\n@[simp]\ntheorem Homeomorph.toMeasurableEquiv_symm_coe (h : \u03b3 \u2243\u209c \u03b3\u2082) :\n    (h.toMeasurableEquiv.symm : \u03b3\u2082 \u2192 \u03b3) = h.symm :=\n  rfl\n#align homeomorph.to_measurable_equiv_symm_coe Homeomorph.toMeasurableEquiv_symm_coe\n\nend Homeomorph\n\n@[measurability]\ntheorem ContinuousMap.measurable (f : C(\u03b1, \u03b3)) : Measurable f :=\n  f.continuous.measurable\n#align continuous_map.measurable ContinuousMap.measurable\n\ntheorem measurable_of_continuousOn_compl_singleton [T1Space \u03b1] {f : \u03b1 \u2192 \u03b3} (a : \u03b1)\n    (hf : ContinuousOn f {a}\u1d9c) : Measurable f :=\n  measurable_of_measurable_on_compl_singleton a\n    (continuousOn_iff_continuous_restrict.1 hf).measurable\n#align measurable_of_continuous_on_compl_singleton measurable_of_continuousOn_compl_singleton\n\ntheorem Continuous.measurable2 [SecondCountableTopologyEither \u03b1 \u03b2] {f : \u03b4 \u2192 \u03b1}\n    {g : \u03b4 \u2192 \u03b2} {c : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (h : Continuous fun p : \u03b1 \u00d7 \u03b2 => c p.1 p.2) (hf : Measurable f)\n    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=\n  h.measurable.comp (hf.prod_mk hg)\n#align continuous.measurable2 Continuous.measurable2\n\ntheorem Continuous.aemeasurable2 [SecondCountableTopologyEither \u03b1 \u03b2]\n    {f : \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b2} {c : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {\u03bc : Measure \u03b4}\n    (h : Continuous fun p : \u03b1 \u00d7 \u03b2 => c p.1 p.2) (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun a => c (f a) (g a)) \u03bc :=\n  h.measurable.comp_aemeasurable (hf.prod_mk hg)\n#align continuous.ae_measurable2 Continuous.aemeasurable2\n\ninstance (priority := 100) HasContinuousInv\u2080.measurableInv [GroupWithZero \u03b3] [T1Space \u03b3]\n    [HasContinuousInv\u2080 \u03b3] : MeasurableInv \u03b3 :=\n  \u27e8measurable_of_continuousOn_compl_singleton 0 continuousOn_inv\u2080\u27e9\n#align has_continuous_inv\u2080.has_measurable_inv HasContinuousInv\u2080.measurableInv\n\n@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul\u2082 [SecondCountableTopology \u03b3] [Mul \u03b3]\n    [ContinuousMul \u03b3] : MeasurableMul\u2082 \u03b3 :=\n  \u27e8continuous_mul.measurable\u27e9\n#align has_continuous_mul.has_measurable_mul\u2082 ContinuousMul.measurableMul\u2082\n#align has_continuous_add.has_measurable_mul\u2082 ContinuousAdd.measurableMul\u2082\n\ninstance (priority := 100) ContinuousSub.measurableSub\u2082 [SecondCountableTopology \u03b3] [Sub \u03b3]\n    [ContinuousSub \u03b3] : MeasurableSub\u2082 \u03b3 :=\n  \u27e8continuous_sub.measurable\u27e9\n#align has_continuous_sub.has_measurable_sub\u2082 ContinuousSub.measurableSub\u2082\n\ninstance (priority := 100) ContinuousSMul.measurableSMul\u2082 {M \u03b1} [TopologicalSpace M]\n    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace \u03b1]\n    [SecondCountableTopologyEither M \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1] [SMul M \u03b1]\n    [ContinuousSMul M \u03b1] : MeasurableSMul\u2082 M \u03b1 :=\n  \u27e8continuous_smul.measurable\u27e9\n#align has_continuous_smul.has_measurable_smul\u2082 ContinuousSMul.measurableSMul\u2082\n\nend\n\nsection BorelSpace\n\nvariable [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1] [TopologicalSpace \u03b2]\n  [MeasurableSpace \u03b2] [BorelSpace \u03b2] [TopologicalSpace \u03b3] [MeasurableSpace \u03b3] [BorelSpace \u03b3]\n  [MeasurableSpace \u03b4]\n\ntheorem pi_le_borel_pi {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    [\u2200 i, MeasurableSpace (\u03c0 i)] [\u2200 i, BorelSpace (\u03c0 i)] :\n      MeasurableSpace.pi \u2264 borel (\u2200 i, \u03c0 i) := by\n  have : \u2039\u2200 i, MeasurableSpace (\u03c0 i)\u203a = fun i => borel (\u03c0 i) :=\n    funext fun i => BorelSpace.measurable_eq\n  rw [this]\n  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable\n#align pi_le_borel_pi pi_le_borel_pi\n\ntheorem prod_le_borel_prod : Prod.instMeasurableSpace \u2264 borel (\u03b1 \u00d7 \u03b2) := by\n  rw [\u2039BorelSpace \u03b1\u203a.measurable_eq, \u2039BorelSpace \u03b2\u203a.measurable_eq]\n  refine' sup_le _ _\n  \u00b7 exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable\n  \u00b7 exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable\n#align prod_le_borel_prod prod_le_borel_prod\n\ninstance Pi.borelSpace {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [Countable \u03b9] [\u2200 i, TopologicalSpace (\u03c0 i)]\n    [\u2200 i, MeasurableSpace (\u03c0 i)] [\u2200 i, SecondCountableTopology (\u03c0 i)] [\u2200 i, BorelSpace (\u03c0 i)] :\n    BorelSpace (\u2200 i, \u03c0 i) :=\n  \u27e8le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le\u27e9\n#align pi.borel_space Pi.borelSpace\n\ninstance Prod.borelSpace [SecondCountableTopologyEither \u03b1 \u03b2] :\n    BorelSpace (\u03b1 \u00d7 \u03b2) :=\n  \u27e8le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le\u27e9\n#align prod.borel_space Prod.borelSpace\n\n/-- Given a measurable embedding to a Borel space which is also a topological embedding, then the\nsource space is also a Borel space. -/\nlemma MeasurableEmbedding.borelSpace {\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b2] [TopologicalSpace \u03b2] [h\u03b2 : BorelSpace \u03b2] {e : \u03b1 \u2192 \u03b2}\n    (h'e : MeasurableEmbedding e) (h''e : Inducing e) :\n    BorelSpace \u03b1 := by\n  constructor\n  have : MeasurableSpace.comap e (borel \u03b2) = \u2039_\u203a := by simpa [h\u03b2.measurable_eq] using h'e.comap_eq\n  rw [\u2190 this, \u2190 borel_comap, h''e.induced]\n\ninstance _root_.ULift.instBorelSpace : BorelSpace (ULift \u03b1) :=\n  MeasurableEquiv.ulift.measurableEmbedding.borelSpace Homeomorph.ulift.inducing\n\ninstance DiscreteMeasurableSpace.toBorelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [DiscreteTopology \u03b1]\n    [MeasurableSpace \u03b1] [DiscreteMeasurableSpace \u03b1] : BorelSpace \u03b1 := by\n  constructor; ext; simp [MeasurableSpace.measurableSet_generateFrom, measurableSet_discrete]\n\nprotected theorem Embedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h\u2081 : Embedding f)\n    (h\u2082 : MeasurableSet (range f)) : MeasurableEmbedding f :=\n  show MeasurableEmbedding\n      (((\u2191) : range f \u2192 \u03b2) \u2218 (Homeomorph.ofEmbedding f h\u2081).toMeasurableEquiv) from\n    (MeasurableEmbedding.subtype_coe h\u2082).comp (MeasurableEquiv.measurableEmbedding _)\n#align embedding.measurable_embedding Embedding.measurableEmbedding\n\nprotected theorem ClosedEmbedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h : ClosedEmbedding f) :\n    MeasurableEmbedding f :=\n  h.toEmbedding.measurableEmbedding h.isClosed_range.measurableSet\n#align closed_embedding.measurable_embedding ClosedEmbedding.measurableEmbedding\n\nprotected theorem OpenEmbedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h : OpenEmbedding f) :\n    MeasurableEmbedding f :=\n  h.toEmbedding.measurableEmbedding h.isOpen_range.measurableSet\n#align open_embedding.measurable_embedding OpenEmbedding.measurableEmbedding\n\nsection LinearOrder\n\nvariable [LinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]\n\ntheorem measurable_of_Iio {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iio x)) : Measurable f := by\n  convert measurable_generateFrom (\u03b1 := \u03b4) _\n  \u00b7 exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)\n  \u00b7 rintro _ \u27e8x, rfl\u27e9; exact hf x\n#align measurable_of_Iio measurable_of_Iio\n\ntheorem UpperSemicontinuous.measurable [TopologicalSpace \u03b4] [OpensMeasurableSpace \u03b4] {f : \u03b4 \u2192 \u03b1}\n    (hf : UpperSemicontinuous f) : Measurable f :=\n  measurable_of_Iio fun y => (hf.isOpen_preimage y).measurableSet\n#align upper_semicontinuous.measurable UpperSemicontinuous.measurable\n\ntheorem measurable_of_Ioi {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Ioi x)) : Measurable f := by\n  convert measurable_generateFrom (\u03b1 := \u03b4) _\n  \u00b7 exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)\n  \u00b7 rintro _ \u27e8x, rfl\u27e9; exact hf x\n#align measurable_of_Ioi measurable_of_Ioi\n\ntheorem LowerSemicontinuous.measurable [TopologicalSpace \u03b4] [OpensMeasurableSpace \u03b4] {f : \u03b4 \u2192 \u03b1}\n    (hf : LowerSemicontinuous f) : Measurable f :=\n  measurable_of_Ioi fun y => (hf.isOpen_preimage y).measurableSet\n#align lower_semicontinuous.measurable LowerSemicontinuous.measurable\n\ntheorem measurable_of_Iic {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iic x)) : Measurable f := by\n  apply measurable_of_Ioi\n  simp_rw [\u2190 compl_Iic, preimage_compl, MeasurableSet.compl_iff]\n  assumption\n#align measurable_of_Iic measurable_of_Iic\n\ntheorem measurable_of_Ici {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Ici x)) : Measurable f := by\n  apply measurable_of_Iio\n  simp_rw [\u2190 compl_Ici, preimage_compl, MeasurableSet.compl_iff]\n  assumption\n#align measurable_of_Ici measurable_of_Ici\n\n/-- If a function is the least upper bound of countably many measurable functions,\nthen it is measurable. -/\ntheorem Measurable.isLUB {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i))\n    (hg : \u2200 b, IsLUB { a | \u2203 i, f i b = a } (g b)) : Measurable g := by\n  change \u2200 b, IsLUB (range fun i => f i b) (g b) at hg\n  rw [\u2039BorelSpace \u03b1\u203a.measurable_eq, borel_eq_generateFrom_Ioi \u03b1]\n  apply measurable_generateFrom\n  rintro _ \u27e8a, rfl\u27e9\n  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, setOf_exists]\n  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).measurableSet\n#align measurable.is_lub Measurable.isLUB\n\n/-- If a function is the least upper bound of countably many measurable functions on a measurable\nset `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/\ntheorem Measurable.isLUB_of_mem {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g g' : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, Measurable (f i))\n    {s : Set \u03b4} (hs : MeasurableSet s) (hg : \u2200 b \u2208 s, IsLUB { a | \u2203 i, f i b = a } (g b))\n    (hg' : EqOn g g' s\u1d9c) (g'_meas : Measurable g') : Measurable g := by\n  rcases isEmpty_or_nonempty \u03b9 with h\u03b9|\u27e8\u27e8i\u27e9\u27e9\n  \u00b7 rcases eq_empty_or_nonempty s with rfl|\u27e8x, hx\u27e9\n    \u00b7 convert g'_meas\n      rwa [compl_empty, eqOn_univ] at hg'\n    \u00b7 have A : \u2200 b \u2208 s, IsBot (g b) := by simpa using hg\n      have B : \u2200 b \u2208 s, g b = g x := by\n        intro b hb\n        apply le_antisymm (A b hb (g x)) (A x hx (g b))\n      have : g = s.piecewise (fun _y \u21a6 g x) g' := by\n        ext b\n        by_cases hb : b \u2208 s\n        \u00b7 simp [hb, B]\n        \u00b7 simp [hb, hg' hb]\n      rw [this]\n      exact Measurable.piecewise hs measurable_const g'_meas\n  \u00b7 let f' : \u03b9 \u2192 \u03b4 \u2192 \u03b1 := fun i \u21a6 s.piecewise (f i) g'\n    suffices \u2200 b, IsLUB { a | \u2203 i, f' i b = a } (g b) from\n      Measurable.isLUB (fun i \u21a6 Measurable.piecewise hs (hf i) g'_meas) this\n    intro b\n    by_cases hb : b \u2208 s\n    \u00b7 have A : \u2200 i, f' i b = f i b := fun i \u21a6 by simp [f', hb]\n      simpa [A] using hg b hb\n    \u00b7 have A : \u2200 i, f' i b = g' b := fun i \u21a6 by simp [f', hb]\n      have : {a | \u2203 (_i : \u03b9), g' b = a} = {g' b} := by\n        apply Subset.antisymm\n        \u00b7 rintro - \u27e8_j, rfl\u27e9\n          simp only [mem_singleton_iff]\n        \u00b7 rintro - rfl\n          exact \u27e8i, rfl\u27e9\n      simp [A, this, hg' hb, isLUB_singleton]\n\ntheorem AEMeasurable.isLUB {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) (hg : \u2200\u1d50 b \u2202\u03bc, IsLUB { a | \u2203 i, f i b = a } (g b)) :\n    AEMeasurable g \u03bc := by\n  nontriviality \u03b1\n  haveI h\u03b1 : Nonempty \u03b1 := inferInstance\n  cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9\n  \u00b7 simp only [IsEmpty.exists_iff, setOf_false, isLUB_empty_iff] at hg\n    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (ha _).antisymm (hb _))\n  let p : \u03b4 \u2192 (\u03b9 \u2192 \u03b1) \u2192 Prop := fun x f' => IsLUB { a | \u2203 i, f' i = a } (g x)\n  let g_seq := (aeSeqSet hf p).piecewise g fun _ => h\u03b1.some\n  have hg_seq : \u2200 b, IsLUB { a | \u2203 i, aeSeq hf p i b = a } (g_seq b) := by\n    intro b\n    simp only [g_seq, aeSeq, Set.piecewise]\n    split_ifs with h\n    \u00b7 have h_set_eq : { a : \u03b1 | \u2203 i : \u03b9, (hf i).mk (f i) b = a } =\n        { a : \u03b1 | \u2203 i : \u03b9, f i b = a } := by\n        ext x\n        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]\n      rw [h_set_eq]\n      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h\n    \u00b7 exact IsGreatest.isLUB \u27e8(@exists_const (h\u03b1.some = h\u03b1.some) \u03b9 _).2 rfl, fun x \u27e8i, hi\u27e9 => hi.ge\u27e9\n  refine' \u27e8g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, _\u27e9\n  exact\n    (ite_ae_eq_of_measure_compl_zero g (fun _ => h\u03b1.some) (aeSeqSet hf p)\n        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm\n#align ae_measurable.is_lub AEMeasurable.isLUB\n\n/-- If a function is the greatest lower bound of countably many measurable functions,\nthen it is measurable. -/\ntheorem Measurable.isGLB {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i))\n    (hg : \u2200 b, IsGLB { a | \u2203 i, f i b = a } (g b)) : Measurable g :=\n  Measurable.isLUB (\u03b1 := \u03b1\u1d52\u1d48) hf hg\n#align measurable.is_glb Measurable.isGLB\n\n/-- If a function is the greatest lower bound of countably many measurable functions on a measurable\nset `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/\ntheorem Measurable.isGLB_of_mem {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g g' : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, Measurable (f i))\n    {s : Set \u03b4} (hs : MeasurableSet s) (hg : \u2200 b \u2208 s, IsGLB { a | \u2203 i, f i b = a } (g b))\n    (hg' : EqOn g g' s\u1d9c) (g'_meas : Measurable g') : Measurable g :=\n  Measurable.isLUB_of_mem (\u03b1 := \u03b1\u1d52\u1d48) hf hs hg hg'  g'_meas\n\ntheorem AEMeasurable.isGLB {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) (hg : \u2200\u1d50 b \u2202\u03bc, IsGLB { a | \u2203 i, f i b = a } (g b)) :\n    AEMeasurable g \u03bc :=\n  AEMeasurable.isLUB (\u03b1 := \u03b1\u1d52\u1d48) hf hg\n#align ae_measurable.is_glb AEMeasurable.isGLB\n\nprotected theorem Monotone.measurable [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Monotone f) : Measurable f :=\n  suffices h : \u2200 x, OrdConnected (f \u207b\u00b9' Ioi x) from measurable_of_Ioi fun x => (h x).measurableSet\n  fun _ => ordConnected_def.mpr fun _a ha _ _ _c hc => lt_of_lt_of_le ha (hf hc.1)\n#align monotone.measurable Monotone.measurable\n\ntheorem aemeasurable_restrict_of_monotoneOn [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {\u03bc : Measure \u03b2}\n    {s : Set \u03b2} (hs : MeasurableSet s) {f : \u03b2 \u2192 \u03b1} (hf : MonotoneOn f s) :\n    AEMeasurable f (\u03bc.restrict s) :=\n  have : Monotone (f \u2218 (\u2191) : s \u2192 \u03b1) := fun \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 => fun (hxy : x \u2264 y) => hf hx hy hxy\n  aemeasurable_restrict_of_measurable_subtype hs this.measurable\n#align ae_measurable_restrict_of_monotone_on aemeasurable_restrict_of_monotoneOn\n\nprotected theorem Antitone.measurable [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Antitone f) : Measurable f :=\n  @Monotone.measurable \u03b1\u1d52\u1d48 \u03b2 _ _ \u2039_\u203a _ _ _ _ _ \u2039_\u203a _ _ _ hf\n#align antitone.measurable Antitone.measurable\n\ntheorem aemeasurable_restrict_of_antitoneOn [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {\u03bc : Measure \u03b2}\n    {s : Set \u03b2} (hs : MeasurableSet s) {f : \u03b2 \u2192 \u03b1} (hf : AntitoneOn f s) :\n    AEMeasurable f (\u03bc.restrict s) :=\n  @aemeasurable_restrict_of_monotoneOn \u03b1\u1d52\u1d48 \u03b2 _ _ \u2039_\u203a _ _ _ _ _ \u2039_\u203a _ _ _ _ hs _ hf\n#align ae_measurable_restrict_of_antitone_on aemeasurable_restrict_of_antitoneOn\n\ntheorem measurableSet_of_mem_nhdsWithin_Ioi_aux {s : Set \u03b1} (h : \u2200 x \u2208 s, s \u2208 \ud835\udcdd[>] x)\n    (h' : \u2200 x \u2208 s, \u2203 y, x < y) : MeasurableSet s := by\n  choose! M hM using h'\n  suffices H : (s \\ interior s).Countable by\n    have : s = interior s \u222a s \\ interior s := by rw [union_diff_cancel interior_subset]\n    rw [this]\n    exact isOpen_interior.measurableSet.union H.measurableSet\n  have A : \u2200 x \u2208 s, \u2203 y \u2208 Ioi x, Ioo x y \u2286 s := fun x hx =>\n    (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)\n  choose! y hy h'y using A\n  have B : Set.PairwiseDisjoint (s \\ interior s) fun x => Ioo x (y x) := by\n    intro x hx x' hx' hxx'\n    rcases lt_or_gt_of_ne hxx' with (h' | h')\n    \u00b7 refine disjoint_left.2 fun z hz h'z => ?_\n      have : x' \u2208 interior s :=\n        mem_interior.2 \u27e8Ioo x (y x), h'y _ hx.1, isOpen_Ioo, \u27e8h', h'z.1.trans hz.2\u27e9\u27e9\n      exact False.elim (hx'.2 this)\n    \u00b7 refine disjoint_left.2 fun z hz h'z => ?_\n      have : x \u2208 interior s :=\n        mem_interior.2 \u27e8Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, \u27e8h', hz.1.trans h'z.2\u27e9\u27e9\n      exact False.elim (hx.2 this)\n  exact B.countable_of_Ioo fun x hx => hy x hx.1\n#align measurable_set_of_mem_nhds_within_Ioi_aux measurableSet_of_mem_nhdsWithin_Ioi_aux\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem measurableSet_of_mem_nhdsWithin_Ioi {s : Set \u03b1} (h : \u2200 x \u2208 s, s \u2208 \ud835\udcdd[>] x) :\n    MeasurableSet s := by\n  by_cases H : \u2203 x \u2208 s, IsTop x\n  \u00b7 rcases H with \u27e8x\u2080, x\u2080s, h\u2080\u27e9\n    have : s = {x\u2080} \u222a s \\ {x\u2080} := by rw [union_diff_cancel (singleton_subset_iff.2 x\u2080s)]\n    rw [this]\n    refine' (measurableSet_singleton _).union _\n    have A : \u2200 x \u2208 s \\ {x\u2080}, x < x\u2080 := fun x hx => lt_of_le_of_ne (h\u2080 _) (by simpa using hx.2)\n    refine' measurableSet_of_mem_nhdsWithin_Ioi_aux (fun x hx => _) fun x hx => \u27e8x\u2080, A x hx\u27e9\n    obtain \u27e8u, hu, us\u27e9 : \u2203 (u : \u03b1), u \u2208 Ioi x \u2227 Ioo x u \u2286 s :=\n      (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)\n    refine' (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).2 \u27e8u, hu, fun y hy => \u27e8us hy, _\u27e9\u27e9\n    exact ne_of_lt (hy.2.trans_le (h\u2080 _))\n  \u00b7 apply measurableSet_of_mem_nhdsWithin_Ioi_aux h\n    simp only [IsTop] at H\n    push_neg at H\n    exact H\n#align measurable_set_of_mem_nhds_within_Ioi measurableSet_of_mem_nhdsWithin_Ioi\n\nlemma measurableSet_bddAbove_range {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    MeasurableSet {b | BddAbove (range (fun i \u21a6 f i b))} := by\n  rcases isEmpty_or_nonempty \u03b1 with h\u03b1|h\u03b1\n  \u00b7 have : \u2200 b, range (fun i \u21a6 f i b) = \u2205 := fun b \u21a6 eq_empty_of_isEmpty _\n    simp [this]\n  have A : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c} := by\n    intro i c\n    exact measurableSet_le (hf i) measurable_const\n  have B : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 i, f i x \u2264 c} := by\n    intro c\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun i \u21a6 A i c)\n  obtain \u27e8u, hu\u27e9 : \u2203 (u : \u2115 \u2192 \u03b1), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter \u03b1)\n  have : {b | BddAbove (range (fun i \u21a6 f i b))} = {x | \u2203 n, \u2200 i, f i x \u2264 u n} := by\n    apply Subset.antisymm\n    \u00b7 rintro x \u27e8c, hc\u27e9\n      obtain \u27e8n, hn\u27e9 : \u2203 n, c \u2264 u n := (tendsto_atTop.1 hu c).exists\n      exact \u27e8n, fun i \u21a6 (hc ((mem_range_self i))).trans hn\u27e9\n    \u00b7 rintro x \u27e8n, hn\u27e9\n      refine \u27e8u n, ?_\u27e9\n      rintro - \u27e8i, rfl\u27e9\n      exact hn i\n  rw [this, setOf_exists]\n  exact MeasurableSet.iUnion (fun n \u21a6 B (u n))\n\nlemma measurableSet_bddBelow_range {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    MeasurableSet {b | BddBelow (range (fun i \u21a6 f i b))} :=\n  measurableSet_bddAbove_range (\u03b1 := \u03b1\u1d52\u1d48) hf\n\nend LinearOrder\n\n@[measurability]\ntheorem Measurable.iSup_Prop {\u03b1} [MeasurableSpace \u03b1] [ConditionallyCompleteLattice \u03b1]\n    (p : Prop) {f : \u03b4 \u2192 \u03b1} (hf : Measurable f) : Measurable fun b => \u2a06 _ : p, f b := by\n  simp_rw [ciSup_eq_ite]\n  split_ifs with h\n  \u00b7 exact hf\n  \u00b7 exact measurable_const\n#align measurable.supr_Prop Measurable.iSup_Prop\n\n@[measurability]\ntheorem Measurable.iInf_Prop {\u03b1} [MeasurableSpace \u03b1] [ConditionallyCompleteLattice \u03b1]\n    (p : Prop) {f : \u03b4 \u2192 \u03b1} (hf : Measurable f) : Measurable fun b => \u2a05 _ : p, f b := by\n  simp_rw [ciInf_eq_ite]\n  split_ifs with h\n  \u00b7 exact hf\n  \u00b7 exact measurable_const\n#align measurable.infi_Prop Measurable.iInf_Prop\n\nsection ConditionallyCompleteLinearOrder\n\nvariable [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]\n\n@[measurability]\ntheorem measurable_iSup {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable (fun b \u21a6 \u2a06 i, f i b) := by\n  rcases isEmpty_or_nonempty \u03b9 with h\u03b9|h\u03b9\n  \u00b7 simp [iSup_of_empty']\n  have A : MeasurableSet {b | BddAbove (range (fun i \u21a6 f i b))} :=\n    measurableSet_bddAbove_range hf\n  have : Measurable (fun (_b : \u03b4) \u21a6 sSup (\u2205 : Set \u03b1)) := measurable_const\n  apply Measurable.isLUB_of_mem hf A _ _ this\n  \u00b7 rintro b \u27e8c, hc\u27e9\n    apply isLUB_ciSup\n    refine \u27e8c, ?_\u27e9\n    rintro d \u27e8i, rfl\u27e9\n    exact hc (mem_range_self i)\n  \u00b7 intro b hb\n    apply csSup_of_not_bddAbove\n    exact hb\n\n@[measurability]\ntheorem aemeasurable_iSup {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a06 i, f i b) \u03bc := by\n  refine \u27e8fun b \u21a6 \u2a06 i, (hf i).mk (f i) b, measurable_iSup (fun i \u21a6 (hf i).measurable_mk), ?_\u27e9\n  filter_upwards [ae_all_iff.2 (fun i \u21a6 (hf i).ae_eq_mk)] with b hb using by simp [hb]\n#align ae_measurable_supr aemeasurable_iSup\n\n@[measurability]\ntheorem measurable_iInf {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun b => \u2a05 i, f i b :=\n  measurable_iSup (\u03b1 := \u03b1\u1d52\u1d48) hf\n#align measurable_infi measurable_iInf\n\n@[measurability]\ntheorem aemeasurable_iInf {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a05 i, f i b) \u03bc :=\n  aemeasurable_iSup (\u03b1 := \u03b1\u1d52\u1d48) hf\n#align ae_measurable_infi aemeasurable_iInf\n\ntheorem measurable_sSup {\u03b9} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {s : Set \u03b9} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable fun x => sSup ((fun i => f i x) '' s) := by\n  have : Countable \u2191s := countable_coe_iff.2 hs\n  convert measurable_iSup (f := (fun (i : s) \u21a6 f i)) (fun i \u21a6 hf i i.2) using 1\n  ext b\n  congr\n  exact image_eq_range (fun i \u21a6 f i b) s\n#align measurable_cSup measurable_sSup\n\ntheorem measurable_sInf {\u03b9} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {s : Set \u03b9} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable fun x => sInf ((fun i => f i x) '' s) :=\n  measurable_sSup (\u03b1 := \u03b1\u1d52\u1d48) hs hf\n#align measurable_cInf measurable_sInf\n\ntheorem measurable_biSup {\u03b9} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) : Measurable fun b => \u2a06 i \u2208 s, f i b := by\n  haveI : Encodable s := hs.toEncodable\n  by_cases H : \u2200 i, i \u2208 s\n  \u00b7 have : \u2200 b, \u2a06 i \u2208 s, f i b = \u2a06 (i : s), f i b :=\n      fun b \u21a6 cbiSup_eq_of_forall (f := fun i \u21a6 f i b) H\n    simp only [this]\n    exact measurable_iSup (fun (i : s) \u21a6 hf i i.2)\n  \u00b7 have : \u2200 b, \u2a06 i \u2208 s, f i b = (\u2a06 (i : s), f i b) \u2294 sSup \u2205 :=\n      fun b \u21a6 cbiSup_eq_of_not_forall (f := fun i \u21a6 f i b) H\n    simp only [this]\n    apply Measurable.sup _ measurable_const\n    exact measurable_iSup (fun (i : s) \u21a6 hf i i.2)\n#align measurable_bsupr measurable_biSup\n\ntheorem aemeasurable_biSup {\u03b9} {\u03bc : Measure \u03b4} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a06 i \u2208 s, f i b) \u03bc := by\n  let g : \u03b9 \u2192 \u03b4 \u2192 \u03b1 := fun i \u21a6 if hi : i \u2208 s then (hf i hi).mk (f i) else fun _b \u21a6 sSup \u2205\n  have : \u2200 i \u2208 s, Measurable (g i) := by\n    intro i hi\n    simpa [g, hi] using (hf i hi).measurable_mk\n  refine \u27e8fun b \u21a6 \u2a06 (i) (_ : i \u2208 s), g i b, measurable_biSup s hs this, ?_\u27e9\n  have : \u2200 i \u2208 s, \u2200\u1d50 b \u2202\u03bc, f i b = g i b :=\n    fun i hi \u21a6 by simpa [g, hi] using (hf i hi).ae_eq_mk\n  filter_upwards [(ae_ball_iff hs).2 this] with b hb\n  exact iSup_congr fun i => iSup_congr (hb i)\n#align ae_measurable_bsupr aemeasurable_biSup\n\ntheorem measurable_biInf {\u03b9} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) : Measurable fun b => \u2a05 i \u2208 s, f i b :=\n  measurable_biSup (\u03b1 := \u03b1\u1d52\u1d48) s hs hf\n#align measurable_binfi measurable_biInf\n\ntheorem aemeasurable_biInf {\u03b9} {\u03bc : Measure \u03b4} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a05 i \u2208 s, f i b) \u03bc :=\n  aemeasurable_biSup (\u03b1 := \u03b1\u1d52\u1d48) s hs hf\n#align ae_measurable_binfi aemeasurable_biInf\n\n/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `\u2115`.\n-/\ntheorem measurable_liminf' {\u03b9 \u03b9'} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {v : Filter \u03b9} (hf : \u2200 i, Measurable (f i))\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasCountableBasis p s) (hs : \u2200 j, (s j).Countable) :\n    Measurable fun x => liminf (f \u00b7 x) v := by\n  /- We would like to write the liminf as `\u2a06 (j : Subtype p), \u2a05 (i : s j), f i x`, as the\n  measurability would follow from the measurability of infs and sups. Unfortunately, this is not\n  true in general conditionally complete linear orders because of issues with empty sets or sets\n  which are not bounded above or below. A slightly more complicated expression for the liminf,\n  valid in general, is given in `Filter.HasBasis.liminf_eq_ite`. This expression, built from\n  `if ... then ... else` and infs and sups, can be readily checked to be measurable. -/\n  have : Countable (Subtype p) := hv.countable\n  rcases isEmpty_or_nonempty (Subtype p) with hp|hp\n  \u00b7 simp [hv.liminf_eq_sSup_iUnion_iInter]\n  by_cases H : \u2203 (j : Subtype p), s j = \u2205\n  \u00b7 simp_rw [hv.liminf_eq_ite, if_pos H, measurable_const]\n  simp_rw [hv.liminf_eq_ite, if_neg H]\n  have : \u2200 i, Countable (s i) := fun i \u21a6 countable_coe_iff.2 (hs i)\n  let m : Subtype p \u2192 Set \u03b4 := fun j \u21a6 {x | BddBelow (range (fun (i : s j) \u21a6 f i x))}\n  have m_meas : \u2200 j, MeasurableSet (m j) :=\n    fun j \u21a6 measurableSet_bddBelow_range (fun (i : s j) \u21a6 hf i)\n  have mc_meas : MeasurableSet {x | \u2200 (j : Subtype p), x \u2209 m j} := by\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun j \u21a6 (m_meas j).compl)\n  apply Measurable.piecewise mc_meas measurable_const\n  apply measurable_iSup (fun j \u21a6 ?_)\n  let reparam : \u03b4 \u2192 Subtype p \u2192 Subtype p := fun x \u21a6 liminf_reparam (fun i \u21a6 f i x) s p\n  let F0 : Subtype p \u2192 \u03b4 \u2192 \u03b1 := fun j x \u21a6 \u2a05 (i : s j), f i x\n  have F0_meas : \u2200 j, Measurable (F0 j) := fun j \u21a6 measurable_iInf (fun (i : s j) \u21a6 hf i)\n  set F1 : \u03b4 \u2192 \u03b1 := fun x \u21a6 F0 (reparam x j) x with hF1\n  change Measurable F1\n  let g : \u2115 \u2192 Subtype p := Classical.choose (exists_surjective_nat (Subtype p))\n  have Z : \u2200 x, \u2203 n, x \u2208 m (g n) \u2228 \u2200 k, x \u2209 m k := by\n    intro x\n    by_cases H : \u2203 k, x \u2208 m k\n    \u00b7 rcases H with \u27e8k, hk\u27e9\n      rcases Classical.choose_spec (exists_surjective_nat (Subtype p)) k with \u27e8n, rfl\u27e9\n      exact \u27e8n, Or.inl hk\u27e9\n    \u00b7 push_neg at H\n      exact \u27e80, Or.inr H\u27e9\n  have : F1 = fun x \u21a6 if x \u2208 m j then F0 j x else F0 (g (Nat.find (Z x))) x := by\n    ext x\n    have A : reparam x j = if x \u2208 m j then j else g (Nat.find (Z x)) := rfl\n    split_ifs with hjx\n    \u00b7 have : reparam x j = j := by rw [A, if_pos hjx]\n      simp only [hF1, this]\n    \u00b7 have : reparam x j = g (Nat.find (Z x)) := by rw [A, if_neg hjx]\n      simp only [hF1, this]\n  rw [this]\n  apply Measurable.piecewise (m_meas j) (F0_meas j)\n  apply Measurable.find (fun n \u21a6 F0_meas (g n)) (fun n \u21a6 ?_)\n  exact (m_meas (g n)).union mc_meas\n#align measurable_liminf' measurable_liminf'\n\n/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `\u2115`.\n-/\ntheorem measurable_limsup' {\u03b9 \u03b9'} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {u : Filter \u03b9} (hf : \u2200 i, Measurable (f i))\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hu : u.HasCountableBasis p s) (hs : \u2200 i, (s i).Countable) :\n    Measurable fun x => limsup (fun i => f i x) u :=\n  measurable_liminf' (\u03b1 := \u03b1\u1d52\u1d48) hf hu hs\n#align measurable_limsup' measurable_limsup'\n\n/-- `liminf` over `\u2115` is measurable. See `measurable_liminf'` for a version with a general filter.\n-/\n@[measurability]\ntheorem measurable_liminf {f : \u2115 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun x => liminf (fun i => f i x) atTop :=\n  measurable_liminf' hf atTop_countable_basis fun _ => to_countable _\n#align measurable_liminf measurable_liminf\n\n/-- `limsup` over `\u2115` is measurable. See `measurable_limsup'` for a version with a general filter.\n-/\n@[measurability]\ntheorem measurable_limsup {f : \u2115 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun x => limsup (fun i => f i x) atTop :=\n  measurable_limsup' hf atTop_countable_basis fun _ => to_countable _\n#align measurable_limsup measurable_limsup\n\nend ConditionallyCompleteLinearOrder\n\n/-- Convert a `Homeomorph` to a `MeasurableEquiv`. -/\ndef Homemorph.toMeasurableEquiv (h : \u03b1 \u2243\u209c \u03b2) : \u03b1 \u2243\u1d50 \u03b2 where\n  toEquiv := h.toEquiv\n  measurable_toFun := h.continuous_toFun.measurable\n  measurable_invFun := h.continuous_invFun.measurable\n#align homemorph.to_measurable_equiv Homemorph.toMeasurableEquiv\n\nprotected theorem IsFiniteMeasureOnCompacts.map (\u03bc : Measure \u03b1) [IsFiniteMeasureOnCompacts \u03bc]\n    (f : \u03b1 \u2243\u209c \u03b2) : IsFiniteMeasureOnCompacts (Measure.map f \u03bc) := by\n  refine \u27e8fun K hK \u21a6 ?_\u27e9\n  rw [\u2190 Homeomorph.toMeasurableEquiv_coe, MeasurableEquiv.map_apply]\n  exact IsCompact.measure_lt_top (f.isCompact_preimage.2 hK)\n#align is_finite_measure_on_compacts.map IsFiniteMeasureOnCompacts.map\n\nend BorelSpace\n\ninstance Empty.borelSpace : BorelSpace Empty :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align empty.borel_space Empty.borelSpace\n\ninstance Unit.borelSpace : BorelSpace Unit :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align unit.borel_space Unit.borelSpace\n\ninstance Bool.borelSpace : BorelSpace Bool :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align bool.borel_space Bool.borelSpace\n\ninstance Nat.borelSpace : BorelSpace \u2115 :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align nat.borel_space Nat.borelSpace\n\ninstance Int.borelSpace : BorelSpace \u2124 :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align int.borel_space Int.borelSpace\n\ninstance Rat.borelSpace : BorelSpace \u211a :=\n  \u27e8borel_eq_top_of_countable.symm\u27e9\n#align rat.borel_space Rat.borelSpace\n\n/- Instances on `Real` and `Complex` are special cases of `RCLike` but without these instances,\nLean fails to prove `BorelSpace (\u03b9 \u2192 \u211d)`, so we leave them here. -/\ninstance Real.measurableSpace : MeasurableSpace \u211d :=\n  borel \u211d\n#align real.measurable_space Real.measurableSpace\n\ninstance Real.borelSpace : BorelSpace \u211d :=\n  \u27e8rfl\u27e9\n#align real.borel_space Real.borelSpace\n\ninstance NNReal.measurableSpace : MeasurableSpace \u211d\u22650 :=\n  Subtype.instMeasurableSpace\n#align nnreal.measurable_space NNReal.measurableSpace\n\ninstance NNReal.borelSpace : BorelSpace \u211d\u22650 :=\n  Subtype.borelSpace _\n#align nnreal.borel_space NNReal.borelSpace\n\ninstance ENNReal.measurableSpace : MeasurableSpace \u211d\u22650\u221e :=\n  borel \u211d\u22650\u221e\n#align ennreal.measurable_space ENNReal.measurableSpace\n\ninstance ENNReal.borelSpace : BorelSpace \u211d\u22650\u221e :=\n  \u27e8rfl\u27e9\n#align ennreal.borel_space ENNReal.borelSpace\n\ninstance EReal.measurableSpace : MeasurableSpace EReal :=\n  borel EReal\n#align ereal.measurable_space EReal.measurableSpace\n\ninstance EReal.borelSpace : BorelSpace EReal :=\n  \u27e8rfl\u27e9\n#align ereal.borel_space EReal.borelSpace\n\n/-- One can cut out `\u211d\u22650\u221e` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : \u2124` and `{\u221e}`. This\ngives a way to compute the measure of a set in terms of sets on which a given function `f` does not\nfluctuate by more than `t`. -/\ntheorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)\n    {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) {s : Set \u03b1} (hs : MeasurableSet s) {t : \u211d\u22650} (ht : 1 < t) :\n    \u03bc s =\n      \u03bc (s \u2229 f \u207b\u00b9' {0}) + \u03bc (s \u2229 f \u207b\u00b9' {\u221e}) +\n      \u2211' n : \u2124, \u03bc (s \u2229 f \u207b\u00b9' Ico ((t : \u211d\u22650\u221e) ^ n) ((t : \u211d\u22650\u221e) ^ (n + 1))) := by\n  have A : \u03bc s = \u03bc (s \u2229 f \u207b\u00b9' {0}) + \u03bc (s \u2229 f \u207b\u00b9' Ioi 0) := by\n    rw [\u2190 measure_union]\n    \u00b7 rw [\u2190 inter_union_distrib_left, \u2190 preimage_union, singleton_union, Ioi_insert,\n        \u2190 _root_.bot_eq_zero, Ici_bot, preimage_univ, inter_univ]\n    \u00b7 exact disjoint_singleton_left.mpr not_mem_Ioi_self\n        |>.preimage f |>.inter_right' s |>.inter_left' s\n    \u00b7 exact hs.inter (hf measurableSet_Ioi)\n  have B : \u03bc (s \u2229 f \u207b\u00b9' Ioi 0) = \u03bc (s \u2229 f \u207b\u00b9' {\u221e}) + \u03bc (s \u2229 f \u207b\u00b9' Ioo 0 \u221e) := by\n    rw [\u2190 measure_union]\n    \u00b7 rw [\u2190 inter_union_distrib_left]\n      congr\n      ext x\n      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]\n      obtain (H | H) : f x = \u221e \u2228 f x < \u221e := eq_or_lt_of_le le_top\n      \u00b7 simp only [H, eq_self_iff_true, or_false_iff, ENNReal.zero_lt_top, not_top_lt, and_false]\n      \u00b7 simp only [H, H.ne, and_true_iff, false_or_iff]\n    \u00b7 refine disjoint_left.2 fun x hx h'x => ?_\n      have : f x < \u221e := h'x.2.2\n      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))\n    \u00b7 exact hs.inter (hf measurableSet_Ioo)\n  have C : \u03bc (s \u2229 f \u207b\u00b9' Ioo 0 \u221e) =\n      \u2211' n : \u2124, \u03bc (s \u2229 f \u207b\u00b9' Ico ((t : \u211d\u22650\u221e) ^ n) ((t : \u211d\u22650\u221e) ^ (n + 1))) := by\n    rw [\u2190 measure_iUnion,\n      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,\n      preimage_iUnion, inter_iUnion]\n    \u00b7 intro i j hij\n      wlog h : i < j generalizing i j\n      \u00b7 exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm\n      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_\n      calc\n        f x < (t : \u211d\u22650\u221e) ^ (i + 1) := hx.2.2\n        _ \u2264 (t : \u211d\u22650\u221e) ^ j := ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h\n        _ \u2264 f x := h'x.2.1\n    \u00b7 intro n\n      exact hs.inter (hf measurableSet_Ico)\n  rw [A, B, C, add_assoc]\n#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow\n\nsection PseudoMetricSpace\n\nvariable [PseudoMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]\nvariable [MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d}\n\nopen Metric\n\n@[measurability]\ntheorem measurableSet_ball : MeasurableSet (Metric.ball x \u03b5) :=\n  Metric.isOpen_ball.measurableSet\n#align measurable_set_ball measurableSet_ball\n\n@[measurability]\ntheorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x \u03b5) :=\n  Metric.isClosed_ball.measurableSet\n#align measurable_set_closed_ball measurableSet_closedBall\n\n@[measurability]\ntheorem measurable_infDist {s : Set \u03b1} : Measurable fun x => infDist x s :=\n  (continuous_infDist_pt s).measurable\n#align measurable_inf_dist measurable_infDist\n\n@[measurability]\ntheorem Measurable.infDist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infDist (f x) s :=\n  measurable_infDist.comp hf\n#align measurable.inf_dist Measurable.infDist\n\n@[measurability]\ntheorem measurable_infNndist {s : Set \u03b1} : Measurable fun x => infNndist x s :=\n  (continuous_infNndist_pt s).measurable\n#align measurable_inf_nndist measurable_infNndist\n\n@[measurability]\ntheorem Measurable.infNndist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infNndist (f x) s :=\n  measurable_infNndist.comp hf\n#align measurable.inf_nndist Measurable.infNndist\n\nsection\n\nvariable [SecondCountableTopology \u03b1]\n\n@[measurability]\ntheorem measurable_dist : Measurable fun p : \u03b1 \u00d7 \u03b1 => dist p.1 p.2 :=\n  continuous_dist.measurable\n#align measurable_dist measurable_dist\n\n@[measurability]\ntheorem Measurable.dist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => dist (f b) (g b) :=\n  (@continuous_dist \u03b1 _).measurable2 hf hg\n#align measurable.dist Measurable.dist\n\n@[measurability]\ntheorem measurable_nndist : Measurable fun p : \u03b1 \u00d7 \u03b1 => nndist p.1 p.2 :=\n  continuous_nndist.measurable\n#align measurable_nndist measurable_nndist\n\n@[measurability]\ntheorem Measurable.nndist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => nndist (f b) (g b) :=\n  (@continuous_nndist \u03b1 _).measurable2 hf hg\n#align measurable.nndist Measurable.nndist\n\nend\n\nend PseudoMetricSpace\n\nsection PseudoEMetricSpace\n\nvariable [PseudoEMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]\nvariable [MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d\u22650\u221e}\n\nopen EMetric\n\n@[measurability]\ntheorem measurableSet_eball : MeasurableSet (EMetric.ball x \u03b5) :=\n  EMetric.isOpen_ball.measurableSet\n#align measurable_set_eball measurableSet_eball\n\n@[measurability]\ntheorem measurable_edist_right : Measurable (edist x) :=\n  (continuous_const.edist continuous_id).measurable\n#align measurable_edist_right measurable_edist_right\n\n@[measurability]\ntheorem measurable_edist_left : Measurable fun y => edist y x :=\n  (continuous_id.edist continuous_const).measurable\n#align measurable_edist_left measurable_edist_left\n\n@[measurability]\ntheorem measurable_infEdist {s : Set \u03b1} : Measurable fun x => infEdist x s :=\n  continuous_infEdist.measurable\n#align measurable_inf_edist measurable_infEdist\n\n@[measurability]\ntheorem Measurable.infEdist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infEdist (f x) s :=\n  measurable_infEdist.comp hf\n#align measurable.inf_edist Measurable.infEdist\n\nopen Metric EMetric\n\n/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed\nthickenings converges to the measure of its closure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc (closure s))) := by\n  have A : Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd[Ioi 0] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n    rw [closure_eq_iInter_cthickening]\n    exact\n      tendsto_measure_biInter_gt (fun r _ => isClosed_cthickening.measurableSet)\n        (fun i j _ ij => cthickening_mono ij _) hs\n  have B : Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd[Iic 0] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n    apply Tendsto.congr' _ tendsto_const_nhds\n    filter_upwards [self_mem_nhdsWithin (\u03b1 := \u211d)] with _ hr\n    rw [cthickening_of_nonpos hr]\n  convert B.sup A\n  exact (nhds_left_sup_nhds_right' 0).symm\n#align tendsto_measure_cthickening tendsto_measure_cthickening\n\n/-- If a closed set has a closed thickening with finite measure, then the measure of its closed\n`r`-thickenings converge to its measure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc s)) := by\n  convert tendsto_measure_cthickening hs\n  exact h's.closure_eq.symm\n#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_isClosed\n\n/-- If a set has a thickening with finite measure, then the measures of its `r`-thickenings\nconverge to the measure of its closure as `r > 0` tends to `0`. -/\ntheorem tendsto_measure_thickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n  rw [closure_eq_iInter_thickening]\n  exact tendsto_measure_biInter_gt (fun r _ => isOpen_thickening.measurableSet)\n      (fun i j _ ij => thickening_mono ij _) hs\n\n/-- If a closed set has a thickening with finite measure, then the measure of its\n`r`-thickenings converge to its measure as `r > 0` tends to `0`. -/\ntheorem tendsto_measure_thickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc s)) := by\n  convert tendsto_measure_thickening hs\n  exact h's.closure_eq.symm\n\nvariable [SecondCountableTopology \u03b1]\n\n@[measurability]\ntheorem measurable_edist : Measurable fun p : \u03b1 \u00d7 \u03b1 => edist p.1 p.2 :=\n  continuous_edist.measurable\n#align measurable_edist measurable_edist\n\n@[measurability]\ntheorem Measurable.edist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => edist (f b) (g b) :=\n  (@continuous_edist \u03b1 _).measurable2 hf hg\n#align measurable.edist Measurable.edist\n\n@[measurability]\ntheorem AEMeasurable.edist {f g : \u03b2 \u2192 \u03b1} {\u03bc : Measure \u03b2} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => edist (f a) (g a)) \u03bc :=\n  (@continuous_edist \u03b1 _).aemeasurable2 hf hg\n#align ae_measurable.edist AEMeasurable.edist\n\nend PseudoEMetricSpace\n\n/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to\nits measure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening_of_isCompact [MetricSpace \u03b1] [MeasurableSpace \u03b1]\n    [OpensMeasurableSpace \u03b1] [ProperSpace \u03b1] {\u03bc : Measure \u03b1} [IsFiniteMeasureOnCompacts \u03bc]\n    {s : Set \u03b1} (hs : IsCompact s) :\n    Tendsto (fun r => \u03bc (Metric.cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc s)) :=\n  tendsto_measure_cthickening_of_isClosed\n    \u27e81, zero_lt_one, hs.isBounded.cthickening.measure_lt_top.ne\u27e9 hs.isClosed\n#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_isCompact\n\n/-- If a measurable space is countably generated and separates points, it arises as\nthe borel sets of some second countable t4 topology (i.e. a separable metrizable one). -", "theoremStatement": "/\ntheorem exists_borelSpace_of_countablyGenerated_of_separatesPoints (\u03b1 : Type*)\n    [m : MeasurableSpace \u03b1] [CountablyGenerated \u03b1] [SeparatesPoints \u03b1] :\n    \u2203 \u03c4 : TopologicalSpace \u03b1, SecondCountableTopology \u03b1 \u2227 T4Space \u03b1 \u2227 BorelSpace", "theoremName": "exists_borelSpace_of_countablyGenerated_of_separatesPoints", "fileCreated": {"commit": "11332d53f1", "date": "2023-05-21"}, "theoremCreated": {"commit": "726f2a5ff9", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "positionMetadata": {"lineInFile": 1907, "tokenPositionInFile": 88883, "theoremPositionInFile": 217}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "= by\n  rcases measurableEquiv_nat_bool_of_countablyGenerated \u03b1 with \u27e8s, \u27e8f\u27e9\u27e9\n  letI := induced f inferInstance\n  let F := f.toEquiv.toHomeomorphOfInducing $ inducing_induced _\n  exact \u27e8inferInstance, F.secondCountableTopology, F.symm.t4Space,\n    MeasurableEmbedding.borelSpace f.measurableEmbedding F.inducin", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 309}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2017 Johannes H\u00f6lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H\u00f6lzl, Yury Kudryashov\n-/\nimport Mathlib.Analysis.Normed.Group.Basic\nimport Mathlib.MeasureTheory.Function.AEMeasurableSequence\nimport Mathlib.MeasureTheory.Group.Arithmetic\nimport Mathlib.MeasureTheory.Order.Lattice\nimport Mathlib.Topology.Instances.EReal\nimport Mathlib.Topology.MetricSpace.Thickening\nimport Mathlib.Topology.GDelta\nimport Mathlib.Topology.Order.Lattice\nimport Mathlib.Topology.Semicontinuous\n\n#align_import measure_theory.constructions.borel_space.basic from \"leanprover-community/mathlib\"@\"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce\"\n\n/-!\n# Borel (measurable) space\n\n## Main definitions\n\n* `borel \u03b1` : the least `\u03c3`-algebra that contains all open sets;\n* `class BorelSpace` : a space with `TopologicalSpace` and `MeasurableSpace` structures\n  such that `\u2039MeasurableSpace \u03b1\u203a = borel \u03b1`;\n* `class OpensMeasurableSpace` : a space with `TopologicalSpace` and `MeasurableSpace`\n  structures such that all open sets are measurable; equivalently, `borel \u03b1 \u2264 \u2039MeasurableSpace \u03b1\u203a`.\n* `BorelSpace` instances on `Empty`, `Unit`, `Bool`, `Nat`, `Int`, `Rat`;\n* `MeasurableSpace` and `BorelSpace` instances on `\u211d`, `\u211d\u22650`, `\u211d\u22650\u221e`.\n\n## Main statements\n\n* `IsOpen.measurableSet`, `IsClosed.measurableSet`: open and closed sets are measurable;\n* `Continuous.measurable` : a continuous function is measurable;\n* `Continuous.measurable2` : if `f : \u03b1 \u2192 \u03b2` and `g : \u03b1 \u2192 \u03b3` are measurable and `op : \u03b2 \u00d7 \u03b3 \u2192 \u03b4`\n  is continuous, then `fun x => op (f x, g y)` is measurable;\n* `Measurable.add` etc : dot notation for arithmetic operations on `Measurable` predicates,\n  and similarly for `dist` and `edist`;\n* `AEMeasurable.add` : similar dot notation for almost everywhere measurable functions;\n* `Measurable.ennreal*` : special cases for arithmetic operations on `\u211d\u22650\u221e`.\n-/\n\n\nnoncomputable section\n\nopen Set Filter MeasureTheory\n\nopen scoped Classical BigOperators Topology NNReal ENNReal MeasureTheory\n\nuniverse u v w x y\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b3\u2082 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}\n\nopen MeasurableSpace TopologicalSpace\n\n/-- `MeasurableSpace` structure generated by `TopologicalSpace`. -/\ndef borel (\u03b1 : Type u) [TopologicalSpace \u03b1] : MeasurableSpace \u03b1 :=\n  generateFrom { s : Set \u03b1 | IsOpen s }\n#align borel borel\n\ntheorem borel_anti : Antitone (@borel \u03b1) := fun _ _ h =>\n  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)\n#align borel_anti borel_anti\n\ntheorem borel_eq_top_of_discrete [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] : borel \u03b1 = \u22a4 :=\n  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)\n#align borel_eq_top_of_discrete borel_eq_top_of_discrete\n\ntheorem borel_eq_top_of_countable [TopologicalSpace \u03b1] [T1Space \u03b1] [Countable \u03b1] : borel \u03b1 = \u22a4 := by\n  refine' top_le_iff.1 fun s _ => biUnion_of_singleton s \u25b8 _\n  apply MeasurableSet.biUnion s.to_countable\n  intro x _\n  apply MeasurableSet.of_compl\n  apply GenerateMeasurable.basic\n  exact isClosed_singleton.isOpen_compl\n#align borel_eq_top_of_countable borel_eq_top_of_countable\n\ntheorem borel_eq_generateFrom_of_subbasis {s : Set (Set \u03b1)} [t : TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] (hs : t = .generateFrom s) : borel \u03b1 = .generateFrom s :=\n  le_antisymm\n    (generateFrom_le fun u (hu : t.IsOpen u) => by\n      rw [hs] at hu\n      induction hu with\n      | basic u hu => exact GenerateMeasurable.basic u hu\n      | univ => exact @MeasurableSet.univ \u03b1 (generateFrom s)\n      | inter s\u2081 s\u2082 _ _ hs\u2081 hs\u2082 => exact @MeasurableSet.inter \u03b1 (generateFrom s) _ _ hs\u2081 hs\u2082\n      | sUnion f hf ih =>\n        rcases isOpen_sUnion_countable f (by rwa [hs]) with \u27e8v, hv, vf, vu\u27e9\n        rw [\u2190 vu]\n        exact @MeasurableSet.sUnion \u03b1 (generateFrom s) _ hv fun x xv => ih _ (vf xv))\n    (generateFrom_le fun u hu =>\n      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)\n#align borel_eq_generate_from_of_subbasis borel_eq_generateFrom_of_subbasis\n\ntheorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] {s : Set (Set \u03b1)} (hs : IsTopologicalBasis s) :\n    borel \u03b1 = .generateFrom s :=\n  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom\n#align topological_space.is_topological_basis.borel_eq_generate_from TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom\n\ntheorem isPiSystem_isOpen [TopologicalSpace \u03b1] : IsPiSystem ({s : Set \u03b1 | IsOpen s}) :=\n  fun _s hs _t ht _ => IsOpen.inter hs ht\n#align is_pi_system_is_open isPiSystem_isOpen\n\nlemma isPiSystem_isClosed [TopologicalSpace \u03b1] : IsPiSystem ({s : Set \u03b1 | IsClosed s}) :=\n  fun _s hs _t ht _ \u21a6 IsClosed.inter hs ht\n\ntheorem borel_eq_generateFrom_isClosed [TopologicalSpace \u03b1] :\n    borel \u03b1 = .generateFrom { s | IsClosed s } :=\n  le_antisymm\n    (generateFrom_le fun _t ht =>\n      @MeasurableSet.of_compl \u03b1 _ (generateFrom { s | IsClosed s })\n        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))\n    (generateFrom_le fun _t ht =>\n      @MeasurableSet.of_compl \u03b1 _ (borel \u03b1) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))\n#align borel_eq_generate_from_is_closed borel_eq_generateFrom_isClosed\n\nsection OrderTopology\n\nvariable (\u03b1)\nvariable [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]\n\ntheorem borel_eq_generateFrom_Iio : borel \u03b1 = .generateFrom (range Iio) := by\n  refine' le_antisymm _ (generateFrom_le _)\n  \u00b7 rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals \u03b1 _ _ _)]\n    letI : MeasurableSpace \u03b1 := MeasurableSpace.generateFrom (range Iio)\n    have H : \u2200 a : \u03b1, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ \u27e8_, rfl\u27e9\n    refine' generateFrom_le _\n    rintro _ \u27e8a, rfl | rfl\u27e9\n    \u00b7 rcases em (\u2203 b, a \u22d6 b) with \u27e8b, hb\u27e9 | hcovBy\n      \u00b7 rw [hb.Ioi_eq, \u2190 compl_Iio]\n        exact (H _).compl\n      \u00b7 rcases isOpen_biUnion_countable (Ioi a) Ioi fun _ _ \u21a6 isOpen_Ioi with \u27e8t, hat, htc, htU\u27e9\n        have : Ioi a = \u22c3 b \u2208 t, Ici b := by\n          refine Subset.antisymm ?_ <| iUnion\u2082_subset fun b hb \u21a6 Ici_subset_Ioi.2 (hat hb)\n          refine Subset.trans ?_ <| iUnion\u2082_mono fun _ _ \u21a6 Ioi_subset_Ici_self\n          simpa [CovBy, htU, subset_def] using hcovBy\n        simp only [this, \u2190 compl_Iio]\n        exact .biUnion htc <| fun _ _ \u21a6 (H _).compl\n    \u00b7 apply H\n  \u00b7 rw [forall_mem_range]\n    intro a\n    exact GenerateMeasurable.basic _ isOpen_Iio\n#align borel_eq_generate_from_Iio borel_eq_generateFrom_Iio\n\ntheorem borel_eq_generateFrom_Ioi : borel \u03b1 = .generateFrom (range Ioi) :=\n  @borel_eq_generateFrom_Iio \u03b1\u1d52\u1d48 _ (by infer_instance : SecondCountableTopology \u03b1) _ _\n#align borel_eq_generate_from_Ioi borel_eq_generateFrom_Ioi\n\ntheorem borel_eq_generateFrom_Iic :\n    borel \u03b1 = MeasurableSpace.generateFrom (range Iic) := by\n  rw [borel_eq_generateFrom_Ioi]\n  refine' le_antisymm _ _\n  \u00b7 refine' MeasurableSpace.generateFrom_le fun t ht => _\n    obtain \u27e8u, rfl\u27e9 := ht\n    rw [\u2190 compl_Iic]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr \u27e8u, rfl\u27e9)).compl\n  \u00b7 refine' MeasurableSpace.generateFrom_le fun t ht => _\n    obtain \u27e8u, rfl\u27e9 := ht\n    rw [\u2190 compl_Ioi]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr \u27e8u, rfl\u27e9)).compl\n#align borel_eq_generate_from_Iic borel_eq_generateFrom_Iic\n\ntheorem borel_eq_generateFrom_Ici : borel \u03b1 = MeasurableSpace.generateFrom (range Ici) :=\n  @borel_eq_generateFrom_Iic \u03b1\u1d52\u1d48 _ _ _ _\n#align borel_eq_generate_from_Ici borel_eq_generateFrom_Ici\n\nend OrderTopology\n\ntheorem borel_comap {f : \u03b1 \u2192 \u03b2} {t : TopologicalSpace \u03b2} :\n    @borel \u03b1 (t.induced f) = (@borel \u03b2 t).comap f :=\n  comap_generateFrom.symm\n#align borel_comap borel_comap\n\ntheorem Continuous.borel_measurable [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Continuous f) : @Measurable \u03b1 \u03b2 (borel \u03b1) (borel \u03b2) f :=\n  Measurable.of_le_map <|\n    generateFrom_le fun s hs => GenerateMeasurable.basic (f \u207b\u00b9' s) (hs.preimage hf)\n#align continuous.borel_measurable Continuous.borel_measurable\n\n/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that\nall open sets are measurable. -/\nclass OpensMeasurableSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [h : MeasurableSpace \u03b1] : Prop where\n  /-- Borel-measurable sets are measurable. -/\n  borel_le : borel \u03b1 \u2264 h\n#align opens_measurable_space OpensMeasurableSpace\n#align opens_measurable_space.borel_le OpensMeasurableSpace.borel_le\n\n/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that\nthe `\u03c3`-algebra of measurable sets is exactly the `\u03c3`-algebra generated by open sets. -/\nclass BorelSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] : Prop where\n  /-- The measurable sets are exactly the Borel-measurable sets. -/\n  measurable_eq : \u2039MeasurableSpace \u03b1\u203a = borel \u03b1\n#align borel_space BorelSpace\n#align borel_space.measurable_eq BorelSpace.measurable_eq\n\nnamespace Mathlib.Tactic.Borelize\n\nopen Lean Elab Term Tactic Meta\n\n/-- The behaviour of `borelize \u03b1` depends on the existing assumptions on `\u03b1`.\n\n- if `\u03b1` is a topological space with instances `[MeasurableSpace \u03b1] [BorelSpace \u03b1]`, then\n  `borelize \u03b1` replaces the former instance by `borel \u03b1`;\n- otherwise, `borelize \u03b1` adds instances `borel \u03b1 : MeasurableSpace \u03b1` and `\u27e8rfl\u27e9 : BorelSpace \u03b1`.\n\nFinally, `borelize \u03b1 \u03b2 \u03b3` runs `borelize \u03b1; borelize \u03b2; borelize \u03b3`.\n-/\nsyntax \"borelize\" (ppSpace colGt term:max)* : tactic\n\n/-- Add instances `borel e : MeasurableSpace e` and `\u27e8rfl\u27e9 : BorelSpace e`. -/\ndef addBorelInstance (e : Expr) : TacticM Unit := do\n  let t \u2190 Lean.Elab.Term.exprToSyntax e\n  evalTactic <| \u2190 `(tactic|\n    refine_lift\n      letI : MeasurableSpace $t := borel $t\n      haveI : BorelSpace $t := \u27e8rfl\u27e9\n      ?_)\n\n/-- Given a type `e`, an assumption `i : MeasurableSpace e`, and an instance `[BorelSpace e]`,\nreplace `i` with `borel e`. -/\ndef borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do\n  let te \u2190 Lean.Elab.Term.exprToSyntax e\n  evalTactic <| \u2190 `(tactic|\n    have := @BorelSpace.measurable_eq $te _ _ _)\n  try\n    liftMetaTactic fun m => return [\u2190 subst m i]\n  catch _ =>\n    let et \u2190 synthInstance (\u2190 mkAppOptM ``TopologicalSpace #[e])\n    throwError m!\"\\\n      `\u2039TopologicalSpace {e}\u203a := {et}\\n\\\n      depends on\\n\\\n      {Expr.fvar i} : MeasurableSpace {e}`\\n\\\n      so `borelize` isn't avaliable\"\n  evalTactic <| \u2190 `(tactic|\n    refine_lift\n      letI : MeasurableSpace $te := borel $te\n      ?_)\n\n/-- Given a type `$t`, if there is an assumption `[i : MeasurableSpace $t]`, then try to prove\n`[BorelSpace $t]` and replace `i` with `borel $t`. Otherwise, add instances\n`borel $t : MeasurableSpace $t` and `\u27e8rfl\u27e9 : BorelSpace $t`. -/\ndef borelize (t : Term) : TacticM Unit := withMainContext <| do\n  let u \u2190 mkFreshLevelMVar\n  let e \u2190 withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))\n  let i? \u2190 findLocalDeclWithType? (\u2190 mkAppOptM ``MeasurableSpace #[e])\n  i?.elim (addBorelInstance e) (borelToRefl e)\n\nelab_rules : tactic\n  | `(tactic| borelize $[$t:term]*) => t.forM borelize\n\nend Mathlib.Tactic.Borelize\n\ninstance (priority := 100) OrderDual.opensMeasurableSpace {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [h : OpensMeasurableSpace \u03b1] : OpensMeasurableSpace \u03b1\u1d52\u1d48 where\n  borel_le := h.borel_le\n#align order_dual.opens_measurable_space OrderDual.opensMeasurableSpace\n\ninstance (priority := 100) OrderDual.borelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [h : BorelSpace \u03b1] : BorelSpace \u03b1\u1d52\u1d48 where\n  measurable_eq := h.measurable_eq\n#align order_dual.borel_space OrderDual.borelSpace\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ninstance (priority := 100) BorelSpace.opensMeasurable {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [BorelSpace \u03b1] : OpensMeasurableSpace \u03b1 :=\n  \u27e8ge_of_eq <| BorelSpace.measurable_eq\u27e9\n#align borel_space.opens_measurable BorelSpace.opensMeasurable\n\ninstance Subtype.borelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [MeasurableSpace \u03b1]\n    [h\u03b1 : BorelSpace \u03b1] (s : Set \u03b1) : BorelSpace s :=\n  \u27e8by borelize \u03b1; symm; apply borel_comap\u27e9\n#align subtype.borel_space Subtype.borelSpace\n\ninstance Countable.instBorelSpace [Countable \u03b1] [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1]\n    [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] : BorelSpace \u03b1 := by\n  have : \u2200 s, @MeasurableSet \u03b1 inferInstance s := fun s \u21a6 s.to_countable.measurableSet\n  have : \u2200 s, @MeasurableSet \u03b1 (borel \u03b1) s := fun s \u21a6 measurableSet_generateFrom (isOpen_discrete s)\n  exact \u27e8by aesop\u27e9\n\ninstance Subtype.opensMeasurableSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [MeasurableSpace \u03b1]\n    [h : OpensMeasurableSpace \u03b1] (s : Set \u03b1) : OpensMeasurableSpace s :=\n  \u27e8by\n    rw [borel_comap]\n    exact comap_mono h.1\u27e9\n#align subtype.opens_measurable_space Subtype.opensMeasurableSpace\n\nlemma opensMeasurableSpace_iff_forall_measurableSet\n    [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] :\n    OpensMeasurableSpace \u03b1 \u2194  (\u2200 (s : Set \u03b1), IsOpen s \u2192 MeasurableSet s) := by\n  refine \u27e8fun h s hs \u21a6 ?_, fun h \u21a6 \u27e8generateFrom_le h\u27e9\u27e9\n  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs\n\ninstance (priority := 100) BorelSpace.countablyGenerated {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [BorelSpace \u03b1] [SecondCountableTopology \u03b1] : CountablyGenerated \u03b1 := by\n  obtain \u27e8b, bct, -, hb\u27e9 := exists_countable_basis \u03b1\n  refine' \u27e8\u27e8b, bct, _\u27e9\u27e9\n  borelize \u03b1\n  exact hb.borel_eq_generateFrom\n#align borel_space.countably_generated BorelSpace.countablyGenerated\n\ntheorem MeasurableSet.induction_on_open [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1]\n    {C : Set \u03b1 \u2192 Prop} (h_open : \u2200 U, IsOpen U \u2192 C U)\n    (h_compl : \u2200 t, MeasurableSet t \u2192 C t \u2192 C t\u1d9c)\n    (h_union :\n      \u2200 f : \u2115 \u2192 Set \u03b1,\n        Pairwise (Disjoint on f) \u2192 (\u2200 i, MeasurableSet (f i)) \u2192 (\u2200 i, C (f i)) \u2192 C (\u22c3 i, f i)) :\n    \u2200 \u2983t\u2984, MeasurableSet t \u2192 C t :=\n  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen\n    (h_open _ isOpen_empty) h_open h_compl h_union\n#align measurable_set.induction_on_open MeasurableSet.induction_on_open\n\nsection\n\nvariable [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1] [TopologicalSpace \u03b2]\n  [MeasurableSpace \u03b2] [OpensMeasurableSpace \u03b2] [TopologicalSpace \u03b3] [MeasurableSpace \u03b3]\n  [BorelSpace \u03b3] [TopologicalSpace \u03b3\u2082] [MeasurableSpace \u03b3\u2082] [BorelSpace \u03b3\u2082] [MeasurableSpace \u03b4]\n\ntheorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=\n  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h\n#align is_open.measurable_set IsOpen.measurableSet\n\ninstance (priority := 500) {s : Set \u03b1} [HasCountableSeparatingOn \u03b1 IsOpen s] :\n    HasCountableSeparatingOn \u03b1 MeasurableSet s :=\n  .mono (fun _ \u21a6 IsOpen.measurableSet) Subset.rfl\n\n@[measurability]\ntheorem measurableSet_interior : MeasurableSet (interior s) :=\n  isOpen_interior.measurableSet\n#align measurable_set_interior measurableSet_interior\n\ntheorem IsG\u03b4.measurableSet (h : IsG\u03b4 s) : MeasurableSet s := by\n  rcases h with \u27e8S, hSo, hSc, rfl\u27e9\n  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet\nset_option linter.uppercaseLean3 false in\n#align is_G\u03b4.measurable_set IsG\u03b4.measurableSet\n\ntheorem measurableSet_of_continuousAt {\u03b2} [EMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    MeasurableSet { x | ContinuousAt f x } :=\n  (IsG\u03b4.setOf_continuousAt f).measurableSet\n#align measurable_set_of_continuous_at measurableSet_of_continuousAt\n\ntheorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=\n  h.isOpen_compl.measurableSet.of_compl\n#align is_closed.measurable_set IsClosed.measurableSet\n\ntheorem IsCompact.measurableSet [T2Space \u03b1] (h : IsCompact s) : MeasurableSet s :=\n  h.isClosed.measurableSet\n#align is_compact.measurable_set IsCompact.measurableSet\n\n/-- If two points are topologically inseparable,\nthen they can't be separated by a Borel measurable set. -/\ntheorem Inseparable.mem_measurableSet_iff {x y : \u03b3} (h : Inseparable x y) {s : Set \u03b3}\n    (hs : MeasurableSet s) : x \u2208 s \u2194 y \u2208 s :=\n  hs.induction_on_open (C := fun s \u21a6 (x \u2208 s \u2194 y \u2208 s)) (fun _ \u21a6 h.mem_open_iff) (fun s _ hs \u21a6 hs.not)\n    fun _ _ _ h \u21a6 by simp [h]\n\n/-- If `K` is a compact set in an R\u2081 space and `s \u2287 K` is a Borel measurable superset,\nthen `s` includes the closure of `K` as well. -/\ntheorem IsCompact.closure_subset_measurableSet [R1Space \u03b3] {K s : Set \u03b3} (hK : IsCompact K)\n    (hs : MeasurableSet s) (hKs : K \u2286 s) : closure K \u2286 s := by\n  rw [hK.closure_eq_biUnion_inseparable, iUnion\u2082_subset_iff]\n  exact fun x hx y hy \u21a6 (hy.mem_measurableSet_iff hs).1 (hKs hx)\n\n/-- In an R\u2081 topological space with Borel measure `\u03bc`,\nthe measure of the closure of a compact set `K` is equal to the measure of `K`.\n\nSee also `MeasureTheory.Measure.OuterRegular.measure_closure_eq_of_isCompact`\nfor a version that assumes `\u03bc` to be outer regular\nbut does not assume the `\u03c3`-algebra to be Borel.  -/\ntheorem IsCompact.measure_closure [R1Space \u03b3] {K : Set \u03b3} (hK : IsCompact K) (\u03bc : Measure \u03b3) :\n    \u03bc (closure K) = \u03bc K := by\n  refine le_antisymm ?_ (measure_mono subset_closure)\n  calc\n    \u03bc (closure K) \u2264 \u03bc (toMeasurable \u03bc K) := measure_mono <|\n      hK.closure_subset_measurableSet (measurableSet_toMeasurable ..) (subset_toMeasurable ..)\n    _ = \u03bc K := measure_toMeasurable ..\n\n@[measurability]\ntheorem measurableSet_closure : MeasurableSet (closure s) :=\n  isClosed_closure.measurableSet\n#align measurable_set_closure measurableSet_closure\n\ntheorem measurable_of_isOpen {f : \u03b4 \u2192 \u03b3} (hf : \u2200 s, IsOpen s \u2192 MeasurableSet (f \u207b\u00b9' s)) :\n    Measurable f := by\n  rw [\u2039BorelSpace \u03b3\u203a.measurable_eq]\n  exact measurable_generateFrom hf\n#align measurable_of_is_open measurable_of_isOpen\n\ntheorem measurable_of_isClosed {f : \u03b4 \u2192 \u03b3} (hf : \u2200 s, IsClosed s \u2192 MeasurableSet (f \u207b\u00b9' s)) :\n    Measurable f := by\n  apply measurable_of_isOpen; intro s hs\n  rw [\u2190 MeasurableSet.compl_iff, \u2190 preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs\n#align measurable_of_is_closed measurable_of_isClosed\n\ntheorem measurable_of_isClosed' {f : \u03b4 \u2192 \u03b3}\n    (hf : \u2200 s, IsClosed s \u2192 s.Nonempty \u2192 s \u2260 univ \u2192 MeasurableSet (f \u207b\u00b9' s)) : Measurable f := by\n  apply measurable_of_isClosed; intro s hs\n  rcases eq_empty_or_nonempty s with h1 | h1\n  \u00b7 simp [h1]\n  by_cases h2 : s = univ\n  \u00b7 simp [h2]\n  exact hf s hs h1 h2\n#align measurable_of_is_closed' measurable_of_isClosed'\n\ninstance nhds_isMeasurablyGenerated (a : \u03b1) : (\ud835\udcdd a).IsMeasurablyGenerated := by\n  rw [nhds, iInf_subtype']\n  refine' @Filter.iInf_isMeasurablyGenerated \u03b1 _ _ _ fun i => _\n  exact i.2.2.measurableSet.principal_isMeasurablyGenerated\n#align nhds_is_measurably_generated nhds_isMeasurablyGenerated\n\n/-- If `s` is a measurable set, then `\ud835\udcdd[s] a` is a measurably generated filter for\neach `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.\n-/\ntheorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set \u03b1} (hs : MeasurableSet s) (a : \u03b1) :\n    (\ud835\udcdd[s] a).IsMeasurablyGenerated :=\n  haveI := hs.principal_isMeasurablyGenerated\n  Filter.inf_isMeasurablyGenerated _ _\n#align measurable_set.nhds_within_is_measurably_generated MeasurableSet.nhdsWithin_isMeasurablyGenerated\n\ninstance (priority := 100) OpensMeasurableSpace.separatesPoints [T0Space \u03b1] :\n    SeparatesPoints \u03b1 := by\n  rw [separatesPoints_iff]\n  intro x y hxy\n  apply Inseparable.eq\n  rw [inseparable_iff_forall_open]\n  exact fun s hs => hxy _ hs.measurableSet\n\n-- see Note [lower instance priority]\ninstance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space \u03b1] :\n    MeasurableSingletonClass \u03b1 :=\n  \u27e8fun _ => isClosed_singleton.measurableSet\u27e9\n#align opens_measurable_space.to_measurable_singleton_class OpensMeasurableSpace.toMeasurableSingletonClass\n\ninstance Pi.opensMeasurableSpace {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [Countable \u03b9]\n    [t' : \u2200 i, TopologicalSpace (\u03c0 i)] [\u2200 i, MeasurableSpace (\u03c0 i)]\n    [\u2200 i, SecondCountableTopology (\u03c0 i)] [\u2200 i, OpensMeasurableSpace (\u03c0 i)] :\n    OpensMeasurableSpace (\u2200 i, \u03c0 i) := by\n  constructor\n  have : Pi.topologicalSpace = .generateFrom { t | \u2203 (s : \u2200 a, Set (\u03c0 a)) (i : Finset \u03b9),\n      (\u2200 a \u2208 i, s a \u2208 countableBasis (\u03c0 a)) \u2227 t = pi (\u2191i) s } := by\n    rw [funext fun a => @eq_generateFrom_countableBasis (\u03c0 a) _ _, pi_generateFrom_eq]\n  rw [borel_eq_generateFrom_of_subbasis this]\n  apply generateFrom_le\n  rintro _ \u27e8s, i, hi, rfl\u27e9\n  refine' MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet _\n  rw [eq_generateFrom_countableBasis (\u03c0 a)]\n  exact .basic _ (hi a ha)\n#align pi.opens_measurable_space Pi.opensMeasurableSpace\n\n/-- The typeclass `SecondCountableTopologyEither \u03b1 \u03b2` registers the fact that at least one of\nthe two spaces has second countable topology. This is the right assumption to ensure that continuous\nmaps from `\u03b1` to `\u03b2` are strongly measurable. -/\nclass SecondCountableTopologyEither (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] :\n  Prop where\n  /-- The projection out of `SecondCountableTopologyEither` -/\n  out : SecondCountableTopology \u03b1 \u2228 SecondCountableTopology \u03b2\n#align second_countable_topology_either SecondCountableTopologyEither\n\ninstance (priority := 100) secondCountableTopologyEither_of_left (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1]\n    [TopologicalSpace \u03b2] [SecondCountableTopology \u03b1] : SecondCountableTopologyEither \u03b1 \u03b2 where\n  out := Or.inl (by infer_instance)\n#align second_countable_topology_either_of_left secondCountableTopologyEither_of_left\n\ninstance (priority := 100) secondCountableTopologyEither_of_right (\u03b1 \u03b2 : Type*)\n    [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [SecondCountableTopology \u03b2] :\n    SecondCountableTopologyEither \u03b1 \u03b2 where\n  out := Or.inr (by infer_instance)\n#align second_countable_topology_either_of_right secondCountableTopologyEither_of_right\n\n/-- If either `\u03b1` or `\u03b2` has second-countable topology, then the open sets in `\u03b1 \u00d7 \u03b2` belong to the\nproduct sigma-algebra. -/\ninstance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither \u03b1 \u03b2] :\n    OpensMeasurableSpace (\u03b1 \u00d7 \u03b2) := by\n  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs \u21a6 ?_)\n  rcases h.out with h\u03b1|h\u03b2\n  \u00b7 let F : Set \u03b1 \u2192 Set \u03b2 := fun a \u21a6 {y | \u2203 b, IsOpen b \u2227 y \u2208 b \u2227 a \u00d7\u02e2 b \u2286 s}\n    have A : \u2200 a, IsOpen (F a) := by\n      intro a\n      apply isOpen_iff_forall_mem_open.2\n      rintro y \u27e8b, b_open, yb, hb\u27e9\n      exact \u27e8b, fun z zb \u21a6 \u27e8b, b_open, zb, hb\u27e9, b_open, yb\u27e9\n    have : s = \u22c3 a \u2208 countableBasis \u03b1, a \u00d7\u02e2 F a := by\n      apply Subset.antisymm\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        rcases isOpen_prod_iff.1 hs y1 y2 hy with \u27e8u, v, u_open, v_open, yu, yv, huv\u27e9\n        obtain \u27e8a, ha, ya, au\u27e9 : \u2203 a \u2208 countableBasis \u03b1, y1 \u2208 a \u2227 a \u2286 u :=\n          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis \u03b1) yu u_open\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]\n        exact \u27e8a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huv\u27e9\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy\n        rcases hy with \u27e8a, ya, -, b, -, yb, hb\u27e9\n        exact hb (mem_prod.2 \u27e8ya, yb\u27e9)\n    rw [this]\n    apply MeasurableSet.biUnion (countable_countableBasis \u03b1) (fun a ha \u21a6 ?_)\n    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet\n  \u00b7 let F : Set \u03b2 \u2192 Set \u03b1 := fun a \u21a6 {y | \u2203 b, IsOpen b \u2227 y \u2208 b \u2227 b \u00d7\u02e2 a \u2286 s}\n    have A : \u2200 a, IsOpen (F a) := by\n      intro a\n      apply isOpen_iff_forall_mem_open.2\n      rintro y \u27e8b, b_open, yb, hb\u27e9\n      exact \u27e8b, fun z zb \u21a6 \u27e8b, b_open, zb, hb\u27e9, b_open, yb\u27e9\n    have : s = \u22c3 a \u2208 countableBasis \u03b2, F a \u00d7\u02e2 a := by\n      apply Subset.antisymm\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        rcases isOpen_prod_iff.1 hs y1 y2 hy with \u27e8u, v, u_open, v_open, yu, yv, huv\u27e9\n        obtain \u27e8a, ha, ya, au\u27e9 : \u2203 a \u2208 countableBasis \u03b2, y2 \u2208 a \u2227 a \u2286 v :=\n          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis \u03b2) yv v_open\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]\n        exact \u27e8a, \u27e8u, u_open, yu, (Set.prod_mono_right au).trans huv\u27e9, ha, ya\u27e9\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy\n        rcases hy with \u27e8a, \u27e8b, -, yb, hb\u27e9, -, ya\u27e9\n        exact hb (mem_prod.2 \u27e8yb, ya\u27e9)\n    rw [this]\n    apply MeasurableSet.biUnion (countable_countableBasis \u03b2) (fun a ha \u21a6 ?_)\n    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet\n\nvariable {\u03b1' : Type*} [TopologicalSpace \u03b1'] [MeasurableSpace \u03b1']\n\ntheorem interior_ae_eq_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    interior s =\u1d50[\u03bc] s :=\n  interior_subset.eventuallyLE.antisymm <| subset_closure.eventuallyLE.trans (ae_le_set.2 h)\n#align interior_ae_eq_of_null_frontier interior_ae_eq_of_null_frontier\n\ntheorem measure_interior_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    \u03bc (interior s) = \u03bc s :=\n  measure_congr (interior_ae_eq_of_null_frontier h)\n#align measure_interior_of_null_frontier measure_interior_of_null_frontier\n\ntheorem nullMeasurableSet_of_null_frontier {s : Set \u03b1} {\u03bc : Measure \u03b1} (h : \u03bc (frontier s) = 0) :\n    NullMeasurableSet s \u03bc :=\n  \u27e8interior s, isOpen_interior.measurableSet, (interior_ae_eq_of_null_frontier h).symm\u27e9\n#align null_measurable_set_of_null_frontier nullMeasurableSet_of_null_frontier\n\ntheorem closure_ae_eq_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    closure s =\u1d50[\u03bc] s :=\n  ((ae_le_set.2 h).trans interior_subset.eventuallyLE).antisymm <| subset_closure.eventuallyLE\n#align closure_ae_eq_of_null_frontier closure_ae_eq_of_null_frontier\n\ntheorem measure_closure_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    \u03bc (closure s) = \u03bc s :=\n  measure_congr (closure_ae_eq_of_null_frontier h)\n#align measure_closure_of_null_frontier measure_closure_of_null_frontier\n\nsection Preorder\n\nvariable [Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1}\n\n@[simp, measurability]\ntheorem measurableSet_Ici : MeasurableSet (Ici a) :=\n  isClosed_Ici.measurableSet\n#align measurable_set_Ici measurableSet_Ici\n\n@[simp, measurability]\ntheorem measurableSet_Iic : MeasurableSet (Iic a) :=\n  isClosed_Iic.measurableSet\n#align measurable_set_Iic measurableSet_Iic\n\n@[simp, measurability]\ntheorem measurableSet_Icc : MeasurableSet (Icc a b) :=\n  isClosed_Icc.measurableSet\n#align measurable_set_Icc measurableSet_Icc\n\ninstance nhdsWithin_Ici_isMeasurablyGenerated : (\ud835\udcdd[Ici b] a).IsMeasurablyGenerated :=\n  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _\n#align nhds_within_Ici_is_measurably_generated nhdsWithin_Ici_isMeasurablyGenerated\n\ninstance nhdsWithin_Iic_isMeasurablyGenerated : (\ud835\udcdd[Iic b] a).IsMeasurablyGenerated :=\n  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _\n#align nhds_within_Iic_is_measurably_generated nhdsWithin_Iic_isMeasurablyGenerated\n\ninstance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (\ud835\udcdd[Icc a b] x) := by\n  rw [\u2190 Ici_inter_Iic, nhdsWithin_inter]\n  infer_instance\n#align nhds_within_Icc_is_measurably_generated nhdsWithin_Icc_isMeasurablyGenerated\n\ninstance atTop_isMeasurablyGenerated : (Filter.atTop : Filter \u03b1).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated\n#align at_top_is_measurably_generated atTop_isMeasurablyGenerated\n\ninstance atBot_isMeasurablyGenerated : (Filter.atBot : Filter \u03b1).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated\n#align at_bot_is_measurably_generated atBot_isMeasurablyGenerated\n\ninstance [R1Space \u03b1] : IsMeasurablyGenerated (cocompact \u03b1) where\n  exists_measurable_subset := by\n    intro _ hs\n    obtain \u27e8t, ht, hts\u27e9 := mem_cocompact.mp hs\n    exact \u27e8(closure t)\u1d9c, ht.closure.compl_mem_cocompact, isClosed_closure.measurableSet.compl,\n      (compl_subset_compl.2 subset_closure).trans hts\u27e9\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}\n\n@[measurability]\ntheorem measurableSet_le' : MeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 \u2264 p.2 } :=\n  OrderClosedTopology.isClosed_le'.measurableSet\n#align measurable_set_le' measurableSet_le'\n\n@[measurability]\ntheorem measurableSet_le {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    MeasurableSet { a | f a \u2264 g a } :=\n  hf.prod_mk hg measurableSet_le'\n#align measurable_set_le measurableSet_le\n\nend PartialOrder\n\nsection LinearOrder\n\nvariable [LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1}\n\n-- we open this locale only here to avoid issues with list being treated as intervals above\nopen Interval\n\n@[simp, measurability]\ntheorem measurableSet_Iio : MeasurableSet (Iio a) :=\n  isOpen_Iio.measurableSet\n#align measurable_set_Iio measurableSet_Iio\n\n@[simp, measurability]\ntheorem measurableSet_Ioi : MeasurableSet (Ioi a) :=\n  isOpen_Ioi.measurableSet\n#align measurable_set_Ioi measurableSet_Ioi\n\n@[simp, measurability]\ntheorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=\n  isOpen_Ioo.measurableSet\n#align measurable_set_Ioo measurableSet_Ioo\n\n@[simp, measurability]\ntheorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=\n  measurableSet_Ioi.inter measurableSet_Iic\n#align measurable_set_Ioc measurableSet_Ioc\n\n@[simp, measurability]\ntheorem measurableSet_Ico : MeasurableSet (Ico a b) :=\n  measurableSet_Ici.inter measurableSet_Iio\n#align measurable_set_Ico measurableSet_Ico\n\ninstance nhdsWithin_Ioi_isMeasurablyGenerated : (\ud835\udcdd[Ioi b] a).IsMeasurablyGenerated :=\n  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _\n#align nhds_within_Ioi_is_measurably_generated nhdsWithin_Ioi_isMeasurablyGenerated\n\ninstance nhdsWithin_Iio_isMeasurablyGenerated : (\ud835\udcdd[Iio b] a).IsMeasurablyGenerated :=\n  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _\n#align nhds_within_Iio_is_measurably_generated nhdsWithin_Iio_isMeasurablyGenerated\n\ninstance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (\ud835\udcdd[[[a, b]]] x) :=\n  nhdsWithin_Icc_isMeasurablyGenerated\n#align nhds_within_uIcc_is_measurably_generated nhdsWithin_uIcc_isMeasurablyGenerated\n\n@[measurability]\ntheorem measurableSet_lt' [SecondCountableTopology \u03b1] : MeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 } :=\n  (isOpen_lt continuous_fst continuous_snd).measurableSet\n#align measurable_set_lt' measurableSet_lt'\n\n@[measurability]\ntheorem measurableSet_lt [SecondCountableTopology \u03b1] {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=\n  hf.prod_mk hg measurableSet_lt'\n#align measurable_set_lt measurableSet_lt\n\ntheorem nullMeasurableSet_lt [SecondCountableTopology \u03b1] {\u03bc : Measure \u03b4} {f g : \u03b4 \u2192 \u03b1}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) : NullMeasurableSet { a | f a < g a } \u03bc :=\n  (hf.prod_mk hg).nullMeasurable measurableSet_lt'\n#align null_measurable_set_lt nullMeasurableSet_lt\n\ntheorem nullMeasurableSet_lt' [SecondCountableTopology \u03b1] {\u03bc : Measure (\u03b1 \u00d7 \u03b1)} :\n    NullMeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 } \u03bc :=\n  measurableSet_lt'.nullMeasurableSet\n\ntheorem nullMeasurableSet_le [SecondCountableTopology \u03b1] {\u03bc : Measure \u03b4}\n    {f g : \u03b4 \u2192 \u03b1} (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    NullMeasurableSet { a | f a \u2264 g a } \u03bc :=\n  (hf.prod_mk hg).nullMeasurable measurableSet_le'\n\ntheorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by\n  let u := \u22c3 (x \u2208 s) (y \u2208 s), Ioo x y\n  have huopen : IsOpen u := isOpen_biUnion fun _ _ => isOpen_biUnion fun _ _ => isOpen_Ioo\n  have humeas : MeasurableSet u := huopen.measurableSet\n  have hfinite : (s \\ u).Finite := s.finite_diff_iUnion_Ioo\n  have : u \u2286 s := iUnion\u2082_subset fun x hx => iUnion\u2082_subset fun y hy =>\n    Ioo_subset_Icc_self.trans (h.out hx hy)\n  rw [\u2190 union_diff_cancel this]\n  exact humeas.union hfinite.measurableSet\n#align set.ord_connected.measurable_set Set.OrdConnected.measurableSet\n\ntheorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=\n  h.ordConnected.measurableSet\n#align is_preconnected.measurable_set IsPreconnected.measurableSet\n\ntheorem generateFrom_Ico_mem_le_borel {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderClosedTopology \u03b1] (s t : Set \u03b1) :\n    MeasurableSpace.generateFrom { S | \u2203 l \u2208 s, \u2203 u \u2208 t, l < u \u2227 Ico l u = S }\n      \u2264 borel \u03b1 := by\n  apply generateFrom_le\n  borelize \u03b1\n  rintro _ \u27e8a, -, b, -, -, rfl\u27e9\n  exact measurableSet_Ico\n#align generate_from_Ico_mem_le_borel generateFrom_Ico_mem_le_borel\n\ntheorem Dense.borel_eq_generateFrom_Ico_mem_aux {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] {s : Set \u03b1} (hd : Dense s)\n    (hbot : \u2200 x, IsBot x \u2192 x \u2208 s) (hIoo : \u2200 x y : \u03b1, x < y \u2192 Ioo x y = \u2205 \u2192 y \u2208 s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ico l u = S } := by\n  set S : Set (Set \u03b1) := { S | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ico l u = S }\n  refine' le_antisymm _ (generateFrom_Ico_mem_le_borel _ _)\n  letI : MeasurableSpace \u03b1 := generateFrom S\n  rw [borel_eq_generateFrom_Iio]\n  refine' generateFrom_le (forall_mem_range.2 fun a => _)\n  rcases hd.exists_countable_dense_subset_bot_top with \u27e8t, hts, hc, htd, htb, -\u27e9\n  by_cases ha : \u2200 b < a, (Ioo b a).Nonempty\n  \u00b7 convert_to MeasurableSet (\u22c3 (l \u2208 t) (u \u2208 t) (_ : l < u) (_ : u \u2264 a), Ico l u)\n    \u00b7 ext y\n      simp only [mem_iUnion, mem_Iio, mem_Ico]\n      constructor\n      \u00b7 intro hy\n        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with \u27e8l, hlt, hly\u27e9\n        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with \u27e8u, hut, hyu, hua\u27e9\n        exact \u27e8l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu\u27e9\n      \u00b7 rintro \u27e8l, -, u, -, -, hua, -, hyu\u27e9\n        exact hyu.trans_le hua\n    \u00b7 refine' MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => _\n      refine' MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun _ => _\n      exact .basic _ \u27e8a, hts ha, b, hts hb, hab, mem_singleton _\u27e9\n  \u00b7 simp only [not_forall, not_nonempty_iff_eq_empty] at ha\n    replace ha : a \u2208 s := hIoo ha.choose a ha.choose_spec.fst ha.choose_spec.snd\n    convert_to MeasurableSet (\u22c3 (l \u2208 t) (_ : l < a), Ico l a)\n    \u00b7 symm\n      simp only [\u2190 Ici_inter_Iio, \u2190 iUnion_inter, inter_eq_right, subset_def, mem_iUnion,\n        mem_Ici, mem_Iio]\n      intro x hx\n      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with \u27e8z, hzt, hzx\u27e9\n      exact \u27e8z, hzt, hzx.trans_lt hx, hzx\u27e9\n    \u00b7 refine' .biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => _\n      exact .basic _ \u27e8x, hts hx, a, ha, hlt, mem_singleton _\u27e9\n#align dense.borel_eq_generate_from_Ico_mem_aux Dense.borel_eq_generateFrom_Ico_mem_aux\n\ntheorem Dense.borel_eq_generateFrom_Ico_mem {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] [DenselyOrdered \u03b1] [NoMinOrder \u03b1] {s : Set \u03b1}\n    (hd : Dense s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ico l u = S } :=\n  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun x y hxy H =>\n    ((nonempty_Ioo.2 hxy).ne_empty H).elim\n#align dense.borel_eq_generate_from_Ico_mem Dense.borel_eq_generateFrom_Ico_mem\n\ntheorem borel_eq_generateFrom_Ico (\u03b1 : Type*) [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [LinearOrder \u03b1] [OrderTopology \u03b1] :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 (l u : \u03b1), l < u \u2227 Ico l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and_iff] using\n    (@dense_univ \u03b1 _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n#align borel_eq_generate_from_Ico borel_eq_generateFrom_Ico\n\ntheorem Dense.borel_eq_generateFrom_Ioc_mem_aux {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] {s : Set \u03b1} (hd : Dense s)\n    (hbot : \u2200 x, IsTop x \u2192 x \u2208 s) (hIoo : \u2200 x y : \u03b1, x < y \u2192 Ioo x y = \u2205 \u2192 x \u2208 s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ioc l u = S } := by\n  convert hd.orderDual.borel_eq_generateFrom_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _\n    using 2\n  \u00b7 ext s\n    constructor <;> rintro \u27e8l, hl, u, hu, hlt, rfl\u27e9\n    exacts [\u27e8u, hu, l, hl, hlt, dual_Ico\u27e9, \u27e8u, hu, l, hl, hlt, dual_Ioc\u27e9]\n  \u00b7 erw [dual_Ioo]\n    exact he\n#align dense.borel_eq_generate_from_Ioc_mem_aux Dense.borel_eq_generateFrom_Ioc_mem_aux\n\ntheorem Dense.borel_eq_generateFrom_Ioc_mem {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] [DenselyOrdered \u03b1] [NoMaxOrder \u03b1] {s : Set \u03b1}\n    (hd : Dense s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ioc l u = S } :=\n  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun x y hxy H =>\n    ((nonempty_Ioo.2 hxy).ne_empty H).elim\n#align dense.borel_eq_generate_from_Ioc_mem Dense.borel_eq_generateFrom_Ioc_mem\n\ntheorem borel_eq_generateFrom_Ioc (\u03b1 : Type*) [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [LinearOrder \u03b1] [OrderTopology \u03b1] :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l u, l < u \u2227 Ioc l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and_iff] using\n    (@dense_univ \u03b1 _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n#align borel_eq_generate_from_Ioc borel_eq_generateFrom_Ioc\n\nnamespace MeasureTheory.Measure\n\n/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If\n`\u03b1` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `\u03bc` and\n`\u03bd`. -/\ntheorem ext_of_Ico_finite {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u03bc univ = \u03bd univ) (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) :\n    \u03bc = \u03bd := by\n  refine'\n    ext_of_generate_finite _ (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico \u03b1))\n      (isPiSystem_Ico (id : \u03b1 \u2192 \u03b1) id) _ h\u03bc\u03bd\n  \u00b7 rintro - \u27e8a, b, hlt, rfl\u27e9\n    exact h hlt\n#align measure_theory.measure.ext_of_Ico_finite MeasureTheory.Measure.ext_of_Ico_finite\n\n/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If\n`\u03b1` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ioc` is an extensionality lemma with weaker assumptions on `\u03bc` and\n`\u03bd`. -/\ntheorem ext_of_Ioc_finite {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u03bc univ = \u03bd univ) (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) :\n    \u03bc = \u03bd := by\n  refine' @ext_of_Ico_finite \u03b1\u1d52\u1d48 _ _ _ _ _ \u2039_\u203a \u03bc \u03bd _ h\u03bc\u03bd fun a b hab => _\n  erw [dual_Ico (\u03b1 := \u03b1)]\n  exact h hab\n#align measure_theory.measure.ext_of_Ioc_finite MeasureTheory.Measure.ext_of_Ioc_finite\n\n/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico' {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] [NoMaxOrder \u03b1]\n    (\u03bc \u03bd : Measure \u03b1) (h\u03bc : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) \u2260 \u221e)\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) : \u03bc = \u03bd := by\n  rcases exists_countable_dense_bot_top \u03b1 with \u27e8s, hsc, hsd, hsb, _\u27e9\n  have : (\u22c3 (l \u2208 s) (u \u2208 s) (_ : l < u), {Ico l u} : Set (Set \u03b1)).Countable :=\n    hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _\n  simp only [\u2190 setOf_eq_eq_singleton, \u2190 setOf_exists] at this\n  refine'\n    Measure.ext_of_generateFrom_of_cover_subset\n      (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico \u03b1)) (isPiSystem_Ico id id) _ this\n      _ _ _\n  \u00b7 rintro _ \u27e8l, -, u, -, h, rfl\u27e9\n    exact \u27e8l, u, h, rfl\u27e9\n  \u00b7 refine' sUnion_eq_univ_iff.2 fun x => _\n    rcases hsd.exists_le' hsb x with \u27e8l, hls, hlx\u27e9\n    rcases hsd.exists_gt x with \u27e8u, hus, hxu\u27e9\n    exact \u27e8_, \u27e8l, hls, u, hus, hlx.trans_lt hxu, rfl\u27e9, hlx, hxu\u27e9\n  \u00b7 rintro _ \u27e8l, -, u, -, hlt, rfl\u27e9\n    exact h\u03bc hlt\n  \u00b7 rintro _ \u27e8l, u, hlt, rfl\u27e9\n    exact h hlt\n#align measure_theory.measure.ext_of_Ico' MeasureTheory.Measure.ext_of_Ico'\n\n/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc' {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] [NoMinOrder \u03b1]\n    (\u03bc \u03bd : Measure \u03b1) (h\u03bc : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) \u2260 \u221e)\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) : \u03bc = \u03bd := by\n  refine' @ext_of_Ico' \u03b1\u1d52\u1d48 _ _ _ _ _ \u2039_\u203a _ \u03bc \u03bd _ _ <;> intro a b hab <;> erw [dual_Ico (\u03b1 := \u03b1)]\n  exacts [h\u03bc hab, h hab]\n#align measure_theory.measure.ext_of_Ioc' MeasureTheory.Measure.ext_of_Ioc'\n\n/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico {\u03b1 : Type*} [TopologicalSpace \u03b1] {_m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [BorelSpace \u03b1] [NoMaxOrder \u03b1] (\u03bc \u03bd : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc]\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) : \u03bc = \u03bd :=\n  \u03bc.ext_of_Ico' \u03bd (fun _ _ _ => measure_Ico_lt_top.ne) h\n#align measure_theory.measure.ext_of_Ico MeasureTheory.Measure.ext_of_Ico\n\n/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc {\u03b1 : Type*} [TopologicalSpace \u03b1] {_m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [BorelSpace \u03b1] [NoMinOrder \u03b1] (\u03bc \u03bd : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc]\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) : \u03bc = \u03bd :=\n  \u03bc.ext_of_Ioc' \u03bd (fun _ _ _ => measure_Ioc_lt_top.ne) h\n#align measure_theory.measure.ext_of_Ioc MeasureTheory.Measure.ext_of_Ioc\n\n/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed\nintervals. -/\ntheorem ext_of_Iic {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h : \u2200 a, \u03bc (Iic a) = \u03bd (Iic a)) : \u03bc = \u03bd := by\n  refine' ext_of_Ioc_finite \u03bc \u03bd _ fun a b hlt => _\n  \u00b7 rcases exists_countable_dense_bot_top \u03b1 with \u27e8s, hsc, hsd, -, hst\u27e9\n    have : DirectedOn (\u00b7 \u2264 \u00b7) s := directedOn_iff_directed.2 (Subtype.mono_coe _).directed_le\n    simp only [\u2190 biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]\n  rw [\u2190 Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic,\n    measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic, h a, h b]\n  \u00b7 rw [\u2190 h a]\n    exact (measure_lt_top \u03bc _).ne\n  \u00b7 exact (measure_lt_top \u03bc _).ne\n#align measure_theory.measure.ext_of_Iic MeasureTheory.Measure.ext_of_Iic\n\n/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite\nintervals. -/\ntheorem ext_of_Ici {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h : \u2200 a, \u03bc (Ici a) = \u03bd (Ici a)) : \u03bc = \u03bd :=\n  @ext_of_Iic \u03b1\u1d52\u1d48 _ _ _ _ _ \u2039_\u203a _ _ _ h\n#align measure_theory.measure.ext_of_Ici MeasureTheory.Measure.ext_of_Ici\n\nend MeasureTheory.Measure\n\nend LinearOrder\n\nsection LinearOrder\n\nvariable [LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b : \u03b1}\n\n@[measurability]\ntheorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=\n  measurableSet_Icc\n#align measurable_set_uIcc measurableSet_uIcc\n\n@[measurability]\ntheorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=\n  measurableSet_Ioc\n#align measurable_set_uIoc measurableSet_uIoc\n\nvariable [SecondCountableTopology \u03b1]\n\n@[measurability]\ntheorem Measurable.max {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => max (f a) (g a) := by\n  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg\n#align measurable.max Measurable.max\n\n@[measurability]\nnonrec theorem AEMeasurable.max {f g : \u03b4 \u2192 \u03b1} {\u03bc : Measure \u03b4} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => max (f a) (g a)) \u03bc :=\n  \u27e8fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,\n    EventuallyEq.comp\u2082 hf.ae_eq_mk _ hg.ae_eq_mk\u27e9\n#align ae_measurable.max AEMeasurable.max\n\n@[measurability]\ntheorem Measurable.min {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => min (f a) (g a) := by\n  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg\n#align measurable.min Measurable.min\n\n@[measurability]\nnonrec theorem AEMeasurable.min {f g : \u03b4 \u2192 \u03b1} {\u03bc : Measure \u03b4} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => min (f a) (g a)) \u03bc :=\n  \u27e8fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,\n    EventuallyEq.comp\u2082 hf.ae_eq_mk _ hg.ae_eq_mk\u27e9\n#align ae_measurable.min AEMeasurable.min\n\nend LinearOrder\n\n/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`\nis measurable. -/\ntheorem Continuous.measurable {f : \u03b1 \u2192 \u03b3} (hf : Continuous f) : Measurable f :=\n  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)\n#align continuous.measurable Continuous.measurable\n\n/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`\nis ae-measurable. -/\ntheorem Continuous.aemeasurable {f : \u03b1 \u2192 \u03b3} (h : Continuous f) {\u03bc : Measure \u03b1} : AEMeasurable f \u03bc :=\n  h.measurable.aemeasurable\n#align continuous.ae_measurable Continuous.aemeasurable\n\ntheorem ClosedEmbedding.measurable {f : \u03b1 \u2192 \u03b3} (hf : ClosedEmbedding f) : Measurable f :=\n  hf.continuous.measurable\n#align closed_embedding.measurable ClosedEmbedding.measurable\n\n/-- If a function is defined piecewise in terms of functions which are continuous on their\nrespective pieces, then it is measurable. -/\ntheorem ContinuousOn.measurable_piecewise {f g : \u03b1 \u2192 \u03b3} {s : Set \u03b1} [\u2200 j : \u03b1, Decidable (j \u2208 s)]\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s\u1d9c) (hs : MeasurableSet s) :\n    Measurable (s.piecewise f g) := by\n  refine' measurable_of_isOpen fun t ht => _\n  rw [piecewise_preimage, Set.ite]\n  apply MeasurableSet.union\n  \u00b7 rcases _root_.continuousOn_iff'.1 hf t ht with \u27e8u, u_open, hu\u27e9\n    rw [hu]\n    exact u_open.measurableSet.inter hs\n  \u00b7 rcases _root_.continuousOn_iff'.1 hg t ht with \u27e8u, u_open, hu\u27e9\n    rw [diff_eq_compl_inter, inter_comm, hu]\n    exact u_open.measurableSet.inter hs.compl\n#align continuous_on.measurable_piecewise ContinuousOn.measurable_piecewise\n\n@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul [Mul \u03b3] [ContinuousMul \u03b3] :\n    MeasurableMul \u03b3 where\n  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable\n  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable\n#align has_continuous_mul.has_measurable_mul ContinuousMul.measurableMul\n#align has_continuous_add.has_measurable_add ContinuousAdd.measurableAdd\n\ninstance (priority := 100) ContinuousSub.measurableSub [Sub \u03b3] [ContinuousSub \u03b3] :\n    MeasurableSub \u03b3 where\n  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable\n  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable\n#align has_continuous_sub.has_measurable_sub ContinuousSub.measurableSub\n\n@[to_additive]\ninstance (priority := 100) TopologicalGroup.measurableInv [Group \u03b3] [TopologicalGroup \u03b3] :\n    MeasurableInv \u03b3 :=\n  \u27e8continuous_inv.measurable\u27e9\n#align topological_group.has_measurable_inv TopologicalGroup.measurableInv\n#align topological_add_group.has_measurable_neg TopologicalAddGroup.measurableNeg\n\ninstance (priority := 100) ContinuousSMul.measurableSMul {M \u03b1} [TopologicalSpace M]\n    [TopologicalSpace \u03b1] [MeasurableSpace M] [MeasurableSpace \u03b1] [OpensMeasurableSpace M]\n    [BorelSpace \u03b1] [SMul M \u03b1] [ContinuousSMul M \u03b1] : MeasurableSMul M \u03b1 :=\n  \u27e8fun _ => (continuous_const_smul _).measurable, fun _ =>\n    (continuous_id.smul continuous_const).measurable\u27e9\n#align has_continuous_smul.has_measurable_smul ContinuousSMul.measurableSMul\n\nsection Lattice\n\ninstance (priority := 100) ContinuousSup.measurableSup [Sup \u03b3] [ContinuousSup \u03b3] :\n    MeasurableSup \u03b3 where\n  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable\n  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable\n#align has_continuous_sup.has_measurable_sup ContinuousSup.measurableSup\n\ninstance (priority := 100) ContinuousSup.measurableSup\u2082 [SecondCountableTopology \u03b3] [Sup \u03b3]\n    [ContinuousSup \u03b3] : MeasurableSup\u2082 \u03b3 :=\n  \u27e8continuous_sup.measurable\u27e9\n#align has_continuous_sup.has_measurable_sup\u2082 ContinuousSup.measurableSup\u2082\n\ninstance (priority := 100) ContinuousInf.measurableInf [Inf \u03b3] [ContinuousInf \u03b3] :\n    MeasurableInf \u03b3 where\n  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable\n  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable\n#align has_continuous_inf.has_measurable_inf ContinuousInf.measurableInf\n\ninstance (priority := 100) ContinuousInf.measurableInf\u2082 [SecondCountableTopology \u03b3] [Inf \u03b3]\n    [ContinuousInf \u03b3] : MeasurableInf\u2082 \u03b3 :=\n  \u27e8continuous_inf.measurable\u27e9\n#align has_continuous_inf.has_measurable_inf\u2082 ContinuousInf.measurableInf\u2082\n\nend Lattice\n\nsection Homeomorph\n\n@[measurability]\nprotected theorem Homeomorph.measurable (h : \u03b1 \u2243\u209c \u03b3) : Measurable h :=\n  h.continuous.measurable\n#align homeomorph.measurable Homeomorph.measurable\n\n/-- A homeomorphism between two Borel spaces is a measurable equivalence. -/\ndef Homeomorph.toMeasurableEquiv (h : \u03b3 \u2243\u209c \u03b3\u2082) : \u03b3 \u2243\u1d50 \u03b3\u2082 where\n  measurable_toFun := h.measurable\n  measurable_invFun := h.symm.measurable\n  toEquiv := h.toEquiv\n#align homeomorph.to_measurable_equiv Homeomorph.toMeasurableEquiv\n\nlemma Homeomorph.measurableEmbedding (h : \u03b3 \u2243\u209c \u03b3\u2082) : MeasurableEmbedding h :=\n  h.toMeasurableEquiv.measurableEmbedding\n\n@[simp]\ntheorem Homeomorph.toMeasurableEquiv_coe (h : \u03b3 \u2243\u209c \u03b3\u2082) : (h.toMeasurableEquiv : \u03b3 \u2192 \u03b3\u2082) = h :=\n  rfl\n#align homeomorph.to_measurable_equiv_coe Homeomorph.toMeasurableEquiv_coe\n\n@[simp]\ntheorem Homeomorph.toMeasurableEquiv_symm_coe (h : \u03b3 \u2243\u209c \u03b3\u2082) :\n    (h.toMeasurableEquiv.symm : \u03b3\u2082 \u2192 \u03b3) = h.symm :=\n  rfl\n#align homeomorph.to_measurable_equiv_symm_coe Homeomorph.toMeasurableEquiv_symm_coe\n\nend Homeomorph\n\n@[measurability]\ntheorem ContinuousMap.measurable (f : C(\u03b1, \u03b3)) : Measurable f :=\n  f.continuous.measurable\n#align continuous_map.measurable ContinuousMap.measurable\n\ntheorem measurable_of_continuousOn_compl_singleton [T1Space \u03b1] {f : \u03b1 \u2192 \u03b3} (a : \u03b1)\n    (hf : ContinuousOn f {a}\u1d9c) : Measurable f :=\n  measurable_of_measurable_on_compl_singleton a\n    (continuousOn_iff_continuous_restrict.1 hf).measurable\n#align measurable_of_continuous_on_compl_singleton measurable_of_continuousOn_compl_singleton\n\ntheorem Continuous.measurable2 [SecondCountableTopologyEither \u03b1 \u03b2] {f : \u03b4 \u2192 \u03b1}\n    {g : \u03b4 \u2192 \u03b2} {c : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (h : Continuous fun p : \u03b1 \u00d7 \u03b2 => c p.1 p.2) (hf : Measurable f)\n    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=\n  h.measurable.comp (hf.prod_mk hg)\n#align continuous.measurable2 Continuous.measurable2\n\ntheorem Continuous.aemeasurable2 [SecondCountableTopologyEither \u03b1 \u03b2]\n    {f : \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b2} {c : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {\u03bc : Measure \u03b4}\n    (h : Continuous fun p : \u03b1 \u00d7 \u03b2 => c p.1 p.2) (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun a => c (f a) (g a)) \u03bc :=\n  h.measurable.comp_aemeasurable (hf.prod_mk hg)\n#align continuous.ae_measurable2 Continuous.aemeasurable2\n\ninstance (priority := 100) HasContinuousInv\u2080.measurableInv [GroupWithZero \u03b3] [T1Space \u03b3]\n    [HasContinuousInv\u2080 \u03b3] : MeasurableInv \u03b3 :=\n  \u27e8measurable_of_continuousOn_compl_singleton 0 continuousOn_inv\u2080\u27e9\n#align has_continuous_inv\u2080.has_measurable_inv HasContinuousInv\u2080.measurableInv\n\n@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul\u2082 [SecondCountableTopology \u03b3] [Mul \u03b3]\n    [ContinuousMul \u03b3] : MeasurableMul\u2082 \u03b3 :=\n  \u27e8continuous_mul.measurable\u27e9\n#align has_continuous_mul.has_measurable_mul\u2082 ContinuousMul.measurableMul\u2082\n#align has_continuous_add.has_measurable_mul\u2082 ContinuousAdd.measurableMul\u2082\n\ninstance (priority := 100) ContinuousSub.measurableSub\u2082 [SecondCountableTopology \u03b3] [Sub \u03b3]\n    [ContinuousSub \u03b3] : MeasurableSub\u2082 \u03b3 :=\n  \u27e8continuous_sub.measurable\u27e9\n#align has_continuous_sub.has_measurable_sub\u2082 ContinuousSub.measurableSub\u2082\n\ninstance (priority := 100) ContinuousSMul.measurableSMul\u2082 {M \u03b1} [TopologicalSpace M]\n    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace \u03b1]\n    [SecondCountableTopologyEither M \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1] [SMul M \u03b1]\n    [ContinuousSMul M \u03b1] : MeasurableSMul\u2082 M \u03b1 :=\n  \u27e8continuous_smul.measurable\u27e9\n#align has_continuous_smul.has_measurable_smul\u2082 ContinuousSMul.measurableSMul\u2082\n\nend\n\nsection BorelSpace\n\nvariable [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1] [TopologicalSpace \u03b2]\n  [MeasurableSpace \u03b2] [BorelSpace \u03b2] [TopologicalSpace \u03b3] [MeasurableSpace \u03b3] [BorelSpace \u03b3]\n  [MeasurableSpace \u03b4]\n\ntheorem pi_le_borel_pi {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    [\u2200 i, MeasurableSpace (\u03c0 i)] [\u2200 i, BorelSpace (\u03c0 i)] :\n      MeasurableSpace.pi \u2264 borel (\u2200 i, \u03c0 i) := by\n  have : \u2039\u2200 i, MeasurableSpace (\u03c0 i)\u203a = fun i => borel (\u03c0 i) :=\n    funext fun i => BorelSpace.measurable_eq\n  rw [this]\n  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable\n#align pi_le_borel_pi pi_le_borel_pi\n\ntheorem prod_le_borel_prod : Prod.instMeasurableSpace \u2264 borel (\u03b1 \u00d7 \u03b2) := by\n  rw [\u2039BorelSpace \u03b1\u203a.measurable_eq, \u2039BorelSpace \u03b2\u203a.measurable_eq]\n  refine' sup_le _ _\n  \u00b7 exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable\n  \u00b7 exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable\n#align prod_le_borel_prod prod_le_borel_prod\n\ninstance Pi.borelSpace {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [Countable \u03b9] [\u2200 i, TopologicalSpace (\u03c0 i)]\n    [\u2200 i, MeasurableSpace (\u03c0 i)] [\u2200 i, SecondCountableTopology (\u03c0 i)] [\u2200 i, BorelSpace (\u03c0 i)] :\n    BorelSpace (\u2200 i, \u03c0 i) :=\n  \u27e8le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le\u27e9\n#align pi.borel_space Pi.borelSpace\n\ninstance Prod.borelSpace [SecondCountableTopologyEither \u03b1 \u03b2] :\n    BorelSpace (\u03b1 \u00d7 \u03b2) :=\n  \u27e8le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le\u27e9\n#align prod.borel_space Prod.borelSpace\n\n/-- Given a measurable embedding to a Borel space which is also a topological embedding, then the\nsource space is also a Borel space. -/\nlemma MeasurableEmbedding.borelSpace {\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b2] [TopologicalSpace \u03b2] [h\u03b2 : BorelSpace \u03b2] {e : \u03b1 \u2192 \u03b2}\n    (h'e : MeasurableEmbedding e) (h''e : Inducing e) :\n    BorelSpace \u03b1 := by\n  constructor\n  have : MeasurableSpace.comap e (borel \u03b2) = \u2039_\u203a := by simpa [h\u03b2.measurable_eq] using h'e.comap_eq\n  rw [\u2190 this, \u2190 borel_comap, h''e.induced]\n\ninstance _root_.ULift.instBorelSpace : BorelSpace (ULift \u03b1) :=\n  MeasurableEquiv.ulift.measurableEmbedding.borelSpace Homeomorph.ulift.inducing\n\ninstance DiscreteMeasurableSpace.toBorelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [DiscreteTopology \u03b1]\n    [MeasurableSpace \u03b1] [DiscreteMeasurableSpace \u03b1] : BorelSpace \u03b1 := by\n  constructor; ext; simp [MeasurableSpace.measurableSet_generateFrom, measurableSet_discrete]\n\nprotected theorem Embedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h\u2081 : Embedding f)\n    (h\u2082 : MeasurableSet (range f)) : MeasurableEmbedding f :=\n  show MeasurableEmbedding\n      (((\u2191) : range f \u2192 \u03b2) \u2218 (Homeomorph.ofEmbedding f h\u2081).toMeasurableEquiv) from\n    (MeasurableEmbedding.subtype_coe h\u2082).comp (MeasurableEquiv.measurableEmbedding _)\n#align embedding.measurable_embedding Embedding.measurableEmbedding\n\nprotected theorem ClosedEmbedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h : ClosedEmbedding f) :\n    MeasurableEmbedding f :=\n  h.toEmbedding.measurableEmbedding h.isClosed_range.measurableSet\n#align closed_embedding.measurable_embedding ClosedEmbedding.measurableEmbedding\n\nprotected theorem OpenEmbedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h : OpenEmbedding f) :\n    MeasurableEmbedding f :=\n  h.toEmbedding.measurableEmbedding h.isOpen_range.measurableSet\n#align open_embedding.measurable_embedding OpenEmbedding.measurableEmbedding\n\nsection LinearOrder\n\nvariable [LinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]\n\ntheorem measurable_of_Iio {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iio x)) : Measurable f := by\n  convert measurable_generateFrom (\u03b1 := \u03b4) _\n  \u00b7 exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)\n  \u00b7 rintro _ \u27e8x, rfl\u27e9; exact hf x\n#align measurable_of_Iio measurable_of_Iio\n\ntheorem UpperSemicontinuous.measurable [TopologicalSpace \u03b4] [OpensMeasurableSpace \u03b4] {f : \u03b4 \u2192 \u03b1}\n    (hf : UpperSemicontinuous f) : Measurable f :=\n  measurable_of_Iio fun y => (hf.isOpen_preimage y).measurableSet\n#align upper_semicontinuous.measurable UpperSemicontinuous.measurable\n\ntheorem measurable_of_Ioi {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Ioi x)) : Measurable f := by\n  convert measurable_generateFrom (\u03b1 := \u03b4) _\n  \u00b7 exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)\n  \u00b7 rintro _ \u27e8x, rfl\u27e9; exact hf x\n#align measurable_of_Ioi measurable_of_Ioi\n\ntheorem LowerSemicontinuous.measurable [TopologicalSpace \u03b4] [OpensMeasurableSpace \u03b4] {f : \u03b4 \u2192 \u03b1}\n    (hf : LowerSemicontinuous f) : Measurable f :=\n  measurable_of_Ioi fun y => (hf.isOpen_preimage y).measurableSet\n#align lower_semicontinuous.measurable LowerSemicontinuous.measurable\n\ntheorem measurable_of_Iic {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iic x)) : Measurable f := by\n  apply measurable_of_Ioi\n  simp_rw [\u2190 compl_Iic, preimage_compl, MeasurableSet.compl_iff]\n  assumption\n#align measurable_of_Iic measurable_of_Iic\n\ntheorem measurable_of_Ici {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Ici x)) : Measurable f := by\n  apply measurable_of_Iio\n  simp_rw [\u2190 compl_Ici, preimage_compl, MeasurableSet.compl_iff]\n  assumption\n#align measurable_of_Ici measurable_of_Ici\n\n/-- If a function is the least upper bound of countably many measurable functions,\nthen it is measurable. -/\ntheorem Measurable.isLUB {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i))\n    (hg : \u2200 b, IsLUB { a | \u2203 i, f i b = a } (g b)) : Measurable g := by\n  change \u2200 b, IsLUB (range fun i => f i b) (g b) at hg\n  rw [\u2039BorelSpace \u03b1\u203a.measurable_eq, borel_eq_generateFrom_Ioi \u03b1]\n  apply measurable_generateFrom\n  rintro _ \u27e8a, rfl\u27e9\n  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, setOf_exists]\n  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).measurableSet\n#align measurable.is_lub Measurable.isLUB\n\n/-- If a function is the least upper bound of countably many measurable functions on a measurable\nset `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/\ntheorem Measurable.isLUB_of_mem {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g g' : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, Measurable (f i))\n    {s : Set \u03b4} (hs : MeasurableSet s) (hg : \u2200 b \u2208 s, IsLUB { a | \u2203 i, f i b = a } (g b))\n    (hg' : EqOn g g' s\u1d9c) (g'_meas : Measurable g') : Measurable g := by\n  rcases isEmpty_or_nonempty \u03b9 with h\u03b9|\u27e8\u27e8i\u27e9\u27e9\n  \u00b7 rcases eq_empty_or_nonempty s with rfl|\u27e8x, hx\u27e9\n    \u00b7 convert g'_meas\n      rwa [compl_empty, eqOn_univ] at hg'\n    \u00b7 have A : \u2200 b \u2208 s, IsBot (g b) := by simpa using hg\n      have B : \u2200 b \u2208 s, g b = g x := by\n        intro b hb\n        apply le_antisymm (A b hb (g x)) (A x hx (g b))\n      have : g = s.piecewise (fun _y \u21a6 g x) g' := by\n        ext b\n        by_cases hb : b \u2208 s\n        \u00b7 simp [hb, B]\n        \u00b7 simp [hb, hg' hb]\n      rw [this]\n      exact Measurable.piecewise hs measurable_const g'_meas\n  \u00b7 let f' : \u03b9 \u2192 \u03b4 \u2192 \u03b1 := fun i \u21a6 s.piecewise (f i) g'\n    suffices \u2200 b, IsLUB { a | \u2203 i, f' i b = a } (g b) from\n      Measurable.isLUB (fun i \u21a6 Measurable.piecewise hs (hf i) g'_meas) this\n    intro b\n    by_cases hb : b \u2208 s\n    \u00b7 have A : \u2200 i, f' i b = f i b := fun i \u21a6 by simp [f', hb]\n      simpa [A] using hg b hb\n    \u00b7 have A : \u2200 i, f' i b = g' b := fun i \u21a6 by simp [f', hb]\n      have : {a | \u2203 (_i : \u03b9), g' b = a} = {g' b} := by\n        apply Subset.antisymm\n        \u00b7 rintro - \u27e8_j, rfl\u27e9\n          simp only [mem_singleton_iff]\n        \u00b7 rintro - rfl\n          exact \u27e8i, rfl\u27e9\n      simp [A, this, hg' hb, isLUB_singleton]\n\ntheorem AEMeasurable.isLUB {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) (hg : \u2200\u1d50 b \u2202\u03bc, IsLUB { a | \u2203 i, f i b = a } (g b)) :\n    AEMeasurable g \u03bc := by\n  nontriviality \u03b1\n  haveI h\u03b1 : Nonempty \u03b1 := inferInstance\n  cases' isEmpty_or_nonempty \u03b9 with h\u03b9 h\u03b9\n  \u00b7 simp only [IsEmpty.exists_iff, setOf_false, isLUB_empty_iff] at hg\n    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (ha _).antisymm (hb _))\n  let p : \u03b4 \u2192 (\u03b9 \u2192 \u03b1) \u2192 Prop := fun x f' => IsLUB { a | \u2203 i, f' i = a } (g x)\n  let g_seq := (aeSeqSet hf p).piecewise g fun _ => h\u03b1.some\n  have hg_seq : \u2200 b, IsLUB { a | \u2203 i, aeSeq hf p i b = a } (g_seq b) := by\n    intro b\n    simp only [g_seq, aeSeq, Set.piecewise]\n    split_ifs with h\n    \u00b7 have h_set_eq : { a : \u03b1 | \u2203 i : \u03b9, (hf i).mk (f i) b = a } =\n        { a : \u03b1 | \u2203 i : \u03b9, f i b = a } := by\n        ext x\n        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]\n      rw [h_set_eq]\n      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h\n    \u00b7 exact IsGreatest.isLUB \u27e8(@exists_const (h\u03b1.some = h\u03b1.some) \u03b9 _).2 rfl, fun x \u27e8i, hi\u27e9 => hi.ge\u27e9\n  refine' \u27e8g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, _\u27e9\n  exact\n    (ite_ae_eq_of_measure_compl_zero g (fun _ => h\u03b1.some) (aeSeqSet hf p)\n        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm\n#align ae_measurable.is_lub AEMeasurable.isLUB\n\n/-- If a function is the greatest lower bound of countably many measurable functions,\nthen it is measurable. -/\ntheorem Measurable.isGLB {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i))\n    (hg : \u2200 b, IsGLB { a | \u2203 i, f i b = a } (g b)) : Measurable g :=\n  Measurable.isLUB (\u03b1 := \u03b1\u1d52\u1d48) hf hg\n#align measurable.is_glb Measurable.isGLB\n\n/-- If a function is the greatest lower bound of countably many measurable functions on a measurable\nset `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/\ntheorem Measurable.isGLB_of_mem {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g g' : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, Measurable (f i))\n    {s : Set \u03b4} (hs : MeasurableSet s) (hg : \u2200 b \u2208 s, IsGLB { a | \u2203 i, f i b = a } (g b))\n    (hg' : EqOn g g' s\u1d9c) (g'_meas : Measurable g') : Measurable g :=\n  Measurable.isLUB_of_mem (\u03b1 := \u03b1\u1d52\u1d48) hf hs hg hg'  g'_meas\n\ntheorem AEMeasurable.isGLB {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) (hg : \u2200\u1d50 b \u2202\u03bc, IsGLB { a | \u2203 i, f i b = a } (g b)) :\n    AEMeasurable g \u03bc :=\n  AEMeasurable.isLUB (\u03b1 := \u03b1\u1d52\u1d48) hf hg\n#align ae_measurable.is_glb AEMeasurable.isGLB\n\nprotected theorem Monotone.measurable [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Monotone f) : Measurable f :=\n  suffices h : \u2200 x, OrdConnected (f \u207b\u00b9' Ioi x) from measurable_of_Ioi fun x => (h x).measurableSet\n  fun _ => ordConnected_def.mpr fun _a ha _ _ _c hc => lt_of_lt_of_le ha (hf hc.1)\n#align monotone.measurable Monotone.measurable\n\ntheorem aemeasurable_restrict_of_monotoneOn [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {\u03bc : Measure \u03b2}\n    {s : Set \u03b2} (hs : MeasurableSet s) {f : \u03b2 \u2192 \u03b1} (hf : MonotoneOn f s) :\n    AEMeasurable f (\u03bc.restrict s) :=\n  have : Monotone (f \u2218 (\u2191) : s \u2192 \u03b1) := fun \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 => fun (hxy : x \u2264 y) => hf hx hy hxy\n  aemeasurable_restrict_of_measurable_subtype hs this.measurable\n#align ae_measurable_restrict_of_monotone_on aemeasurable_restrict_of_monotoneOn\n\nprotected theorem Antitone.measurable [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Antitone f) : Measurable f :=\n  @Monotone.measurable \u03b1\u1d52\u1d48 \u03b2 _ _ \u2039_\u203a _ _ _ _ _ \u2039_\u203a _ _ _ hf\n#align antitone.measurable Antitone.measurable\n\ntheorem aemeasurable_restrict_of_antitoneOn [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {\u03bc : Measure \u03b2}\n    {s : Set \u03b2} (hs : MeasurableSet s) {f : \u03b2 \u2192 \u03b1} (hf : AntitoneOn f s) :\n    AEMeasurable f (\u03bc.restrict s) :=\n  @aemeasurable_restrict_of_monotoneOn \u03b1\u1d52\u1d48 \u03b2 _ _ \u2039_\u203a _ _ _ _ _ \u2039_\u203a _ _ _ _ hs _ hf\n#align ae_measurable_restrict_of_antitone_on aemeasurable_restrict_of_antitoneOn\n\ntheorem measurableSet_of_mem_nhdsWithin_Ioi_aux {s : Set \u03b1} (h : \u2200 x \u2208 s, s \u2208 \ud835\udcdd[>] x)\n    (h' : \u2200 x \u2208 s, \u2203 y, x < y) : MeasurableSet s := by\n  choose! M hM using h'\n  suffices H : (s \\ interior s).Countable by\n    have : s = interior s \u222a s \\ interior s := by rw [union_diff_cancel interior_subset]\n    rw [this]\n    exact isOpen_interior.measurableSet.union H.measurableSet\n  have A : \u2200 x \u2208 s, \u2203 y \u2208 Ioi x, Ioo x y \u2286 s := fun x hx =>\n    (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)\n  choose! y hy h'y using A\n  have B : Set.PairwiseDisjoint (s \\ interior s) fun x => Ioo x (y x) := by\n    intro x hx x' hx' hxx'\n    rcases lt_or_gt_of_ne hxx' with (h' | h')\n    \u00b7 refine disjoint_left.2 fun z hz h'z => ?_\n      have : x' \u2208 interior s :=\n        mem_interior.2 \u27e8Ioo x (y x), h'y _ hx.1, isOpen_Ioo, \u27e8h', h'z.1.trans hz.2\u27e9\u27e9\n      exact False.elim (hx'.2 this)\n    \u00b7 refine disjoint_left.2 fun z hz h'z => ?_\n      have : x \u2208 interior s :=\n        mem_interior.2 \u27e8Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, \u27e8h', hz.1.trans h'z.2\u27e9\u27e9\n      exact False.elim (hx.2 this)\n  exact B.countable_of_Ioo fun x hx => hy x hx.1\n#align measurable_set_of_mem_nhds_within_Ioi_aux measurableSet_of_mem_nhdsWithin_Ioi_aux\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem measurableSet_of_mem_nhdsWithin_Ioi {s : Set \u03b1} (h : \u2200 x \u2208 s, s \u2208 \ud835\udcdd[>] x) :\n    MeasurableSet s := by\n  by_cases H : \u2203 x \u2208 s, IsTop x\n  \u00b7 rcases H with \u27e8x\u2080, x\u2080s, h\u2080\u27e9\n    have : s = {x\u2080} \u222a s \\ {x\u2080} := by rw [union_diff_cancel (singleton_subset_iff.2 x\u2080s)]\n    rw [this]\n    refine' (measurableSet_singleton _).union _\n    have A : \u2200 x \u2208 s \\ {x\u2080}, x < x\u2080 := fun x hx => lt_of_le_of_ne (h\u2080 _) (by simpa using hx.2)\n    refine' measurableSet_of_mem_nhdsWithin_Ioi_aux (fun x hx => _) fun x hx => \u27e8x\u2080, A x hx\u27e9\n    obtain \u27e8u, hu, us\u27e9 : \u2203 (u : \u03b1), u \u2208 Ioi x \u2227 Ioo x u \u2286 s :=\n      (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)\n    refine' (mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' (A x hx)).2 \u27e8u, hu, fun y hy => \u27e8us hy, _\u27e9\u27e9\n    exact ne_of_lt (hy.2.trans_le (h\u2080 _))\n  \u00b7 apply measurableSet_of_mem_nhdsWithin_Ioi_aux h\n    simp only [IsTop] at H\n    push_neg at H\n    exact H\n#align measurable_set_of_mem_nhds_within_Ioi measurableSet_of_mem_nhdsWithin_Ioi\n\nlemma measurableSet_bddAbove_range {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    MeasurableSet {b | BddAbove (range (fun i \u21a6 f i b))} := by\n  rcases isEmpty_or_nonempty \u03b1 with h\u03b1|h\u03b1\n  \u00b7 have : \u2200 b, range (fun i \u21a6 f i b) = \u2205 := fun b \u21a6 eq_empty_of_isEmpty _\n    simp [this]\n  have A : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c} := by\n    intro i c\n    exact measurableSet_le (hf i) measurable_const\n  have B : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 i, f i x \u2264 c} := by\n    intro c\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun i \u21a6 A i c)\n  obtain \u27e8u, hu\u27e9 : \u2203 (u : \u2115 \u2192 \u03b1), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter \u03b1)\n  have : {b | BddAbove (range (fun i \u21a6 f i b))} = {x | \u2203 n, \u2200 i, f i x \u2264 u n} := by\n    apply Subset.antisymm\n    \u00b7 rintro x \u27e8c, hc\u27e9\n      obtain \u27e8n, hn\u27e9 : \u2203 n, c \u2264 u n := (tendsto_atTop.1 hu c).exists\n      exact \u27e8n, fun i \u21a6 (hc ((mem_range_self i))).trans hn\u27e9\n    \u00b7 rintro x \u27e8n, hn\u27e9\n      refine \u27e8u n, ?_\u27e9\n      rintro - \u27e8i, rfl\u27e9\n      exact hn i\n  rw [this, setOf_exists]\n  exact MeasurableSet.iUnion (fun n \u21a6 B (u n))\n\nlemma measurableSet_bddBelow_range {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    MeasurableSet {b | BddBelow (range (fun i \u21a6 f i b))} :=\n  measurableSet_bddAbove_range (\u03b1 := \u03b1\u1d52\u1d48) hf\n\nend LinearOrder\n\n@[measurability]\ntheorem Measurable.iSup_Prop {\u03b1} [MeasurableSpace \u03b1] [ConditionallyCompleteLattice \u03b1]\n    (p : Prop) {f : \u03b4 \u2192 \u03b1} (hf : Measurable f) : Measurable fun b => \u2a06 _ : p, f b := by\n  simp_rw [ciSup_eq_ite]\n  split_ifs with h\n  \u00b7 exact hf\n  \u00b7 exact measurable_const\n#align measurable.supr_Prop Measurable.iSup_Prop\n\n@[measurability]\ntheorem Measurable.iInf_Prop {\u03b1} [MeasurableSpace \u03b1] [ConditionallyCompleteLattice \u03b1]\n    (p : Prop) {f : \u03b4 \u2192 \u03b1} (hf : Measurable f) : Measurable fun b => \u2a05 _ : p, f b := by\n  simp_rw [ciInf_eq_ite]\n  split_ifs with h\n  \u00b7 exact hf\n  \u00b7 exact measurable_const\n#align measurable.infi_Prop Measurable.iInf_Prop\n\nsection ConditionallyCompleteLinearOrder\n\nvariable [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]\n\n@[measurability]\ntheorem measurable_iSup {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable (fun b \u21a6 \u2a06 i, f i b) := by\n  rcases isEmpty_or_nonempty \u03b9 with h\u03b9|h\u03b9\n  \u00b7 simp [iSup_of_empty']\n  have A : MeasurableSet {b | BddAbove (range (fun i \u21a6 f i b))} :=\n    measurableSet_bddAbove_range hf\n  have : Measurable (fun (_b : \u03b4) \u21a6 sSup (\u2205 : Set \u03b1)) := measurable_const\n  apply Measurable.isLUB_of_mem hf A _ _ this\n  \u00b7 rintro b \u27e8c, hc\u27e9\n    apply isLUB_ciSup\n    refine \u27e8c, ?_\u27e9\n    rintro d \u27e8i, rfl\u27e9\n    exact hc (mem_range_self i)\n  \u00b7 intro b hb\n    apply csSup_of_not_bddAbove\n    exact hb\n\n@[measurability]\ntheorem aemeasurable_iSup {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a06 i, f i b) \u03bc := by\n  refine \u27e8fun b \u21a6 \u2a06 i, (hf i).mk (f i) b, measurable_iSup (fun i \u21a6 (hf i).measurable_mk), ?_\u27e9\n  filter_upwards [ae_all_iff.2 (fun i \u21a6 (hf i).ae_eq_mk)] with b hb using by simp [hb]\n#align ae_measurable_supr aemeasurable_iSup\n\n@[measurability]\ntheorem measurable_iInf {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun b => \u2a05 i, f i b :=\n  measurable_iSup (\u03b1 := \u03b1\u1d52\u1d48) hf\n#align measurable_infi measurable_iInf\n\n@[measurability]\ntheorem aemeasurable_iInf {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a05 i, f i b) \u03bc :=\n  aemeasurable_iSup (\u03b1 := \u03b1\u1d52\u1d48) hf\n#align ae_measurable_infi aemeasurable_iInf\n\ntheorem measurable_sSup {\u03b9} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {s : Set \u03b9} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable fun x => sSup ((fun i => f i x) '' s) := by\n  have : Countable \u2191s := countable_coe_iff.2 hs\n  convert measurable_iSup (f := (fun (i : s) \u21a6 f i)) (fun i \u21a6 hf i i.2) using 1\n  ext b\n  congr\n  exact image_eq_range (fun i \u21a6 f i b) s\n#align measurable_cSup measurable_sSup\n\ntheorem measurable_sInf {\u03b9} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {s : Set \u03b9} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable fun x => sInf ((fun i => f i x) '' s) :=\n  measurable_sSup (\u03b1 := \u03b1\u1d52\u1d48) hs hf\n#align measurable_cInf measurable_sInf\n\ntheorem measurable_biSup {\u03b9} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) : Measurable fun b => \u2a06 i \u2208 s, f i b := by\n  haveI : Encodable s := hs.toEncodable\n  by_cases H : \u2200 i, i \u2208 s\n  \u00b7 have : \u2200 b, \u2a06 i \u2208 s, f i b = \u2a06 (i : s), f i b :=\n      fun b \u21a6 cbiSup_eq_of_forall (f := fun i \u21a6 f i b) H\n    simp only [this]\n    exact measurable_iSup (fun (i : s) \u21a6 hf i i.2)\n  \u00b7 have : \u2200 b, \u2a06 i \u2208 s, f i b = (\u2a06 (i : s), f i b) \u2294 sSup \u2205 :=\n      fun b \u21a6 cbiSup_eq_of_not_forall (f := fun i \u21a6 f i b) H\n    simp only [this]\n    apply Measurable.sup _ measurable_const\n    exact measurable_iSup (fun (i : s) \u21a6 hf i i.2)\n#align measurable_bsupr measurable_biSup\n\ntheorem aemeasurable_biSup {\u03b9} {\u03bc : Measure \u03b4} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a06 i \u2208 s, f i b) \u03bc := by\n  let g : \u03b9 \u2192 \u03b4 \u2192 \u03b1 := fun i \u21a6 if hi : i \u2208 s then (hf i hi).mk (f i) else fun _b \u21a6 sSup \u2205\n  have : \u2200 i \u2208 s, Measurable (g i) := by\n    intro i hi\n    simpa [g, hi] using (hf i hi).measurable_mk\n  refine \u27e8fun b \u21a6 \u2a06 (i) (_ : i \u2208 s), g i b, measurable_biSup s hs this, ?_\u27e9\n  have : \u2200 i \u2208 s, \u2200\u1d50 b \u2202\u03bc, f i b = g i b :=\n    fun i hi \u21a6 by simpa [g, hi] using (hf i hi).ae_eq_mk\n  filter_upwards [(ae_ball_iff hs).2 this] with b hb\n  exact iSup_congr fun i => iSup_congr (hb i)\n#align ae_measurable_bsupr aemeasurable_biSup\n\ntheorem measurable_biInf {\u03b9} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) : Measurable fun b => \u2a05 i \u2208 s, f i b :=\n  measurable_biSup (\u03b1 := \u03b1\u1d52\u1d48) s hs hf\n#align measurable_binfi measurable_biInf\n\ntheorem aemeasurable_biInf {\u03b9} {\u03bc : Measure \u03b4} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a05 i \u2208 s, f i b) \u03bc :=\n  aemeasurable_biSup (\u03b1 := \u03b1\u1d52\u1d48) s hs hf\n#align ae_measurable_binfi aemeasurable_biInf\n\n/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `\u2115`.\n-/\ntheorem measurable_liminf' {\u03b9 \u03b9'} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {v : Filter \u03b9} (hf : \u2200 i, Measurable (f i))\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasCountableBasis p s) (hs : \u2200 j, (s j).Countable) :\n    Measurable fun x => liminf (f \u00b7 x) v := by\n  /- We would like to write the liminf as `\u2a06 (j : Subtype p), \u2a05 (i : s j), f i x`, as the\n  measurability would follow from the measurability of infs and sups. Unfortunately, this is not\n  true in general conditionally complete linear orders because of issues with empty sets or sets\n  which are not bounded above or below. A slightly more complicated expression for the liminf,\n  valid in general, is given in `Filter.HasBasis.liminf_eq_ite`. This expression, built from\n  `if ... then ... else` and infs and sups, can be readily checked to be measurable. -/\n  have : Countable (Subtype p) := hv.countable\n  rcases isEmpty_or_nonempty (Subtype p) with hp|hp\n  \u00b7 simp [hv.liminf_eq_sSup_iUnion_iInter]\n  by_cases H : \u2203 (j : Subtype p), s j = \u2205\n  \u00b7 simp_rw [hv.liminf_eq_ite, if_pos H, measurable_const]\n  simp_rw [hv.liminf_eq_ite, if_neg H]\n  have : \u2200 i, Countable (s i) := fun i \u21a6 countable_coe_iff.2 (hs i)\n  let m : Subtype p \u2192 Set \u03b4 := fun j \u21a6 {x | BddBelow (range (fun (i : s j) \u21a6 f i x))}\n  have m_meas : \u2200 j, MeasurableSet (m j) :=\n    fun j \u21a6 measurableSet_bddBelow_range (fun (i : s j) \u21a6 hf i)\n  have mc_meas : MeasurableSet {x | \u2200 (j : Subtype p), x \u2209 m j} := by\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun j \u21a6 (m_meas j).compl)\n  apply Measurable.piecewise mc_meas measurable_const\n  apply measurable_iSup (fun j \u21a6 ?_)\n  let reparam : \u03b4 \u2192 Subtype p \u2192 Subtype p := fun x \u21a6 liminf_reparam (fun i \u21a6 f i x) s p\n  let F0 : Subtype p \u2192 \u03b4 \u2192 \u03b1 := fun j x \u21a6 \u2a05 (i : s j), f i x\n  have F0_meas : \u2200 j, Measurable (F0 j) := fun j \u21a6 measurable_iInf (fun (i : s j) \u21a6 hf i)\n  set F1 : \u03b4 \u2192 \u03b1 := fun x \u21a6 F0 (reparam x j) x with hF1\n  change Measurable F1\n  let g : \u2115 \u2192 Subtype p := Classical.choose (exists_surjective_nat (Subtype p))\n  have Z : \u2200 x, \u2203 n, x \u2208 m (g n) \u2228 \u2200 k, x \u2209 m k := by\n    intro x\n    by_cases H : \u2203 k, x \u2208 m k\n    \u00b7 rcases H with \u27e8k, hk\u27e9\n      rcases Classical.choose_spec (exists_surjective_nat (Subtype p)) k with \u27e8n, rfl\u27e9\n      exact \u27e8n, Or.inl hk\u27e9\n    \u00b7 push_neg at H\n      exact \u27e80, Or.inr H\u27e9\n  have : F1 = fun x \u21a6 if x \u2208 m j then F0 j x else F0 (g (Nat.find (Z x))) x := by\n    ext x\n    have A : reparam x j = if x \u2208 m j then j else g (Nat.find (Z x)) := rfl\n    split_ifs with hjx\n    \u00b7 have : reparam x j = j := by rw [A, if_pos hjx]\n      simp only [hF1, this]\n    \u00b7 have : reparam x j = g (Nat.find (Z x)) := by rw [A, if_neg hjx]\n      simp only [hF1, this]\n  rw [this]\n  apply Measurable.piecewise (m_meas j) (F0_meas j)\n  apply Measurable.find (fun n \u21a6 F0_meas (g n)) (fun n \u21a6 ?_)\n  exact (m_meas (g n)).union mc_meas\n#align measurable_liminf' measurable_liminf'\n\n/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `\u2115`.\n-/\ntheorem measurable_limsup' {\u03b9 \u03b9'} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {u : Filter \u03b9} (hf : \u2200 i, Measurable (f i))\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hu : u.HasCountableBasis p s) (hs : \u2200 i, (s i).Countable) :\n    Measurable fun x => limsup (fun i => f i x) u :=\n  measurable_liminf' (\u03b1 := \u03b1\u1d52\u1d48) hf hu hs\n#align measurable_limsup' measurable_limsup'\n\n/-- `liminf` over `\u2115` is measurable. See `measurable_liminf'` for a version with a general filter.\n-/\n@[measurability]\ntheorem measurable_liminf {f : \u2115 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun x => liminf (fun i => f i x) atTop :=\n  measurable_liminf' hf atTop_countable_basis fun _ => to_countable _\n#align measurable_liminf measurable_liminf\n\n/-- `limsup` over `\u2115` is measurable. See `measurable_limsup'` for a version with a general filter.\n-/\n@[measurability]\ntheorem measurable_limsup {f : \u2115 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun x => limsup (fun i => f i x) atTop :=\n  measurable_limsup' hf atTop_countable_basis fun _ => to_countable _\n#align measurable_limsup measurable_limsup\n\nend ConditionallyCompleteLinearOrder\n\n/-- Convert a `Homeomorph` to a `MeasurableEquiv`. -/\ndef Homemorph.toMeasurableEquiv (h : \u03b1 \u2243\u209c \u03b2) : \u03b1 \u2243\u1d50 \u03b2 where\n  toEquiv := h.toEquiv\n  measurable_toFun := h.continuous_toFun.measurable\n  measurable_invFun := h.continuous_invFun.measurable\n#align homemorph.to_measurable_equiv Homemorph.toMeasurableEquiv\n\nprotected theorem IsFiniteMeasureOnCompacts.map (\u03bc : Measure \u03b1) [IsFiniteMeasureOnCompacts \u03bc]\n    (f : \u03b1 \u2243\u209c \u03b2) : IsFiniteMeasureOnCompacts (Measure.map f \u03bc) := by\n  refine \u27e8fun K hK \u21a6 ?_\u27e9\n  rw [\u2190 Homeomorph.toMeasurableEquiv_coe, MeasurableEquiv.map_apply]\n  exact IsCompact.measure_lt_top (f.isCompact_preimage.2 hK)\n#align is_finite_measure_on_compacts.map IsFiniteMeasureOnCompacts.map\n\nend BorelSpace\n\ninstance Empty.borelSpace : BorelSpace Empty :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align empty.borel_space Empty.borelSpace\n\ninstance Unit.borelSpace : BorelSpace Unit :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align unit.borel_space Unit.borelSpace\n\ninstance Bool.borelSpace : BorelSpace Bool :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align bool.borel_space Bool.borelSpace\n\ninstance Nat.borelSpace : BorelSpace \u2115 :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align nat.borel_space Nat.borelSpace\n\ninstance Int.borelSpace : BorelSpace \u2124 :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9\n#align int.borel_space Int.borelSpace\n\ninstance Rat.borelSpace : BorelSpace \u211a :=\n  \u27e8borel_eq_top_of_countable.symm\u27e9\n#align rat.borel_space Rat.borelSpace\n\n/- Instances on `Real` and `Complex` are special cases of `RCLike` but without these instances,\nLean fails to prove `BorelSpace (\u03b9 \u2192 \u211d)`, so we leave them here. -/\ninstance Real.measurableSpace : MeasurableSpace \u211d :=\n  borel \u211d\n#align real.measurable_space Real.measurableSpace\n\ninstance Real.borelSpace : BorelSpace \u211d :=\n  \u27e8rfl\u27e9\n#align real.borel_space Real.borelSpace\n\ninstance NNReal.measurableSpace : MeasurableSpace \u211d\u22650 :=\n  Subtype.instMeasurableSpace\n#align nnreal.measurable_space NNReal.measurableSpace\n\ninstance NNReal.borelSpace : BorelSpace \u211d\u22650 :=\n  Subtype.borelSpace _\n#align nnreal.borel_space NNReal.borelSpace\n\ninstance ENNReal.measurableSpace : MeasurableSpace \u211d\u22650\u221e :=\n  borel \u211d\u22650\u221e\n#align ennreal.measurable_space ENNReal.measurableSpace\n\ninstance ENNReal.borelSpace : BorelSpace \u211d\u22650\u221e :=\n  \u27e8rfl\u27e9\n#align ennreal.borel_space ENNReal.borelSpace\n\ninstance EReal.measurableSpace : MeasurableSpace EReal :=\n  borel EReal\n#align ereal.measurable_space EReal.measurableSpace\n\ninstance EReal.borelSpace : BorelSpace EReal :=\n  \u27e8rfl\u27e9\n#align ereal.borel_space EReal.borelSpace\n\n/-- One can cut out `\u211d\u22650\u221e` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : \u2124` and `{\u221e}`. This\ngives a way to compute the measure of a set in terms of sets on which a given function `f` does not\nfluctuate by more than `t`. -/\ntheorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)\n    {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) {s : Set \u03b1} (hs : MeasurableSet s) {t : \u211d\u22650} (ht : 1 < t) :\n    \u03bc s =\n      \u03bc (s \u2229 f \u207b\u00b9' {0}) + \u03bc (s \u2229 f \u207b\u00b9' {\u221e}) +\n      \u2211' n : \u2124, \u03bc (s \u2229 f \u207b\u00b9' Ico ((t : \u211d\u22650\u221e) ^ n) ((t : \u211d\u22650\u221e) ^ (n + 1))) := by\n  have A : \u03bc s = \u03bc (s \u2229 f \u207b\u00b9' {0}) + \u03bc (s \u2229 f \u207b\u00b9' Ioi 0) := by\n    rw [\u2190 measure_union]\n    \u00b7 rw [\u2190 inter_union_distrib_left, \u2190 preimage_union, singleton_union, Ioi_insert,\n        \u2190 _root_.bot_eq_zero, Ici_bot, preimage_univ, inter_univ]\n    \u00b7 exact disjoint_singleton_left.mpr not_mem_Ioi_self\n        |>.preimage f |>.inter_right' s |>.inter_left' s\n    \u00b7 exact hs.inter (hf measurableSet_Ioi)\n  have B : \u03bc (s \u2229 f \u207b\u00b9' Ioi 0) = \u03bc (s \u2229 f \u207b\u00b9' {\u221e}) + \u03bc (s \u2229 f \u207b\u00b9' Ioo 0 \u221e) := by\n    rw [\u2190 measure_union]\n    \u00b7 rw [\u2190 inter_union_distrib_left]\n      congr\n      ext x\n      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]\n      obtain (H | H) : f x = \u221e \u2228 f x < \u221e := eq_or_lt_of_le le_top\n      \u00b7 simp only [H, eq_self_iff_true, or_false_iff, ENNReal.zero_lt_top, not_top_lt, and_false]\n      \u00b7 simp only [H, H.ne, and_true_iff, false_or_iff]\n    \u00b7 refine disjoint_left.2 fun x hx h'x => ?_\n      have : f x < \u221e := h'x.2.2\n      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))\n    \u00b7 exact hs.inter (hf measurableSet_Ioo)\n  have C : \u03bc (s \u2229 f \u207b\u00b9' Ioo 0 \u221e) =\n      \u2211' n : \u2124, \u03bc (s \u2229 f \u207b\u00b9' Ico ((t : \u211d\u22650\u221e) ^ n) ((t : \u211d\u22650\u221e) ^ (n + 1))) := by\n    rw [\u2190 measure_iUnion,\n      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,\n      preimage_iUnion, inter_iUnion]\n    \u00b7 intro i j hij\n      wlog h : i < j generalizing i j\n      \u00b7 exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm\n      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_\n      calc\n        f x < (t : \u211d\u22650\u221e) ^ (i + 1) := hx.2.2\n        _ \u2264 (t : \u211d\u22650\u221e) ^ j := ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h\n        _ \u2264 f x := h'x.2.1\n    \u00b7 intro n\n      exact hs.inter (hf measurableSet_Ico)\n  rw [A, B, C, add_assoc]\n#align measure_eq_measure_preimage_add_measure_tsum_Ico_zpow measure_eq_measure_preimage_add_measure_tsum_Ico_zpow\n\nsection PseudoMetricSpace\n\nvariable [PseudoMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]\nvariable [MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d}\n\nopen Metric\n\n@[measurability]\ntheorem measurableSet_ball : MeasurableSet (Metric.ball x \u03b5) :=\n  Metric.isOpen_ball.measurableSet\n#align measurable_set_ball measurableSet_ball\n\n@[measurability]\ntheorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x \u03b5) :=\n  Metric.isClosed_ball.measurableSet\n#align measurable_set_closed_ball measurableSet_closedBall\n\n@[measurability]\ntheorem measurable_infDist {s : Set \u03b1} : Measurable fun x => infDist x s :=\n  (continuous_infDist_pt s).measurable\n#align measurable_inf_dist measurable_infDist\n\n@[measurability]\ntheorem Measurable.infDist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infDist (f x) s :=\n  measurable_infDist.comp hf\n#align measurable.inf_dist Measurable.infDist\n\n@[measurability]\ntheorem measurable_infNndist {s : Set \u03b1} : Measurable fun x => infNndist x s :=\n  (continuous_infNndist_pt s).measurable\n#align measurable_inf_nndist measurable_infNndist\n\n@[measurability]\ntheorem Measurable.infNndist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infNndist (f x) s :=\n  measurable_infNndist.comp hf\n#align measurable.inf_nndist Measurable.infNndist\n\nsection\n\nvariable [SecondCountableTopology \u03b1]\n\n@[measurability]\ntheorem measurable_dist : Measurable fun p : \u03b1 \u00d7 \u03b1 => dist p.1 p.2 :=\n  continuous_dist.measurable\n#align measurable_dist measurable_dist\n\n@[measurability]\ntheorem Measurable.dist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => dist (f b) (g b) :=\n  (@continuous_dist \u03b1 _).measurable2 hf hg\n#align measurable.dist Measurable.dist\n\n@[measurability]\ntheorem measurable_nndist : Measurable fun p : \u03b1 \u00d7 \u03b1 => nndist p.1 p.2 :=\n  continuous_nndist.measurable\n#align measurable_nndist measurable_nndist\n\n@[measurability]\ntheorem Measurable.nndist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => nndist (f b) (g b) :=\n  (@continuous_nndist \u03b1 _).measurable2 hf hg\n#align measurable.nndist Measurable.nndist\n\nend\n\nend PseudoMetricSpace\n\nsection PseudoEMetricSpace\n\nvariable [PseudoEMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]\nvariable [MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d\u22650\u221e}\n\nopen EMetric\n\n@[measurability]\ntheorem measurableSet_eball : MeasurableSet (EMetric.ball x \u03b5) :=\n  EMetric.isOpen_ball.measurableSet\n#align measurable_set_eball measurableSet_eball\n\n@[measurability]\ntheorem measurable_edist_right : Measurable (edist x) :=\n  (continuous_const.edist continuous_id).measurable\n#align measurable_edist_right measurable_edist_right\n\n@[measurability]\ntheorem measurable_edist_left : Measurable fun y => edist y x :=\n  (continuous_id.edist continuous_const).measurable\n#align measurable_edist_left measurable_edist_left\n\n@[measurability]\ntheorem measurable_infEdist {s : Set \u03b1} : Measurable fun x => infEdist x s :=\n  continuous_infEdist.measurable\n#align measurable_inf_edist measurable_infEdist\n\n@[measurability]\ntheorem Measurable.infEdist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infEdist (f x) s :=\n  measurable_infEdist.comp hf\n#align measurable.inf_edist Measurable.infEdist\n\nopen Metric EMetric\n\n/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed\nthickenings converges to the measure of its closure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc (closure s))) := by\n  have A : Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd[Ioi 0] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n    rw [closure_eq_iInter_cthickening]\n    exact\n      tendsto_measure_biInter_gt (fun r _ => isClosed_cthickening.measurableSet)\n        (fun i j _ ij => cthickening_mono ij _) hs\n  have B : Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd[Iic 0] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n    apply Tendsto.congr' _ tendsto_const_nhds\n    filter_upwards [self_mem_nhdsWithin (\u03b1 := \u211d)] with _ hr\n    rw [cthickening_of_nonpos hr]\n  convert B.sup A\n  exact (nhds_left_sup_nhds_right' 0).symm\n#align tendsto_measure_cthickening tendsto_measure_cthickening\n\n/-- If a closed set has a closed thickening with finite measure, then the measure of its closed\n`r`-thickenings converge to its measure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc s)) := by\n  convert tendsto_measure_cthickening hs\n  exact h's.closure_eq.symm\n#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_isClosed\n\n/-- If a set has a thickening with finite measure, then the measures of its `r`-thickenings\nconverge to the measure of its closure as `r > 0` tends to `0`. -/\ntheorem tendsto_measure_thickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n  rw [closure_eq_iInter_thickening]\n  exact tendsto_measure_biInter_gt (fun r _ => isOpen_thickening.measurableSet)\n      (fun i j _ ij => thickening_mono ij _) hs\n\n/-- If a closed set has a thickening with finite measure, then the measure of its\n`r`-thickenings converge to its measure as `r > 0` tends to `0`. -/\ntheorem tendsto_measure_thickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc s)) := by\n  convert tendsto_measure_thickening hs\n  exact h's.closure_eq.symm\n\nvariable [SecondCountableTopology \u03b1]\n\n@[measurability]\ntheorem measurable_edist : Measurable fun p : \u03b1 \u00d7 \u03b1 => edist p.1 p.2 :=\n  continuous_edist.measurable\n#align measurable_edist measurable_edist\n\n@[measurability]\ntheorem Measurable.edist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => edist (f b) (g b) :=\n  (@continuous_edist \u03b1 _).measurable2 hf hg\n#align measurable.edist Measurable.edist\n\n@[measurability]\ntheorem AEMeasurable.edist {f g : \u03b2 \u2192 \u03b1} {\u03bc : Measure \u03b2} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => edist (f a) (g a)) \u03bc :=\n  (@continuous_edist \u03b1 _).aemeasurable2 hf hg\n#align ae_measurable.edist AEMeasurable.edist\n\nend PseudoEMetricSpace\n\n/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to\nits measure as `r` tends to `0`. -/\ntheorem tendsto_measure_cthickening_of_isCompact [MetricSpace \u03b1] [MeasurableSpace \u03b1]\n    [OpensMeasurableSpace \u03b1] [ProperSpace \u03b1] {\u03bc : Measure \u03b1} [IsFiniteMeasureOnCompacts \u03bc]\n    {s : Set \u03b1} (hs : IsCompact s) :\n    Tendsto (fun r => \u03bc (Metric.cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc s)) :=\n  tendsto_measure_cthickening_of_isClosed\n    \u27e81, zero_lt_one, hs.isBounded.cthickening.measure_lt_top.ne\u27e9 hs.isClosed\n#align tendsto_measure_cthickening_of_is_compact tendsto_measure_cthickening_of_isCompact\n\n/-- If a measurable space is countably generated and separates points, it arises as\nthe borel sets of some second countable t4 topology (i.e. a separable metrizable one). -/\ntheorem exists_borelSpace_of_countablyGenerated_of_separatesPoints (\u03b1 : Type*)\n    [m : MeasurableSpace \u03b1] [CountablyGenerated \u03b1] [SeparatesPoints \u03b1] :\n    \u2203 \u03c4 : TopologicalSpace \u03b1, SecondCountableTopology \u03b1 \u2227 T4Space \u03b1 \u2227 BorelSpace \u03b1 := by\n  rcases measurableEquiv_nat_bool_of_countablyGenerated \u03b1 with \u27e8s, \u27e8f\u27e9\u27e9\n  letI := induced f inferInstance\n  let F := f.toEquiv.toHomeomorphOfInducing $ inducing_induced _\n  exact \u27e8inferInstance, F.secondCountableTopology, F.symm.t4Space,\n    MeasurableEmbedding.borelSpace f.measurableEmbedding F.inducing\u27e9\n\n/-- If a measurable space on `\u03b1` is countably generated and separates points, there is some\nsecond countable t4 topology on `\u03b1` (i.e. a separable metrizable one) for which every\nopen set is measurable. -/\n", "theoremStatement": "theorem exists_opensMeasurableSpace_of_hasCountableSeparatingOn (\u03b1 : Type*)\n    [m : MeasurableSpace \u03b1] [HasCountableSeparatingOn \u03b1 MeasurableSet univ] :\n    \u2203 \u03c4 : TopologicalSpace \u03b1, SecondCountableTopology \u03b1 \u2227 T4Space \u03b1 \u2227 OpensMeasurableSpace \u03b1", "theoremName": "exists_opensMeasurableSpace_of_hasCountableSeparatingOn", "fileCreated": {"commit": "11332d53f1", "date": "2023-05-21"}, "theoremCreated": {"commit": "726f2a5ff9", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "positionMetadata": {"lineInFile": 1920, "tokenPositionInFile": 89637, "theoremPositionInFile": 218}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rcases exists_countablyGenerated_le_of_hasCountableSeparatingOn \u03b1 with \u27e8m', _, _, m'le\u27e9\n  rcases exists_borelSpace_of_countablyGenerated_of_separatesPoints (m := m') with \u27e8\u03c4, _, _, \u03c4m'\u27e9\n  exact \u27e8\u03c4, \u2039_\u203a, \u2039_\u203a, @OpensMeasurableSpace.mk _ _ m (\u03c4m'.measurable_eq.symm.le.trans m'le)\u27e9", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 283}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\nimport Mathlib.Algebra.Ring.Int\nimport Mathlib.Data.Fin.VecNotation\nimport Mathlib.Logic.Equiv.Defs\nimport Mathlib.Logic.Embedding.Set\n\n#align_import logic.equiv.fin from \"leanprover-community/mathlib\"@\"bd835ef554f37ef9b804f0903089211f89cb370b\"\n\n/-!\n# Equivalences for `Fin n`\n-/\n\nuniverse u\n\nvariable {m n : \u2115}\n\n/-- Equivalence between `Fin 0` and `Empty`. -/\ndef finZeroEquiv : Fin 0 \u2243 Empty :=\n  Equiv.equivEmpty _\n#align fin_zero_equiv finZeroEquiv\n\n/-- Equivalence between `Fin 0` and `PEmpty`. -/\ndef finZeroEquiv' : Fin 0 \u2243 PEmpty.{u} :=\n  Equiv.equivPEmpty _\n#align fin_zero_equiv' finZeroEquiv'\n\n/-- Equivalence between `Fin 1` and `Unit`. -/\ndef finOneEquiv : Fin 1 \u2243 Unit :=\n  Equiv.equivPUnit _\n#align fin_one_equiv finOneEquiv\n\n/-- Equivalence between `Fin 2` and `Bool`. -/\ndef finTwoEquiv : Fin 2 \u2243 Bool where\n  toFun := ![false, true]\n  invFun b := b.casesOn 0 1\n  left_inv := Fin.forall_fin_two.2 <| by simp\n  right_inv := Bool.forall_bool.2 <| by simp\n#align fin_two_equiv finTwoEquiv\n\n/-- `\u03a0 i : Fin 2, \u03b1 i` is equivalent to `\u03b1 0 \u00d7 \u03b1 1`. See also `finTwoArrowEquiv` for a\nnon-dependent version and `prodEquivPiFinTwo` for a version with inputs `\u03b1 \u03b2 : Type u`. -/\n@[simps (config := .asFn)]\ndef piFinTwoEquiv (\u03b1 : Fin 2 \u2192 Type u) : (\u2200 i, \u03b1 i) \u2243 \u03b1 0 \u00d7 \u03b1 1\n    where\n  toFun f := (f 0, f 1)\n  invFun p := Fin.cons p.1 <| Fin.cons p.2 finZeroElim\n  left_inv _ := funext <| Fin.forall_fin_two.2 \u27e8rfl, rfl\u27e9\n  right_inv := fun _ => rfl\n#align pi_fin_two_equiv piFinTwoEquiv\n#align pi_fin_two_equiv_symm_apply piFinTwoEquiv_symm_apply\n#align pi_fin_two_equiv_apply piFinTwoEquiv_apply\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\ntheorem Fin.preimage_apply_01_prod {\u03b1 : Fin 2 \u2192 Type u} (s : Set (\u03b1 0)) (t : Set (\u03b1 1)) :\n    (fun f : \u2200 i, \u03b1 i => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t =\n      Set.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim) := by\n  ext f\n  simp [Fin.forall_fin_two]\n#align fin.preimage_apply_01_prod Fin.preimage_apply_01_prod\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\ntheorem Fin.preimage_apply_01_prod' {\u03b1 : Type u} (s t : Set \u03b1) :\n    (fun f : Fin 2 \u2192 \u03b1 => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t = Set.pi Set.univ ![s, t] :=\n  @Fin.preimage_apply_01_prod (fun _ => \u03b1) s t\n#align fin.preimage_apply_01_prod' Fin.preimage_apply_01_prod'\n\n/-- A product space `\u03b1 \u00d7 \u03b2` is equivalent to the space `\u03a0 i : Fin 2, \u03b3 i`, where\n`\u03b3 = Fin.cons \u03b1 (Fin.cons \u03b2 finZeroElim)`. See also `piFinTwoEquiv` and\n`finTwoArrowEquiv`. -/\n@[simps! (config := .asFn)]\ndef prodEquivPiFinTwo (\u03b1 \u03b2 : Type u) : \u03b1 \u00d7 \u03b2 \u2243 \u2200 i : Fin 2, ![\u03b1, \u03b2] i :=\n  (piFinTwoEquiv (Fin.cons \u03b1 (Fin.cons \u03b2 finZeroElim))).symm\n#align prod_equiv_pi_fin_two prodEquivPiFinTwo\n#align prod_equiv_pi_fin_two_apply prodEquivPiFinTwo_apply\n#align prod_equiv_pi_fin_two_symm_apply prodEquivPiFinTwo_symm_apply\n\n/-- The space of functions `Fin 2 \u2192 \u03b1` is equivalent to `\u03b1 \u00d7 \u03b1`. See also `piFinTwoEquiv` and\n`prodEquivPiFinTwo`. -/\n@[simps (config := .asFn)]\ndef finTwoArrowEquiv (\u03b1 : Type*) : (Fin 2 \u2192 \u03b1) \u2243 \u03b1 \u00d7 \u03b1 :=\n  { piFinTwoEquiv fun _ => \u03b1 with invFun := fun x => ![x.1, x.2] }\n#align fin_two_arrow_equiv finTwoArrowEquiv\n#align fin_two_arrow_equiv_symm_apply finTwoArrowEquiv_symm_apply\n#align fin_two_arrow_equiv_apply finTwoArrowEquiv_apply\n\n/-- `\u03a0 i : Fin 2, \u03b1 i` is order equivalent to `\u03b1 0 \u00d7 \u03b1 1`. See also `OrderIso.finTwoArrowEquiv`\nfor a non-dependent version. -/\ndef OrderIso.piFinTwoIso (\u03b1 : Fin 2 \u2192 Type u) [\u2200 i, Preorder (\u03b1 i)] : (\u2200 i, \u03b1 i) \u2243o \u03b1 0 \u00d7 \u03b1 1\n    where\n  toEquiv := piFinTwoEquiv \u03b1\n  map_rel_iff' := Iff.symm Fin.forall_fin_two\n#align order_iso.pi_fin_two_iso OrderIso.piFinTwoIso\n\n/-- The space of functions `Fin 2 \u2192 \u03b1` is order equivalent to `\u03b1 \u00d7 \u03b1`. See also\n`OrderIso.piFinTwoIso`. -/\ndef OrderIso.finTwoArrowIso (\u03b1 : Type*) [Preorder \u03b1] : (Fin 2 \u2192 \u03b1) \u2243o \u03b1 \u00d7 \u03b1 :=\n  { OrderIso.piFinTwoIso fun _ => \u03b1 with toEquiv := finTwoArrowEquiv \u03b1 }\n#align order_iso.fin_two_arrow_iso OrderIso.finTwoArrowIso\n\n/-- The 'identity' equivalence between `Fin n` and `Fin m` when `n = m`. -/\ndef finCongr (h : m = n) : Fin m \u2243 Fin n :=\n  (Fin.castIso h).toEquiv\n#align fin_congr finCongr\n\n@[simp] theorem finCongr_apply_mk (h : m = n) (k : \u2115) (w : k < m) :\n    finCongr h \u27e8k, w\u27e9 = \u27e8k, h \u25b8 w\u27e9 :=\n  rfl\n#align fin_congr_apply_mk finCongr_apply_mk\n\n@[simp] theorem finCongr_symm (h : m = n) : (finCongr h).symm = finCongr h.symm :=\n  rfl\n#align fin_congr_symm finCongr_symm\n\n@[simp] theorem finCongr_apply_coe (h : m = n) (k : Fin m) : (finCongr h k : \u2115) = k :=\n  rfl\n#align fin_congr_apply_coe finCongr_apply_coe\n\ntheorem finCongr_symm_apply_coe (h : m = n) (k : Fin n) : ((finCongr h).symm k : \u2115) = k :=\n  rfl\n#align fin_congr_symm_apply_coe finCongr_symm_apply_coe\n\n/-- An equivalence that removes `i` and maps it to `none`.\nThis is a version of `Fin.predAbove` that produces `Option (Fin n)` instead of\nmapping both `i.cast_succ` and `i.succ` to `i`. -/\ndef finSuccEquiv' (i : Fin (n + 1)) : Fin (n + 1) \u2243 Option (Fin n)\n    where\n  toFun := i.insertNth none some\n  invFun x := x.casesOn' i (Fin.succAbove i)\n  left_inv x := Fin.succAboveCases i (by simp) (fun j => by simp) x\n  right_inv x := by cases x <;> dsimp <;> simp\n#align fin_succ_equiv' finSuccEquiv'\n\n@[simp]\ntheorem finSuccEquiv'_at (i : Fin (n + 1)) : (finSuccEquiv' i) i = none := by\n  simp [finSuccEquiv']\n#align fin_succ_equiv'_at finSuccEquiv'_at\n\n@[simp]\ntheorem finSuccEquiv'_succAbove (i : Fin (n + 1)) (j : Fin n) :\n    finSuccEquiv' i (i.succAbove j) = some j :=\n  @Fin.insertNth_apply_succAbove n (fun _ => Option (Fin n)) i _ _ _\n#align fin_succ_equiv'_succ_above finSuccEquiv'_succAbove\n\ntheorem finSuccEquiv'_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i) (Fin.castSucc m) = m := by\n  rw [\u2190 Fin.succAbove_of_castSucc_lt _ _ h, finSuccEquiv'_succAbove]\n#align fin_succ_equiv'_below finSuccEquiv'_below\n\ntheorem finSuccEquiv'_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i) m.succ = some m := by\n  rw [\u2190 Fin.succAbove_of_le_castSucc _ _ h, finSuccEquiv'_succAbove]\n#align fin_succ_equiv'_above finSuccEquiv'_above\n\n@[simp]\ntheorem finSuccEquiv'_symm_none (i : Fin (n + 1)) : (finSuccEquiv' i).symm none = i :=\n  rfl\n#align fin_succ_equiv'_symm_none finSuccEquiv'_symm_none\n\n@[simp]\ntheorem finSuccEquiv'_symm_some (i : Fin (n + 1)) (j : Fin n) :\n    (finSuccEquiv' i).symm (some j) = i.succAbove j :=\n  rfl\n#align fin_succ_equiv'_symm_some finSuccEquiv'_symm_some\n\ntheorem finSuccEquiv'_symm_some_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm (some m) = Fin.castSucc m :=\n  Fin.succAbove_of_castSucc_lt i m h\n#align fin_succ_equiv'_symm_some_below finSuccEquiv'_symm_some_below\n\ntheorem finSuccEquiv'_symm_some_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i).symm (some m) = m.succ :=\n  Fin.succAbove_of_le_castSucc i m h\n#align fin_succ_equiv'_symm_some_above finSuccEquiv'_symm_some_above\n\ntheorem finSuccEquiv'_symm_coe_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm m = Fin.castSucc m :=\n  finSuccEquiv'_symm_some_below h\n#align fin_succ_equiv'_symm_coe_below finSuccEquiv'_symm_coe_below\n\ntheorem finSuccEquiv'_symm_coe_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i).symm m = m.succ :=\n  finSuccEquiv'_symm_some_above h\n#align fin_succ_equiv'_symm_coe_above finSuccEquiv'_symm_coe_above\n\n/-- Equivalence between `Fin (n + 1)` and `Option (Fin n)`.\nThis is a version of `Fin.pred` that produces `Option (Fin n)` instead of\nrequiring a proof that the input is not `0`. -/\ndef finSuccEquiv (n : \u2115) : Fin (n + 1) \u2243 Option (Fin n) :=\n  finSuccEquiv' 0\n#align fin_succ_equiv finSuccEquiv\n\n@[simp]\ntheorem finSuccEquiv_zero : (finSuccEquiv n) 0 = none :=\n  rfl\n#align fin_succ_equiv_zero finSuccEquiv_zero\n\n@[simp]\ntheorem finSuccEquiv_succ (m : Fin n) : (finSuccEquiv n) m.succ = some m :=\n  finSuccEquiv'_above (Fin.zero_le _)\n#align fin_succ_equiv_succ finSuccEquiv_succ\n\n@[simp]\ntheorem finSuccEquiv_symm_none : (finSuccEquiv n).symm none = 0 :=\n  finSuccEquiv'_symm_none _\n#align fin_succ_equiv_symm_none finSuccEquiv_symm_none\n\n@[simp]\ntheorem finSuccEquiv_symm_some (m : Fin n) : (finSuccEquiv n).symm (some m) = m.succ :=\n  congr_fun Fin.succAbove_zero m\n#align fin_succ_equiv_symm_some finSuccEquiv_symm_some\n#align fin_succ_equiv_symm_coe finSuccEquiv_symm_some\n\n/-- The equiv version of `Fin.predAbove_zero`. -/\ntheorem finSuccEquiv'_zero : finSuccEquiv' (0 : Fin (n + 1)) = finSuccEquiv n :=\n  rfl\n#align fin_succ_equiv'_zero finSuccEquiv'_zero\n\ntheorem finSuccEquiv'_last_apply_castSucc (i : Fin n) :\n    finSuccEquiv' (Fin.last n) (Fin.castSucc i) = i := by\n  rw [\u2190 Fin.succAbove_last, finSuccEquiv'_succAbove]\n\ntheorem finSuccEquiv'_last_apply {i : Fin (n + 1)} (h : i \u2260 Fin.last n) :\n    finSuccEquiv' (Fin.last n) i = Fin.castLT i (Fin.val_lt_last h) := by\n  rcases Fin.exists_castSucc_eq.2 h with \u27e8i, rfl\u27e9\n  rw [finSuccEquiv'_last_apply_castSucc]\n  rfl\n#align fin_succ_equiv'_last_apply finSuccEquiv'_last_apply\n\ntheorem finSuccEquiv'_ne_last_apply {i j : Fin (n + 1)} (hi : i \u2260 Fin.last n) (hj : j \u2260 i) :\n    finSuccEquiv' i j = (i.castLT (Fin.val_lt_last hi)).predAbove j := by\n  rcases Fin.exists_succAbove_eq hj with \u27e8j, rfl\u27e9\n  rcases Fin.exists_castSucc_eq.2 hi with \u27e8i, rfl\u27e9\n  simp\n#align fin_succ_equiv'_ne_last_apply finSuccEquiv'_ne_last_apply\n\n/-- `Fin.succAbove` as an order isomorphism between `Fin n` and `{x : Fin (n + 1) // x \u2260 p}`. -/\ndef finSuccAboveEquiv (p : Fin (n + 1)) : Fin n \u2243o { x : Fin (n + 1) // x \u2260 p } :=\n  { Equiv.optionSubtype p \u27e8(finSuccEquiv' p).symm, rfl\u27e9 with\n    map_rel_iff' := p.succAboveEmb.map_rel_iff' }\n#align fin_succ_above_equiv finSuccAboveEquiv\n\ntheorem finSuccAboveEquiv_apply (p : Fin (n + 1)) (i : Fin n) :\n    finSuccAboveEquiv p i = \u27e8p.succAbove i, p.succAbove_ne i\u27e9 :=\n  rfl\n#align fin_succ_above_equiv_apply finSuccAboveEquiv_apply\n\ntheorem finSuccAboveEquiv_symm_apply_last (x : { x : Fin (n + 1) // x \u2260 Fin.last n }) :\n    (finSuccAboveEquiv (Fin.last n)).symm x = Fin.castLT x.1 (Fin.val_lt_last x.2) := by\n  rw [\u2190 Option.some_inj]\n  simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_last_apply x.property\n#align fin_succ_above_equiv_symm_apply_last finSuccAboveEquiv_symm_apply_last\n\ntheorem finSuccAboveEquiv_symm_apply_ne_last {p : Fin (n + 1)} (h : p \u2260 Fin.last n)\n    (x : { x : Fin (n + 1) // x \u2260 p }) :\n    (finSuccAboveEquiv p).symm x = (p.castLT (Fin.val_lt_last h)).predAbove x := by\n  rw [\u2190 Option.some_inj]\n  simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_ne_last_apply h x.property\n#align fin_succ_above_equiv_symm_apply_ne_last finSuccAboveEquiv_symm_apply_ne_last\n\n/-- `Equiv` between `Fin (n + 1)` and `Option (Fin n)` sending `Fin.last n` to `none` -/\ndef finSuccEquivLast : Fin (n + 1) \u2243 Option (Fin n) :=\n  finSuccEquiv' (Fin.last n)\n#align fin_succ_equiv_last finSuccEquivLast\n\n@[simp]\ntheorem finSuccEquivLast_castSucc (i : Fin n) : finSuccEquivLast (Fin.castSucc i) = some i :=\n  finSuccEquiv'_below i.2\n#align fin_succ_equiv_last_cast_succ finSuccEquivLast_castSucc\n\n@[simp]\ntheorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none := by\n  simp [finSuccEquivLast]\n#align fin_succ_equiv_last_last finSuccEquivLast_last\n\n@[simp]\ntheorem finSuccEquivLast_symm_some (i : Fin n) :\n    finSuccEquivLast.symm (some i) = Fin.castSucc i :=\n  finSuccEquiv'_symm_some_below i.2\n#align fin_succ_equiv_last_symm_some finSuccEquivLast_symm_some\n#align fin_succ_equiv_last_symm_coe finSuccEquivLast_symm_some\n\n@[simp] theorem finSuccEquivLast_symm_none : finSuccEquivLast.symm none = Fin.last n :=\n  finSuccEquiv'_symm_none _\n#align fin_succ_equiv_last_symm_none finSuccEquivLast_symm_none\n\n/-- Equivalence between `\u03a0 j : Fin (n + 1), \u03b1 j` and `\u03b1 i \u00d7 \u03a0 j : Fin n, \u03b1 (Fin.succAbove i j)`. -/\n@[simps (config := .asFn)]\ndef Equiv.piFinSuccAbove (\u03b1 : Fin (n + 1) \u2192 Type u) (i : Fin (n + 1)) :\n    (\u2200 j, \u03b1 j) \u2243 \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toFun f := i.extractNth f\n  invFun f := i.insertNth f.1 f.2\n  left_inv f := by simp\n  right_inv f := by simp\n#align equiv.pi_fin_succ_above_equiv Equiv.piFinSuccAbove\n#align equiv.pi_fin_succ_above_equiv_apply Equiv.piFinSuccAbove_apply\n#align equiv.pi_fin_succ_above_equiv_symm_apply Equiv.piFinSuccAbove_symm_apply\n\n/-- Order isomorphism between `\u03a0 j : Fin (n + 1), \u03b1 j` and\n`\u03b1 i \u00d7 \u03a0 j : Fin n, \u03b1 (Fin.succAbove i j)`. -/\ndef OrderIso.piFinSuccAboveIso (\u03b1 : Fin (n + 1) \u2192 Type u) [\u2200 i, LE (\u03b1 i)]\n    (i : Fin (n + 1)) : (\u2200 j, \u03b1 j) \u2243o \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toEquiv := Equiv.piFinSuccAbove \u03b1 i\n  map_rel_iff' := Iff.symm i.forall_iff_succAbove\n#align order_iso.pi_fin_succ_above_iso OrderIso.piFinSuccAboveIso\n\n/-- Equivalence between `Fin (n + 1) \u2192 \u03b2` and `\u03b2 \u00d7 (Fin n \u2192 \u03b2)`. -/\n@[simps! (config := .asFn)]\ndef Equiv.piFinSucc (n : \u2115) (\u03b2 : Type u) : (Fin (n + 1) \u2192 \u03b2) \u2243 \u03b2 \u00d7 (Fin n \u2192 \u03b2) :=\n  Equiv.piFinSuccAbove (fun _ => \u03b2) 0\n#align equiv.pi_fin_succ Equiv.piFinSucc\n#align equiv.pi_fin_succ_apply Equiv.piFinSucc_apply\n#align equiv.pi_fin_succ_symm_apply Equiv.piFinSucc_symm_apply\n\n/-- An embedding `e : Fin (n+1) \u21aa \u03b9` corresponds to an embedding `f : Fin n \u21aa \u03b9` (corresponding\nthe last `n` coordinates of `e`) together with a value not taken by `f` (corresponding to `e 0`). -/\ndef Equiv.embeddingFinSucc (n : \u2115) (\u03b9 : Type*) :\n    (Fin (n+1) \u21aa \u03b9) \u2243 (\u03a3 (e : Fin n \u21aa \u03b9), {i // i \u2209 Set.range e}) :=\n  ((finSuccEquiv n).embeddingCongr (Equiv.refl \u03b9)).trans\n    (Function.Embedding.optionEmbeddingEquiv (Fin n) \u03b9)\n\n", "theoremStatement": "@[simp] lemma Equiv.embeddingFinSucc_fst {n : \u2115} {\u03b9 : Type*} (e : Fin (n+1) \u21aa \u03b9) :\n    ((Equiv.embeddingFinSucc n \u03b9 e).1 : Fin n \u2192 \u03b9) = e \u2218 Fin.succ", "theoremName": "Equiv.embeddingFinSucc_fst", "fileCreated": {"commit": "885e8510c4", "date": "2023-01-23"}, "theoremCreated": {"commit": "98843f5bd5", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Logic/Equiv/Fin.lean", "positionMetadata": {"lineInFile": 325, "tokenPositionInFile": 13691, "theoremPositionInFile": 49}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 3}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\nimport Mathlib.Algebra.Ring.Int\nimport Mathlib.Data.Fin.VecNotation\nimport Mathlib.Logic.Equiv.Defs\nimport Mathlib.Logic.Embedding.Set\n\n#align_import logic.equiv.fin from \"leanprover-community/mathlib\"@\"bd835ef554f37ef9b804f0903089211f89cb370b\"\n\n/-!\n# Equivalences for `Fin n`\n-/\n\nuniverse u\n\nvariable {m n : \u2115}\n\n/-- Equivalence between `Fin 0` and `Empty`. -/\ndef finZeroEquiv : Fin 0 \u2243 Empty :=\n  Equiv.equivEmpty _\n#align fin_zero_equiv finZeroEquiv\n\n/-- Equivalence between `Fin 0` and `PEmpty`. -/\ndef finZeroEquiv' : Fin 0 \u2243 PEmpty.{u} :=\n  Equiv.equivPEmpty _\n#align fin_zero_equiv' finZeroEquiv'\n\n/-- Equivalence between `Fin 1` and `Unit`. -/\ndef finOneEquiv : Fin 1 \u2243 Unit :=\n  Equiv.equivPUnit _\n#align fin_one_equiv finOneEquiv\n\n/-- Equivalence between `Fin 2` and `Bool`. -/\ndef finTwoEquiv : Fin 2 \u2243 Bool where\n  toFun := ![false, true]\n  invFun b := b.casesOn 0 1\n  left_inv := Fin.forall_fin_two.2 <| by simp\n  right_inv := Bool.forall_bool.2 <| by simp\n#align fin_two_equiv finTwoEquiv\n\n/-- `\u03a0 i : Fin 2, \u03b1 i` is equivalent to `\u03b1 0 \u00d7 \u03b1 1`. See also `finTwoArrowEquiv` for a\nnon-dependent version and `prodEquivPiFinTwo` for a version with inputs `\u03b1 \u03b2 : Type u`. -/\n@[simps (config := .asFn)]\ndef piFinTwoEquiv (\u03b1 : Fin 2 \u2192 Type u) : (\u2200 i, \u03b1 i) \u2243 \u03b1 0 \u00d7 \u03b1 1\n    where\n  toFun f := (f 0, f 1)\n  invFun p := Fin.cons p.1 <| Fin.cons p.2 finZeroElim\n  left_inv _ := funext <| Fin.forall_fin_two.2 \u27e8rfl, rfl\u27e9\n  right_inv := fun _ => rfl\n#align pi_fin_two_equiv piFinTwoEquiv\n#align pi_fin_two_equiv_symm_apply piFinTwoEquiv_symm_apply\n#align pi_fin_two_equiv_apply piFinTwoEquiv_apply\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\ntheorem Fin.preimage_apply_01_prod {\u03b1 : Fin 2 \u2192 Type u} (s : Set (\u03b1 0)) (t : Set (\u03b1 1)) :\n    (fun f : \u2200 i, \u03b1 i => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t =\n      Set.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim) := by\n  ext f\n  simp [Fin.forall_fin_two]\n#align fin.preimage_apply_01_prod Fin.preimage_apply_01_prod\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\ntheorem Fin.preimage_apply_01_prod' {\u03b1 : Type u} (s t : Set \u03b1) :\n    (fun f : Fin 2 \u2192 \u03b1 => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t = Set.pi Set.univ ![s, t] :=\n  @Fin.preimage_apply_01_prod (fun _ => \u03b1) s t\n#align fin.preimage_apply_01_prod' Fin.preimage_apply_01_prod'\n\n/-- A product space `\u03b1 \u00d7 \u03b2` is equivalent to the space `\u03a0 i : Fin 2, \u03b3 i`, where\n`\u03b3 = Fin.cons \u03b1 (Fin.cons \u03b2 finZeroElim)`. See also `piFinTwoEquiv` and\n`finTwoArrowEquiv`. -/\n@[simps! (config := .asFn)]\ndef prodEquivPiFinTwo (\u03b1 \u03b2 : Type u) : \u03b1 \u00d7 \u03b2 \u2243 \u2200 i : Fin 2, ![\u03b1, \u03b2] i :=\n  (piFinTwoEquiv (Fin.cons \u03b1 (Fin.cons \u03b2 finZeroElim))).symm\n#align prod_equiv_pi_fin_two prodEquivPiFinTwo\n#align prod_equiv_pi_fin_two_apply prodEquivPiFinTwo_apply\n#align prod_equiv_pi_fin_two_symm_apply prodEquivPiFinTwo_symm_apply\n\n/-- The space of functions `Fin 2 \u2192 \u03b1` is equivalent to `\u03b1 \u00d7 \u03b1`. See also `piFinTwoEquiv` and\n`prodEquivPiFinTwo`. -/\n@[simps (config := .asFn)]\ndef finTwoArrowEquiv (\u03b1 : Type*) : (Fin 2 \u2192 \u03b1) \u2243 \u03b1 \u00d7 \u03b1 :=\n  { piFinTwoEquiv fun _ => \u03b1 with invFun := fun x => ![x.1, x.2] }\n#align fin_two_arrow_equiv finTwoArrowEquiv\n#align fin_two_arrow_equiv_symm_apply finTwoArrowEquiv_symm_apply\n#align fin_two_arrow_equiv_apply finTwoArrowEquiv_apply\n\n/-- `\u03a0 i : Fin 2, \u03b1 i` is order equivalent to `\u03b1 0 \u00d7 \u03b1 1`. See also `OrderIso.finTwoArrowEquiv`\nfor a non-dependent version. -/\ndef OrderIso.piFinTwoIso (\u03b1 : Fin 2 \u2192 Type u) [\u2200 i, Preorder (\u03b1 i)] : (\u2200 i, \u03b1 i) \u2243o \u03b1 0 \u00d7 \u03b1 1\n    where\n  toEquiv := piFinTwoEquiv \u03b1\n  map_rel_iff' := Iff.symm Fin.forall_fin_two\n#align order_iso.pi_fin_two_iso OrderIso.piFinTwoIso\n\n/-- The space of functions `Fin 2 \u2192 \u03b1` is order equivalent to `\u03b1 \u00d7 \u03b1`. See also\n`OrderIso.piFinTwoIso`. -/\ndef OrderIso.finTwoArrowIso (\u03b1 : Type*) [Preorder \u03b1] : (Fin 2 \u2192 \u03b1) \u2243o \u03b1 \u00d7 \u03b1 :=\n  { OrderIso.piFinTwoIso fun _ => \u03b1 with toEquiv := finTwoArrowEquiv \u03b1 }\n#align order_iso.fin_two_arrow_iso OrderIso.finTwoArrowIso\n\n/-- The 'identity' equivalence between `Fin n` and `Fin m` when `n = m`. -/\ndef finCongr (h : m = n) : Fin m \u2243 Fin n :=\n  (Fin.castIso h).toEquiv\n#align fin_congr finCongr\n\n@[simp] theorem finCongr_apply_mk (h : m = n) (k : \u2115) (w : k < m) :\n    finCongr h \u27e8k, w\u27e9 = \u27e8k, h \u25b8 w\u27e9 :=\n  rfl\n#align fin_congr_apply_mk finCongr_apply_mk\n\n@[simp] theorem finCongr_symm (h : m = n) : (finCongr h).symm = finCongr h.symm :=\n  rfl\n#align fin_congr_symm finCongr_symm\n\n@[simp] theorem finCongr_apply_coe (h : m = n) (k : Fin m) : (finCongr h k : \u2115) = k :=\n  rfl\n#align fin_congr_apply_coe finCongr_apply_coe\n\ntheorem finCongr_symm_apply_coe (h : m = n) (k : Fin n) : ((finCongr h).symm k : \u2115) = k :=\n  rfl\n#align fin_congr_symm_apply_coe finCongr_symm_apply_coe\n\n/-- An equivalence that removes `i` and maps it to `none`.\nThis is a version of `Fin.predAbove` that produces `Option (Fin n)` instead of\nmapping both `i.cast_succ` and `i.succ` to `i`. -/\ndef finSuccEquiv' (i : Fin (n + 1)) : Fin (n + 1) \u2243 Option (Fin n)\n    where\n  toFun := i.insertNth none some\n  invFun x := x.casesOn' i (Fin.succAbove i)\n  left_inv x := Fin.succAboveCases i (by simp) (fun j => by simp) x\n  right_inv x := by cases x <;> dsimp <;> simp\n#align fin_succ_equiv' finSuccEquiv'\n\n@[simp]\ntheorem finSuccEquiv'_at (i : Fin (n + 1)) : (finSuccEquiv' i) i = none := by\n  simp [finSuccEquiv']\n#align fin_succ_equiv'_at finSuccEquiv'_at\n\n@[simp]\ntheorem finSuccEquiv'_succAbove (i : Fin (n + 1)) (j : Fin n) :\n    finSuccEquiv' i (i.succAbove j) = some j :=\n  @Fin.insertNth_apply_succAbove n (fun _ => Option (Fin n)) i _ _ _\n#align fin_succ_equiv'_succ_above finSuccEquiv'_succAbove\n\ntheorem finSuccEquiv'_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i) (Fin.castSucc m) = m := by\n  rw [\u2190 Fin.succAbove_of_castSucc_lt _ _ h, finSuccEquiv'_succAbove]\n#align fin_succ_equiv'_below finSuccEquiv'_below\n\ntheorem finSuccEquiv'_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i) m.succ = some m := by\n  rw [\u2190 Fin.succAbove_of_le_castSucc _ _ h, finSuccEquiv'_succAbove]\n#align fin_succ_equiv'_above finSuccEquiv'_above\n\n@[simp]\ntheorem finSuccEquiv'_symm_none (i : Fin (n + 1)) : (finSuccEquiv' i).symm none = i :=\n  rfl\n#align fin_succ_equiv'_symm_none finSuccEquiv'_symm_none\n\n@[simp]\ntheorem finSuccEquiv'_symm_some (i : Fin (n + 1)) (j : Fin n) :\n    (finSuccEquiv' i).symm (some j) = i.succAbove j :=\n  rfl\n#align fin_succ_equiv'_symm_some finSuccEquiv'_symm_some\n\ntheorem finSuccEquiv'_symm_some_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm (some m) = Fin.castSucc m :=\n  Fin.succAbove_of_castSucc_lt i m h\n#align fin_succ_equiv'_symm_some_below finSuccEquiv'_symm_some_below\n\ntheorem finSuccEquiv'_symm_some_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i).symm (some m) = m.succ :=\n  Fin.succAbove_of_le_castSucc i m h\n#align fin_succ_equiv'_symm_some_above finSuccEquiv'_symm_some_above\n\ntheorem finSuccEquiv'_symm_coe_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm m = Fin.castSucc m :=\n  finSuccEquiv'_symm_some_below h\n#align fin_succ_equiv'_symm_coe_below finSuccEquiv'_symm_coe_below\n\ntheorem finSuccEquiv'_symm_coe_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i).symm m = m.succ :=\n  finSuccEquiv'_symm_some_above h\n#align fin_succ_equiv'_symm_coe_above finSuccEquiv'_symm_coe_above\n\n/-- Equivalence between `Fin (n + 1)` and `Option (Fin n)`.\nThis is a version of `Fin.pred` that produces `Option (Fin n)` instead of\nrequiring a proof that the input is not `0`. -/\ndef finSuccEquiv (n : \u2115) : Fin (n + 1) \u2243 Option (Fin n) :=\n  finSuccEquiv' 0\n#align fin_succ_equiv finSuccEquiv\n\n@[simp]\ntheorem finSuccEquiv_zero : (finSuccEquiv n) 0 = none :=\n  rfl\n#align fin_succ_equiv_zero finSuccEquiv_zero\n\n@[simp]\ntheorem finSuccEquiv_succ (m : Fin n) : (finSuccEquiv n) m.succ = some m :=\n  finSuccEquiv'_above (Fin.zero_le _)\n#align fin_succ_equiv_succ finSuccEquiv_succ\n\n@[simp]\ntheorem finSuccEquiv_symm_none : (finSuccEquiv n).symm none = 0 :=\n  finSuccEquiv'_symm_none _\n#align fin_succ_equiv_symm_none finSuccEquiv_symm_none\n\n@[simp]\ntheorem finSuccEquiv_symm_some (m : Fin n) : (finSuccEquiv n).symm (some m) = m.succ :=\n  congr_fun Fin.succAbove_zero m\n#align fin_succ_equiv_symm_some finSuccEquiv_symm_some\n#align fin_succ_equiv_symm_coe finSuccEquiv_symm_some\n\n/-- The equiv version of `Fin.predAbove_zero`. -/\ntheorem finSuccEquiv'_zero : finSuccEquiv' (0 : Fin (n + 1)) = finSuccEquiv n :=\n  rfl\n#align fin_succ_equiv'_zero finSuccEquiv'_zero\n\ntheorem finSuccEquiv'_last_apply_castSucc (i : Fin n) :\n    finSuccEquiv' (Fin.last n) (Fin.castSucc i) = i := by\n  rw [\u2190 Fin.succAbove_last, finSuccEquiv'_succAbove]\n\ntheorem finSuccEquiv'_last_apply {i : Fin (n + 1)} (h : i \u2260 Fin.last n) :\n    finSuccEquiv' (Fin.last n) i = Fin.castLT i (Fin.val_lt_last h) := by\n  rcases Fin.exists_castSucc_eq.2 h with \u27e8i, rfl\u27e9\n  rw [finSuccEquiv'_last_apply_castSucc]\n  rfl\n#align fin_succ_equiv'_last_apply finSuccEquiv'_last_apply\n\ntheorem finSuccEquiv'_ne_last_apply {i j : Fin (n + 1)} (hi : i \u2260 Fin.last n) (hj : j \u2260 i) :\n    finSuccEquiv' i j = (i.castLT (Fin.val_lt_last hi)).predAbove j := by\n  rcases Fin.exists_succAbove_eq hj with \u27e8j, rfl\u27e9\n  rcases Fin.exists_castSucc_eq.2 hi with \u27e8i, rfl\u27e9\n  simp\n#align fin_succ_equiv'_ne_last_apply finSuccEquiv'_ne_last_apply\n\n/-- `Fin.succAbove` as an order isomorphism between `Fin n` and `{x : Fin (n + 1) // x \u2260 p}`. -/\ndef finSuccAboveEquiv (p : Fin (n + 1)) : Fin n \u2243o { x : Fin (n + 1) // x \u2260 p } :=\n  { Equiv.optionSubtype p \u27e8(finSuccEquiv' p).symm, rfl\u27e9 with\n    map_rel_iff' := p.succAboveEmb.map_rel_iff' }\n#align fin_succ_above_equiv finSuccAboveEquiv\n\ntheorem finSuccAboveEquiv_apply (p : Fin (n + 1)) (i : Fin n) :\n    finSuccAboveEquiv p i = \u27e8p.succAbove i, p.succAbove_ne i\u27e9 :=\n  rfl\n#align fin_succ_above_equiv_apply finSuccAboveEquiv_apply\n\ntheorem finSuccAboveEquiv_symm_apply_last (x : { x : Fin (n + 1) // x \u2260 Fin.last n }) :\n    (finSuccAboveEquiv (Fin.last n)).symm x = Fin.castLT x.1 (Fin.val_lt_last x.2) := by\n  rw [\u2190 Option.some_inj]\n  simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_last_apply x.property\n#align fin_succ_above_equiv_symm_apply_last finSuccAboveEquiv_symm_apply_last\n\ntheorem finSuccAboveEquiv_symm_apply_ne_last {p : Fin (n + 1)} (h : p \u2260 Fin.last n)\n    (x : { x : Fin (n + 1) // x \u2260 p }) :\n    (finSuccAboveEquiv p).symm x = (p.castLT (Fin.val_lt_last h)).predAbove x := by\n  rw [\u2190 Option.some_inj]\n  simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_ne_last_apply h x.property\n#align fin_succ_above_equiv_symm_apply_ne_last finSuccAboveEquiv_symm_apply_ne_last\n\n/-- `Equiv` between `Fin (n + 1)` and `Option (Fin n)` sending `Fin.last n` to `none` -/\ndef finSuccEquivLast : Fin (n + 1) \u2243 Option (Fin n) :=\n  finSuccEquiv' (Fin.last n)\n#align fin_succ_equiv_last finSuccEquivLast\n\n@[simp]\ntheorem finSuccEquivLast_castSucc (i : Fin n) : finSuccEquivLast (Fin.castSucc i) = some i :=\n  finSuccEquiv'_below i.2\n#align fin_succ_equiv_last_cast_succ finSuccEquivLast_castSucc\n\n@[simp]\ntheorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none := by\n  simp [finSuccEquivLast]\n#align fin_succ_equiv_last_last finSuccEquivLast_last\n\n@[simp]\ntheorem finSuccEquivLast_symm_some (i : Fin n) :\n    finSuccEquivLast.symm (some i) = Fin.castSucc i :=\n  finSuccEquiv'_symm_some_below i.2\n#align fin_succ_equiv_last_symm_some finSuccEquivLast_symm_some\n#align fin_succ_equiv_last_symm_coe finSuccEquivLast_symm_some\n\n@[simp] theorem finSuccEquivLast_symm_none : finSuccEquivLast.symm none = Fin.last n :=\n  finSuccEquiv'_symm_none _\n#align fin_succ_equiv_last_symm_none finSuccEquivLast_symm_none\n\n/-- Equivalence between `\u03a0 j : Fin (n + 1), \u03b1 j` and `\u03b1 i \u00d7 \u03a0 j : Fin n, \u03b1 (Fin.succAbove i j)`. -/\n@[simps (config := .asFn)]\ndef Equiv.piFinSuccAbove (\u03b1 : Fin (n + 1) \u2192 Type u) (i : Fin (n + 1)) :\n    (\u2200 j, \u03b1 j) \u2243 \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toFun f := i.extractNth f\n  invFun f := i.insertNth f.1 f.2\n  left_inv f := by simp\n  right_inv f := by simp\n#align equiv.pi_fin_succ_above_equiv Equiv.piFinSuccAbove\n#align equiv.pi_fin_succ_above_equiv_apply Equiv.piFinSuccAbove_apply\n#align equiv.pi_fin_succ_above_equiv_symm_apply Equiv.piFinSuccAbove_symm_apply\n\n/-- Order isomorphism between `\u03a0 j : Fin (n + 1), \u03b1 j` and\n`\u03b1 i \u00d7 \u03a0 j : Fin n, \u03b1 (Fin.succAbove i j)`. -/\ndef OrderIso.piFinSuccAboveIso (\u03b1 : Fin (n + 1) \u2192 Type u) [\u2200 i, LE (\u03b1 i)]\n    (i : Fin (n + 1)) : (\u2200 j, \u03b1 j) \u2243o \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toEquiv := Equiv.piFinSuccAbove \u03b1 i\n  map_rel_iff' := Iff.symm i.forall_iff_succAbove\n#align order_iso.pi_fin_succ_above_iso OrderIso.piFinSuccAboveIso\n\n/-- Equivalence between `Fin (n + 1) \u2192 \u03b2` and `\u03b2 \u00d7 (Fin n \u2192 \u03b2)`. -/\n@[simps! (config := .asFn)]\ndef Equiv.piFinSucc (n : \u2115) (\u03b2 : Type u) : (Fin (n + 1) \u2192 \u03b2) \u2243 \u03b2 \u00d7 (Fin n \u2192 \u03b2) :=\n  Equiv.piFinSuccAbove (fun _ => \u03b2) 0\n#align equiv.pi_fin_succ Equiv.piFinSucc\n#align equiv.pi_fin_succ_apply Equiv.piFinSucc_apply\n#align equiv.pi_fin_succ_symm_apply Equiv.piFinSucc_symm_apply\n\n/-- An embedding `e : Fin (n+1) \u21aa \u03b9` corresponds to an embedding `f : Fin n \u21aa \u03b9` (corresponding\nthe last `n` coordinates of `e`) together with a value not taken by `f` (corresponding to `e 0`). -/\ndef Equiv.embeddingFinSucc (n : \u2115) (\u03b9 : Type*) :\n    (Fin (n+1) \u21aa \u03b9) \u2243 (\u03a3 (e : Fin n \u21aa \u03b9), {i // i \u2209 Set.range e}) :=\n  ((finSuccEquiv n).embeddingCongr (Equiv.refl \u03b9)).trans\n    (Function.Embedding.optionEmbeddingEquiv (Fin n) \u03b9)\n\n@[simp] lemma Equiv.embeddingFinSucc_fst {n : \u2115} {\u03b9 : Type*} (e : Fin (n+1) \u21aa \u03b9) :\n    ((Equiv.embeddingFinSucc n \u03b9 e).1 : Fin n \u2192 \u03b9) = e \u2218 Fin.succ := rfl\n\n", "theoremStatement": "@[simp] lemma Equiv.embeddingFinSucc_snd {n : \u2115} {\u03b9 : Type*} (e : Fin (n+1) \u21aa \u03b9) :\n    ((Equiv.embeddingFinSucc n \u03b9 e).2 : \u03b9) = e 0", "theoremName": "Equiv.embeddingFinSucc_snd", "fileCreated": {"commit": "885e8510c4", "date": "2023-01-23"}, "theoremCreated": {"commit": "98843f5bd5", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Logic/Equiv/Fin.lean", "positionMetadata": {"lineInFile": 328, "tokenPositionInFile": 13848, "theoremPositionInFile": 50}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 3}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\nimport Mathlib.Algebra.Ring.Int\nimport Mathlib.Data.Fin.VecNotation\nimport Mathlib.Logic.Equiv.Defs\nimport Mathlib.Logic.Embedding.Set\n\n#align_import logic.equiv.fin from \"leanprover-community/mathlib\"@\"bd835ef554f37ef9b804f0903089211f89cb370b\"\n\n/-!\n# Equivalences for `Fin n`\n-/\n\nuniverse u\n\nvariable {m n : \u2115}\n\n/-- Equivalence between `Fin 0` and `Empty`. -/\ndef finZeroEquiv : Fin 0 \u2243 Empty :=\n  Equiv.equivEmpty _\n#align fin_zero_equiv finZeroEquiv\n\n/-- Equivalence between `Fin 0` and `PEmpty`. -/\ndef finZeroEquiv' : Fin 0 \u2243 PEmpty.{u} :=\n  Equiv.equivPEmpty _\n#align fin_zero_equiv' finZeroEquiv'\n\n/-- Equivalence between `Fin 1` and `Unit`. -/\ndef finOneEquiv : Fin 1 \u2243 Unit :=\n  Equiv.equivPUnit _\n#align fin_one_equiv finOneEquiv\n\n/-- Equivalence between `Fin 2` and `Bool`. -/\ndef finTwoEquiv : Fin 2 \u2243 Bool where\n  toFun := ![false, true]\n  invFun b := b.casesOn 0 1\n  left_inv := Fin.forall_fin_two.2 <| by simp\n  right_inv := Bool.forall_bool.2 <| by simp\n#align fin_two_equiv finTwoEquiv\n\n/-- `\u03a0 i : Fin 2, \u03b1 i` is equivalent to `\u03b1 0 \u00d7 \u03b1 1`. See also `finTwoArrowEquiv` for a\nnon-dependent version and `prodEquivPiFinTwo` for a version with inputs `\u03b1 \u03b2 : Type u`. -/\n@[simps (config := .asFn)]\ndef piFinTwoEquiv (\u03b1 : Fin 2 \u2192 Type u) : (\u2200 i, \u03b1 i) \u2243 \u03b1 0 \u00d7 \u03b1 1\n    where\n  toFun f := (f 0, f 1)\n  invFun p := Fin.cons p.1 <| Fin.cons p.2 finZeroElim\n  left_inv _ := funext <| Fin.forall_fin_two.2 \u27e8rfl, rfl\u27e9\n  right_inv := fun _ => rfl\n#align pi_fin_two_equiv piFinTwoEquiv\n#align pi_fin_two_equiv_symm_apply piFinTwoEquiv_symm_apply\n#align pi_fin_two_equiv_apply piFinTwoEquiv_apply\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\ntheorem Fin.preimage_apply_01_prod {\u03b1 : Fin 2 \u2192 Type u} (s : Set (\u03b1 0)) (t : Set (\u03b1 1)) :\n    (fun f : \u2200 i, \u03b1 i => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t =\n      Set.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim) := by\n  ext f\n  simp [Fin.forall_fin_two]\n#align fin.preimage_apply_01_prod Fin.preimage_apply_01_prod\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\ntheorem Fin.preimage_apply_01_prod' {\u03b1 : Type u} (s t : Set \u03b1) :\n    (fun f : Fin 2 \u2192 \u03b1 => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t = Set.pi Set.univ ![s, t] :=\n  @Fin.preimage_apply_01_prod (fun _ => \u03b1) s t\n#align fin.preimage_apply_01_prod' Fin.preimage_apply_01_prod'\n\n/-- A product space `\u03b1 \u00d7 \u03b2` is equivalent to the space `\u03a0 i : Fin 2, \u03b3 i`, where\n`\u03b3 = Fin.cons \u03b1 (Fin.cons \u03b2 finZeroElim)`. See also `piFinTwoEquiv` and\n`finTwoArrowEquiv`. -/\n@[simps! (config := .asFn)]\ndef prodEquivPiFinTwo (\u03b1 \u03b2 : Type u) : \u03b1 \u00d7 \u03b2 \u2243 \u2200 i : Fin 2, ![\u03b1, \u03b2] i :=\n  (piFinTwoEquiv (Fin.cons \u03b1 (Fin.cons \u03b2 finZeroElim))).symm\n#align prod_equiv_pi_fin_two prodEquivPiFinTwo\n#align prod_equiv_pi_fin_two_apply prodEquivPiFinTwo_apply\n#align prod_equiv_pi_fin_two_symm_apply prodEquivPiFinTwo_symm_apply\n\n/-- The space of functions `Fin 2 \u2192 \u03b1` is equivalent to `\u03b1 \u00d7 \u03b1`. See also `piFinTwoEquiv` and\n`prodEquivPiFinTwo`. -/\n@[simps (config := .asFn)]\ndef finTwoArrowEquiv (\u03b1 : Type*) : (Fin 2 \u2192 \u03b1) \u2243 \u03b1 \u00d7 \u03b1 :=\n  { piFinTwoEquiv fun _ => \u03b1 with invFun := fun x => ![x.1, x.2] }\n#align fin_two_arrow_equiv finTwoArrowEquiv\n#align fin_two_arrow_equiv_symm_apply finTwoArrowEquiv_symm_apply\n#align fin_two_arrow_equiv_apply finTwoArrowEquiv_apply\n\n/-- `\u03a0 i : Fin 2, \u03b1 i` is order equivalent to `\u03b1 0 \u00d7 \u03b1 1`. See also `OrderIso.finTwoArrowEquiv`\nfor a non-dependent version. -/\ndef OrderIso.piFinTwoIso (\u03b1 : Fin 2 \u2192 Type u) [\u2200 i, Preorder (\u03b1 i)] : (\u2200 i, \u03b1 i) \u2243o \u03b1 0 \u00d7 \u03b1 1\n    where\n  toEquiv := piFinTwoEquiv \u03b1\n  map_rel_iff' := Iff.symm Fin.forall_fin_two\n#align order_iso.pi_fin_two_iso OrderIso.piFinTwoIso\n\n/-- The space of functions `Fin 2 \u2192 \u03b1` is order equivalent to `\u03b1 \u00d7 \u03b1`. See also\n`OrderIso.piFinTwoIso`. -/\ndef OrderIso.finTwoArrowIso (\u03b1 : Type*) [Preorder \u03b1] : (Fin 2 \u2192 \u03b1) \u2243o \u03b1 \u00d7 \u03b1 :=\n  { OrderIso.piFinTwoIso fun _ => \u03b1 with toEquiv := finTwoArrowEquiv \u03b1 }\n#align order_iso.fin_two_arrow_iso OrderIso.finTwoArrowIso\n\n/-- The 'identity' equivalence between `Fin n` and `Fin m` when `n = m`. -/\ndef finCongr (h : m = n) : Fin m \u2243 Fin n :=\n  (Fin.castIso h).toEquiv\n#align fin_congr finCongr\n\n@[simp] theorem finCongr_apply_mk (h : m = n) (k : \u2115) (w : k < m) :\n    finCongr h \u27e8k, w\u27e9 = \u27e8k, h \u25b8 w\u27e9 :=\n  rfl\n#align fin_congr_apply_mk finCongr_apply_mk\n\n@[simp] theorem finCongr_symm (h : m = n) : (finCongr h).symm = finCongr h.symm :=\n  rfl\n#align fin_congr_symm finCongr_symm\n\n@[simp] theorem finCongr_apply_coe (h : m = n) (k : Fin m) : (finCongr h k : \u2115) = k :=\n  rfl\n#align fin_congr_apply_coe finCongr_apply_coe\n\ntheorem finCongr_symm_apply_coe (h : m = n) (k : Fin n) : ((finCongr h).symm k : \u2115) = k :=\n  rfl\n#align fin_congr_symm_apply_coe finCongr_symm_apply_coe\n\n/-- An equivalence that removes `i` and maps it to `none`.\nThis is a version of `Fin.predAbove` that produces `Option (Fin n)` instead of\nmapping both `i.cast_succ` and `i.succ` to `i`. -/\ndef finSuccEquiv' (i : Fin (n + 1)) : Fin (n + 1) \u2243 Option (Fin n)\n    where\n  toFun := i.insertNth none some\n  invFun x := x.casesOn' i (Fin.succAbove i)\n  left_inv x := Fin.succAboveCases i (by simp) (fun j => by simp) x\n  right_inv x := by cases x <;> dsimp <;> simp\n#align fin_succ_equiv' finSuccEquiv'\n\n@[simp]\ntheorem finSuccEquiv'_at (i : Fin (n + 1)) : (finSuccEquiv' i) i = none := by\n  simp [finSuccEquiv']\n#align fin_succ_equiv'_at finSuccEquiv'_at\n\n@[simp]\ntheorem finSuccEquiv'_succAbove (i : Fin (n + 1)) (j : Fin n) :\n    finSuccEquiv' i (i.succAbove j) = some j :=\n  @Fin.insertNth_apply_succAbove n (fun _ => Option (Fin n)) i _ _ _\n#align fin_succ_equiv'_succ_above finSuccEquiv'_succAbove\n\ntheorem finSuccEquiv'_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i) (Fin.castSucc m) = m := by\n  rw [\u2190 Fin.succAbove_of_castSucc_lt _ _ h, finSuccEquiv'_succAbove]\n#align fin_succ_equiv'_below finSuccEquiv'_below\n\ntheorem finSuccEquiv'_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i) m.succ = some m := by\n  rw [\u2190 Fin.succAbove_of_le_castSucc _ _ h, finSuccEquiv'_succAbove]\n#align fin_succ_equiv'_above finSuccEquiv'_above\n\n@[simp]\ntheorem finSuccEquiv'_symm_none (i : Fin (n + 1)) : (finSuccEquiv' i).symm none = i :=\n  rfl\n#align fin_succ_equiv'_symm_none finSuccEquiv'_symm_none\n\n@[simp]\ntheorem finSuccEquiv'_symm_some (i : Fin (n + 1)) (j : Fin n) :\n    (finSuccEquiv' i).symm (some j) = i.succAbove j :=\n  rfl\n#align fin_succ_equiv'_symm_some finSuccEquiv'_symm_some\n\ntheorem finSuccEquiv'_symm_some_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm (some m) = Fin.castSucc m :=\n  Fin.succAbove_of_castSucc_lt i m h\n#align fin_succ_equiv'_symm_some_below finSuccEquiv'_symm_some_below\n\ntheorem finSuccEquiv'_symm_some_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i).symm (some m) = m.succ :=\n  Fin.succAbove_of_le_castSucc i m h\n#align fin_succ_equiv'_symm_some_above finSuccEquiv'_symm_some_above\n\ntheorem finSuccEquiv'_symm_coe_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm m = Fin.castSucc m :=\n  finSuccEquiv'_symm_some_below h\n#align fin_succ_equiv'_symm_coe_below finSuccEquiv'_symm_coe_below\n\ntheorem finSuccEquiv'_symm_coe_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i).symm m = m.succ :=\n  finSuccEquiv'_symm_some_above h\n#align fin_succ_equiv'_symm_coe_above finSuccEquiv'_symm_coe_above\n\n/-- Equivalence between `Fin (n + 1)` and `Option (Fin n)`.\nThis is a version of `Fin.pred` that produces `Option (Fin n)` instead of\nrequiring a proof that the input is not `0`. -/\ndef finSuccEquiv (n : \u2115) : Fin (n + 1) \u2243 Option (Fin n) :=\n  finSuccEquiv' 0\n#align fin_succ_equiv finSuccEquiv\n\n@[simp]\ntheorem finSuccEquiv_zero : (finSuccEquiv n) 0 = none :=\n  rfl\n#align fin_succ_equiv_zero finSuccEquiv_zero\n\n@[simp]\ntheorem finSuccEquiv_succ (m : Fin n) : (finSuccEquiv n) m.succ = some m :=\n  finSuccEquiv'_above (Fin.zero_le _)\n#align fin_succ_equiv_succ finSuccEquiv_succ\n\n@[simp]\ntheorem finSuccEquiv_symm_none : (finSuccEquiv n).symm none = 0 :=\n  finSuccEquiv'_symm_none _\n#align fin_succ_equiv_symm_none finSuccEquiv_symm_none\n\n@[simp]\ntheorem finSuccEquiv_symm_some (m : Fin n) : (finSuccEquiv n).symm (some m) = m.succ :=\n  congr_fun Fin.succAbove_zero m\n#align fin_succ_equiv_symm_some finSuccEquiv_symm_some\n#align fin_succ_equiv_symm_coe finSuccEquiv_symm_some\n\n/-- The equiv version of `Fin.predAbove_zero`. -/\ntheorem finSuccEquiv'_zero : finSuccEquiv' (0 : Fin (n + 1)) = finSuccEquiv n :=\n  rfl\n#align fin_succ_equiv'_zero finSuccEquiv'_zero\n\ntheorem finSuccEquiv'_last_apply_castSucc (i : Fin n) :\n    finSuccEquiv' (Fin.last n) (Fin.castSucc i) = i := by\n  rw [\u2190 Fin.succAbove_last, finSuccEquiv'_succAbove]\n\ntheorem finSuccEquiv'_last_apply {i : Fin (n + 1)} (h : i \u2260 Fin.last n) :\n    finSuccEquiv' (Fin.last n) i = Fin.castLT i (Fin.val_lt_last h) := by\n  rcases Fin.exists_castSucc_eq.2 h with \u27e8i, rfl\u27e9\n  rw [finSuccEquiv'_last_apply_castSucc]\n  rfl\n#align fin_succ_equiv'_last_apply finSuccEquiv'_last_apply\n\ntheorem finSuccEquiv'_ne_last_apply {i j : Fin (n + 1)} (hi : i \u2260 Fin.last n) (hj : j \u2260 i) :\n    finSuccEquiv' i j = (i.castLT (Fin.val_lt_last hi)).predAbove j := by\n  rcases Fin.exists_succAbove_eq hj with \u27e8j, rfl\u27e9\n  rcases Fin.exists_castSucc_eq.2 hi with \u27e8i, rfl\u27e9\n  simp\n#align fin_succ_equiv'_ne_last_apply finSuccEquiv'_ne_last_apply\n\n/-- `Fin.succAbove` as an order isomorphism between `Fin n` and `{x : Fin (n + 1) // x \u2260 p}`. -/\ndef finSuccAboveEquiv (p : Fin (n + 1)) : Fin n \u2243o { x : Fin (n + 1) // x \u2260 p } :=\n  { Equiv.optionSubtype p \u27e8(finSuccEquiv' p).symm, rfl\u27e9 with\n    map_rel_iff' := p.succAboveEmb.map_rel_iff' }\n#align fin_succ_above_equiv finSuccAboveEquiv\n\ntheorem finSuccAboveEquiv_apply (p : Fin (n + 1)) (i : Fin n) :\n    finSuccAboveEquiv p i = \u27e8p.succAbove i, p.succAbove_ne i\u27e9 :=\n  rfl\n#align fin_succ_above_equiv_apply finSuccAboveEquiv_apply\n\ntheorem finSuccAboveEquiv_symm_apply_last (x : { x : Fin (n + 1) // x \u2260 Fin.last n }) :\n    (finSuccAboveEquiv (Fin.last n)).symm x = Fin.castLT x.1 (Fin.val_lt_last x.2) := by\n  rw [\u2190 Option.some_inj]\n  simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_last_apply x.property\n#align fin_succ_above_equiv_symm_apply_last finSuccAboveEquiv_symm_apply_last\n\ntheorem finSuccAboveEquiv_symm_apply_ne_last {p : Fin (n + 1)} (h : p \u2260 Fin.last n)\n    (x : { x : Fin (n + 1) // x \u2260 p }) :\n    (finSuccAboveEquiv p).symm x = (p.castLT (Fin.val_lt_last h)).predAbove x := by\n  rw [\u2190 Option.some_inj]\n  simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_ne_last_apply h x.property\n#align fin_succ_above_equiv_symm_apply_ne_last finSuccAboveEquiv_symm_apply_ne_last\n\n/-- `Equiv` between `Fin (n + 1)` and `Option (Fin n)` sending `Fin.last n` to `none` -/\ndef finSuccEquivLast : Fin (n + 1) \u2243 Option (Fin n) :=\n  finSuccEquiv' (Fin.last n)\n#align fin_succ_equiv_last finSuccEquivLast\n\n@[simp]\ntheorem finSuccEquivLast_castSucc (i : Fin n) : finSuccEquivLast (Fin.castSucc i) = some i :=\n  finSuccEquiv'_below i.2\n#align fin_succ_equiv_last_cast_succ finSuccEquivLast_castSucc\n\n@[simp]\ntheorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none := by\n  simp [finSuccEquivLast]\n#align fin_succ_equiv_last_last finSuccEquivLast_last\n\n@[simp]\ntheorem finSuccEquivLast_symm_some (i : Fin n) :\n    finSuccEquivLast.symm (some i) = Fin.castSucc i :=\n  finSuccEquiv'_symm_some_below i.2\n#align fin_succ_equiv_last_symm_some finSuccEquivLast_symm_some\n#align fin_succ_equiv_last_symm_coe finSuccEquivLast_symm_some\n\n@[simp] theorem finSuccEquivLast_symm_none : finSuccEquivLast.symm none = Fin.last n :=\n  finSuccEquiv'_symm_none _\n#align fin_succ_equiv_last_symm_none finSuccEquivLast_symm_none\n\n/-- Equivalence between `\u03a0 j : Fin (n + 1), \u03b1 j` and `\u03b1 i \u00d7 \u03a0 j : Fin n, \u03b1 (Fin.succAbove i j)`. -/\n@[simps (config := .asFn)]\ndef Equiv.piFinSuccAbove (\u03b1 : Fin (n + 1) \u2192 Type u) (i : Fin (n + 1)) :\n    (\u2200 j, \u03b1 j) \u2243 \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toFun f := i.extractNth f\n  invFun f := i.insertNth f.1 f.2\n  left_inv f := by simp\n  right_inv f := by simp\n#align equiv.pi_fin_succ_above_equiv Equiv.piFinSuccAbove\n#align equiv.pi_fin_succ_above_equiv_apply Equiv.piFinSuccAbove_apply\n#align equiv.pi_fin_succ_above_equiv_symm_apply Equiv.piFinSuccAbove_symm_apply\n\n/-- Order isomorphism between `\u03a0 j : Fin (n + 1), \u03b1 j` and\n`\u03b1 i \u00d7 \u03a0 j : Fin n, \u03b1 (Fin.succAbove i j)`. -/\ndef OrderIso.piFinSuccAboveIso (\u03b1 : Fin (n + 1) \u2192 Type u) [\u2200 i, LE (\u03b1 i)]\n    (i : Fin (n + 1)) : (\u2200 j, \u03b1 j) \u2243o \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toEquiv := Equiv.piFinSuccAbove \u03b1 i\n  map_rel_iff' := Iff.symm i.forall_iff_succAbove\n#align order_iso.pi_fin_succ_above_iso OrderIso.piFinSuccAboveIso\n\n/-- Equivalence between `Fin (n + 1) \u2192 \u03b2` and `\u03b2 \u00d7 (Fin n \u2192 \u03b2)`. -/\n@[simps! (config := .asFn)]\ndef Equiv.piFinSucc (n : \u2115) (\u03b2 : Type u) : (Fin (n + 1) \u2192 \u03b2) \u2243 \u03b2 \u00d7 (Fin n \u2192 \u03b2) :=\n  Equiv.piFinSuccAbove (fun _ => \u03b2) 0\n#align equiv.pi_fin_succ Equiv.piFinSucc\n#align equiv.pi_fin_succ_apply Equiv.piFinSucc_apply\n#align equiv.pi_fin_succ_symm_apply Equiv.piFinSucc_symm_apply\n\n/-- An embedding `e : Fin (n+1) \u21aa \u03b9` corresponds to an embedding `f : Fin n \u21aa \u03b9` (corresponding\nthe last `n` coordinates of `e`) together with a value not taken by `f` (corresponding to `e 0`). -/\ndef Equiv.embeddingFinSucc (n : \u2115) (\u03b9 : Type*) :\n    (Fin (n+1) \u21aa \u03b9) \u2243 (\u03a3 (e : Fin n \u21aa \u03b9), {i // i \u2209 Set.range e}) :=\n  ((finSuccEquiv n).embeddingCongr (Equiv.refl \u03b9)).trans\n    (Function.Embedding.optionEmbeddingEquiv (Fin n) \u03b9)\n\n@[simp] lemma Equiv.embeddingFinSucc_fst {n : \u2115} {\u03b9 : Type*} (e : Fin (n+1) \u21aa \u03b9) :\n    ((Equiv.embeddingFinSucc n \u03b9 e).1 : Fin n \u2192 \u03b9) = e \u2218 Fin.succ := rfl\n\n@[simp] lemma Equiv.embeddingFinSucc_snd {n : \u2115} {\u03b9 : Type*} (e : Fin (n+1) \u21aa \u03b9) :\n    ((Equiv.embeddingFinSucc n \u03b9 e).2 : \u03b9) = e 0 := rfl\n\n", "theoremStatement": "@[simp] lemma Equiv.coe_embeddingFinSucc_symm {n : \u2115} {\u03b9 : Type*}\n    (f : \u03a3 (e : Fin n \u21aa \u03b9), {i // i \u2209 Set.range e}) :\n    ((Equiv.embeddingFinSucc n \u03b9).symm f : Fin (n + 1) \u2192 \u03b9) = Fin.cons f.2.1 f.1", "theoremName": "Equiv.coe_embeddingFinSucc_symm", "fileCreated": {"commit": "885e8510c4", "date": "2023-01-23"}, "theoremCreated": {"commit": "98843f5bd5", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Logic/Equiv/Fin.lean", "positionMetadata": {"lineInFile": 331, "tokenPositionInFile": 13988, "theoremPositionInFile": 51}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  ext i\n  exact Fin.cases rfl (fun j \u21a6 rfl) i", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 48}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.Group.Prod\nimport Mathlib.Order.Cover\n\n#align_import algebra.support from \"leanprover-community/mathlib\"@\"29cb56a7b35f72758b05a30490e1f10bd62c35c1\"\n\n/-!\n# Support of a function\n\nIn this file we define `Function.support f = {x | f x \u2260 0}` and prove its basic properties.\nWe also define `Function.mulSupport f = {x | f x \u2260 1}`.\n-/\n\n\nopen Set\n\nnamespace Function\n\nvariable {\u03b1 \u03b2 A B M N P R S G M\u2080 G\u2080 : Type*} {\u03b9 : Sort*}\n\nsection One\n\nvariable [One M] [One N] [One P]\n\n/-- `support` of a function is the set of points `x` such that `f x \u2260 0`. -/\ndef support [Zero A] (f : \u03b1 \u2192 A) : Set \u03b1 :=\n  { x | f x \u2260 0 }\n#align function.support Function.support\n\n/-- `mulSupport` of a function is the set of points `x` such that `f x \u2260 1`. -/\n@[to_additive existing]\ndef mulSupport (f : \u03b1 \u2192 M) : Set \u03b1 :=\n  { x | f x \u2260 1 }\n#align function.mul_support Function.mulSupport\n\n@[to_additive]\ntheorem mulSupport_eq_preimage (f : \u03b1 \u2192 M) : mulSupport f = f \u207b\u00b9' {1}\u1d9c :=\n  rfl\n#align function.mul_support_eq_preimage Function.mulSupport_eq_preimage\n#align function.support_eq_preimage Function.support_eq_preimage\n\n@[to_additive]\ntheorem nmem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2209 mulSupport f \u2194 f x = 1 :=\n  not_not\n#align function.nmem_mul_support Function.nmem_mulSupport\n#align function.nmem_support Function.nmem_support\n\n@[to_additive]\ntheorem compl_mulSupport {f : \u03b1 \u2192 M} : (mulSupport f)\u1d9c = { x | f x = 1 } :=\n  ext fun _ => nmem_mulSupport\n#align function.compl_mul_support Function.compl_mulSupport\n#align function.compl_support Function.compl_support\n\n@[to_additive (attr := simp)]\ntheorem mem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2208 mulSupport f \u2194 f x \u2260 1 :=\n  Iff.rfl\n#align function.mem_mul_support Function.mem_mulSupport\n#align function.mem_support Function.mem_support\n\n@[to_additive (attr := simp)]\ntheorem mulSupport_subset_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} : mulSupport f \u2286 s \u2194 \u2200 x, f x \u2260 1 \u2192 x \u2208 s :=\n  Iff.rfl\n#align function.mul_support_subset_iff Function.mulSupport_subset_iff\n#align function.support_subset_iff Function.support_subset_iff\n\n@[to_additive]\ntheorem mulSupport_subset_iff' {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f \u2286 s \u2194 \u2200 x \u2209 s, f x = 1 :=\n  forall_congr' fun _ => not_imp_comm\n#align function.mul_support_subset_iff' Function.mulSupport_subset_iff'\n#align function.support_subset_iff' Function.support_subset_iff'\n\n@[to_additive]\ntheorem mulSupport_eq_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f = s \u2194 (\u2200 x, x \u2208 s \u2192 f x \u2260 1) \u2227 \u2200 x, x \u2209 s \u2192 f x = 1 := by\n  simp (config := { contextual := true }) only [ext_iff, mem_mulSupport, ne_eq, iff_def,\n    not_imp_comm, and_comm, forall_and]\n#align function.mul_support_eq_iff Function.mulSupport_eq_iff\n#align function.support_eq_iff Function.support_eq_iff\n\n", "theoremStatement": "@[to_additive]\ntheorem ext_iff_mulSupport {f g : \u03b1 \u2192 M} :\n    f = g \u2194 f.mulSupport = g.mulSupport \u2227 \u2200 x \u2208 f.mulSupport, f x = g x", "theoremName": "ext_iff_mulSupport", "fileCreated": {"commit": "82ddb54f6c", "date": "2023-12-13"}, "theoremCreated": {"commit": "1342b9e13a", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Function/Support.lean", "positionMetadata": {"lineInFile": 85, "tokenPositionInFile": 2889, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "\u27e8fun h \u21a6 h \u25b8 \u27e8rfl, fun _ _ \u21a6 rfl\u27e9, fun \u27e8h\u2081, h\u2082\u27e9 \u21a6 funext fun x \u21a6 by\n    if hx : x \u2208 f.mulSupport then exact h\u2082 x hx\n    else rw [nmem_mulSupport.1 hx, nmem_mulSupport.1 (mt (Set.ext_iff.1 h\u2081 x).2 hx)]\u27e9", "proofType": "term", "proofLengthLines": 3, "proofLengthTokens": 201}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.Group.Prod\nimport Mathlib.Order.Cover\n\n#align_import algebra.support from \"leanprover-community/mathlib\"@\"29cb56a7b35f72758b05a30490e1f10bd62c35c1\"\n\n/-!\n# Support of a function\n\nIn this file we define `Function.support f = {x | f x \u2260 0}` and prove its basic properties.\nWe also define `Function.mulSupport f = {x | f x \u2260 1}`.\n-/\n\n\nopen Set\n\nnamespace Function\n\nvariable {\u03b1 \u03b2 A B M N P R S G M\u2080 G\u2080 : Type*} {\u03b9 : Sort*}\n\nsection One\n\nvariable [One M] [One N] [One P]\n\n/-- `support` of a function is the set of points `x` such that `f x \u2260 0`. -/\ndef support [Zero A] (f : \u03b1 \u2192 A) : Set \u03b1 :=\n  { x | f x \u2260 0 }\n#align function.support Function.support\n\n/-- `mulSupport` of a function is the set of points `x` such that `f x \u2260 1`. -/\n@[to_additive existing]\ndef mulSupport (f : \u03b1 \u2192 M) : Set \u03b1 :=\n  { x | f x \u2260 1 }\n#align function.mul_support Function.mulSupport\n\n@[to_additive]\ntheorem mulSupport_eq_preimage (f : \u03b1 \u2192 M) : mulSupport f = f \u207b\u00b9' {1}\u1d9c :=\n  rfl\n#align function.mul_support_eq_preimage Function.mulSupport_eq_preimage\n#align function.support_eq_preimage Function.support_eq_preimage\n\n@[to_additive]\ntheorem nmem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2209 mulSupport f \u2194 f x = 1 :=\n  not_not\n#align function.nmem_mul_support Function.nmem_mulSupport\n#align function.nmem_support Function.nmem_support\n\n@[to_additive]\ntheorem compl_mulSupport {f : \u03b1 \u2192 M} : (mulSupport f)\u1d9c = { x | f x = 1 } :=\n  ext fun _ => nmem_mulSupport\n#align function.compl_mul_support Function.compl_mulSupport\n#align function.compl_support Function.compl_support\n\n@[to_additive (attr := simp)]\ntheorem mem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2208 mulSupport f \u2194 f x \u2260 1 :=\n  Iff.rfl\n#align function.mem_mul_support Function.mem_mulSupport\n#align function.mem_support Function.mem_support\n\n@[to_additive (attr := simp)]\ntheorem mulSupport_subset_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} : mulSupport f \u2286 s \u2194 \u2200 x, f x \u2260 1 \u2192 x \u2208 s :=\n  Iff.rfl\n#align function.mul_support_subset_iff Function.mulSupport_subset_iff\n#align function.support_subset_iff Function.support_subset_iff\n\n@[to_additive]\ntheorem mulSupport_subset_iff' {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f \u2286 s \u2194 \u2200 x \u2209 s, f x = 1 :=\n  forall_congr' fun _ => not_imp_comm\n#align function.mul_support_subset_iff' Function.mulSupport_subset_iff'\n#align function.support_subset_iff' Function.support_subset_iff'\n\n@[to_additive]\ntheorem mulSupport_eq_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f = s \u2194 (\u2200 x, x \u2208 s \u2192 f x \u2260 1) \u2227 \u2200 x, x \u2209 s \u2192 f x = 1 := by\n  simp (config := { contextual := true }) only [ext_iff, mem_mulSupport, ne_eq, iff_def,\n    not_imp_comm, and_comm, forall_and]\n#align function.mul_support_eq_iff Function.mulSupport_eq_iff\n#align function.support_eq_iff Function.support_eq_iff\n\n@[to_additive]\ntheorem ext_iff_mulSupport {f g : \u03b1 \u2192 M} :\n    f = g \u2194 f.mulSupport = g.mulSupport \u2227 \u2200 x \u2208 f.mulSupport, f x = g x :=\n  \u27e8fun h \u21a6 h \u25b8 \u27e8rfl, fun _ _ \u21a6 rfl\u27e9, fun \u27e8h\u2081, h\u2082\u27e9 \u21a6 funext fun x \u21a6 by\n    if hx : x \u2208 f.mulSupport then exact h\u2082 x hx\n    else rw [nmem_mulSupport.1 hx, nmem_mulSupport.1 (mt (Set.ext_iff.1 h\u2081 x).2 hx)]\u27e9\n\n", "theoremStatement": "@[to_additive]\ntheorem mulSupport_update_of_ne_one [DecidableEq \u03b1] (f : \u03b1 \u2192 M) (x : \u03b1) {y : M} (hy : y \u2260 1) :\n    mulSupport (update f x y) = insert x (mulSupport f)", "theoremName": "mulSupport_update_of_ne_one", "fileCreated": {"commit": "82ddb54f6c", "date": "2023-12-13"}, "theoremCreated": {"commit": "1342b9e13a", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Function/Support.lean", "positionMetadata": {"lineInFile": 92, "tokenPositionInFile": 3227, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 59}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.Group.Prod\nimport Mathlib.Order.Cover\n\n#align_import algebra.support from \"leanprover-community/mathlib\"@\"29cb56a7b35f72758b05a30490e1f10bd62c35c1\"\n\n/-!\n# Support of a function\n\nIn this file we define `Function.support f = {x | f x \u2260 0}` and prove its basic properties.\nWe also define `Function.mulSupport f = {x | f x \u2260 1}`.\n-/\n\n\nopen Set\n\nnamespace Function\n\nvariable {\u03b1 \u03b2 A B M N P R S G M\u2080 G\u2080 : Type*} {\u03b9 : Sort*}\n\nsection One\n\nvariable [One M] [One N] [One P]\n\n/-- `support` of a function is the set of points `x` such that `f x \u2260 0`. -/\ndef support [Zero A] (f : \u03b1 \u2192 A) : Set \u03b1 :=\n  { x | f x \u2260 0 }\n#align function.support Function.support\n\n/-- `mulSupport` of a function is the set of points `x` such that `f x \u2260 1`. -/\n@[to_additive existing]\ndef mulSupport (f : \u03b1 \u2192 M) : Set \u03b1 :=\n  { x | f x \u2260 1 }\n#align function.mul_support Function.mulSupport\n\n@[to_additive]\ntheorem mulSupport_eq_preimage (f : \u03b1 \u2192 M) : mulSupport f = f \u207b\u00b9' {1}\u1d9c :=\n  rfl\n#align function.mul_support_eq_preimage Function.mulSupport_eq_preimage\n#align function.support_eq_preimage Function.support_eq_preimage\n\n@[to_additive]\ntheorem nmem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2209 mulSupport f \u2194 f x = 1 :=\n  not_not\n#align function.nmem_mul_support Function.nmem_mulSupport\n#align function.nmem_support Function.nmem_support\n\n@[to_additive]\ntheorem compl_mulSupport {f : \u03b1 \u2192 M} : (mulSupport f)\u1d9c = { x | f x = 1 } :=\n  ext fun _ => nmem_mulSupport\n#align function.compl_mul_support Function.compl_mulSupport\n#align function.compl_support Function.compl_support\n\n@[to_additive (attr := simp)]\ntheorem mem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2208 mulSupport f \u2194 f x \u2260 1 :=\n  Iff.rfl\n#align function.mem_mul_support Function.mem_mulSupport\n#align function.mem_support Function.mem_support\n\n@[to_additive (attr := simp)]\ntheorem mulSupport_subset_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} : mulSupport f \u2286 s \u2194 \u2200 x, f x \u2260 1 \u2192 x \u2208 s :=\n  Iff.rfl\n#align function.mul_support_subset_iff Function.mulSupport_subset_iff\n#align function.support_subset_iff Function.support_subset_iff\n\n@[to_additive]\ntheorem mulSupport_subset_iff' {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f \u2286 s \u2194 \u2200 x \u2209 s, f x = 1 :=\n  forall_congr' fun _ => not_imp_comm\n#align function.mul_support_subset_iff' Function.mulSupport_subset_iff'\n#align function.support_subset_iff' Function.support_subset_iff'\n\n@[to_additive]\ntheorem mulSupport_eq_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f = s \u2194 (\u2200 x, x \u2208 s \u2192 f x \u2260 1) \u2227 \u2200 x, x \u2209 s \u2192 f x = 1 := by\n  simp (config := { contextual := true }) only [ext_iff, mem_mulSupport, ne_eq, iff_def,\n    not_imp_comm, and_comm, forall_and]\n#align function.mul_support_eq_iff Function.mulSupport_eq_iff\n#align function.support_eq_iff Function.support_eq_iff\n\n@[to_additive]\ntheorem ext_iff_mulSupport {f g : \u03b1 \u2192 M} :\n    f = g \u2194 f.mulSupport = g.mulSupport \u2227 \u2200 x \u2208 f.mulSupport, f x = g x :=\n  \u27e8fun h \u21a6 h \u25b8 \u27e8rfl, fun _ _ \u21a6 rfl\u27e9, fun \u27e8h\u2081, h\u2082\u27e9 \u21a6 funext fun x \u21a6 by\n    if hx : x \u2208 f.mulSupport then exact h\u2082 x hx\n    else rw [nmem_mulSupport.1 hx, nmem_mulSupport.1 (mt (Set.ext_iff.1 h\u2081 x).2 hx)]\u27e9\n\n@[to_additive]\ntheorem mulSupport_update_of_ne_one [DecidableEq \u03b1] (f : \u03b1 \u2192 M) (x : \u03b1) {y : M} (hy : y \u2260 1) :\n    mulSupport (update f x y) = insert x (mulSupport f) := by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]\n\n", "theoremStatement": "@[to_additive]\ntheorem mulSupport_update_one [DecidableEq \u03b1] (f : \u03b1 \u2192 M) (x : \u03b1) :\n    mulSupport (update f x 1) = mulSupport f \\ {x}", "theoremName": "mulSupport_update_one", "fileCreated": {"commit": "82ddb54f6c", "date": "2023-12-13"}, "theoremCreated": {"commit": "1342b9e13a", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Function/Support.lean", "positionMetadata": {"lineInFile": 97, "tokenPositionInFile": 3457, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 59}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.Group.Prod\nimport Mathlib.Order.Cover\n\n#align_import algebra.support from \"leanprover-community/mathlib\"@\"29cb56a7b35f72758b05a30490e1f10bd62c35c1\"\n\n/-!\n# Support of a function\n\nIn this file we define `Function.support f = {x | f x \u2260 0}` and prove its basic properties.\nWe also define `Function.mulSupport f = {x | f x \u2260 1}`.\n-/\n\n\nopen Set\n\nnamespace Function\n\nvariable {\u03b1 \u03b2 A B M N P R S G M\u2080 G\u2080 : Type*} {\u03b9 : Sort*}\n\nsection One\n\nvariable [One M] [One N] [One P]\n\n/-- `support` of a function is the set of points `x` such that `f x \u2260 0`. -/\ndef support [Zero A] (f : \u03b1 \u2192 A) : Set \u03b1 :=\n  { x | f x \u2260 0 }\n#align function.support Function.support\n\n/-- `mulSupport` of a function is the set of points `x` such that `f x \u2260 1`. -/\n@[to_additive existing]\ndef mulSupport (f : \u03b1 \u2192 M) : Set \u03b1 :=\n  { x | f x \u2260 1 }\n#align function.mul_support Function.mulSupport\n\n@[to_additive]\ntheorem mulSupport_eq_preimage (f : \u03b1 \u2192 M) : mulSupport f = f \u207b\u00b9' {1}\u1d9c :=\n  rfl\n#align function.mul_support_eq_preimage Function.mulSupport_eq_preimage\n#align function.support_eq_preimage Function.support_eq_preimage\n\n@[to_additive]\ntheorem nmem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2209 mulSupport f \u2194 f x = 1 :=\n  not_not\n#align function.nmem_mul_support Function.nmem_mulSupport\n#align function.nmem_support Function.nmem_support\n\n@[to_additive]\ntheorem compl_mulSupport {f : \u03b1 \u2192 M} : (mulSupport f)\u1d9c = { x | f x = 1 } :=\n  ext fun _ => nmem_mulSupport\n#align function.compl_mul_support Function.compl_mulSupport\n#align function.compl_support Function.compl_support\n\n@[to_additive (attr := simp)]\ntheorem mem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2208 mulSupport f \u2194 f x \u2260 1 :=\n  Iff.rfl\n#align function.mem_mul_support Function.mem_mulSupport\n#align function.mem_support Function.mem_support\n\n@[to_additive (attr := simp)]\ntheorem mulSupport_subset_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} : mulSupport f \u2286 s \u2194 \u2200 x, f x \u2260 1 \u2192 x \u2208 s :=\n  Iff.rfl\n#align function.mul_support_subset_iff Function.mulSupport_subset_iff\n#align function.support_subset_iff Function.support_subset_iff\n\n@[to_additive]\ntheorem mulSupport_subset_iff' {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f \u2286 s \u2194 \u2200 x \u2209 s, f x = 1 :=\n  forall_congr' fun _ => not_imp_comm\n#align function.mul_support_subset_iff' Function.mulSupport_subset_iff'\n#align function.support_subset_iff' Function.support_subset_iff'\n\n@[to_additive]\ntheorem mulSupport_eq_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f = s \u2194 (\u2200 x, x \u2208 s \u2192 f x \u2260 1) \u2227 \u2200 x, x \u2209 s \u2192 f x = 1 := by\n  simp (config := { contextual := true }) only [ext_iff, mem_mulSupport, ne_eq, iff_def,\n    not_imp_comm, and_comm, forall_and]\n#align function.mul_support_eq_iff Function.mulSupport_eq_iff\n#align function.support_eq_iff Function.support_eq_iff\n\n@[to_additive]\ntheorem ext_iff_mulSupport {f g : \u03b1 \u2192 M} :\n    f = g \u2194 f.mulSupport = g.mulSupport \u2227 \u2200 x \u2208 f.mulSupport, f x = g x :=\n  \u27e8fun h \u21a6 h \u25b8 \u27e8rfl, fun _ _ \u21a6 rfl\u27e9, fun \u27e8h\u2081, h\u2082\u27e9 \u21a6 funext fun x \u21a6 by\n    if hx : x \u2208 f.mulSupport then exact h\u2082 x hx\n    else rw [nmem_mulSupport.1 hx, nmem_mulSupport.1 (mt (Set.ext_iff.1 h\u2081 x).2 hx)]\u27e9\n\n@[to_additive]\ntheorem mulSupport_update_of_ne_one [DecidableEq \u03b1] (f : \u03b1 \u2192 M) (x : \u03b1) {y : M} (hy : y \u2260 1) :\n    mulSupport (update f x y) = insert x (mulSupport f) := by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]\n\n@[to_additive]\ntheorem mulSupport_update_one [DecidableEq \u03b1] (f : \u03b1 \u2192 M) (x : \u03b1) :\n    mulSupport (update f x 1) = mulSupport f \\ {x} := by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]\n\n", "theoremStatement": "@[to_additive]\ntheorem mulSupport_update_eq_ite [DecidableEq \u03b1] [DecidableEq M] (f : \u03b1 \u2192 M) (x : \u03b1) (y : M) :\n    mulSupport (update f x y) = if y = 1 then mulSupport f \\ {x} else insert x (mulSupport f)", "theoremName": "mulSupport_update_eq_ite", "fileCreated": {"commit": "82ddb54f6c", "date": "2023-12-13"}, "theoremCreated": {"commit": "1342b9e13a", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Function/Support.lean", "positionMetadata": {"lineInFile": 102, "tokenPositionInFile": 3655, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rcases eq_or_ne y 1 with rfl | hy <;> simp [mulSupport_update_one, mulSupport_update_of_ne_one, *]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 103}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\nimport Mathlib.RingTheory.QuotientNilpotent\nimport Mathlib.RingTheory.Smooth.Basic\nimport Mathlib.RingTheory.Unramified.Basic\n\n#align_import ring_theory.etale from \"leanprover-community/mathlib\"@\"73f96237417835f148a1f7bc1ff55f67119b7166\"\n\n/-!\n\n# Etale morphisms\n\nAn `R`-algebra `A` is formally \u00e9tale if for every `R`-algebra,\nevery square-zero ideal `I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists\nexactly one lift `A \u2192\u2090[R] B`.\nIt is \u00e9tale if it is formally \u00e9tale and of finite presentation.\n\nWe show that the property extends onto nilpotent ideals, and that these properties are stable\nunder `R`-algebra homomorphisms and compositions.\n\nWe show that \u00e9tale is stable under algebra isomorphisms, composition and\nlocalization at an element.\n\n## TODO:\n\n- Show that \u00e9tale is stable under base change.\n\n-/\n\n\n-- Porting note: added to make the syntax work below.\nopen scoped TensorProduct\n\nuniverse u\n\nnamespace Algebra\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R` algebra `A` is formally \u00e9tale if for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists exactly one lift `A \u2192\u2090[R] B`. -/\n@[mk_iff]\nclass FormallyEtale : Prop where\n  comp_bijective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Bijective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)\n#align algebra.formally_etale Algebra.FormallyEtale\n\nend\n\nnamespace FormallyEtale\n\nsection\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable {B : Type u} [CommRing B] [Algebra R B] (I : Ideal B)\n\ntheorem iff_unramified_and_smooth :\n    FormallyEtale R A \u2194 FormallyUnramified R A \u2227 FormallySmooth R A := by\n  rw [formallyUnramified_iff, formallySmooth_iff, formallyEtale_iff]\n  simp_rw [\u2190 forall_and, Function.Bijective]\n#align algebra.formally_etale.iff_unramified_and_smooth Algebra.FormallyEtale.iff_unramified_and_smooth\n\ninstance (priority := 100) to_unramified [h : FormallyEtale R A] :\n    FormallyUnramified R A :=\n  (FormallyEtale.iff_unramified_and_smooth.mp h).1\n#align algebra.formally_etale.to_unramified Algebra.FormallyEtale.to_unramified\n\ninstance (priority := 100) to_smooth [h : FormallyEtale R A] : FormallySmooth R A :=\n  (FormallyEtale.iff_unramified_and_smooth.mp h).2\n#align algebra.formally_etale.to_smooth Algebra.FormallyEtale.to_smooth\n\ntheorem of_unramified_and_smooth [h\u2081 : FormallyUnramified R A]\n    [h\u2082 : FormallySmooth R A] : FormallyEtale R A :=\n  FormallyEtale.iff_unramified_and_smooth.mpr \u27e8h\u2081, h\u2082\u27e9\n#align algebra.formally_etale.of_unramified_and_smooth Algebra.FormallyEtale.of_unramified_and_smooth\n\nend\n\nsection OfEquiv\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A B : Type u} [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]\n\ntheorem of_equiv [FormallyEtale R A] (e : A \u2243\u2090[R] B) : FormallyEtale R B :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.of_equiv e, FormallySmooth.of_equiv e\u27e9\n#align algebra.formally_etale.of_equiv Algebra.FormallyEtale.of_equiv\n\nend OfEquiv\n\nsection Comp\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [CommSemiring A] [Algebra R A]\nvariable (B : Type u) [Semiring B] [Algebra R B] [Algebra A B] [IsScalarTower R A B]\n\ntheorem comp [FormallyEtale R A] [FormallyEtale A B] : FormallyEtale R B :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.comp R A B, FormallySmooth.comp R A B\u27e9\n#align algebra.formally_etale.comp Algebra.FormallyEtale.comp\n\nend Comp\n\nsection BaseChange\n\nopen scoped TensorProduct\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable (B : Type u) [CommSemiring B] [Algebra R B]\n\ninstance base_change [FormallyEtale R A] : FormallyEtale B (B \u2297[R] A) :=\n  FormallyEtale.iff_unramified_and_smooth.mpr \u27e8inferInstance, inferInstance\u27e9\n#align algebra.formally_etale.base_change Algebra.FormallyEtale.base_change\n\nend BaseChange\n\nsection Localization\n\nvariable {R S R\u2098 S\u2098 : Type u} [CommRing R] [CommRing S] [CommRing R\u2098] [CommRing S\u2098]\nvariable (M : Submonoid R)\nvariable [Algebra R S] [Algebra R S\u2098] [Algebra S S\u2098] [Algebra R R\u2098] [Algebra R\u2098 S\u2098]\nvariable [IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]\nvariable [IsLocalization M R\u2098] [IsLocalization (M.map (algebraMap R S)) S\u2098]\n\n-- Porting note: no longer supported\n-- attribute [local elab_as_elim] Ideal.IsNilpotent.induction_on\n\ntheorem of_isLocalization : FormallyEtale R R\u2098 :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.of_isLocalization M, FormallySmooth.of_isLocalization M\u27e9\n#align algebra.formally_etale.of_is_localization Algebra.FormallyEtale.of_isLocalization\n\ntheorem localization_base [FormallyEtale R S\u2098] : FormallyEtale R\u2098 S\u2098 :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.localization_base M, FormallySmooth.localization_base M\u27e9\n#align algebra.formally_etale.localization_base Algebra.FormallyEtale.localization_base\n\ntheorem localization_map [FormallyEtale R S] : FormallyEtale R\u2098 S\u2098 := by\n  haveI : FormallyEtale S S\u2098 := FormallyEtale.of_isLocalization (M.map (algebraMap R S))\n  haveI : FormallyEtale R S\u2098 := FormallyEtale.comp R S S\u2098\n  exact FormallyEtale.localization_base M\n#align algebra.formally_etale.localization_map Algebra.FormallyEtale.localization_map\n\nend Localization\n\nend FormallyEtale\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is \u00e9tale if it is formally \u00e9tale and of finite presentation. -/\nclass Etale : Prop where\n  formallyEtale : FormallyEtale R A := by infer_instance\n  finitePresentation : FinitePresentation R A := by infer_instance\n\nend\n\nnamespace Etale\n\nattribute [instance] formallyEtale finitePresentation\n\nvariable {R : Type u} [CommRing R]\nvariable {A B : Type u} [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]\n\n/-- Being \u00e9tale is transported via algebra isomorphisms. -/\n", "theoremStatement": "theorem of_equiv [Etale R A] (e : A \u2243\u2090[R] B) : Etale R B", "theoremName": "of_equiv", "fileCreated": {"commit": "d991fe8f80", "date": "2024-04-08"}, "theoremCreated": {"commit": "c9ab842e13", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/Etale/Basic.lean", "positionMetadata": {"lineInFile": 178, "tokenPositionInFile": 6134, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "where\n  formallyEtale := FormallyEtale.of_equiv e\n  finitePresentation := FinitePresentation.equiv e", "proofType": "term", "proofLengthLines": 3, "proofLengthTokens": 100}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\nimport Mathlib.RingTheory.QuotientNilpotent\nimport Mathlib.RingTheory.Smooth.Basic\nimport Mathlib.RingTheory.Unramified.Basic\n\n#align_import ring_theory.etale from \"leanprover-community/mathlib\"@\"73f96237417835f148a1f7bc1ff55f67119b7166\"\n\n/-!\n\n# Etale morphisms\n\nAn `R`-algebra `A` is formally \u00e9tale if for every `R`-algebra,\nevery square-zero ideal `I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists\nexactly one lift `A \u2192\u2090[R] B`.\nIt is \u00e9tale if it is formally \u00e9tale and of finite presentation.\n\nWe show that the property extends onto nilpotent ideals, and that these properties are stable\nunder `R`-algebra homomorphisms and compositions.\n\nWe show that \u00e9tale is stable under algebra isomorphisms, composition and\nlocalization at an element.\n\n## TODO:\n\n- Show that \u00e9tale is stable under base change.\n\n-/\n\n\n-- Porting note: added to make the syntax work below.\nopen scoped TensorProduct\n\nuniverse u\n\nnamespace Algebra\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R` algebra `A` is formally \u00e9tale if for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists exactly one lift `A \u2192\u2090[R] B`. -/\n@[mk_iff]\nclass FormallyEtale : Prop where\n  comp_bijective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Bijective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)\n#align algebra.formally_etale Algebra.FormallyEtale\n\nend\n\nnamespace FormallyEtale\n\nsection\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable {B : Type u} [CommRing B] [Algebra R B] (I : Ideal B)\n\ntheorem iff_unramified_and_smooth :\n    FormallyEtale R A \u2194 FormallyUnramified R A \u2227 FormallySmooth R A := by\n  rw [formallyUnramified_iff, formallySmooth_iff, formallyEtale_iff]\n  simp_rw [\u2190 forall_and, Function.Bijective]\n#align algebra.formally_etale.iff_unramified_and_smooth Algebra.FormallyEtale.iff_unramified_and_smooth\n\ninstance (priority := 100) to_unramified [h : FormallyEtale R A] :\n    FormallyUnramified R A :=\n  (FormallyEtale.iff_unramified_and_smooth.mp h).1\n#align algebra.formally_etale.to_unramified Algebra.FormallyEtale.to_unramified\n\ninstance (priority := 100) to_smooth [h : FormallyEtale R A] : FormallySmooth R A :=\n  (FormallyEtale.iff_unramified_and_smooth.mp h).2\n#align algebra.formally_etale.to_smooth Algebra.FormallyEtale.to_smooth\n\ntheorem of_unramified_and_smooth [h\u2081 : FormallyUnramified R A]\n    [h\u2082 : FormallySmooth R A] : FormallyEtale R A :=\n  FormallyEtale.iff_unramified_and_smooth.mpr \u27e8h\u2081, h\u2082\u27e9\n#align algebra.formally_etale.of_unramified_and_smooth Algebra.FormallyEtale.of_unramified_and_smooth\n\nend\n\nsection OfEquiv\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A B : Type u} [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]\n\ntheorem of_equiv [FormallyEtale R A] (e : A \u2243\u2090[R] B) : FormallyEtale R B :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.of_equiv e, FormallySmooth.of_equiv e\u27e9\n#align algebra.formally_etale.of_equiv Algebra.FormallyEtale.of_equiv\n\nend OfEquiv\n\nsection Comp\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [CommSemiring A] [Algebra R A]\nvariable (B : Type u) [Semiring B] [Algebra R B] [Algebra A B] [IsScalarTower R A B]\n\ntheorem comp [FormallyEtale R A] [FormallyEtale A B] : FormallyEtale R B :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.comp R A B, FormallySmooth.comp R A B\u27e9\n#align algebra.formally_etale.comp Algebra.FormallyEtale.comp\n\nend Comp\n\nsection BaseChange\n\nopen scoped TensorProduct\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable (B : Type u) [CommSemiring B] [Algebra R B]\n\ninstance base_change [FormallyEtale R A] : FormallyEtale B (B \u2297[R] A) :=\n  FormallyEtale.iff_unramified_and_smooth.mpr \u27e8inferInstance, inferInstance\u27e9\n#align algebra.formally_etale.base_change Algebra.FormallyEtale.base_change\n\nend BaseChange\n\nsection Localization\n\nvariable {R S R\u2098 S\u2098 : Type u} [CommRing R] [CommRing S] [CommRing R\u2098] [CommRing S\u2098]\nvariable (M : Submonoid R)\nvariable [Algebra R S] [Algebra R S\u2098] [Algebra S S\u2098] [Algebra R R\u2098] [Algebra R\u2098 S\u2098]\nvariable [IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]\nvariable [IsLocalization M R\u2098] [IsLocalization (M.map (algebraMap R S)) S\u2098]\n\n-- Porting note: no longer supported\n-- attribute [local elab_as_elim] Ideal.IsNilpotent.induction_on\n\ntheorem of_isLocalization : FormallyEtale R R\u2098 :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.of_isLocalization M, FormallySmooth.of_isLocalization M\u27e9\n#align algebra.formally_etale.of_is_localization Algebra.FormallyEtale.of_isLocalization\n\ntheorem localization_base [FormallyEtale R S\u2098] : FormallyEtale R\u2098 S\u2098 :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.localization_base M, FormallySmooth.localization_base M\u27e9\n#align algebra.formally_etale.localization_base Algebra.FormallyEtale.localization_base\n\ntheorem localization_map [FormallyEtale R S] : FormallyEtale R\u2098 S\u2098 := by\n  haveI : FormallyEtale S S\u2098 := FormallyEtale.of_isLocalization (M.map (algebraMap R S))\n  haveI : FormallyEtale R S\u2098 := FormallyEtale.comp R S S\u2098\n  exact FormallyEtale.localization_base M\n#align algebra.formally_etale.localization_map Algebra.FormallyEtale.localization_map\n\nend Localization\n\nend FormallyEtale\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is \u00e9tale if it is formally \u00e9tale and of finite presentation. -/\nclass Etale : Prop where\n  formallyEtale : FormallyEtale R A := by infer_instance\n  finitePresentation : FinitePresentation R A := by infer_instance\n\nend\n\nnamespace Etale\n\nattribute [instance] formallyEtale finitePresentation\n\nvariable {R : Type u} [CommRing R]\nvariable {A B : Type u} [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]\n\n/-- Being \u00e9tale is transported via algebra isomorphisms. -/\ntheorem of_equiv [Etale R A] (e : A \u2243\u2090[R] B) : Etale R B where\n  formallyEtale := FormallyEtale.of_equiv e\n  finitePresentation := FinitePresentation.equiv e\n\nsection Comp\n\nvariable (R A B)\nvariable [Algebra A B] [IsScalarTower R A B]\n\n/-- \u00c9tale is stable under composition. -/\n", "theoremStatement": "theorem comp [Etale R A] [Etale A B] : Etale R B", "theoremName": "comp", "fileCreated": {"commit": "d991fe8f80", "date": "2024-04-08"}, "theoremCreated": {"commit": "c9ab842e13", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/Etale/Basic.lean", "positionMetadata": {"lineInFile": 188, "tokenPositionInFile": 6412, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "where\n  formallyEtale := FormallyEtale.comp R A B\n  finitePresentation := FinitePresentation.trans R A B", "proofType": "term", "proofLengthLines": 3, "proofLengthTokens": 104}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\nimport Mathlib.RingTheory.QuotientNilpotent\nimport Mathlib.RingTheory.Smooth.Basic\nimport Mathlib.RingTheory.Unramified.Basic\n\n#align_import ring_theory.etale from \"leanprover-community/mathlib\"@\"73f96237417835f148a1f7bc1ff55f67119b7166\"\n\n/-!\n\n# Etale morphisms\n\nAn `R`-algebra `A` is formally \u00e9tale if for every `R`-algebra,\nevery square-zero ideal `I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists\nexactly one lift `A \u2192\u2090[R] B`.\nIt is \u00e9tale if it is formally \u00e9tale and of finite presentation.\n\nWe show that the property extends onto nilpotent ideals, and that these properties are stable\nunder `R`-algebra homomorphisms and compositions.\n\nWe show that \u00e9tale is stable under algebra isomorphisms, composition and\nlocalization at an element.\n\n## TODO:\n\n- Show that \u00e9tale is stable under base change.\n\n-/\n\n\n-- Porting note: added to make the syntax work below.\nopen scoped TensorProduct\n\nuniverse u\n\nnamespace Algebra\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R` algebra `A` is formally \u00e9tale if for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists exactly one lift `A \u2192\u2090[R] B`. -/\n@[mk_iff]\nclass FormallyEtale : Prop where\n  comp_bijective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Bijective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)\n#align algebra.formally_etale Algebra.FormallyEtale\n\nend\n\nnamespace FormallyEtale\n\nsection\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable {B : Type u} [CommRing B] [Algebra R B] (I : Ideal B)\n\ntheorem iff_unramified_and_smooth :\n    FormallyEtale R A \u2194 FormallyUnramified R A \u2227 FormallySmooth R A := by\n  rw [formallyUnramified_iff, formallySmooth_iff, formallyEtale_iff]\n  simp_rw [\u2190 forall_and, Function.Bijective]\n#align algebra.formally_etale.iff_unramified_and_smooth Algebra.FormallyEtale.iff_unramified_and_smooth\n\ninstance (priority := 100) to_unramified [h : FormallyEtale R A] :\n    FormallyUnramified R A :=\n  (FormallyEtale.iff_unramified_and_smooth.mp h).1\n#align algebra.formally_etale.to_unramified Algebra.FormallyEtale.to_unramified\n\ninstance (priority := 100) to_smooth [h : FormallyEtale R A] : FormallySmooth R A :=\n  (FormallyEtale.iff_unramified_and_smooth.mp h).2\n#align algebra.formally_etale.to_smooth Algebra.FormallyEtale.to_smooth\n\ntheorem of_unramified_and_smooth [h\u2081 : FormallyUnramified R A]\n    [h\u2082 : FormallySmooth R A] : FormallyEtale R A :=\n  FormallyEtale.iff_unramified_and_smooth.mpr \u27e8h\u2081, h\u2082\u27e9\n#align algebra.formally_etale.of_unramified_and_smooth Algebra.FormallyEtale.of_unramified_and_smooth\n\nend\n\nsection OfEquiv\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A B : Type u} [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]\n\ntheorem of_equiv [FormallyEtale R A] (e : A \u2243\u2090[R] B) : FormallyEtale R B :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.of_equiv e, FormallySmooth.of_equiv e\u27e9\n#align algebra.formally_etale.of_equiv Algebra.FormallyEtale.of_equiv\n\nend OfEquiv\n\nsection Comp\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [CommSemiring A] [Algebra R A]\nvariable (B : Type u) [Semiring B] [Algebra R B] [Algebra A B] [IsScalarTower R A B]\n\ntheorem comp [FormallyEtale R A] [FormallyEtale A B] : FormallyEtale R B :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.comp R A B, FormallySmooth.comp R A B\u27e9\n#align algebra.formally_etale.comp Algebra.FormallyEtale.comp\n\nend Comp\n\nsection BaseChange\n\nopen scoped TensorProduct\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable (B : Type u) [CommSemiring B] [Algebra R B]\n\ninstance base_change [FormallyEtale R A] : FormallyEtale B (B \u2297[R] A) :=\n  FormallyEtale.iff_unramified_and_smooth.mpr \u27e8inferInstance, inferInstance\u27e9\n#align algebra.formally_etale.base_change Algebra.FormallyEtale.base_change\n\nend BaseChange\n\nsection Localization\n\nvariable {R S R\u2098 S\u2098 : Type u} [CommRing R] [CommRing S] [CommRing R\u2098] [CommRing S\u2098]\nvariable (M : Submonoid R)\nvariable [Algebra R S] [Algebra R S\u2098] [Algebra S S\u2098] [Algebra R R\u2098] [Algebra R\u2098 S\u2098]\nvariable [IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]\nvariable [IsLocalization M R\u2098] [IsLocalization (M.map (algebraMap R S)) S\u2098]\n\n-- Porting note: no longer supported\n-- attribute [local elab_as_elim] Ideal.IsNilpotent.induction_on\n\ntheorem of_isLocalization : FormallyEtale R R\u2098 :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.of_isLocalization M, FormallySmooth.of_isLocalization M\u27e9\n#align algebra.formally_etale.of_is_localization Algebra.FormallyEtale.of_isLocalization\n\ntheorem localization_base [FormallyEtale R S\u2098] : FormallyEtale R\u2098 S\u2098 :=\n  FormallyEtale.iff_unramified_and_smooth.mpr\n    \u27e8FormallyUnramified.localization_base M, FormallySmooth.localization_base M\u27e9\n#align algebra.formally_etale.localization_base Algebra.FormallyEtale.localization_base\n\ntheorem localization_map [FormallyEtale R S] : FormallyEtale R\u2098 S\u2098 := by\n  haveI : FormallyEtale S S\u2098 := FormallyEtale.of_isLocalization (M.map (algebraMap R S))\n  haveI : FormallyEtale R S\u2098 := FormallyEtale.comp R S S\u2098\n  exact FormallyEtale.localization_base M\n#align algebra.formally_etale.localization_map Algebra.FormallyEtale.localization_map\n\nend Localization\n\nend FormallyEtale\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is \u00e9tale if it is formally \u00e9tale and of finite presentation. -/\nclass Etale : Prop where\n  formallyEtale : FormallyEtale R A := by infer_instance\n  finitePresentation : FinitePresentation R A := by infer_instance\n\nend\n\nnamespace Etale\n\nattribute [instance] formallyEtale finitePresentation\n\nvariable {R : Type u} [CommRing R]\nvariable {A B : Type u} [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]\n\n/-- Being \u00e9tale is transported via algebra isomorphisms. -/\ntheorem of_equiv [Etale R A] (e : A \u2243\u2090[R] B) : Etale R B where\n  formallyEtale := FormallyEtale.of_equiv e\n  finitePresentation := FinitePresentation.equiv e\n\nsection Comp\n\nvariable (R A B)\nvariable [Algebra A B] [IsScalarTower R A B]\n\n/-- \u00c9tale is stable under composition. -/\ntheorem comp [Etale R A] [Etale A B] : Etale R B where\n  formallyEtale := FormallyEtale.comp R A B\n  finitePresentation := FinitePresentation.trans R A B\n\nend Comp\n\n/-- Localization at an element is \u00e9tale. -/\n", "theoremStatement": "theorem of_isLocalization_Away (r : R) [IsLocalization.Away r A] : Etale R A", "theoremName": "of_isLocalization_Away", "fileCreated": {"commit": "d991fe8f80", "date": "2024-04-08"}, "theoremCreated": {"commit": "c9ab842e13", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/Etale/Basic.lean", "positionMetadata": {"lineInFile": 195, "tokenPositionInFile": 6621, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "where\n  formallyEtale := Algebra.FormallyEtale.of_isLocalization (Submonoid.powers r)\n  finitePresentation := IsLocalization.Away.finitePresentation r", "proofType": "term", "proofLengthLines": 3, "proofLengthTokens": 150}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\nimport Mathlib.RingTheory.FinitePresentation\nimport Mathlib.RingTheory.Localization.Away.Basic\nimport Mathlib.RingTheory.Localization.Away.AdjoinRoot\nimport Mathlib.RingTheory.QuotientNilpotent\nimport Mathlib.RingTheory.TensorProduct.Basic\n\n/-!\n\n# Unramified morphisms\n\nAn `R`-algebra `A` is formally unramified if for every `R`-algebra,\nevery square-zero ideal `I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists\nat most one lift `A \u2192\u2090[R] B`.\nIt is unramified if it is formally unramified and of finite type.\n\nNote that there are multiple definitions in the literature. The definition we give is equivalent to\nthe one in the Stacks Project https://stacks.math.columbia.edu/tag/00US. Note that in EGA unramified\nis defined as formally unramified and of finite presentation.\n\nWe show that the property extends onto nilpotent ideals, and that it is stable\nunder `R`-algebra homomorphisms and compositions.\n\nWe show that unramified is stable under algebra isomorphisms, composition and\nlocalization at an element.\n\n# TODO\n\n- Show that unramified is stable under base change.\n\n-/\n\n-- Porting note: added to make the syntax work below.\nopen scoped TensorProduct\n\nuniverse u\n\nnamespace Algebra\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is formally unramified if for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists at most one lift `A \u2192\u2090[R] B`. -/\n@[mk_iff]\nclass FormallyUnramified : Prop where\n  comp_injective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Injective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)\n#align algebra.formally_unramified Algebra.FormallyUnramified\n\nend\n\nnamespace FormallyUnramified\n\nsection\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable {B : Type u} [CommRing B] [Algebra R B] (I : Ideal B)\n\ntheorem lift_unique {B : Type u} [CommRing B] [_RB : Algebra R B]\n    [FormallyUnramified R A] (I : Ideal B) (hI : IsNilpotent I) (g\u2081 g\u2082 : A \u2192\u2090[R] B)\n    (h : (Ideal.Quotient.mk\u2090 R I).comp g\u2081 = (Ideal.Quotient.mk\u2090 R I).comp g\u2082) : g\u2081 = g\u2082 := by\n  revert g\u2081 g\u2082\n  change Function.Injective (Ideal.Quotient.mk\u2090 R I).comp\n  revert _RB\n  apply Ideal.IsNilpotent.induction_on (R := B) I hI\n  \u00b7 intro B _ I hI _; exact FormallyUnramified.comp_injective I hI\n  \u00b7 intro B _ I J hIJ h\u2081 h\u2082 _ g\u2081 g\u2082 e\n    apply h\u2081\n    apply h\u2082\n    ext x\n    replace e := AlgHom.congr_fun e x\n    dsimp only [AlgHom.comp_apply, Ideal.Quotient.mk\u2090_eq_mk] at e \u22a2\n    rwa [Ideal.Quotient.eq, \u2190 map_sub, Ideal.mem_quotient_iff_mem hIJ, \u2190 Ideal.Quotient.eq]\n#align algebra.formally_unramified.lift_unique Algebra.FormallyUnramified.lift_unique\n\ntheorem ext [FormallyUnramified R A] (hI : IsNilpotent I) {g\u2081 g\u2082 : A \u2192\u2090[R] B}\n    (H : \u2200 x, Ideal.Quotient.mk I (g\u2081 x) = Ideal.Quotient.mk I (g\u2082 x)) : g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique I hI g\u2081 g\u2082 (AlgHom.ext H)\n#align algebra.formally_unramified.ext Algebra.FormallyUnramified.ext\n\ntheorem lift_unique_of_ringHom [FormallyUnramified R A] {C : Type u} [CommRing C]\n    (f : B \u2192+* C) (hf : IsNilpotent <| RingHom.ker f) (g\u2081 g\u2082 : A \u2192\u2090[R] B)\n    (h : f.comp \u2191g\u2081 = f.comp (g\u2082 : A \u2192+* B)) : g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique _ hf _ _\n    (by\n      ext x\n      have := RingHom.congr_fun h x\n      simpa only [Ideal.Quotient.eq, Function.comp_apply, AlgHom.coe_comp, Ideal.Quotient.mk\u2090_eq_mk,\n        RingHom.mem_ker, map_sub, sub_eq_zero])\n#align algebra.formally_unramified.lift_unique_of_ring_hom Algebra.FormallyUnramified.lift_unique_of_ringHom\n\ntheorem ext' [FormallyUnramified R A] {C : Type u} [CommRing C] (f : B \u2192+* C)\n    (hf : IsNilpotent <| RingHom.ker f) (g\u2081 g\u2082 : A \u2192\u2090[R] B) (h : \u2200 x, f (g\u2081 x) = f (g\u2082 x)) :\n    g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique_of_ringHom f hf g\u2081 g\u2082 (RingHom.ext h)\n#align algebra.formally_unramified.ext' Algebra.FormallyUnramified.ext'\n\ntheorem lift_unique' [FormallyUnramified R A] {C : Type u} [CommRing C]\n    [Algebra R C] (f : B \u2192\u2090[R] C) (hf : IsNilpotent <| RingHom.ker (f : B \u2192+* C))\n    (g\u2081 g\u2082 : A \u2192\u2090[R] B) (h : f.comp g\u2081 = f.comp g\u2082) : g\u2081 = g\u2082 :=\n  FormallyUnramified.ext' _ hf g\u2081 g\u2082 (AlgHom.congr_fun h)\n#align algebra.formally_unramified.lift_unique' Algebra.FormallyUnramified.lift_unique'\n\nend\n\nsection OfEquiv\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A B : Type u} [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]\n\ntheorem of_equiv [FormallyUnramified R A] (e : A \u2243\u2090[R] B) :\n    FormallyUnramified R B := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e'\n  rw [\u2190 f\u2081.comp_id, \u2190 f\u2082.comp_id, \u2190 e.comp_symm, \u2190 AlgHom.comp_assoc, \u2190 AlgHom.comp_assoc]\n  congr 1\n  refine' FormallyUnramified.comp_injective I hI _\n  rw [\u2190 AlgHom.comp_assoc, e', AlgHom.comp_assoc]\n#align algebra.formally_unramified.of_equiv Algebra.FormallyUnramified.of_equiv\n\nend OfEquiv\n\nsection Comp\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [CommSemiring A] [Algebra R A]\nvariable (B : Type u) [Semiring B] [Algebra R B] [Algebra A B] [IsScalarTower R A B]\n\ntheorem comp [FormallyUnramified R A] [FormallyUnramified A B] :\n    FormallyUnramified R B := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e\n  have e' :=\n    FormallyUnramified.lift_unique I \u27e82, hI\u27e9 (f\u2081.comp <| IsScalarTower.toAlgHom R A B)\n      (f\u2082.comp <| IsScalarTower.toAlgHom R A B) (by rw [\u2190 AlgHom.comp_assoc, e, AlgHom.comp_assoc])\n  letI := (f\u2081.comp (IsScalarTower.toAlgHom R A B)).toRingHom.toAlgebra\n  let F\u2081 : B \u2192\u2090[A] C := { f\u2081 with commutes' := fun r => rfl }\n  let F\u2082 : B \u2192\u2090[A] C := { f\u2082 with commutes' := AlgHom.congr_fun e'.symm }\n  ext1 x\n  change F\u2081 x = F\u2082 x\n  congr\n  exact FormallyUnramified.ext I \u27e82, hI\u27e9 (AlgHom.congr_fun e)\n#align algebra.formally_unramified.comp Algebra.FormallyUnramified.comp\n\ntheorem of_comp [FormallyUnramified R B] : FormallyUnramified A B := by\n  constructor\n  intro Q _ _ I e f\u2081 f\u2082 e'\n  letI := ((algebraMap A Q).comp (algebraMap R A)).toAlgebra\n  letI : IsScalarTower R A Q := IsScalarTower.of_algebraMap_eq' rfl\n  refine' AlgHom.restrictScalars_injective R _\n  refine' FormallyUnramified.ext I \u27e82, e\u27e9 _\n  intro x\n  exact AlgHom.congr_fun e' x\n#align algebra.formally_unramified.of_comp Algebra.FormallyUnramified.of_comp\n\nend Comp\n\nsection BaseChange\n\nopen scoped TensorProduct\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable (B : Type u) [CommSemiring B] [Algebra R B]\n\ninstance base_change [FormallyUnramified R A] :\n    FormallyUnramified B (B \u2297[R] A) := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e\n  letI := ((algebraMap B C).comp (algebraMap R B)).toAlgebra\n  haveI : IsScalarTower R B C := IsScalarTower.of_algebraMap_eq' rfl\n  ext : 1\n  \u00b7 exact Subsingleton.elim _ _\n  \u00b7 exact FormallyUnramified.ext I \u27e82, hI\u27e9 fun x => AlgHom.congr_fun e (1 \u2297\u209c x)\n#align algebra.formally_unramified.base_change Algebra.FormallyUnramified.base_change\n\nend BaseChange\n\nsection Localization\n\nvariable {R S R\u2098 S\u2098 : Type u} [CommRing R] [CommRing S] [CommRing R\u2098] [CommRing S\u2098]\nvariable (M : Submonoid R)\nvariable [Algebra R S] [Algebra R S\u2098] [Algebra S S\u2098] [Algebra R R\u2098] [Algebra R\u2098 S\u2098]\nvariable [IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]\nvariable [IsLocalization M R\u2098] [IsLocalization (M.map (algebraMap R S)) S\u2098]\n\n-- Porting note: no longer supported\n-- attribute [local elab_as_elim] Ideal.IsNilpotent.induction_on\n\n/-- This holds in general for epimorphisms. -/\ntheorem of_isLocalization : FormallyUnramified R R\u2098 := by\n  constructor\n  intro Q _ _ I _ f\u2081 f\u2082 _\n  apply AlgHom.coe_ringHom_injective\n  refine' IsLocalization.ringHom_ext M _\n  ext\n  simp\n#align algebra.formally_unramified.of_is_localization Algebra.FormallyUnramified.of_isLocalization\n\n/-- This actually does not need the localization instance, and is stated here again for\nconsistency. See `Algebra.FormallyUnramified.of_comp` instead.\n\n The intended use is for copying proofs between `Formally{Unramified, Smooth, Etale}`\n without the need to change anything (including removing redundant arguments). -/\n-- @[nolint unusedArguments] -- Porting note: removed\ntheorem localization_base [FormallyUnramified R S\u2098] : FormallyUnramified R\u2098 S\u2098 :=\n  -- Porting note: added\n  let _ := M\n  FormallyUnramified.of_comp R R\u2098 S\u2098\n#align algebra.formally_unramified.localization_base Algebra.FormallyUnramified.localization_base\n\ntheorem localization_map [FormallyUnramified R S] :\n    FormallyUnramified R\u2098 S\u2098 := by\n  haveI : FormallyUnramified S S\u2098 :=\n    FormallyUnramified.of_isLocalization (M.map (algebraMap R S))\n  haveI : FormallyUnramified R S\u2098 := FormallyUnramified.comp R S S\u2098\n  exact FormallyUnramified.localization_base M\n#align algebra.formally_unramified.localization_map Algebra.FormallyUnramified.localization_map\n\nend Localization\n\nend FormallyUnramified\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is unramified if it is formally unramified and of finite type.\n-/\nclass Unramified : Prop where\n  formallyUnramified : FormallyUnramified R A := by infer_instance\n  finiteType : FiniteType R A := by infer_instance\n\nend\n\nnamespace Unramified\n\nattribute [instance] formallyUnramified finiteType\n\nvariable {R : Type u} [CommRing R]\nvariable {A B : Type u} [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]\n\n/-- Being unramified is transported via algebra isomorphisms. -/\n", "theoremStatement": "theorem of_equiv [Unramified R A] (e : A \u2243\u2090[R] B) : Unramified R B", "theoremName": "of_equiv", "fileCreated": {"commit": "d991fe8f80", "date": "2024-04-08"}, "theoremCreated": {"commit": "c9ab842e13", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/Unramified/Basic.lean", "positionMetadata": {"lineInFile": 255, "tokenPositionInFile": 9561, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "where\n  formallyUnramified := FormallyUnramified.of_equiv e\n  finiteType := FiniteType.equiv Unramified.finiteType e", "proofType": "term", "proofLengthLines": 3, "proofLengthTokens": 116}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\nimport Mathlib.RingTheory.FinitePresentation\nimport Mathlib.RingTheory.Localization.Away.Basic\nimport Mathlib.RingTheory.Localization.Away.AdjoinRoot\nimport Mathlib.RingTheory.QuotientNilpotent\nimport Mathlib.RingTheory.TensorProduct.Basic\n\n/-!\n\n# Unramified morphisms\n\nAn `R`-algebra `A` is formally unramified if for every `R`-algebra,\nevery square-zero ideal `I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists\nat most one lift `A \u2192\u2090[R] B`.\nIt is unramified if it is formally unramified and of finite type.\n\nNote that there are multiple definitions in the literature. The definition we give is equivalent to\nthe one in the Stacks Project https://stacks.math.columbia.edu/tag/00US. Note that in EGA unramified\nis defined as formally unramified and of finite presentation.\n\nWe show that the property extends onto nilpotent ideals, and that it is stable\nunder `R`-algebra homomorphisms and compositions.\n\nWe show that unramified is stable under algebra isomorphisms, composition and\nlocalization at an element.\n\n# TODO\n\n- Show that unramified is stable under base change.\n\n-/\n\n-- Porting note: added to make the syntax work below.\nopen scoped TensorProduct\n\nuniverse u\n\nnamespace Algebra\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is formally unramified if for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists at most one lift `A \u2192\u2090[R] B`. -/\n@[mk_iff]\nclass FormallyUnramified : Prop where\n  comp_injective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Injective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)\n#align algebra.formally_unramified Algebra.FormallyUnramified\n\nend\n\nnamespace FormallyUnramified\n\nsection\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable {B : Type u} [CommRing B] [Algebra R B] (I : Ideal B)\n\ntheorem lift_unique {B : Type u} [CommRing B] [_RB : Algebra R B]\n    [FormallyUnramified R A] (I : Ideal B) (hI : IsNilpotent I) (g\u2081 g\u2082 : A \u2192\u2090[R] B)\n    (h : (Ideal.Quotient.mk\u2090 R I).comp g\u2081 = (Ideal.Quotient.mk\u2090 R I).comp g\u2082) : g\u2081 = g\u2082 := by\n  revert g\u2081 g\u2082\n  change Function.Injective (Ideal.Quotient.mk\u2090 R I).comp\n  revert _RB\n  apply Ideal.IsNilpotent.induction_on (R := B) I hI\n  \u00b7 intro B _ I hI _; exact FormallyUnramified.comp_injective I hI\n  \u00b7 intro B _ I J hIJ h\u2081 h\u2082 _ g\u2081 g\u2082 e\n    apply h\u2081\n    apply h\u2082\n    ext x\n    replace e := AlgHom.congr_fun e x\n    dsimp only [AlgHom.comp_apply, Ideal.Quotient.mk\u2090_eq_mk] at e \u22a2\n    rwa [Ideal.Quotient.eq, \u2190 map_sub, Ideal.mem_quotient_iff_mem hIJ, \u2190 Ideal.Quotient.eq]\n#align algebra.formally_unramified.lift_unique Algebra.FormallyUnramified.lift_unique\n\ntheorem ext [FormallyUnramified R A] (hI : IsNilpotent I) {g\u2081 g\u2082 : A \u2192\u2090[R] B}\n    (H : \u2200 x, Ideal.Quotient.mk I (g\u2081 x) = Ideal.Quotient.mk I (g\u2082 x)) : g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique I hI g\u2081 g\u2082 (AlgHom.ext H)\n#align algebra.formally_unramified.ext Algebra.FormallyUnramified.ext\n\ntheorem lift_unique_of_ringHom [FormallyUnramified R A] {C : Type u} [CommRing C]\n    (f : B \u2192+* C) (hf : IsNilpotent <| RingHom.ker f) (g\u2081 g\u2082 : A \u2192\u2090[R] B)\n    (h : f.comp \u2191g\u2081 = f.comp (g\u2082 : A \u2192+* B)) : g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique _ hf _ _\n    (by\n      ext x\n      have := RingHom.congr_fun h x\n      simpa only [Ideal.Quotient.eq, Function.comp_apply, AlgHom.coe_comp, Ideal.Quotient.mk\u2090_eq_mk,\n        RingHom.mem_ker, map_sub, sub_eq_zero])\n#align algebra.formally_unramified.lift_unique_of_ring_hom Algebra.FormallyUnramified.lift_unique_of_ringHom\n\ntheorem ext' [FormallyUnramified R A] {C : Type u} [CommRing C] (f : B \u2192+* C)\n    (hf : IsNilpotent <| RingHom.ker f) (g\u2081 g\u2082 : A \u2192\u2090[R] B) (h : \u2200 x, f (g\u2081 x) = f (g\u2082 x)) :\n    g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique_of_ringHom f hf g\u2081 g\u2082 (RingHom.ext h)\n#align algebra.formally_unramified.ext' Algebra.FormallyUnramified.ext'\n\ntheorem lift_unique' [FormallyUnramified R A] {C : Type u} [CommRing C]\n    [Algebra R C] (f : B \u2192\u2090[R] C) (hf : IsNilpotent <| RingHom.ker (f : B \u2192+* C))\n    (g\u2081 g\u2082 : A \u2192\u2090[R] B) (h : f.comp g\u2081 = f.comp g\u2082) : g\u2081 = g\u2082 :=\n  FormallyUnramified.ext' _ hf g\u2081 g\u2082 (AlgHom.congr_fun h)\n#align algebra.formally_unramified.lift_unique' Algebra.FormallyUnramified.lift_unique'\n\nend\n\nsection OfEquiv\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A B : Type u} [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]\n\ntheorem of_equiv [FormallyUnramified R A] (e : A \u2243\u2090[R] B) :\n    FormallyUnramified R B := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e'\n  rw [\u2190 f\u2081.comp_id, \u2190 f\u2082.comp_id, \u2190 e.comp_symm, \u2190 AlgHom.comp_assoc, \u2190 AlgHom.comp_assoc]\n  congr 1\n  refine' FormallyUnramified.comp_injective I hI _\n  rw [\u2190 AlgHom.comp_assoc, e', AlgHom.comp_assoc]\n#align algebra.formally_unramified.of_equiv Algebra.FormallyUnramified.of_equiv\n\nend OfEquiv\n\nsection Comp\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [CommSemiring A] [Algebra R A]\nvariable (B : Type u) [Semiring B] [Algebra R B] [Algebra A B] [IsScalarTower R A B]\n\ntheorem comp [FormallyUnramified R A] [FormallyUnramified A B] :\n    FormallyUnramified R B := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e\n  have e' :=\n    FormallyUnramified.lift_unique I \u27e82, hI\u27e9 (f\u2081.comp <| IsScalarTower.toAlgHom R A B)\n      (f\u2082.comp <| IsScalarTower.toAlgHom R A B) (by rw [\u2190 AlgHom.comp_assoc, e, AlgHom.comp_assoc])\n  letI := (f\u2081.comp (IsScalarTower.toAlgHom R A B)).toRingHom.toAlgebra\n  let F\u2081 : B \u2192\u2090[A] C := { f\u2081 with commutes' := fun r => rfl }\n  let F\u2082 : B \u2192\u2090[A] C := { f\u2082 with commutes' := AlgHom.congr_fun e'.symm }\n  ext1 x\n  change F\u2081 x = F\u2082 x\n  congr\n  exact FormallyUnramified.ext I \u27e82, hI\u27e9 (AlgHom.congr_fun e)\n#align algebra.formally_unramified.comp Algebra.FormallyUnramified.comp\n\ntheorem of_comp [FormallyUnramified R B] : FormallyUnramified A B := by\n  constructor\n  intro Q _ _ I e f\u2081 f\u2082 e'\n  letI := ((algebraMap A Q).comp (algebraMap R A)).toAlgebra\n  letI : IsScalarTower R A Q := IsScalarTower.of_algebraMap_eq' rfl\n  refine' AlgHom.restrictScalars_injective R _\n  refine' FormallyUnramified.ext I \u27e82, e\u27e9 _\n  intro x\n  exact AlgHom.congr_fun e' x\n#align algebra.formally_unramified.of_comp Algebra.FormallyUnramified.of_comp\n\nend Comp\n\nsection BaseChange\n\nopen scoped TensorProduct\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable (B : Type u) [CommSemiring B] [Algebra R B]\n\ninstance base_change [FormallyUnramified R A] :\n    FormallyUnramified B (B \u2297[R] A) := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e\n  letI := ((algebraMap B C).comp (algebraMap R B)).toAlgebra\n  haveI : IsScalarTower R B C := IsScalarTower.of_algebraMap_eq' rfl\n  ext : 1\n  \u00b7 exact Subsingleton.elim _ _\n  \u00b7 exact FormallyUnramified.ext I \u27e82, hI\u27e9 fun x => AlgHom.congr_fun e (1 \u2297\u209c x)\n#align algebra.formally_unramified.base_change Algebra.FormallyUnramified.base_change\n\nend BaseChange\n\nsection Localization\n\nvariable {R S R\u2098 S\u2098 : Type u} [CommRing R] [CommRing S] [CommRing R\u2098] [CommRing S\u2098]\nvariable (M : Submonoid R)\nvariable [Algebra R S] [Algebra R S\u2098] [Algebra S S\u2098] [Algebra R R\u2098] [Algebra R\u2098 S\u2098]\nvariable [IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]\nvariable [IsLocalization M R\u2098] [IsLocalization (M.map (algebraMap R S)) S\u2098]\n\n-- Porting note: no longer supported\n-- attribute [local elab_as_elim] Ideal.IsNilpotent.induction_on\n\n/-- This holds in general for epimorphisms. -/\ntheorem of_isLocalization : FormallyUnramified R R\u2098 := by\n  constructor\n  intro Q _ _ I _ f\u2081 f\u2082 _\n  apply AlgHom.coe_ringHom_injective\n  refine' IsLocalization.ringHom_ext M _\n  ext\n  simp\n#align algebra.formally_unramified.of_is_localization Algebra.FormallyUnramified.of_isLocalization\n\n/-- This actually does not need the localization instance, and is stated here again for\nconsistency. See `Algebra.FormallyUnramified.of_comp` instead.\n\n The intended use is for copying proofs between `Formally{Unramified, Smooth, Etale}`\n without the need to change anything (including removing redundant arguments). -/\n-- @[nolint unusedArguments] -- Porting note: removed\ntheorem localization_base [FormallyUnramified R S\u2098] : FormallyUnramified R\u2098 S\u2098 :=\n  -- Porting note: added\n  let _ := M\n  FormallyUnramified.of_comp R R\u2098 S\u2098\n#align algebra.formally_unramified.localization_base Algebra.FormallyUnramified.localization_base\n\ntheorem localization_map [FormallyUnramified R S] :\n    FormallyUnramified R\u2098 S\u2098 := by\n  haveI : FormallyUnramified S S\u2098 :=\n    FormallyUnramified.of_isLocalization (M.map (algebraMap R S))\n  haveI : FormallyUnramified R S\u2098 := FormallyUnramified.comp R S S\u2098\n  exact FormallyUnramified.localization_base M\n#align algebra.formally_unramified.localization_map Algebra.FormallyUnramified.localization_map\n\nend Localization\n\nend FormallyUnramified\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is unramified if it is formally unramified and of finite type.\n-/\nclass Unramified : Prop where\n  formallyUnramified : FormallyUnramified R A := by infer_instance\n  finiteType : FiniteType R A := by infer_instance\n\nend\n\nnamespace Unramified\n\nattribute [instance] formallyUnramified finiteType\n\nvariable {R : Type u} [CommRing R]\nvariable {A B : Type u} [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]\n\n/-- Being unramified is transported via algebra isomorphisms. -/\ntheorem of_equiv [Unramified R A] (e : A \u2243\u2090[R] B) : Unramified R B where\n  formallyUnramified := FormallyUnramified.of_equiv e\n  finiteType := FiniteType.equiv Unramified.finiteType e\n\n/-- Localization at an element is unramified. -/\n", "theoremStatement": "theorem of_isLocalization_Away (r : R) [IsLocalization.Away r A] : Unramified R A", "theoremName": "of_isLocalization_Away", "fileCreated": {"commit": "d991fe8f80", "date": "2024-04-08"}, "theoremCreated": {"commit": "c9ab842e13", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/Unramified/Basic.lean", "positionMetadata": {"lineInFile": 260, "tokenPositionInFile": 9795, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "where\n  formallyUnramified := Algebra.FormallyUnramified.of_isLocalization (Submonoid.powers r)\n  finiteType :=\n    haveI : FinitePresentation R A := IsLocalization.Away.finitePresentation r\n    inferInstance", "proofType": "term", "proofLengthLines": 5, "proofLengthTokens": 208}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\nimport Mathlib.RingTheory.FinitePresentation\nimport Mathlib.RingTheory.Localization.Away.Basic\nimport Mathlib.RingTheory.Localization.Away.AdjoinRoot\nimport Mathlib.RingTheory.QuotientNilpotent\nimport Mathlib.RingTheory.TensorProduct.Basic\n\n/-!\n\n# Unramified morphisms\n\nAn `R`-algebra `A` is formally unramified if for every `R`-algebra,\nevery square-zero ideal `I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists\nat most one lift `A \u2192\u2090[R] B`.\nIt is unramified if it is formally unramified and of finite type.\n\nNote that there are multiple definitions in the literature. The definition we give is equivalent to\nthe one in the Stacks Project https://stacks.math.columbia.edu/tag/00US. Note that in EGA unramified\nis defined as formally unramified and of finite presentation.\n\nWe show that the property extends onto nilpotent ideals, and that it is stable\nunder `R`-algebra homomorphisms and compositions.\n\nWe show that unramified is stable under algebra isomorphisms, composition and\nlocalization at an element.\n\n# TODO\n\n- Show that unramified is stable under base change.\n\n-/\n\n-- Porting note: added to make the syntax work below.\nopen scoped TensorProduct\n\nuniverse u\n\nnamespace Algebra\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is formally unramified if for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A \u2192\u2090[R] B \u29f8 I`, there exists at most one lift `A \u2192\u2090[R] B`. -/\n@[mk_iff]\nclass FormallyUnramified : Prop where\n  comp_injective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Injective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)\n#align algebra.formally_unramified Algebra.FormallyUnramified\n\nend\n\nnamespace FormallyUnramified\n\nsection\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable {B : Type u} [CommRing B] [Algebra R B] (I : Ideal B)\n\ntheorem lift_unique {B : Type u} [CommRing B] [_RB : Algebra R B]\n    [FormallyUnramified R A] (I : Ideal B) (hI : IsNilpotent I) (g\u2081 g\u2082 : A \u2192\u2090[R] B)\n    (h : (Ideal.Quotient.mk\u2090 R I).comp g\u2081 = (Ideal.Quotient.mk\u2090 R I).comp g\u2082) : g\u2081 = g\u2082 := by\n  revert g\u2081 g\u2082\n  change Function.Injective (Ideal.Quotient.mk\u2090 R I).comp\n  revert _RB\n  apply Ideal.IsNilpotent.induction_on (R := B) I hI\n  \u00b7 intro B _ I hI _; exact FormallyUnramified.comp_injective I hI\n  \u00b7 intro B _ I J hIJ h\u2081 h\u2082 _ g\u2081 g\u2082 e\n    apply h\u2081\n    apply h\u2082\n    ext x\n    replace e := AlgHom.congr_fun e x\n    dsimp only [AlgHom.comp_apply, Ideal.Quotient.mk\u2090_eq_mk] at e \u22a2\n    rwa [Ideal.Quotient.eq, \u2190 map_sub, Ideal.mem_quotient_iff_mem hIJ, \u2190 Ideal.Quotient.eq]\n#align algebra.formally_unramified.lift_unique Algebra.FormallyUnramified.lift_unique\n\ntheorem ext [FormallyUnramified R A] (hI : IsNilpotent I) {g\u2081 g\u2082 : A \u2192\u2090[R] B}\n    (H : \u2200 x, Ideal.Quotient.mk I (g\u2081 x) = Ideal.Quotient.mk I (g\u2082 x)) : g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique I hI g\u2081 g\u2082 (AlgHom.ext H)\n#align algebra.formally_unramified.ext Algebra.FormallyUnramified.ext\n\ntheorem lift_unique_of_ringHom [FormallyUnramified R A] {C : Type u} [CommRing C]\n    (f : B \u2192+* C) (hf : IsNilpotent <| RingHom.ker f) (g\u2081 g\u2082 : A \u2192\u2090[R] B)\n    (h : f.comp \u2191g\u2081 = f.comp (g\u2082 : A \u2192+* B)) : g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique _ hf _ _\n    (by\n      ext x\n      have := RingHom.congr_fun h x\n      simpa only [Ideal.Quotient.eq, Function.comp_apply, AlgHom.coe_comp, Ideal.Quotient.mk\u2090_eq_mk,\n        RingHom.mem_ker, map_sub, sub_eq_zero])\n#align algebra.formally_unramified.lift_unique_of_ring_hom Algebra.FormallyUnramified.lift_unique_of_ringHom\n\ntheorem ext' [FormallyUnramified R A] {C : Type u} [CommRing C] (f : B \u2192+* C)\n    (hf : IsNilpotent <| RingHom.ker f) (g\u2081 g\u2082 : A \u2192\u2090[R] B) (h : \u2200 x, f (g\u2081 x) = f (g\u2082 x)) :\n    g\u2081 = g\u2082 :=\n  FormallyUnramified.lift_unique_of_ringHom f hf g\u2081 g\u2082 (RingHom.ext h)\n#align algebra.formally_unramified.ext' Algebra.FormallyUnramified.ext'\n\ntheorem lift_unique' [FormallyUnramified R A] {C : Type u} [CommRing C]\n    [Algebra R C] (f : B \u2192\u2090[R] C) (hf : IsNilpotent <| RingHom.ker (f : B \u2192+* C))\n    (g\u2081 g\u2082 : A \u2192\u2090[R] B) (h : f.comp g\u2081 = f.comp g\u2082) : g\u2081 = g\u2082 :=\n  FormallyUnramified.ext' _ hf g\u2081 g\u2082 (AlgHom.congr_fun h)\n#align algebra.formally_unramified.lift_unique' Algebra.FormallyUnramified.lift_unique'\n\nend\n\nsection OfEquiv\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A B : Type u} [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]\n\ntheorem of_equiv [FormallyUnramified R A] (e : A \u2243\u2090[R] B) :\n    FormallyUnramified R B := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e'\n  rw [\u2190 f\u2081.comp_id, \u2190 f\u2082.comp_id, \u2190 e.comp_symm, \u2190 AlgHom.comp_assoc, \u2190 AlgHom.comp_assoc]\n  congr 1\n  refine' FormallyUnramified.comp_injective I hI _\n  rw [\u2190 AlgHom.comp_assoc, e', AlgHom.comp_assoc]\n#align algebra.formally_unramified.of_equiv Algebra.FormallyUnramified.of_equiv\n\nend OfEquiv\n\nsection Comp\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [CommSemiring A] [Algebra R A]\nvariable (B : Type u) [Semiring B] [Algebra R B] [Algebra A B] [IsScalarTower R A B]\n\ntheorem comp [FormallyUnramified R A] [FormallyUnramified A B] :\n    FormallyUnramified R B := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e\n  have e' :=\n    FormallyUnramified.lift_unique I \u27e82, hI\u27e9 (f\u2081.comp <| IsScalarTower.toAlgHom R A B)\n      (f\u2082.comp <| IsScalarTower.toAlgHom R A B) (by rw [\u2190 AlgHom.comp_assoc, e, AlgHom.comp_assoc])\n  letI := (f\u2081.comp (IsScalarTower.toAlgHom R A B)).toRingHom.toAlgebra\n  let F\u2081 : B \u2192\u2090[A] C := { f\u2081 with commutes' := fun r => rfl }\n  let F\u2082 : B \u2192\u2090[A] C := { f\u2082 with commutes' := AlgHom.congr_fun e'.symm }\n  ext1 x\n  change F\u2081 x = F\u2082 x\n  congr\n  exact FormallyUnramified.ext I \u27e82, hI\u27e9 (AlgHom.congr_fun e)\n#align algebra.formally_unramified.comp Algebra.FormallyUnramified.comp\n\ntheorem of_comp [FormallyUnramified R B] : FormallyUnramified A B := by\n  constructor\n  intro Q _ _ I e f\u2081 f\u2082 e'\n  letI := ((algebraMap A Q).comp (algebraMap R A)).toAlgebra\n  letI : IsScalarTower R A Q := IsScalarTower.of_algebraMap_eq' rfl\n  refine' AlgHom.restrictScalars_injective R _\n  refine' FormallyUnramified.ext I \u27e82, e\u27e9 _\n  intro x\n  exact AlgHom.congr_fun e' x\n#align algebra.formally_unramified.of_comp Algebra.FormallyUnramified.of_comp\n\nend Comp\n\nsection BaseChange\n\nopen scoped TensorProduct\n\nvariable {R : Type u} [CommSemiring R]\nvariable {A : Type u} [Semiring A] [Algebra R A]\nvariable (B : Type u) [CommSemiring B] [Algebra R B]\n\ninstance base_change [FormallyUnramified R A] :\n    FormallyUnramified B (B \u2297[R] A) := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e\n  letI := ((algebraMap B C).comp (algebraMap R B)).toAlgebra\n  haveI : IsScalarTower R B C := IsScalarTower.of_algebraMap_eq' rfl\n  ext : 1\n  \u00b7 exact Subsingleton.elim _ _\n  \u00b7 exact FormallyUnramified.ext I \u27e82, hI\u27e9 fun x => AlgHom.congr_fun e (1 \u2297\u209c x)\n#align algebra.formally_unramified.base_change Algebra.FormallyUnramified.base_change\n\nend BaseChange\n\nsection Localization\n\nvariable {R S R\u2098 S\u2098 : Type u} [CommRing R] [CommRing S] [CommRing R\u2098] [CommRing S\u2098]\nvariable (M : Submonoid R)\nvariable [Algebra R S] [Algebra R S\u2098] [Algebra S S\u2098] [Algebra R R\u2098] [Algebra R\u2098 S\u2098]\nvariable [IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]\nvariable [IsLocalization M R\u2098] [IsLocalization (M.map (algebraMap R S)) S\u2098]\n\n-- Porting note: no longer supported\n-- attribute [local elab_as_elim] Ideal.IsNilpotent.induction_on\n\n/-- This holds in general for epimorphisms. -/\ntheorem of_isLocalization : FormallyUnramified R R\u2098 := by\n  constructor\n  intro Q _ _ I _ f\u2081 f\u2082 _\n  apply AlgHom.coe_ringHom_injective\n  refine' IsLocalization.ringHom_ext M _\n  ext\n  simp\n#align algebra.formally_unramified.of_is_localization Algebra.FormallyUnramified.of_isLocalization\n\n/-- This actually does not need the localization instance, and is stated here again for\nconsistency. See `Algebra.FormallyUnramified.of_comp` instead.\n\n The intended use is for copying proofs between `Formally{Unramified, Smooth, Etale}`\n without the need to change anything (including removing redundant arguments). -/\n-- @[nolint unusedArguments] -- Porting note: removed\ntheorem localization_base [FormallyUnramified R S\u2098] : FormallyUnramified R\u2098 S\u2098 :=\n  -- Porting note: added\n  let _ := M\n  FormallyUnramified.of_comp R R\u2098 S\u2098\n#align algebra.formally_unramified.localization_base Algebra.FormallyUnramified.localization_base\n\ntheorem localization_map [FormallyUnramified R S] :\n    FormallyUnramified R\u2098 S\u2098 := by\n  haveI : FormallyUnramified S S\u2098 :=\n    FormallyUnramified.of_isLocalization (M.map (algebraMap R S))\n  haveI : FormallyUnramified R S\u2098 := FormallyUnramified.comp R S S\u2098\n  exact FormallyUnramified.localization_base M\n#align algebra.formally_unramified.localization_map Algebra.FormallyUnramified.localization_map\n\nend Localization\n\nend FormallyUnramified\n\nsection\n\nvariable (R : Type u) [CommSemiring R]\nvariable (A : Type u) [Semiring A] [Algebra R A]\n\n/-- An `R`-algebra `A` is unramified if it is formally unramified and of finite type.\n-/\nclass Unramified : Prop where\n  formallyUnramified : FormallyUnramified R A := by infer_instance\n  finiteType : FiniteType R A := by infer_instance\n\nend\n\nnamespace Unramified\n\nattribute [instance] formallyUnramified finiteType\n\nvariable {R : Type u} [CommRing R]\nvariable {A B : Type u} [CommRing A] [Algebra R A] [CommRing B] [Algebra R B]\n\n/-- Being unramified is transported via algebra isomorphisms. -/\ntheorem of_equiv [Unramified R A] (e : A \u2243\u2090[R] B) : Unramified R B where\n  formallyUnramified := FormallyUnramified.of_equiv e\n  finiteType := FiniteType.equiv Unramified.finiteType e\n\n/-- Localization at an element is unramified. -/\ntheorem of_isLocalization_Away (r : R) [IsLocalization.Away r A] : Unramified R A where\n  formallyUnramified := Algebra.FormallyUnramified.of_isLocalization (Submonoid.powers r)\n  finiteType :=\n    haveI : FinitePresentation R A := IsLocalization.Away.finitePresentation r\n    inferInstance\n\nsection Comp\n\nvariable (R A B)\nvariable [Algebra A B] [IsScalarTower R A B]\n\n/-- Unramified is stable under composition. -/\n", "theoremStatement": "theorem comp [Unramified R A] [Unramified A B] : Unramified R B", "theoremName": "comp", "fileCreated": {"commit": "d991fe8f80", "date": "2024-04-08"}, "theoremCreated": {"commit": "c9ab842e13", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/RingTheory/Unramified/Basic.lean", "positionMetadata": {"lineInFile": 272, "tokenPositionInFile": 10211, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "where\n  formallyUnramified := FormallyUnramified.comp R A B\n  finiteType := FiniteType.trans (S := A) Unramified.finiteType\n    Unramified.finiteType", "proofType": "term", "proofLengthLines": 4, "proofLengthTokens": 149}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Floris van Doorn\n-/\nimport Mathlib.CategoryTheory.Limits.Filtered\nimport Mathlib.CategoryTheory.Limits.Shapes.FiniteProducts\nimport Mathlib.CategoryTheory.Limits.Shapes.Kernels\nimport Mathlib.CategoryTheory.DiscreteCategory\n\n#align_import category_theory.limits.opposites from \"leanprover-community/mathlib\"@\"ac3ae212f394f508df43e37aa093722fa9b65d31\"\n\n/-!\n# Limits in `C` give colimits in `C\u1d52\u1d56`.\n\nWe also give special cases for (co)products,\n(co)equalizers, and pullbacks / pushouts.\n\n-/\n\n\nuniverse v\u2081 v\u2082 u\u2081 u\u2082\n\nnoncomputable section\n\nopen CategoryTheory\n\nopen CategoryTheory.Functor\n\nopen Opposite\n\nnamespace CategoryTheory.Limits\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C]\nvariable {J : Type u\u2082} [Category.{v\u2082} J]\n\n#align category_theory.limits.is_limit_cocone_op CategoryTheory.Limits.IsColimit.op\n#align category_theory.limits.is_colimit_cone_op CategoryTheory.Limits.IsLimit.op\n#align category_theory.limits.is_limit_cocone_unop CategoryTheory.Limits.IsColimit.unop\n#align category_theory.limits.is_colimit_cone_unop CategoryTheory.Limits.IsLimit.unop\n\n-- 2024-03-26\n@[deprecated] alias isLimitCoconeOp := IsColimit.op\n@[deprecated] alias isColimitConeOp := IsLimit.op\n@[deprecated] alias isLimitCoconeUnop := IsColimit.unop\n@[deprecated] alias isColimitConeUnop := IsLimit.unop\n\n/-- Turn a colimit for `F : J \u2964 C\u1d52\u1d56` into a limit for `F.leftOp : J\u1d52\u1d56 \u2964 C`. -/\n@[simps]\ndef isLimitConeLeftOpOfCocone (F : J \u2964 C\u1d52\u1d56) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneLeftOpOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeLeftOp s)).unop\n  fac s j :=\n    Quiver.Hom.op_inj <| by\n      simp only [coneLeftOpOfCocone_\u03c0_app, op_comp, Quiver.Hom.op_unop, IsColimit.fac,\n        coconeOfConeLeftOp_\u03b9_app, op_unop]\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac, coconeOfConeLeftOp_\u03b9_app] using w (op j)\n#align category_theory.limits.is_limit_cone_left_op_of_cocone CategoryTheory.Limits.isLimitConeLeftOpOfCocone\n\n/-- Turn a limit of `F : J \u2964 C\u1d52\u1d56` into a colimit of `F.leftOp : J\u1d52\u1d56 \u2964 C`. -/\n@[simps]\ndef isColimitCoconeLeftOpOfCone (F : J \u2964 C\u1d52\u1d56) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeLeftOpOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeLeftOp s)).unop\n  fac s j :=\n    Quiver.Hom.op_inj <| by\n      simp only [coconeLeftOpOfCone_\u03b9_app, op_comp, Quiver.Hom.op_unop, IsLimit.fac,\n        coneOfCoconeLeftOp_\u03c0_app, op_unop]\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac, coneOfCoconeLeftOp_\u03c0_app] using w (op j)\n#align category_theory.limits.is_colimit_cocone_left_op_of_cone CategoryTheory.Limits.isColimitCoconeLeftOpOfCone\n\n/-- Turn a colimit for `F : J\u1d52\u1d56 \u2964 C` into a limit for `F.rightOp : J \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isLimitConeRightOpOfCocone (F : J\u1d52\u1d56 \u2964 C) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneRightOpOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeRightOp s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (unop j)\n#align category_theory.limits.is_limit_cone_right_op_of_cocone CategoryTheory.Limits.isLimitConeRightOpOfCocone\n\n/-- Turn a limit for `F : J\u1d52\u1d56 \u2964 C` into a colimit for `F.rightOp : J \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isColimitCoconeRightOpOfCone (F : J\u1d52\u1d56 \u2964 C) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeRightOpOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeRightOp s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (unop j)\n#align category_theory.limits.is_colimit_cocone_right_op_of_cone CategoryTheory.Limits.isColimitCoconeRightOpOfCone\n\n/-- Turn a colimit for `F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56` into a limit for `F.unop : J \u2964 C`. -/\n@[simps]\ndef isLimitConeUnopOfCocone (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneUnopOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeUnop s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (unop j)\n#align category_theory.limits.is_limit_cone_unop_of_cocone CategoryTheory.Limits.isLimitConeUnopOfCocone\n\n/-- Turn a limit of `F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56` into a colimit of `F.unop : J \u2964 C`. -/\n@[simps]\ndef isColimitCoconeUnopOfCone (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeUnopOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeUnop s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (unop j)\n#align category_theory.limits.is_colimit_cocone_unop_of_cone CategoryTheory.Limits.isColimitCoconeUnopOfCone\n\n/-- Turn a colimit for `F.leftOp : J\u1d52\u1d56 \u2964 C` into a limit for `F : J \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isLimitConeOfCoconeLeftOp (F : J \u2964 C\u1d52\u1d56) {c : Cocone F.leftOp} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeLeftOp c)\n    where\n  lift s := (hc.desc (coconeLeftOpOfCone s)).op\n  fac s j :=\n    Quiver.Hom.unop_inj <| by\n      simp only [coneOfCoconeLeftOp_\u03c0_app, unop_comp, Quiver.Hom.unop_op, IsColimit.fac,\n        coconeLeftOpOfCone_\u03b9_app, unop_op]\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac, coneOfCoconeLeftOp_\u03c0_app] using w (unop j)\n#align category_theory.limits.is_limit_cone_of_cocone_left_op CategoryTheory.Limits.isLimitConeOfCoconeLeftOp\n\n/-- Turn a limit of `F.leftOp : J\u1d52\u1d56 \u2964 C` into a colimit of `F : J \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isColimitCoconeOfConeLeftOp (F : J \u2964 C\u1d52\u1d56) {c : Cone F.leftOp} (hc : IsLimit c) :\n    IsColimit (coconeOfConeLeftOp c)\n    where\n  desc s := (hc.lift (coneLeftOpOfCocone s)).op\n  fac s j :=\n    Quiver.Hom.unop_inj <| by\n      simp only [coconeOfConeLeftOp_\u03b9_app, unop_comp, Quiver.Hom.unop_op, IsLimit.fac,\n        coneLeftOpOfCocone_\u03c0_app, unop_op]\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac, coconeOfConeLeftOp_\u03b9_app] using w (unop j)\n#align category_theory.limits.is_colimit_cocone_of_cone_left_op CategoryTheory.Limits.isColimitCoconeOfConeLeftOp\n\n/-- Turn a colimit for `F.rightOp : J \u2964 C\u1d52\u1d56` into a limit for `F : J\u1d52\u1d56 \u2964 C`. -/\n@[simps]\ndef isLimitConeOfCoconeRightOp (F : J\u1d52\u1d56 \u2964 C) {c : Cocone F.rightOp} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeRightOp c)\n    where\n  lift s := (hc.desc (coconeRightOpOfCone s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (op j)\n#align category_theory.limits.is_limit_cone_of_cocone_right_op CategoryTheory.Limits.isLimitConeOfCoconeRightOp\n\n/-- Turn a limit for `F.rightOp : J \u2964 C\u1d52\u1d56` into a limit for `F : J\u1d52\u1d56 \u2964 C`. -/\n@[simps]\ndef isColimitCoconeOfConeRightOp (F : J\u1d52\u1d56 \u2964 C) {c : Cone F.rightOp} (hc : IsLimit c) :\n    IsColimit (coconeOfConeRightOp c)\n    where\n  desc s := (hc.lift (coneRightOpOfCocone s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (op j)\n#align category_theory.limits.is_colimit_cocone_of_cone_right_op CategoryTheory.Limits.isColimitCoconeOfConeRightOp\n\n/-- Turn a colimit for `F.unop : J \u2964 C` into a limit for `F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isLimitConeOfCoconeUnop (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cocone F.unop} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeUnop c)\n    where\n  lift s := (hc.desc (coconeUnopOfCone s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (op j)\n#align category_theory.limits.is_limit_cone_of_cocone_unop CategoryTheory.Limits.isLimitConeOfCoconeUnop\n\n/-- Turn a limit for `F.unop : J \u2964 C` into a colimit for `F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isColimitConeOfCoconeUnop (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cone F.unop} (hc : IsLimit c) :\n    IsColimit (coconeOfConeUnop c)\n    where\n  desc s := (hc.lift (coneUnopOfCocone s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (op j)\n#align category_theory.limits.is_colimit_cone_of_cocone_unop CategoryTheory.Limits.isColimitConeOfCoconeUnop\n\n/-- If `F.leftOp : J\u1d52\u1d56 \u2964 C` has a colimit, we can construct a limit for `F : J \u2964 C\u1d52\u1d56`.\n-/\ntheorem hasLimit_of_hasColimit_leftOp (F : J \u2964 C\u1d52\u1d56) [HasColimit F.leftOp] : HasLimit F :=\n  HasLimit.mk\n    { cone := coneOfCoconeLeftOp (colimit.cocone F.leftOp)\n      isLimit := isLimitConeOfCoconeLeftOp _ (colimit.isColimit _) }\n#align category_theory.limits.has_limit_of_has_colimit_left_op CategoryTheory.Limits.hasLimit_of_hasColimit_leftOp\n\ntheorem hasLimit_of_hasColimit_op (F : J \u2964 C) [HasColimit F.op] : HasLimit F :=\n  HasLimit.mk\n    { cone := (colimit.cocone F.op).unop\n      isLimit := (colimit.isColimit _).unop }\n\ntheorem hasLimit_op_of_hasColimit (F : J \u2964 C) [HasColimit F] : HasLimit F.op :=\n  HasLimit.mk\n    { cone := (colimit.cocone F).op\n      isLimit := (colimit.isColimit _).op }\n#align category_theory.limits.has_limit_of_has_colimit_op CategoryTheory.Limits.hasLimit_of_hasColimit_op\n\n/-- If `C` has colimits of shape `J\u1d52\u1d56`, we can construct limits in `C\u1d52\u1d56` of shape `J`.\n-/\ntheorem hasLimitsOfShape_op_of_hasColimitsOfShape [HasColimitsOfShape J\u1d52\u1d56 C] :\n    HasLimitsOfShape J C\u1d52\u1d56 :=\n  { has_limit := fun F => hasLimit_of_hasColimit_leftOp F }\n#align category_theory.limits.has_limits_of_shape_op_of_has_colimits_of_shape CategoryTheory.Limits.hasLimitsOfShape_op_of_hasColimitsOfShape\n\ntheorem hasLimitsOfShape_of_hasColimitsOfShape_op [HasColimitsOfShape J\u1d52\u1d56 C\u1d52\u1d56] :\n    HasLimitsOfShape J C :=\n  { has_limit := fun F => hasLimit_of_hasColimit_op F }\n#align category_theory.limits.has_limits_of_shape_of_has_colimits_of_shape_op CategoryTheory.Limits.hasLimitsOfShape_of_hasColimitsOfShape_op\n\nattribute [local instance] hasLimitsOfShape_op_of_hasColimitsOfShape\n\n/-- If `C` has colimits, we can construct limits for `C\u1d52\u1d56`.\n-/\ninstance hasLimits_op_of_hasColimits [HasColimits C] : HasLimits C\u1d52\u1d56 :=\n  \u27e8fun _ => inferInstance\u27e9\n#align category_theory.limits.has_limits_op_of_has_colimits CategoryTheory.Limits.hasLimits_op_of_hasColimits\n\ntheorem hasLimits_of_hasColimits_op [HasColimits C\u1d52\u1d56] : HasLimits C :=\n  { has_limits_of_shape := fun _ _ => hasLimitsOfShape_of_hasColimitsOfShape_op }\n#align category_theory.limits.has_limits_of_has_colimits_op CategoryTheory.Limits.hasLimits_of_hasColimits_op\n\ninstance has_cofiltered_limits_op_of_has_filtered_colimits [HasFilteredColimitsOfSize.{v\u2082, u\u2082} C] :\n    HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56 where\n  HasLimitsOfShape _ _ _ := hasLimitsOfShape_op_of_hasColimitsOfShape\n#align category_theory.limits.has_cofiltered_limits_op_of_has_filtered_colimits CategoryTheory.Limits.has_cofiltered_limits_op_of_has_filtered_colimits\n\ntheorem has_cofiltered_limits_of_has_filtered_colimits_op [HasFilteredColimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56] :\n    HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C :=\n  { HasLimitsOfShape := fun _ _ _ => hasLimitsOfShape_of_hasColimitsOfShape_op }\n#align category_theory.limits.has_cofiltered_limits_of_has_filtered_colimits_op CategoryTheory.Limits.has_cofiltered_limits_of_has_filtered_colimits_op\n\n/-- If `F.leftOp : J\u1d52\u1d56 \u2964 C` has a limit, we can construct a colimit for `F : J \u2964 C\u1d52\u1d56`.\n-/\ntheorem hasColimit_of_hasLimit_leftOp (F : J \u2964 C\u1d52\u1d56) [HasLimit F.leftOp] : HasColimit F :=\n  HasColimit.mk\n    { cocone := coconeOfConeLeftOp (limit.cone F.leftOp)\n      isColimit := isColimitCoconeOfConeLeftOp _ (limit.isLimit _) }\n#align category_theory.limits.has_colimit_of_has_limit_left_op CategoryTheory.Limits.hasColimit_of_hasLimit_leftOp\n\ntheorem hasColimit_of_hasLimit_op (F : J \u2964 C) [HasLimit F.op] : HasColimit F :=\n  HasColimit.mk\n    { cocone := (limit.cone F.op).unop\n      isColimit := (limit.isLimit _).unop }\n#align category_theory.limits.has_colimit_of_has_limit_op CategoryTheory.Limits.hasColimit_of_hasLimit_op\n\ntheorem hasColimit_op_of_hasLimit (F : J \u2964 C) [HasLimit F] : HasColimit F.op :=\n  HasColimit.mk\n    { cocone := (limit.cone F).op\n      isColimit := (limit.isLimit _).op }\n\n/-- If `C` has colimits of shape `J\u1d52\u1d56`, we can construct limits in `C\u1d52\u1d56` of shape `J`.\n-/\ninstance hasColimitsOfShape_op_of_hasLimitsOfShape [HasLimitsOfShape J\u1d52\u1d56 C] :\n    HasColimitsOfShape J C\u1d52\u1d56 where has_colimit F := hasColimit_of_hasLimit_leftOp F\n#align category_theory.limits.has_colimits_of_shape_op_of_has_limits_of_shape CategoryTheory.Limits.hasColimitsOfShape_op_of_hasLimitsOfShape\n\ntheorem hasColimitsOfShape_of_hasLimitsOfShape_op [HasLimitsOfShape J\u1d52\u1d56 C\u1d52\u1d56] :\n    HasColimitsOfShape J C :=\n  { has_colimit := fun F => hasColimit_of_hasLimit_op F }\n#align category_theory.limits.has_colimits_of_shape_of_has_limits_of_shape_op CategoryTheory.Limits.hasColimitsOfShape_of_hasLimitsOfShape_op\n\n/-- If `C` has limits, we can construct colimits for `C\u1d52\u1d56`.\n-/\ninstance hasColimits_op_of_hasLimits [HasLimits C] : HasColimits C\u1d52\u1d56 :=\n  \u27e8fun _ => inferInstance\u27e9\n#align category_theory.limits.has_colimits_op_of_has_limits CategoryTheory.Limits.hasColimits_op_of_hasLimits\n\ntheorem hasColimits_of_hasLimits_op [HasLimits C\u1d52\u1d56] : HasColimits C :=\n  { has_colimits_of_shape := fun _ _ => hasColimitsOfShape_of_hasLimitsOfShape_op }\n#align category_theory.limits.has_colimits_of_has_limits_op CategoryTheory.Limits.hasColimits_of_hasLimits_op\n\ninstance has_filtered_colimits_op_of_has_cofiltered_limits [HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C] :\n    HasFilteredColimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56 where HasColimitsOfShape _ _ _ := inferInstance\n#align category_theory.limits.has_filtered_colimits_op_of_has_cofiltered_limits CategoryTheory.Limits.has_filtered_colimits_op_of_has_cofiltered_limits\n\ntheorem has_filtered_colimits_of_has_cofiltered_limits_op [HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56] :\n    HasFilteredColimitsOfSize.{v\u2082, u\u2082} C :=\n  { HasColimitsOfShape := fun _ _ _ => hasColimitsOfShape_of_hasLimitsOfShape_op }\n#align category_theory.limits.has_filtered_colimits_of_has_cofiltered_limits_op CategoryTheory.Limits.has_filtered_colimits_of_has_cofiltered_limits_op\n\nvariable (X : Type v\u2082)\n\n/-- If `C` has products indexed by `X`, then `C\u1d52\u1d56` has coproducts indexed by `X`.\n-/\ninstance hasCoproductsOfShape_opposite [HasProductsOfShape X C] : HasCoproductsOfShape X C\u1d52\u1d56 := by\n  haveI : HasLimitsOfShape (Discrete X)\u1d52\u1d56 C :=\n    hasLimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  infer_instance\n#align category_theory.limits.has_coproducts_of_shape_opposite CategoryTheory.Limits.hasCoproductsOfShape_opposite\n\ntheorem hasCoproductsOfShape_of_opposite [HasProductsOfShape X C\u1d52\u1d56] : HasCoproductsOfShape X C :=\n  haveI : HasLimitsOfShape (Discrete X)\u1d52\u1d56 C\u1d52\u1d56 :=\n    hasLimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  hasColimitsOfShape_of_hasLimitsOfShape_op\n#align category_theory.limits.has_coproducts_of_shape_of_opposite CategoryTheory.Limits.hasCoproductsOfShape_of_opposite\n\n/-- If `C` has coproducts indexed by `X`, then `C\u1d52\u1d56` has products indexed by `X`.\n-/\ninstance hasProductsOfShape_opposite [HasCoproductsOfShape X C] : HasProductsOfShape X C\u1d52\u1d56 := by\n  haveI : HasColimitsOfShape (Discrete X)\u1d52\u1d56 C :=\n    hasColimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  infer_instance\n#align category_theory.limits.has_products_of_shape_opposite CategoryTheory.Limits.hasProductsOfShape_opposite\n\ntheorem hasProductsOfShape_of_opposite [HasCoproductsOfShape X C\u1d52\u1d56] : HasProductsOfShape X C :=\n  haveI : HasColimitsOfShape (Discrete X)\u1d52\u1d56 C\u1d52\u1d56 :=\n    hasColimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  hasLimitsOfShape_of_hasColimitsOfShape_op\n#align category_theory.limits.has_products_of_shape_of_opposite CategoryTheory.Limits.hasProductsOfShape_of_opposite\n\ninstance hasProducts_opposite [HasCoproducts.{v\u2082} C] : HasProducts.{v\u2082} C\u1d52\u1d56 := fun _ =>\n  inferInstance\n#align category_theory.limits.has_products_opposite CategoryTheory.Limits.hasProducts_opposite\n\ntheorem hasProducts_of_opposite [HasCoproducts.{v\u2082} C\u1d52\u1d56] : HasProducts.{v\u2082} C := fun X =>\n  hasProductsOfShape_of_opposite X\n#align category_theory.limits.has_products_of_opposite CategoryTheory.Limits.hasProducts_of_opposite\n\ninstance hasCoproducts_opposite [HasProducts.{v\u2082} C] : HasCoproducts.{v\u2082} C\u1d52\u1d56 := fun _ =>\n  inferInstance\n#align category_theory.limits.has_coproducts_opposite CategoryTheory.Limits.hasCoproducts_opposite\n\ntheorem hasCoproducts_of_opposite [HasProducts.{v\u2082} C\u1d52\u1d56] : HasCoproducts.{v\u2082} C := fun X =>\n  hasCoproductsOfShape_of_opposite X\n#align category_theory.limits.has_coproducts_of_opposite CategoryTheory.Limits.hasCoproducts_of_opposite\n\ninstance hasFiniteCoproducts_opposite [HasFiniteProducts C] : HasFiniteCoproducts C\u1d52\u1d56 where\n  out _ := Limits.hasCoproductsOfShape_opposite _\n#align category_theory.limits.has_finite_coproducts_opposite CategoryTheory.Limits.hasFiniteCoproducts_opposite\n\ntheorem hasFiniteCoproducts_of_opposite [HasFiniteProducts C\u1d52\u1d56] : HasFiniteCoproducts C :=\n  { out := fun _ => hasCoproductsOfShape_of_opposite _ }\n#align category_theory.limits.has_finite_coproducts_of_opposite CategoryTheory.Limits.hasFiniteCoproducts_of_opposite\n\ninstance hasFiniteProducts_opposite [HasFiniteCoproducts C] : HasFiniteProducts C\u1d52\u1d56 where\n  out _ := inferInstance\n#align category_theory.limits.has_finite_products_opposite CategoryTheory.Limits.hasFiniteProducts_opposite\n\ntheorem hasFiniteProducts_of_opposite [HasFiniteCoproducts C\u1d52\u1d56] : HasFiniteProducts C :=\n  { out := fun _ => hasProductsOfShape_of_opposite _ }\n#align category_theory.limits.has_finite_products_of_opposite CategoryTheory.Limits.hasFiniteProducts_of_opposite\n\nsection OppositeCoproducts\n\nvariable {\u03b1 : Type*} {Z : \u03b1 \u2192 C} [HasCoproduct Z]\n\ninstance : HasLimit (Discrete.functor Z).op := hasLimit_op_of_hasColimit (Discrete.functor Z)\n\ninstance : HasLimit ((Discrete.opposite \u03b1).inverse \u22d9 (Discrete.functor Z).op) :=\n  hasLimitEquivalenceComp (Discrete.opposite \u03b1).symm\n\ninstance : HasProduct (op <| Z \u00b7) := hasLimitOfIso\n  ((Discrete.natIsoFunctor \u226a\u226b Discrete.natIso (fun _ \u21a6 by rfl)) :\n    (Discrete.opposite \u03b1).inverse \u22d9 (Discrete.functor Z).op \u2245\n    Discrete.functor (op <| Z \u00b7))\n\n/-- A `Cofan` gives a `Fan` in the opposite category.  -/\n@[simp]\ndef Cofan.op (c : Cofan Z) : Fan (op <| Z \u00b7) := Fan.mk _ (fun a \u21a6 (c.inj a).op)\n\n/-- If a `Cofan`\u00a0is colimit, then its opposite is limit. -/\ndef Cofan.IsColimit.op {c : Cofan Z} (hc : IsColimit c) : IsLimit c.op := by\n  let e : Discrete.functor (Opposite.op <| Z \u00b7) \u2245 (Discrete.opposite \u03b1).inverse \u22d9\n    (Discrete.functor Z).op := Discrete.natIso (fun _ \u21a6 Iso.refl _)\n  refine IsLimit.ofIsoLimit ((IsLimit.postcomposeInvEquiv e _).2\n    (IsLimit.whiskerEquivalence hc.op (Discrete.opposite \u03b1).symm))\n    (Cones.ext (Iso.refl _) (fun \u27e8a\u27e9 \u21a6 ?_))\n  dsimp\n  erw [Category.id_comp, Category.comp_id]\n  rfl\n\n/--\nThe canonical isomorphism from the opposite of an abstract coproduct to the corresponding product\nin the opposite category.\n-/\ndef opCoproductIsoProduct' {c : Cofan Z} {f : Fan (op <| Z \u00b7)}\n    (hc : IsColimit c) (hf : IsLimit f) : op c.pt \u2245 f.pt :=\n  IsLimit.conePointUniqueUpToIso (Cofan.IsColimit.op hc) hf\n\nvariable (Z) in\n/--\nThe canonical isomorphism from the opposite of the coproduct to the product in the opposite\ncategory.\n-/\ndef opCoproductIsoProduct :\n    op (\u2210 Z) \u2245 \u220f (op <| Z \u00b7) :=\n  opCoproductIsoProduct' (coproductIsCoproduct Z) (productIsProduct (op <| Z \u00b7))\n\ntheorem opCoproductIsoProduct'_inv_comp_inj {c : Cofan Z} {f : Fan (op <| Z \u00b7)}\n    (hc : IsColimit c) (hf : IsLimit f) (b : \u03b1) :\n    (opCoproductIsoProduct' hc hf).inv \u226b (c.inj b).op = f.proj b :=\n  IsLimit.conePointUniqueUpToIso_inv_comp (Cofan.IsColimit.op hc) hf \u27e8b\u27e9\n\n", "theoremStatement": "theorem opCoproductIsoProduct'_comp_self {c c' : Cofan Z} {f : Fan (op <| Z \u00b7)}\n    (hc : IsColimit c) (hc' : IsColimit c') (hf : IsLimit f) :\n    (opCoproductIsoProduct' hc hf).hom \u226b (opCoproductIsoProduct' hc' hf).inv =\n    (hc.coconePointUniqueUpToIso hc').op.inv", "theoremName": "opCoproductIsoProduct'_comp_self", "fileCreated": {"commit": "3fcb15f5aa", "date": "2023-03-11"}, "theoremCreated": {"commit": "423f5783b8", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/CategoryTheory/Limits/Opposites.lean", "positionMetadata": {"lineInFile": 419, "tokenPositionInFile": 20363, "theoremPositionInFile": 54}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  apply Quiver.Hom.unop_inj\n  apply hc'.hom_ext\n  intro \u27e8j\u27e9\n  change c'.inj _ \u226b _ = _\n  simp only [unop_op, unop_comp, Discrete.functor_obj, const_obj_obj, Iso.op_inv,\n    Quiver.Hom.unop_op, IsColimit.comp_coconePointUniqueUpToIso_inv]\n  apply Quiver.Hom.op_inj\n  simp only [op_comp, op_unop, Quiver.Hom.op_unop, Category.assoc,\n    opCoproductIsoProduct'_inv_comp_inj]\n  rw [\u2190 opCoproductIsoProduct'_inv_comp_inj hc hf]\n  simp only [Iso.hom_inv_id_assoc]\n  rfl", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 465}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Floris van Doorn\n-/\nimport Mathlib.CategoryTheory.Limits.Filtered\nimport Mathlib.CategoryTheory.Limits.Shapes.FiniteProducts\nimport Mathlib.CategoryTheory.Limits.Shapes.Kernels\nimport Mathlib.CategoryTheory.DiscreteCategory\n\n#align_import category_theory.limits.opposites from \"leanprover-community/mathlib\"@\"ac3ae212f394f508df43e37aa093722fa9b65d31\"\n\n/-!\n# Limits in `C` give colimits in `C\u1d52\u1d56`.\n\nWe also give special cases for (co)products,\n(co)equalizers, and pullbacks / pushouts.\n\n-/\n\n\nuniverse v\u2081 v\u2082 u\u2081 u\u2082\n\nnoncomputable section\n\nopen CategoryTheory\n\nopen CategoryTheory.Functor\n\nopen Opposite\n\nnamespace CategoryTheory.Limits\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C]\nvariable {J : Type u\u2082} [Category.{v\u2082} J]\n\n#align category_theory.limits.is_limit_cocone_op CategoryTheory.Limits.IsColimit.op\n#align category_theory.limits.is_colimit_cone_op CategoryTheory.Limits.IsLimit.op\n#align category_theory.limits.is_limit_cocone_unop CategoryTheory.Limits.IsColimit.unop\n#align category_theory.limits.is_colimit_cone_unop CategoryTheory.Limits.IsLimit.unop\n\n-- 2024-03-26\n@[deprecated] alias isLimitCoconeOp := IsColimit.op\n@[deprecated] alias isColimitConeOp := IsLimit.op\n@[deprecated] alias isLimitCoconeUnop := IsColimit.unop\n@[deprecated] alias isColimitConeUnop := IsLimit.unop\n\n/-- Turn a colimit for `F : J \u2964 C\u1d52\u1d56` into a limit for `F.leftOp : J\u1d52\u1d56 \u2964 C`. -/\n@[simps]\ndef isLimitConeLeftOpOfCocone (F : J \u2964 C\u1d52\u1d56) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneLeftOpOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeLeftOp s)).unop\n  fac s j :=\n    Quiver.Hom.op_inj <| by\n      simp only [coneLeftOpOfCocone_\u03c0_app, op_comp, Quiver.Hom.op_unop, IsColimit.fac,\n        coconeOfConeLeftOp_\u03b9_app, op_unop]\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac, coconeOfConeLeftOp_\u03b9_app] using w (op j)\n#align category_theory.limits.is_limit_cone_left_op_of_cocone CategoryTheory.Limits.isLimitConeLeftOpOfCocone\n\n/-- Turn a limit of `F : J \u2964 C\u1d52\u1d56` into a colimit of `F.leftOp : J\u1d52\u1d56 \u2964 C`. -/\n@[simps]\ndef isColimitCoconeLeftOpOfCone (F : J \u2964 C\u1d52\u1d56) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeLeftOpOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeLeftOp s)).unop\n  fac s j :=\n    Quiver.Hom.op_inj <| by\n      simp only [coconeLeftOpOfCone_\u03b9_app, op_comp, Quiver.Hom.op_unop, IsLimit.fac,\n        coneOfCoconeLeftOp_\u03c0_app, op_unop]\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac, coneOfCoconeLeftOp_\u03c0_app] using w (op j)\n#align category_theory.limits.is_colimit_cocone_left_op_of_cone CategoryTheory.Limits.isColimitCoconeLeftOpOfCone\n\n/-- Turn a colimit for `F : J\u1d52\u1d56 \u2964 C` into a limit for `F.rightOp : J \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isLimitConeRightOpOfCocone (F : J\u1d52\u1d56 \u2964 C) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneRightOpOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeRightOp s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (unop j)\n#align category_theory.limits.is_limit_cone_right_op_of_cocone CategoryTheory.Limits.isLimitConeRightOpOfCocone\n\n/-- Turn a limit for `F : J\u1d52\u1d56 \u2964 C` into a colimit for `F.rightOp : J \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isColimitCoconeRightOpOfCone (F : J\u1d52\u1d56 \u2964 C) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeRightOpOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeRightOp s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (unop j)\n#align category_theory.limits.is_colimit_cocone_right_op_of_cone CategoryTheory.Limits.isColimitCoconeRightOpOfCone\n\n/-- Turn a colimit for `F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56` into a limit for `F.unop : J \u2964 C`. -/\n@[simps]\ndef isLimitConeUnopOfCocone (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneUnopOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeUnop s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (unop j)\n#align category_theory.limits.is_limit_cone_unop_of_cocone CategoryTheory.Limits.isLimitConeUnopOfCocone\n\n/-- Turn a limit of `F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56` into a colimit of `F.unop : J \u2964 C`. -/\n@[simps]\ndef isColimitCoconeUnopOfCone (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeUnopOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeUnop s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (unop j)\n#align category_theory.limits.is_colimit_cocone_unop_of_cone CategoryTheory.Limits.isColimitCoconeUnopOfCone\n\n/-- Turn a colimit for `F.leftOp : J\u1d52\u1d56 \u2964 C` into a limit for `F : J \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isLimitConeOfCoconeLeftOp (F : J \u2964 C\u1d52\u1d56) {c : Cocone F.leftOp} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeLeftOp c)\n    where\n  lift s := (hc.desc (coconeLeftOpOfCone s)).op\n  fac s j :=\n    Quiver.Hom.unop_inj <| by\n      simp only [coneOfCoconeLeftOp_\u03c0_app, unop_comp, Quiver.Hom.unop_op, IsColimit.fac,\n        coconeLeftOpOfCone_\u03b9_app, unop_op]\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac, coneOfCoconeLeftOp_\u03c0_app] using w (unop j)\n#align category_theory.limits.is_limit_cone_of_cocone_left_op CategoryTheory.Limits.isLimitConeOfCoconeLeftOp\n\n/-- Turn a limit of `F.leftOp : J\u1d52\u1d56 \u2964 C` into a colimit of `F : J \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isColimitCoconeOfConeLeftOp (F : J \u2964 C\u1d52\u1d56) {c : Cone F.leftOp} (hc : IsLimit c) :\n    IsColimit (coconeOfConeLeftOp c)\n    where\n  desc s := (hc.lift (coneLeftOpOfCocone s)).op\n  fac s j :=\n    Quiver.Hom.unop_inj <| by\n      simp only [coconeOfConeLeftOp_\u03b9_app, unop_comp, Quiver.Hom.unop_op, IsLimit.fac,\n        coneLeftOpOfCocone_\u03c0_app, unop_op]\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac, coconeOfConeLeftOp_\u03b9_app] using w (unop j)\n#align category_theory.limits.is_colimit_cocone_of_cone_left_op CategoryTheory.Limits.isColimitCoconeOfConeLeftOp\n\n/-- Turn a colimit for `F.rightOp : J \u2964 C\u1d52\u1d56` into a limit for `F : J\u1d52\u1d56 \u2964 C`. -/\n@[simps]\ndef isLimitConeOfCoconeRightOp (F : J\u1d52\u1d56 \u2964 C) {c : Cocone F.rightOp} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeRightOp c)\n    where\n  lift s := (hc.desc (coconeRightOpOfCone s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (op j)\n#align category_theory.limits.is_limit_cone_of_cocone_right_op CategoryTheory.Limits.isLimitConeOfCoconeRightOp\n\n/-- Turn a limit for `F.rightOp : J \u2964 C\u1d52\u1d56` into a limit for `F : J\u1d52\u1d56 \u2964 C`. -/\n@[simps]\ndef isColimitCoconeOfConeRightOp (F : J\u1d52\u1d56 \u2964 C) {c : Cone F.rightOp} (hc : IsLimit c) :\n    IsColimit (coconeOfConeRightOp c)\n    where\n  desc s := (hc.lift (coneRightOpOfCocone s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (op j)\n#align category_theory.limits.is_colimit_cocone_of_cone_right_op CategoryTheory.Limits.isColimitCoconeOfConeRightOp\n\n/-- Turn a colimit for `F.unop : J \u2964 C` into a limit for `F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isLimitConeOfCoconeUnop (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cocone F.unop} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeUnop c)\n    where\n  lift s := (hc.desc (coconeUnopOfCone s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (op j)\n#align category_theory.limits.is_limit_cone_of_cocone_unop CategoryTheory.Limits.isLimitConeOfCoconeUnop\n\n/-- Turn a limit for `F.unop : J \u2964 C` into a colimit for `F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56`. -/\n@[simps]\ndef isColimitConeOfCoconeUnop (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cone F.unop} (hc : IsLimit c) :\n    IsColimit (coconeOfConeUnop c)\n    where\n  desc s := (hc.lift (coneUnopOfCocone s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (op j)\n#align category_theory.limits.is_colimit_cone_of_cocone_unop CategoryTheory.Limits.isColimitConeOfCoconeUnop\n\n/-- If `F.leftOp : J\u1d52\u1d56 \u2964 C` has a colimit, we can construct a limit for `F : J \u2964 C\u1d52\u1d56`.\n-/\ntheorem hasLimit_of_hasColimit_leftOp (F : J \u2964 C\u1d52\u1d56) [HasColimit F.leftOp] : HasLimit F :=\n  HasLimit.mk\n    { cone := coneOfCoconeLeftOp (colimit.cocone F.leftOp)\n      isLimit := isLimitConeOfCoconeLeftOp _ (colimit.isColimit _) }\n#align category_theory.limits.has_limit_of_has_colimit_left_op CategoryTheory.Limits.hasLimit_of_hasColimit_leftOp\n\ntheorem hasLimit_of_hasColimit_op (F : J \u2964 C) [HasColimit F.op] : HasLimit F :=\n  HasLimit.mk\n    { cone := (colimit.cocone F.op).unop\n      isLimit := (colimit.isColimit _).unop }\n\ntheorem hasLimit_op_of_hasColimit (F : J \u2964 C) [HasColimit F] : HasLimit F.op :=\n  HasLimit.mk\n    { cone := (colimit.cocone F).op\n      isLimit := (colimit.isColimit _).op }\n#align category_theory.limits.has_limit_of_has_colimit_op CategoryTheory.Limits.hasLimit_of_hasColimit_op\n\n/-- If `C` has colimits of shape `J\u1d52\u1d56`, we can construct limits in `C\u1d52\u1d56` of shape `J`.\n-/\ntheorem hasLimitsOfShape_op_of_hasColimitsOfShape [HasColimitsOfShape J\u1d52\u1d56 C] :\n    HasLimitsOfShape J C\u1d52\u1d56 :=\n  { has_limit := fun F => hasLimit_of_hasColimit_leftOp F }\n#align category_theory.limits.has_limits_of_shape_op_of_has_colimits_of_shape CategoryTheory.Limits.hasLimitsOfShape_op_of_hasColimitsOfShape\n\ntheorem hasLimitsOfShape_of_hasColimitsOfShape_op [HasColimitsOfShape J\u1d52\u1d56 C\u1d52\u1d56] :\n    HasLimitsOfShape J C :=\n  { has_limit := fun F => hasLimit_of_hasColimit_op F }\n#align category_theory.limits.has_limits_of_shape_of_has_colimits_of_shape_op CategoryTheory.Limits.hasLimitsOfShape_of_hasColimitsOfShape_op\n\nattribute [local instance] hasLimitsOfShape_op_of_hasColimitsOfShape\n\n/-- If `C` has colimits, we can construct limits for `C\u1d52\u1d56`.\n-/\ninstance hasLimits_op_of_hasColimits [HasColimits C] : HasLimits C\u1d52\u1d56 :=\n  \u27e8fun _ => inferInstance\u27e9\n#align category_theory.limits.has_limits_op_of_has_colimits CategoryTheory.Limits.hasLimits_op_of_hasColimits\n\ntheorem hasLimits_of_hasColimits_op [HasColimits C\u1d52\u1d56] : HasLimits C :=\n  { has_limits_of_shape := fun _ _ => hasLimitsOfShape_of_hasColimitsOfShape_op }\n#align category_theory.limits.has_limits_of_has_colimits_op CategoryTheory.Limits.hasLimits_of_hasColimits_op\n\ninstance has_cofiltered_limits_op_of_has_filtered_colimits [HasFilteredColimitsOfSize.{v\u2082, u\u2082} C] :\n    HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56 where\n  HasLimitsOfShape _ _ _ := hasLimitsOfShape_op_of_hasColimitsOfShape\n#align category_theory.limits.has_cofiltered_limits_op_of_has_filtered_colimits CategoryTheory.Limits.has_cofiltered_limits_op_of_has_filtered_colimits\n\ntheorem has_cofiltered_limits_of_has_filtered_colimits_op [HasFilteredColimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56] :\n    HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C :=\n  { HasLimitsOfShape := fun _ _ _ => hasLimitsOfShape_of_hasColimitsOfShape_op }\n#align category_theory.limits.has_cofiltered_limits_of_has_filtered_colimits_op CategoryTheory.Limits.has_cofiltered_limits_of_has_filtered_colimits_op\n\n/-- If `F.leftOp : J\u1d52\u1d56 \u2964 C` has a limit, we can construct a colimit for `F : J \u2964 C\u1d52\u1d56`.\n-/\ntheorem hasColimit_of_hasLimit_leftOp (F : J \u2964 C\u1d52\u1d56) [HasLimit F.leftOp] : HasColimit F :=\n  HasColimit.mk\n    { cocone := coconeOfConeLeftOp (limit.cone F.leftOp)\n      isColimit := isColimitCoconeOfConeLeftOp _ (limit.isLimit _) }\n#align category_theory.limits.has_colimit_of_has_limit_left_op CategoryTheory.Limits.hasColimit_of_hasLimit_leftOp\n\ntheorem hasColimit_of_hasLimit_op (F : J \u2964 C) [HasLimit F.op] : HasColimit F :=\n  HasColimit.mk\n    { cocone := (limit.cone F.op).unop\n      isColimit := (limit.isLimit _).unop }\n#align category_theory.limits.has_colimit_of_has_limit_op CategoryTheory.Limits.hasColimit_of_hasLimit_op\n\ntheorem hasColimit_op_of_hasLimit (F : J \u2964 C) [HasLimit F] : HasColimit F.op :=\n  HasColimit.mk\n    { cocone := (limit.cone F).op\n      isColimit := (limit.isLimit _).op }\n\n/-- If `C` has colimits of shape `J\u1d52\u1d56`, we can construct limits in `C\u1d52\u1d56` of shape `J`.\n-/\ninstance hasColimitsOfShape_op_of_hasLimitsOfShape [HasLimitsOfShape J\u1d52\u1d56 C] :\n    HasColimitsOfShape J C\u1d52\u1d56 where has_colimit F := hasColimit_of_hasLimit_leftOp F\n#align category_theory.limits.has_colimits_of_shape_op_of_has_limits_of_shape CategoryTheory.Limits.hasColimitsOfShape_op_of_hasLimitsOfShape\n\ntheorem hasColimitsOfShape_of_hasLimitsOfShape_op [HasLimitsOfShape J\u1d52\u1d56 C\u1d52\u1d56] :\n    HasColimitsOfShape J C :=\n  { has_colimit := fun F => hasColimit_of_hasLimit_op F }\n#align category_theory.limits.has_colimits_of_shape_of_has_limits_of_shape_op CategoryTheory.Limits.hasColimitsOfShape_of_hasLimitsOfShape_op\n\n/-- If `C` has limits, we can construct colimits for `C\u1d52\u1d56`.\n-/\ninstance hasColimits_op_of_hasLimits [HasLimits C] : HasColimits C\u1d52\u1d56 :=\n  \u27e8fun _ => inferInstance\u27e9\n#align category_theory.limits.has_colimits_op_of_has_limits CategoryTheory.Limits.hasColimits_op_of_hasLimits\n\ntheorem hasColimits_of_hasLimits_op [HasLimits C\u1d52\u1d56] : HasColimits C :=\n  { has_colimits_of_shape := fun _ _ => hasColimitsOfShape_of_hasLimitsOfShape_op }\n#align category_theory.limits.has_colimits_of_has_limits_op CategoryTheory.Limits.hasColimits_of_hasLimits_op\n\ninstance has_filtered_colimits_op_of_has_cofiltered_limits [HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C] :\n    HasFilteredColimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56 where HasColimitsOfShape _ _ _ := inferInstance\n#align category_theory.limits.has_filtered_colimits_op_of_has_cofiltered_limits CategoryTheory.Limits.has_filtered_colimits_op_of_has_cofiltered_limits\n\ntheorem has_filtered_colimits_of_has_cofiltered_limits_op [HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56] :\n    HasFilteredColimitsOfSize.{v\u2082, u\u2082} C :=\n  { HasColimitsOfShape := fun _ _ _ => hasColimitsOfShape_of_hasLimitsOfShape_op }\n#align category_theory.limits.has_filtered_colimits_of_has_cofiltered_limits_op CategoryTheory.Limits.has_filtered_colimits_of_has_cofiltered_limits_op\n\nvariable (X : Type v\u2082)\n\n/-- If `C` has products indexed by `X`, then `C\u1d52\u1d56` has coproducts indexed by `X`.\n-/\ninstance hasCoproductsOfShape_opposite [HasProductsOfShape X C] : HasCoproductsOfShape X C\u1d52\u1d56 := by\n  haveI : HasLimitsOfShape (Discrete X)\u1d52\u1d56 C :=\n    hasLimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  infer_instance\n#align category_theory.limits.has_coproducts_of_shape_opposite CategoryTheory.Limits.hasCoproductsOfShape_opposite\n\ntheorem hasCoproductsOfShape_of_opposite [HasProductsOfShape X C\u1d52\u1d56] : HasCoproductsOfShape X C :=\n  haveI : HasLimitsOfShape (Discrete X)\u1d52\u1d56 C\u1d52\u1d56 :=\n    hasLimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  hasColimitsOfShape_of_hasLimitsOfShape_op\n#align category_theory.limits.has_coproducts_of_shape_of_opposite CategoryTheory.Limits.hasCoproductsOfShape_of_opposite\n\n/-- If `C` has coproducts indexed by `X`, then `C\u1d52\u1d56` has products indexed by `X`.\n-/\ninstance hasProductsOfShape_opposite [HasCoproductsOfShape X C] : HasProductsOfShape X C\u1d52\u1d56 := by\n  haveI : HasColimitsOfShape (Discrete X)\u1d52\u1d56 C :=\n    hasColimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  infer_instance\n#align category_theory.limits.has_products_of_shape_opposite CategoryTheory.Limits.hasProductsOfShape_opposite\n\ntheorem hasProductsOfShape_of_opposite [HasCoproductsOfShape X C\u1d52\u1d56] : HasProductsOfShape X C :=\n  haveI : HasColimitsOfShape (Discrete X)\u1d52\u1d56 C\u1d52\u1d56 :=\n    hasColimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  hasLimitsOfShape_of_hasColimitsOfShape_op\n#align category_theory.limits.has_products_of_shape_of_opposite CategoryTheory.Limits.hasProductsOfShape_of_opposite\n\ninstance hasProducts_opposite [HasCoproducts.{v\u2082} C] : HasProducts.{v\u2082} C\u1d52\u1d56 := fun _ =>\n  inferInstance\n#align category_theory.limits.has_products_opposite CategoryTheory.Limits.hasProducts_opposite\n\ntheorem hasProducts_of_opposite [HasCoproducts.{v\u2082} C\u1d52\u1d56] : HasProducts.{v\u2082} C := fun X =>\n  hasProductsOfShape_of_opposite X\n#align category_theory.limits.has_products_of_opposite CategoryTheory.Limits.hasProducts_of_opposite\n\ninstance hasCoproducts_opposite [HasProducts.{v\u2082} C] : HasCoproducts.{v\u2082} C\u1d52\u1d56 := fun _ =>\n  inferInstance\n#align category_theory.limits.has_coproducts_opposite CategoryTheory.Limits.hasCoproducts_opposite\n\ntheorem hasCoproducts_of_opposite [HasProducts.{v\u2082} C\u1d52\u1d56] : HasCoproducts.{v\u2082} C := fun X =>\n  hasCoproductsOfShape_of_opposite X\n#align category_theory.limits.has_coproducts_of_opposite CategoryTheory.Limits.hasCoproducts_of_opposite\n\ninstance hasFiniteCoproducts_opposite [HasFiniteProducts C] : HasFiniteCoproducts C\u1d52\u1d56 where\n  out _ := Limits.hasCoproductsOfShape_opposite _\n#align category_theory.limits.has_finite_coproducts_opposite CategoryTheory.Limits.hasFiniteCoproducts_opposite\n\ntheorem hasFiniteCoproducts_of_opposite [HasFiniteProducts C\u1d52\u1d56] : HasFiniteCoproducts C :=\n  { out := fun _ => hasCoproductsOfShape_of_opposite _ }\n#align category_theory.limits.has_finite_coproducts_of_opposite CategoryTheory.Limits.hasFiniteCoproducts_of_opposite\n\ninstance hasFiniteProducts_opposite [HasFiniteCoproducts C] : HasFiniteProducts C\u1d52\u1d56 where\n  out _ := inferInstance\n#align category_theory.limits.has_finite_products_opposite CategoryTheory.Limits.hasFiniteProducts_opposite\n\ntheorem hasFiniteProducts_of_opposite [HasFiniteCoproducts C\u1d52\u1d56] : HasFiniteProducts C :=\n  { out := fun _ => hasProductsOfShape_of_opposite _ }\n#align category_theory.limits.has_finite_products_of_opposite CategoryTheory.Limits.hasFiniteProducts_of_opposite\n\nsection OppositeCoproducts\n\nvariable {\u03b1 : Type*} {Z : \u03b1 \u2192 C} [HasCoproduct Z]\n\ninstance : HasLimit (Discrete.functor Z).op := hasLimit_op_of_hasColimit (Discrete.functor Z)\n\ninstance : HasLimit ((Discrete.opposite \u03b1).inverse \u22d9 (Discrete.functor Z).op) :=\n  hasLimitEquivalenceComp (Discrete.opposite \u03b1).symm\n\ninstance : HasProduct (op <| Z \u00b7) := hasLimitOfIso\n  ((Discrete.natIsoFunctor \u226a\u226b Discrete.natIso (fun _ \u21a6 by rfl)) :\n    (Discrete.opposite \u03b1).inverse \u22d9 (Discrete.functor Z).op \u2245\n    Discrete.functor (op <| Z \u00b7))\n\n/-- A `Cofan` gives a `Fan` in the opposite category.  -/\n@[simp]\ndef Cofan.op (c : Cofan Z) : Fan (op <| Z \u00b7) := Fan.mk _ (fun a \u21a6 (c.inj a).op)\n\n/-- If a `Cofan`\u00a0is colimit, then its opposite is limit. -/\ndef Cofan.IsColimit.op {c : Cofan Z} (hc : IsColimit c) : IsLimit c.op := by\n  let e : Discrete.functor (Opposite.op <| Z \u00b7) \u2245 (Discrete.opposite \u03b1).inverse \u22d9\n    (Discrete.functor Z).op := Discrete.natIso (fun _ \u21a6 Iso.refl _)\n  refine IsLimit.ofIsoLimit ((IsLimit.postcomposeInvEquiv e _).2\n    (IsLimit.whiskerEquivalence hc.op (Discrete.opposite \u03b1).symm))\n    (Cones.ext (Iso.refl _) (fun \u27e8a\u27e9 \u21a6 ?_))\n  dsimp\n  erw [Category.id_comp, Category.comp_id]\n  rfl\n\n/--\nThe canonical isomorphism from the opposite of an abstract coproduct to the corresponding product\nin the opposite category.\n-/\ndef opCoproductIsoProduct' {c : Cofan Z} {f : Fan (op <| Z \u00b7)}\n    (hc : IsColimit c) (hf : IsLimit f) : op c.pt \u2245 f.pt :=\n  IsLimit.conePointUniqueUpToIso (Cofan.IsColimit.op hc) hf\n\nvariable (Z) in\n/--\nThe canonical isomorphism from the opposite of the coproduct to the product in the opposite\ncategory.\n-/\ndef opCoproductIsoProduct :\n    op (\u2210 Z) \u2245 \u220f (op <| Z \u00b7) :=\n  opCoproductIsoProduct' (coproductIsCoproduct Z) (productIsProduct (op <| Z \u00b7))\n\ntheorem opCoproductIsoProduct'_inv_comp_inj {c : Cofan Z} {f : Fan (op <| Z \u00b7)}\n    (hc : IsColimit c) (hf : IsLimit f) (b : \u03b1) :\n    (opCoproductIsoProduct' hc hf).inv \u226b (c.inj b).op = f.proj b :=\n  IsLimit.conePointUniqueUpToIso_inv_comp (Cofan.IsColimit.op hc) hf \u27e8b\u27e9\n\ntheorem opCoproductIsoProduct'_comp_self {c c' : Cofan Z} {f : Fan (op <| Z \u00b7)}\n    (hc : IsColimit c) (hc' : IsColimit c') (hf : IsLimit f) :\n    (opCoproductIsoProduct' hc hf).hom \u226b (opCoproductIsoProduct' hc' hf).inv =\n    (hc.coconePointUniqueUpToIso hc').op.inv := by\n  apply Quiver.Hom.unop_inj\n  apply hc'.hom_ext\n  intro \u27e8j\u27e9\n  change c'.inj _ \u226b _ = _\n  simp only [unop_op, unop_comp, Discrete.functor_obj, const_obj_obj, Iso.op_inv,\n    Quiver.Hom.unop_op, IsColimit.comp_coconePointUniqueUpToIso_inv]\n  apply Quiver.Hom.op_inj\n  simp only [op_comp, op_unop, Quiver.Hom.op_unop, Category.assoc,\n    opCoproductIsoProduct'_inv_comp_inj]\n  rw [\u2190 opCoproductIsoProduct'_inv_comp_inj hc hf]\n  simp only [Iso.hom_inv_id_assoc]\n  rfl\n\nvariable (Z) in\ntheorem opCoproductIsoProduct_inv_comp_\u03b9 (b : \u03b1) :\n    (opCoproductIsoProduct Z).inv \u226b (Sigma.\u03b9 Z b).op = Pi.\u03c0 (op <| Z \u00b7) b :=\n  opCoproductIsoProduct'_inv_comp_inj _ _ b\n\ntheorem desc_op_comp_opCoproductIsoProduct'_hom {c : Cofan Z} {f : Fan (op <| Z \u00b7)}\n    (hc : IsColimit c) (hf : IsLimit f) (c' : Cofan Z) :\n    (hc.desc c').op \u226b (opCoproductIsoProduct' hc hf).hom = hf.lift c'.op := by\n  refine (Iso.eq_comp_inv _).mp (Quiver.Hom.unop_inj (hc.hom_ext (fun \u27e8j\u27e9 \u21a6 Quiver.Hom.op_inj ?_)))\n  simp only [unop_op, Discrete.functor_obj, const_obj_obj, Quiver.Hom.unop_op, IsColimit.fac,\n    Cofan.op, unop_comp, op_comp, op_unop, Quiver.Hom.op_unop, Category.assoc]\n  erw [opCoproductIsoProduct'_inv_comp_inj, IsLimit.fac]\n  rfl\n\ntheorem desc_op_comp_opCoproductIsoProduct_hom {X : C} (\u03c0 : (a : \u03b1) \u2192 Z a \u27f6 X) :\n    (Sigma.desc \u03c0).op \u226b (opCoproductIsoProduct Z).hom = Pi.lift (fun a \u21a6 (\u03c0 a).op) := by\n  convert desc_op_comp_opCoproductIsoProduct'_hom (coproductIsCoproduct Z)\n    (productIsProduct (op <| Z \u00b7)) (Cofan.mk _ \u03c0)\n  \u00b7 ext; simp [Sigma.desc, coproductIsCoproduct]\n  \u00b7 ext; simp [Pi.lift, productIsProduct]\n\nend OppositeCoproducts\n\nsection OppositeProducts\n\nvariable {\u03b1 : Type*} {Z : \u03b1 \u2192 C} [HasProduct Z]\n\ninstance : HasColimit (Discrete.functor Z).op := hasColimit_op_of_hasLimit (Discrete.functor Z)\n\ninstance : HasColimit ((Discrete.opposite \u03b1).inverse \u22d9 (Discrete.functor Z).op) :=\n  hasColimit_equivalence_comp (Discrete.opposite \u03b1).symm\n\ninstance : HasCoproduct (op <| Z \u00b7) := hasColimitOfIso\n  ((Discrete.natIsoFunctor \u226a\u226b Discrete.natIso (fun _ \u21a6 by rfl)) :\n    (Discrete.opposite \u03b1).inverse \u22d9 (Discrete.functor Z).op \u2245\n    Discrete.functor (op <| Z \u00b7)).symm\n\n/-- A `Fan` gives a `Cofan` in the opposite category. -/\n@[simp]\ndef Fan.op (f : Fan Z) : Cofan (op <| Z \u00b7) := Cofan.mk _ (fun a \u21a6 (f.proj a).op)\n\n/-- If a `Fan`\u00a0is limit, then its opposite is colimit. -/\ndef Fan.IsLimit.op {f : Fan Z} (hf : IsLimit f) : IsColimit f.op := by\n  let e : Discrete.functor (Opposite.op <| Z \u00b7) \u2245 (Discrete.opposite \u03b1).inverse \u22d9\n    (Discrete.functor Z).op := Discrete.natIso (fun _ \u21a6 Iso.refl _)\n  refine IsColimit.ofIsoColimit ((IsColimit.precomposeHomEquiv e _).2\n    (IsColimit.whiskerEquivalence hf.op (Discrete.opposite \u03b1).symm))\n    (Cocones.ext (Iso.refl _) (fun \u27e8a\u27e9 \u21a6 ?_))\n  dsimp\n  erw [Category.id_comp, Category.comp_id]\n  rfl\n\n/--\nThe canonical isomorphism from the opposite of an abstract product to the corresponding coproduct\nin the opposite category.\n-/\ndef opProductIsoCoproduct' {f : Fan Z} {c : Cofan (op <| Z \u00b7)}\n    (hf : IsLimit f) (hc : IsColimit c) : op f.pt \u2245 c.pt :=\n  IsColimit.coconePointUniqueUpToIso (Fan.IsLimit.op hf) hc\n\nvariable (Z) in\n/--\nThe canonical isomorphism from the opposite of the product to the coproduct in the opposite\ncategory.\n-/\ndef opProductIsoCoproduct :\n    op (\u220f Z) \u2245 \u2210 (op <| Z \u00b7) :=\n  opProductIsoCoproduct' (productIsProduct Z) (coproductIsCoproduct (op <| Z \u00b7))\n\ntheorem proj_comp_opProductIsoCoproduct'_hom {f : Fan Z} {c : Cofan (op <| Z \u00b7)}\n    (hf : IsLimit f) (hc : IsColimit c) (b : \u03b1) :\n    (f.proj b).op \u226b (opProductIsoCoproduct' hf hc).hom = c.inj b :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (Fan.IsLimit.op hf) hc \u27e8b\u27e9\n\n", "theoremStatement": "theorem opProductIsoCoproduct'_comp_self {f f' : Fan Z} {c : Cofan (op <| Z \u00b7)}\n    (hf : IsLimit f) (hf' : IsLimit f') (hc : IsColimit c) :\n    (opProductIsoCoproduct' hf hc).hom \u226b (opProductIsoCoproduct' hf' hc).inv =\n    (hf.conePointUniqueUpToIso hf').op.inv", "theoremName": "opProductIsoCoproduct'_comp_self", "fileCreated": {"commit": "3fcb15f5aa", "date": "2023-03-11"}, "theoremCreated": {"commit": "423f5783b8", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/CategoryTheory/Limits/Opposites.lean", "positionMetadata": {"lineInFile": 510, "tokenPositionInFile": 24317, "theoremPositionInFile": 66}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  apply Quiver.Hom.unop_inj\n  apply hf.hom_ext\n  intro \u27e8j\u27e9\n  change _ \u226b f.proj _ = _\n  simp only [unop_op, unop_comp, Category.assoc, Discrete.functor_obj, Iso.op_inv,\n    Quiver.Hom.unop_op, IsLimit.conePointUniqueUpToIso_inv_comp]\n  apply Quiver.Hom.op_inj\n  simp only [op_comp, op_unop, Quiver.Hom.op_unop, proj_comp_opProductIsoCoproduct'_hom]\n  rw [\u2190 proj_comp_opProductIsoCoproduct'_hom hf' hc]\n  simp only [Category.assoc, Iso.hom_inv_id, Category.comp_id]\n  rfl", "proofType": "tactic", "proofLengthLines": 12, "proofLengthTokens": 472}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2023 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n/-!\n# \u2124-lattices\n\nLet `E` be a finite dimensional vector space over a `NormedLinearOrderedField` `K` with a solid\nnorm that is also a `FloorRing`, e.g. `\u211d`. A (full) `\u2124`-lattice `L` of `E` is a discrete\nsubgroup of `E` such that `L` spans `E` over `K`.\n\nA `\u2124`-lattice `L` can be defined in two ways:\n* For `b` a basis of `E`, then `L = Submodule.span \u2124 (Set.range b)` is a \u2124-lattice of `E`\n* As an `AddSubgroup E` with the additional properties:\n  * `DiscreteTopology L`, that is `L` is discrete\n  * `Submodule.span \u211d (L : Set E) = \u22a4`, that is `L` spans `E` over `K`.\n\nResults about the first point of view are in the `Zspan` namespace and results about the second\npoint of view are in the `Zlattice` namespace.\n\n## Main results\n\n* `Zspan.isAddFundamentalDomain`: for a \u2124-lattice `Submodule.span \u2124 (Set.range b)`, proves that\nthe set defined by `Zspan.fundamentalDomain` is a fundamental domain.\n* `Zlattice.module_free`: an AddSubgroup of `E` that is discrete and spans `E` over `K` is a free\n`\u2124`-module\n* `Zlattice.rank`:  an AddSubgroup of `E` that is discrete and spans `E` over `K` is a free\n`\u2124`-module of `\u2124`-rank equal to the `K`-rank of `E`\n-/\n\n\nopen scoped BigOperators\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n/-- The fundamental domain of the \u2124-lattice spanned by `b`. See `Zspan.isAddFundamentalDomain`\nfor the proof that it is a fundamental domain. -/\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\ntheorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, \u2190 mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, \u2190 Set.mem_image_equiv]\n  rfl\n\n@[simp]\ntheorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]\n\nlemma fundamentalDomain_pi_basisFun [Fintype \u03b9] :\n    fundamentalDomain (Pi.basisFun \u211d \u03b9) = Set.pi Set.univ fun _ : \u03b9 \u21a6 Set.Ico (0 : \u211d) 1 := by\n  ext; simp\n\nvariable [FloorRing K]\n\nsection Fintype\n\nvariable [Fintype \u03b9]\n\n/-- The map that sends a vector of `E` to the element of the \u2124-lattice spanned by `b` obtained\nby rounding down its coordinates on the basis `b`. -/\ndef floor (m : E) : span \u2124 (Set.range b) := \u2211 i, \u230ab.repr m i\u230b \u2022 b.restrictScalars \u2124 i\n#align zspan.floor Zspan.floor\n\n/-- The map that sends a vector of `E` to the element of the \u2124-lattice spanned by `b` obtained\nby rounding up its coordinates on the basis `b`. -/\ndef ceil (m : E) : span \u2124 (Set.range b) := \u2211 i, \u2308b.repr m i\u2309 \u2022 b.restrictScalars \u2124 i\n#align zspan.ceil Zspan.ceil\n\n@[simp]\ntheorem repr_floor_apply (m : E) (i : \u03b9) : b.repr (floor b m) i = \u230ab.repr m i\u230b := by\n  classical simp only [floor, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_floor_apply Zspan.repr_floor_apply\n\n@[simp]\ntheorem repr_ceil_apply (m : E) (i : \u03b9) : b.repr (ceil b m) i = \u2308b.repr m i\u2309 := by\n  classical simp only [ceil, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_ceil_apply Zspan.repr_ceil_apply\n\n@[simp]\ntheorem floor_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (floor b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_floor_apply b]\n  intro i\n  obtain \u27e8z, hz\u27e9 := (b.mem_span_iff_repr_mem \u2124 _).mp h i\n  rw [\u2190 hz]\n  exact congr_arg (Int.cast : \u2124 \u2192 K) (Int.floor_intCast z)\n#align zspan.floor_eq_self_of_mem Zspan.floor_eq_self_of_mem\n\n@[simp]\ntheorem ceil_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (ceil b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_ceil_apply b]\n  intro i\n  obtain \u27e8z, hz\u27e9 := (b.mem_span_iff_repr_mem \u2124 _).mp h i\n  rw [\u2190 hz]\n  exact congr_arg (Int.cast : \u2124 \u2192 K) (Int.ceil_intCast z)\n#align zspan.ceil_eq_self_of_mem Zspan.ceil_eq_self_of_mem\n\n/-- The map that sends a vector `E` to the `fundamentalDomain` of the lattice,\nsee `Zspan.fract_mem_fundamentalDomain`, and `fractRestrict` for the map with the codomain\nrestricted to `fundamentalDomain`. -/\ndef fract (m : E) : E := m - floor b m\n#align zspan.fract Zspan.fract\n\ntheorem fract_apply (m : E) : fract b m = m - floor b m := rfl\n#align zspan.fract_apply Zspan.fract_apply\n\n@[simp]\ntheorem repr_fract_apply (m : E) (i : \u03b9) : b.repr (fract b m) i = Int.fract (b.repr m i) := by\n  rw [fract, LinearEquiv.map_sub, Finsupp.coe_sub, Pi.sub_apply, repr_floor_apply, Int.fract]\n#align zspan.repr_fract_apply Zspan.repr_fract_apply\n\n@[simp]\ntheorem fract_fract (m : E) : fract b (fract b m) = fract b m :=\n  Basis.ext_elem b fun _ => by classical simp only [repr_fract_apply, Int.fract_fract]\n#align zspan.fract_fract Zspan.fract_fract\n\n@[simp]\ntheorem fract_zspan_add (m : E) {v : E} (h : v \u2208 span \u2124 (Set.range b)) :\n    fract b (v + m) = fract b m := by\n  classical\n  refine (Basis.ext_elem_iff b).mpr fun i => ?_\n  simp_rw [repr_fract_apply, Int.fract_eq_fract]\n  use (b.restrictScalars \u2124).repr \u27e8v, h\u27e9 i\n  rw [map_add, Finsupp.coe_add, Pi.add_apply, add_tsub_cancel_right,\n    \u2190 eq_intCast (algebraMap \u2124 K) _, Basis.restrictScalars_repr_apply, coe_mk]\n#align zspan.fract_zspan_add Zspan.fract_zspan_add\n\n@[simp]\ntheorem fract_add_zspan (m : E) {v : E} (h : v \u2208 span \u2124 (Set.range b)) :\n    fract b (m + v) = fract b m := by rw [add_comm, fract_zspan_add b m h]\n#align zspan.fract_add_zspan Zspan.fract_add_zspan\n\nvariable {b}\n\ntheorem fract_eq_self {x : E} : fract b x = x \u2194 x \u2208 fundamentalDomain b := by\n  classical simp only [Basis.ext_elem_iff b, repr_fract_apply, Int.fract_eq_self,\n    mem_fundamentalDomain, Set.mem_Ico]\n#align zspan.fract_eq_self Zspan.fract_eq_self\n\nvariable (b)\n\ntheorem fract_mem_fundamentalDomain (x : E) : fract b x \u2208 fundamentalDomain b :=\n  fract_eq_self.mp (fract_fract b _)\n#align zspan.fract_mem_fundamental_domain Zspan.fract_mem_fundamentalDomain\n\n/-- The map `fract` with codomain restricted to `fundamentalDomain`. -/\ndef fractRestrict (x : E) : fundamentalDomain b := \u27e8fract b x, fract_mem_fundamentalDomain b x\u27e9\n\ntheorem fractRestrict_surjective : Function.Surjective (fractRestrict b) :=\n  fun x => \u27e8\u2191x, Subtype.eq (fract_eq_self.mpr (Subtype.mem x))\u27e9\n\n@[simp]\ntheorem fractRestrict_apply (x : E) : (fractRestrict b x : E) = fract b x := rfl\n\ntheorem fract_eq_fract (m n : E) : fract b m = fract b n \u2194 -m + n \u2208 span \u2124 (Set.range b) := by\n  classical\n  rw [eq_comm, Basis.ext_elem_iff b]\n  simp_rw [repr_fract_apply, Int.fract_eq_fract, eq_comm, Basis.mem_span_iff_repr_mem,\n    sub_eq_neg_add, map_add, LinearEquiv.map_neg, Finsupp.coe_add, Finsupp.coe_neg, Pi.add_apply,\n    Pi.neg_apply, \u2190 eq_intCast (algebraMap \u2124 K) _, Set.mem_range]\n#align zspan.fract_eq_fract Zspan.fract_eq_fract\n\ntheorem norm_fract_le [HasSolidNorm K] (m : E) : \u2016fract b m\u2016 \u2264 \u2211 i, \u2016b i\u2016 := by\n  classical\n  calc\n    \u2016fract b m\u2016 = \u2016\u2211 i, b.repr (fract b m) i \u2022 b i\u2016 := by rw [b.sum_repr]\n    _ = \u2016\u2211 i, Int.fract (b.repr m i) \u2022 b i\u2016 := by simp_rw [repr_fract_apply]\n    _ \u2264 \u2211 i, \u2016Int.fract (b.repr m i) \u2022 b i\u2016 := norm_sum_le _ _\n    _ = \u2211 i, \u2016Int.fract (b.repr m i)\u2016 * \u2016b i\u2016 := by simp_rw [norm_smul]\n    _ \u2264 \u2211 i, \u2016b i\u2016 := Finset.sum_le_sum fun i _ => ?_\n  suffices \u2016Int.fract ((b.repr m) i)\u2016 \u2264 1 by\n    convert mul_le_mul_of_nonneg_right this (norm_nonneg _ : 0 \u2264 \u2016b i\u2016)\n    exact (one_mul _).symm\n  rw [(norm_one.symm : 1 = \u2016(1 : K)\u2016)]\n  apply norm_le_norm_of_abs_le_abs\n  rw [abs_one, Int.abs_fract]\n  exact le_of_lt (Int.fract_lt_one _)\n#align zspan.norm_fract_le Zspan.norm_fract_le\n\nsection Unique\n\nvariable [Unique \u03b9]\n\n@[simp]\ntheorem coe_floor_self (k : K) : (floor (Basis.singleton \u03b9 K) k : K) = \u230ak\u230b :=\n  Basis.ext_elem _ fun _ => by rw [repr_floor_apply, Basis.singleton_repr, Basis.singleton_repr]\n#align zspan.coe_floor_self Zspan.coe_floor_self\n\n@[simp]\ntheorem coe_fract_self (k : K) : (fract (Basis.singleton \u03b9 K) k : K) = Int.fract k :=\n  Basis.ext_elem _ fun _ => by rw [repr_fract_apply, Basis.singleton_repr, Basis.singleton_repr]\n#align zspan.coe_fract_self Zspan.coe_fract_self\n\nend Unique\n\nend Fintype\n\ntheorem fundamentalDomain_isBounded [Finite \u03b9] [HasSolidNorm K] :\n    IsBounded (fundamentalDomain b) := by\n  cases nonempty_fintype \u03b9\n  refine isBounded_iff_forall_norm_le.2 \u27e8\u2211 j, \u2016b j\u2016, fun x hx \u21a6 ?_\u27e9\n  rw [\u2190 fract_eq_self.mpr hx]\n  apply norm_fract_le\n#align zspan.fundamental_domain_bounded Zspan.fundamentalDomain_isBounded\n\ntheorem vadd_mem_fundamentalDomain [Fintype \u03b9] (y : span \u2124 (Set.range b)) (x : E) :\n    y +\u1d65 x \u2208 fundamentalDomain b \u2194 y = -floor b x := by\n  rw [Subtype.ext_iff, \u2190 add_right_inj x, NegMemClass.coe_neg, \u2190 sub_eq_add_neg, \u2190 fract_apply,\n    \u2190 fract_zspan_add b _ (Subtype.mem y), add_comm, \u2190 vadd_eq_add, \u2190 vadd_def, eq_comm, \u2190\n    fract_eq_self]\n#align zspan.vadd_mem_fundamental_domain Zspan.vadd_mem_fundamentalDomain\n\ntheorem exist_unique_vadd_mem_fundamentalDomain [Finite \u03b9] (x : E) :\n    \u2203! v : span \u2124 (Set.range b), v +\u1d65 x \u2208 fundamentalDomain b := by\n  cases nonempty_fintype \u03b9\n  refine \u27e8-floor b x, ?_, fun y h => ?_\u27e9\n  \u00b7 exact (vadd_mem_fundamentalDomain b (-floor b x) x).mpr rfl\n  \u00b7 exact (vadd_mem_fundamentalDomain b y x).mp h\n#align zspan.exist_unique_vadd_mem_fundamental_domain Zspan.exist_unique_vadd_mem_fundamentalDomain\n\n/-- The map `Zspan.fractRestrict` defines an equiv map between `E \u29f8 span \u2124 (Set.range b)`\nand `Zspan.fundamentalDomain b`. -/\ndef quotientEquiv [Fintype \u03b9] :\n    E \u29f8 span \u2124 (Set.range b) \u2243 (fundamentalDomain b) := by\n  refine Equiv.ofBijective ?_ \u27e8fun x y => ?_, fun x => ?_\u27e9\n  \u00b7 refine fun q => Quotient.liftOn q (fractRestrict b) (fun _ _ h => ?_)\n    rw [Subtype.mk.injEq, fractRestrict_apply, fractRestrict_apply, fract_eq_fract]\n    exact QuotientAddGroup.leftRel_apply.mp h\n  \u00b7 refine Quotient.inductionOn\u2082 x y (fun _ _ hxy => ?_)\n    rw [Quotient.liftOn_mk (s := quotientRel (span \u2124 (Set.range b))), fractRestrict,\n      Quotient.liftOn_mk (s := quotientRel (span \u2124 (Set.range b))),  fractRestrict,\n      Subtype.mk.injEq] at hxy\n    apply Quotient.sound'\n    rwa [QuotientAddGroup.leftRel_apply, mem_toAddSubgroup, \u2190 fract_eq_fract]\n  \u00b7 obtain \u27e8a, rfl\u27e9 := fractRestrict_surjective b x\n    exact \u27e8Quotient.mk'' a, rfl\u27e9\n\n@[simp]\ntheorem quotientEquiv_apply_mk [Fintype \u03b9] (x : E) :\n    quotientEquiv b (Submodule.Quotient.mk x) = fractRestrict b x := rfl\n\n@[simp]\ntheorem quotientEquiv.symm_apply [Fintype \u03b9] (x : fundamentalDomain b) :\n    (quotientEquiv b).symm x = Submodule.Quotient.mk \u2191x := by\n  rw [Equiv.symm_apply_eq, quotientEquiv_apply_mk b \u2191x, Subtype.ext_iff, fractRestrict_apply]\n  exact (fract_eq_self.mpr x.prop).symm\n\nend NormedLatticeField\n\nsection Real\n\ntheorem discreteTopology_pi_basisFun [Finite \u03b9] :\n    DiscreteTopology (span \u2124 (Set.range (Pi.basisFun \u211d \u03b9))) := by\n  cases nonempty_fintype \u03b9\n  refine discreteTopology_iff_isOpen_singleton_zero.mpr \u27e8Metric.ball 0 1, Metric.isOpen_ball, ?_\u27e9\n  ext x\n  rw [Set.mem_preimage, mem_ball_zero_iff, pi_norm_lt_iff zero_lt_one, Set.mem_singleton_iff]\n  simp_rw [\u2190 coe_eq_zero, Function.funext_iff, Pi.zero_apply, Real.norm_eq_abs]\n  refine forall_congr' (fun i => ?_)\n  rsuffices \u27e8y, hy\u27e9 : \u2203 (y : \u2124), (y : \u211d) = (x : \u03b9 \u2192 \u211d) i\n  \u00b7 rw [\u2190 hy, \u2190 Int.cast_abs, \u2190 Int.cast_one,  Int.cast_lt, Int.abs_lt_one_iff, Int.cast_eq_zero]\n  exact ((Pi.basisFun \u211d \u03b9).mem_span_iff_repr_mem \u2124 x).mp (SetLike.coe_mem x) i\n\nvariable [NormedAddCommGroup E] [NormedSpace \u211d E] (b : Basis \u03b9 \u211d E)\n\ntheorem fundamentalDomain_subset_parallelepiped [Fintype \u03b9] :\n    fundamentalDomain b \u2286 parallelepiped b := by\n  rw [fundamentalDomain, parallelepiped_basis_eq, Set.setOf_subset_setOf]\n  exact fun _ h i \u21a6 Set.Ico_subset_Icc_self (h i)\n\ninstance [Finite \u03b9] : DiscreteTopology (span \u2124 (Set.range b)) := by\n  have h : Set.MapsTo b.equivFun (span \u2124 (Set.range b)) (span \u2124 (Set.range (Pi.basisFun \u211d \u03b9))) := by\n    intro _ hx\n    rwa [SetLike.mem_coe, Basis.mem_span_iff_repr_mem] at hx \u22a2\n  convert DiscreteTopology.of_continuous_injective ((continuous_equivFun_basis b).restrict h) ?_\n  \u00b7 exact discreteTopology_pi_basisFun\n  \u00b7 refine Subtype.map_injective _ (Basis.equivFun b).injective\n\ninstance [Finite \u03b9] : DiscreteTopology (span \u2124 (Set.range b)).toAddSubgroup :=\n  inferInstanceAs <| DiscreteTopology (span \u2124 (Set.range b))\n\n@[measurability]\ntheorem fundamentalDomain_measurableSet [MeasurableSpace E] [OpensMeasurableSpace E] [Finite \u03b9] :\n    MeasurableSet (fundamentalDomain b) := by\n  cases nonempty_fintype \u03b9\n  haveI : FiniteDimensional \u211d E := FiniteDimensional.of_fintype_basis b\n  let D : Set (\u03b9 \u2192 \u211d) := Set.pi Set.univ fun _ : \u03b9 => Set.Ico (0 : \u211d) 1\n  rw [(_ : fundamentalDomain b = b.equivFun.toLinearMap \u207b\u00b9' D)]\n  \u00b7 refine measurableSet_preimage (LinearMap.continuous_of_finiteDimensional _).measurable ?_\n    exact MeasurableSet.pi Set.countable_univ fun _ _ => measurableSet_Ico\n  \u00b7 ext\n    simp only [D, fundamentalDomain, Set.mem_Ico, Set.mem_setOf_eq, LinearEquiv.coe_coe,\n      Set.mem_preimage, Basis.equivFun_apply, Set.mem_pi, Set.mem_univ, forall_true_left]\n#align zspan.fundamental_domain_measurable_set Zspan.fundamentalDomain_measurableSet\n\n/-- For a \u2124-lattice `Submodule.span \u2124 (Set.range b)`, proves that the set defined\nby `Zspan.fundamentalDomain` is a fundamental domain. -/\nprotected theorem isAddFundamentalDomain [Finite \u03b9] [MeasurableSpace E] [OpensMeasurableSpace E]\n    (\u03bc : Measure E) :\n    IsAddFundamentalDomain (span \u2124 (Set.range b)).toAddSubgroup (fundamentalDomain b) \u03bc := by\n  cases nonempty_fintype \u03b9\n  exact IsAddFundamentalDomain.mk' (nullMeasurableSet (fundamentalDomain_measurableSet b))\n    fun x => exist_unique_vadd_mem_fundamentalDomain b x\n#align zspan.is_add_fundamental_domain Zspan.isAddFundamentalDomain\n\ntheorem measure_fundamentalDomain_ne_zero [Finite \u03b9] [MeasurableSpace E] [BorelSpace E]\n    {\u03bc : Measure E} [Measure.IsAddHaarMeasure \u03bc] :\n    \u03bc (fundamentalDomain b) \u2260 0 := by\n  convert (Zspan.isAddFundamentalDomain b \u03bc).measure_ne_zero (NeZero.ne \u03bc)\n  simp only [mem_toAddSubgroup]\n  infer_instance\n\ntheorem measure_fundamentalDomain [Fintype \u03b9] [DecidableEq \u03b9] [MeasurableSpace E] (\u03bc : Measure E)\n    [BorelSpace E] [Measure.IsAddHaarMeasure \u03bc] (b\u2080 : Basis \u03b9 \u211d E) :\n    \u03bc (fundamentalDomain b) = ENNReal.ofReal |b\u2080.det b| * \u03bc (fundamentalDomain b\u2080) := by\n  have : FiniteDimensional \u211d E := FiniteDimensional.of_fintype_basis b\n  convert \u03bc.addHaar_preimage_linearEquiv (b.equiv b\u2080 (Equiv.refl \u03b9)) (fundamentalDomain b\u2080)\n  \u00b7 rw [Set.eq_preimage_iff_image_eq (LinearEquiv.bijective _), map_fundamentalDomain,\n      Basis.map_equiv, Equiv.refl_symm, Basis.reindex_refl]\n  \u00b7 rw [\u2190 LinearMap.det_toMatrix b\u2080, Basis.equiv_symm, Equiv.refl_symm, Basis.det_apply]\n    congr\n    ext\n    simp [Basis.toMatrix_apply, LinearMap.toMatrix_apply, LinearEquiv.coe_coe, Basis.equiv_apply]\n\n@[simp]\ntheorem volume_fundamentalDomain [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u211d (\u03b9 \u2192 \u211d)) :\n    volume (fundamentalDomain b) = ENNReal.ofReal |(Matrix.of b).det| := by\n  rw [measure_fundamentalDomain b volume (b\u2080 := Pi.basisFun \u211d \u03b9), fundamentalDomain_pi_basisFun,\n    volume_pi, Measure.pi_pi, Real.volume_Ico, sub_zero, ENNReal.ofReal_one, Finset.prod_const_one,\n    mul_one, \u2190 Matrix.det_transpose]\n  rfl\n\ntheorem fundamentalDomain_ae_parallelepiped [Fintype \u03b9] [MeasurableSpace E] (\u03bc : Measure E)\n    [BorelSpace E] [Measure.IsAddHaarMeasure \u03bc] :\n    fundamentalDomain b =\u1d50[\u03bc] parallelepiped b := by\n  classical\n  have : FiniteDimensional \u211d E := FiniteDimensional.of_fintype_basis b\n  rw [\u2190 measure_symmDiff_eq_zero_iff, symmDiff_of_le (fundamentalDomain_subset_parallelepiped b)]\n  suffices (parallelepiped b \\ fundamentalDomain b) \u2286 \u22c3 i,\n      AffineSubspace.mk' (b i) (span \u211d (b '' (Set.univ \\ {i}))) by\n    refine measure_mono_null this\n      (measure_iUnion_null_iff.mpr fun i \u21a6 Measure.addHaar_affineSubspace \u03bc _ ?_)\n    refine (ne_of_mem_of_not_mem' (AffineSubspace.mem_top _ _ 0)\n      (AffineSubspace.mem_mk'_iff_vsub_mem.not.mpr ?_)).symm\n    simp_rw [vsub_eq_sub, zero_sub, neg_mem_iff]\n    exact linearIndependent_iff_not_mem_span.mp b.linearIndependent i\n  intro x hx\n  simp_rw [parallelepiped_basis_eq, Set.mem_Icc, Set.mem_diff, Set.mem_setOf_eq,\n    mem_fundamentalDomain, Set.mem_Ico, not_forall, not_and, not_lt] at hx\n  obtain \u27e8i, hi\u27e9 := hx.2\n  have : b.repr x i = 1 := le_antisymm (hx.1 i).2 (hi (hx.1 i).1)\n  rw [\u2190 b.sum_repr x, \u2190 Finset.sum_erase_add _ _ (Finset.mem_univ i), this, one_smul, \u2190 vadd_eq_add]\n  refine Set.mem_iUnion.mpr \u27e8i, AffineSubspace.vadd_mem_mk' _\n    (sum_smul_mem _ _ (fun i hi \u21a6 Submodule.subset_span ?_))\u27e9\n  exact \u27e8i, Set.mem_diff_singleton.mpr \u27e8trivial, Finset.ne_of_mem_erase hi\u27e9, rfl\u27e9\n\nend Real\n\nend Zspan\n\nsection Zlattice\n\nopen Submodule FiniteDimensional\n\n-- TODO: generalize this class to other rings than `\u2124`\n/-- An `L : Addsubgroup E` where `E` is a vector space over a normed field `K` is a `\u2124`-lattice if\nit is discrete and spans `E` over `K`. -/\nclass IsZlattice (K : Type*) [NormedField K] {E : Type*} [NormedAddCommGroup E] [NormedSpace K E]\n    (L : AddSubgroup E) [DiscreteTopology L] : Prop where\n  /-- `L` spans the full space `E` over `K`. -/\n  span_top : span K (L : Set E) = \u22a4\n\ntheorem _root_.Zspan.isZlattice {E \u03b9 : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [Finite \u03b9] (b : Basis \u03b9 \u211d E) :\n    IsZlattice \u211d (span \u2124 (Set.range b)).toAddSubgroup where\n  span_top := Zspan.span_top b\n\nvariable (K : Type*) [NormedLinearOrderedField K] [HasSolidNorm K] [FloorRing K]\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]\nvariable [ProperSpace E] (L : AddSubgroup E) [DiscreteTopology L]\n\ntheorem Zlattice.FG [hs : IsZlattice K L] : AddSubgroup.FG L := by\n  suffices (AddSubgroup.toIntSubmodule L).FG by exact (fg_iff_add_subgroup_fg _).mp this\n  obtain \u27e8s, \u27e8h_incl, \u27e8h_span, h_lind\u27e9\u27e9\u27e9 := exists_linearIndependent K (L : Set E)\n  -- Let `s` be a maximal `K`-linear independent family of elements of `L`. We show that\n  -- `L` is finitely generated (as a \u2124-module) because it fits in the exact sequence\n  -- `0 \u2192 span \u2124 s \u2192 L \u2192 L \u29f8 span \u2124 s \u2192 0` with `span \u2124 s` and `L \u29f8 span \u2124 s` finitely generated.\n  refine fg_of_fg_map_of_fg_inf_ker (span \u2124 s).mkQ ?_ ?_\n  \u00b7 -- Let `b` be the `K`-basis of `E` formed by the vectors in `s`. The elements of\n    -- `L \u29f8 span \u2124 s = L \u29f8 span \u2124 b` are in bijection with elements of `L \u2229 fundamentalDomain b`\n    -- so there are finitely many since `fundamentalDomain b` is bounded.\n    refine fg_def.mpr \u27e8map (span \u2124 s).mkQ (AddSubgroup.toIntSubmodule L), ?_, span_eq _\u27e9\n    let b := Basis.mk h_lind (by\n      rw [\u2190 hs.span_top, \u2190 h_span]\n      exact span_mono (by simp only [Subtype.range_coe_subtype, Set.setOf_mem_eq, subset_rfl]))\n    rw [show span \u2124 s = span \u2124 (Set.range b) by simp [b, Basis.coe_mk, Subtype.range_coe_subtype]]\n    have : Fintype s := h_lind.setFinite.fintype\n    refine Set.Finite.of_finite_image (f := ((\u2191) : _ \u2192  E) \u2218 Zspan.quotientEquiv b) ?_\n      (Function.Injective.injOn (Subtype.coe_injective.comp (Zspan.quotientEquiv b).injective) _)\n    have : Set.Finite ((Zspan.fundamentalDomain b) \u2229 L) :=\n      Metric.finite_isBounded_inter_isClosed (Zspan.fundamentalDomain_isBounded b) inferInstance\n    refine Set.Finite.subset this ?_\n    rintro _ \u27e8_, \u27e8\u27e8x, \u27e8h_mem, rfl\u27e9\u27e9, rfl\u27e9\u27e9\n    rw [Function.comp_apply, mkQ_apply, Zspan.quotientEquiv_apply_mk, Zspan.fractRestrict_apply]\n    refine \u27e8?_, ?_\u27e9\n    \u00b7 exact Zspan.fract_mem_fundamentalDomain b x\n    \u00b7 rw [Zspan.fract, SetLike.mem_coe, sub_eq_add_neg]\n      refine AddSubgroup.add_mem _ h_mem\n        (neg_mem (Set.mem_of_subset_of_mem ?_ (Subtype.mem (Zspan.floor b x))))\n      rw [show (L : Set E) = AddSubgroup.toIntSubmodule L by rfl]\n      rw [SetLike.coe_subset_coe, Basis.coe_mk, Subtype.range_coe_subtype, Set.setOf_mem_eq]\n      exact span_le.mpr h_incl\n  \u00b7 -- `span \u2124 s` is finitely generated because `s` is finite\n    rw [ker_mkQ, inf_of_le_right (span_le.mpr h_incl)]\n    exact fg_span (LinearIndependent.setFinite h_lind)\n\ntheorem Zlattice.module_finite [IsZlattice K L] : Module.Finite \u2124 L :=\n  Module.Finite.iff_addGroup_fg.mpr ((AddGroup.fg_iff_addSubgroup_fg L).mpr (FG K L))\n\ninstance instModuleFinite_of_discrete_addSubgroup {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace \u211d E] [FiniteDimensional \u211d E] (L : AddSubgroup E) [DiscreteTopology L] :\n    Module.Finite \u2124 L := by\n  let f := (span \u211d (L : Set E)).subtype\n  let L\u2080 := (AddSubgroup.toIntSubmodule L).comap (f.restrictScalars \u2124)\n  have h_img : f '' L\u2080 = L := by\n    rw [\u2190 LinearMap.coe_restrictScalars \u2124 f, \u2190 Submodule.map_coe (f.restrictScalars \u2124),\n      Submodule.map_comap_eq_self, AddSubgroup.coe_toIntSubmodule]\n    exact fun x hx \u21a6 LinearMap.mem_range.mpr \u27e8\u27e8x, Submodule.subset_span hx\u27e9, rfl\u27e9\n  suffices Module.Finite \u2124 L\u2080 by\n    have : L\u2080.map (f.restrictScalars \u2124) = (AddSubgroup.toIntSubmodule L) :=\n      SetLike.ext'_iff.mpr h_img\n    convert this \u25b8 Module.Finite.map L\u2080 (f.restrictScalars \u2124)\n  have : DiscreteTopology L\u2080.toAddSubgroup := by\n    refine DiscreteTopology.preimage_of_continuous_injective (L : Set E) ?_ (injective_subtype _)\n    exact LinearMap.continuous_of_finiteDimensional f\n  have : IsZlattice \u211d L\u2080.toAddSubgroup := \u27e8by\n    rw [\u2190 (Submodule.map_injective_of_injective (injective_subtype _)).eq_iff, Submodule.map_span,\n      Submodule.map_top, range_subtype, coe_toAddSubgroup, h_img]\u27e9\n  exact Zlattice.module_finite \u211d L\u2080.toAddSubgroup\n\ntheorem Zlattice.module_free [IsZlattice K L] : Module.Free \u2124 L := by\n  have : Module.Finite \u2124 L := module_finite K L\n  have : Module \u211a E := Module.compHom E (algebraMap \u211a K)\n  have : NoZeroSMulDivisors \u2124 E := RatModule.noZeroSMulDivisors\n  have : NoZeroSMulDivisors \u2124 L := by\n    change NoZeroSMulDivisors \u2124 (AddSubgroup.toIntSubmodule L)\n    exact noZeroSMulDivisors _\n  infer_instance\n\ninstance instModuleFree_of_discrete_addSubgroup {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace \u211d E] [FiniteDimensional \u211d E] (L : AddSubgroup E) [DiscreteTopology L] :\n    Module.Free \u2124 L := by\n  have : Module \u211a E := Module.compHom E (algebraMap \u211a \u211d)\n  have : NoZeroSMulDivisors \u2124 E := RatModule.noZeroSMulDivisors\n  have : NoZeroSMulDivisors \u2124 L := by\n    change NoZeroSMulDivisors \u2124 (AddSubgroup.toIntSubmodule L)\n    exact noZeroSMulDivisors _\n  infer_instance\n\ntheorem Zlattice.rank [hs : IsZlattice K L] : finrank \u2124 L = finrank K E := by\n  classical\n  have : Module.Finite \u2124 L := module_finite K L\n  have : Module.Free \u2124 L := module_free K L\n  have : Module \u211a E := Module.compHom E (algebraMap \u211a K)\n  let b\u2080 := Module.Free.chooseBasis \u2124 L\n  -- Let `b` be a `\u2124`-basis of `L` formed of vectors of `E`\n  let b := Subtype.val \u2218 b\u2080\n  have : LinearIndependent \u2124 b :=\n    LinearIndependent.map' b\u2080.linearIndependent (L.toIntSubmodule.subtype) (ker_subtype _)\n  -- We prove some assertions that will be useful later on\n  have h_spanL : span \u2124 (Set.range b) = AddSubgroup.toIntSubmodule L := by\n    convert congrArg (map (Submodule.subtype (AddSubgroup.toIntSubmodule L))) b\u2080.span_eq\n    \u00b7 rw [map_span, Set.range_comp]\n      rfl\n    \u00b7 exact (map_subtype_top _).symm\n  have h_spanE : span K (Set.range b) = \u22a4 := by\n    rw [\u2190 span_span_of_tower (R := \u2124), h_spanL]\n    exact hs.span_top\n  have h_card : Fintype.card (Module.Free.ChooseBasisIndex \u2124 L) =\n      (Set.range b).toFinset.card := by\n    rw [Set.toFinset_range, Finset.univ.card_image_of_injective]\n    rfl\n    exact Subtype.coe_injective.comp (Basis.injective _)\n  rw [finrank_eq_card_chooseBasisIndex]\n    -- We prove that `finrank \u2124 L \u2264 finrank K E` and `finrank K E \u2264 finrank \u2124 L`\n  refine le_antisymm ?_ ?_\n  \u00b7 -- To prove that `finrank \u2124 L \u2264 finrank K E`, we proceed by contradiction and prove that, in\n    -- this case, there is a \u2124-relation between the vectors of `b`\n    obtain \u27e8t, \u27e8ht_inc, \u27e8ht_span, ht_lin\u27e9\u27e9\u27e9 := exists_linearIndependent K (Set.range b)\n    -- `e` is a `K`-basis of `E` formed of vectors of `b`\n    let e : Basis t K E := Basis.mk ht_lin (by simp [ht_span, h_spanE])\n    have : Fintype t := Set.Finite.fintype ((Set.range b).toFinite.subset ht_inc)\n    have h : LinearIndependent \u2124 (fun x : (Set.range b) => (x : E)) := by\n      rwa [linearIndependent_subtype_range (Subtype.coe_injective.comp b\u2080.injective)]\n    contrapose! h\n    -- Since `finrank \u2124 L > finrank K E`, there exists a vector `v \u2208 b` with `v \u2209 e`\n    obtain \u27e8v, hv\u27e9 : (Set.range b \\ Set.range e).Nonempty := by\n      rw [Basis.coe_mk, Subtype.range_coe_subtype, Set.setOf_mem_eq, \u2190 Set.toFinset_nonempty]\n      contrapose h\n      rw [Finset.not_nonempty_iff_eq_empty, Set.toFinset_diff,\n        Finset.sdiff_eq_empty_iff_subset] at h\n      replace h := Finset.card_le_card h\n      rwa [not_lt, h_card, \u2190 topEquiv.finrank_eq, \u2190 h_spanE, \u2190 ht_span,\n        finrank_span_set_eq_card ht_lin]\n    -- Assume that `e \u222a {v}` is not `\u2124`-linear independent then we get the contradiction\n    suffices \u00ac LinearIndependent \u2124 (fun x : \u21a5(insert v (Set.range e)) => (x : E)) by\n      contrapose! this\n      refine LinearIndependent.mono ?_ this\n      exact Set.insert_subset (Set.mem_of_mem_diff hv) (by simp [e, ht_inc])\n    -- We prove finally that `e \u222a {v}` is not \u2124-linear independent or, equivalently,\n    -- not \u211a-linear independent by showing that `v \u2208 span \u211a e`.\n    rw [LinearIndependent.iff_fractionRing \u2124 \u211a,\n      linearIndependent_insert (Set.not_mem_of_mem_diff hv),  not_and, not_not]\n    intro _\n    -- But that follows from the fact that there exist `n, m : \u2115`, `n \u2260 m`\n    -- such that `(n - m) \u2022 v \u2208 span \u2124 e` which is true since `n \u21a6 Zspan.fract e (n \u2022 v)`\n    -- takes value into the finite set `fundamentalDomain e \u2229 L`\n    have h_mapsto : Set.MapsTo (fun n : \u2124 => Zspan.fract e (n \u2022 v)) Set.univ\n        (Metric.closedBall 0 (\u2211 i, \u2016e i\u2016) \u2229 (L : Set E)) := by\n      rw [Set.mapsTo_inter, Set.mapsTo_univ_iff, Set.mapsTo_univ_iff]\n      refine \u27e8fun _ \u21a6 mem_closedBall_zero_iff.mpr (Zspan.norm_fract_le e _), fun _ => ?_\u27e9\n      \u00b7 change _ \u2208 AddSubgroup.toIntSubmodule L\n        rw [\u2190 h_spanL]\n        refine sub_mem ?_ ?_\n        \u00b7 exact zsmul_mem (subset_span (Set.diff_subset _ _ hv)) _\n        \u00b7 exact span_mono (by simp [e, ht_inc]) (coe_mem _)\n    have h_finite : Set.Finite (Metric.closedBall 0 (\u2211 i, \u2016e i\u2016) \u2229 (L : Set E)) :=\n      Metric.finite_isBounded_inter_isClosed Metric.isBounded_closedBall inferInstance\n    obtain \u27e8n, -, m, -, h_neq, h_eq\u27e9 := Set.Infinite.exists_ne_map_eq_of_mapsTo\n      Set.infinite_univ h_mapsto h_finite\n    have h_nz : (-n + m : \u211a) \u2260 0 := by\n      rwa [Ne, add_eq_zero_iff_eq_neg.not, neg_inj, Rat.coe_int_inj, \u2190 Ne]\n    apply (smul_mem_iff _ h_nz).mp\n    refine span_subset_span \u2124 \u211a _ ?_\n    rwa [add_smul, neg_smul, SetLike.mem_coe, \u2190 Zspan.fract_eq_fract, \u2190 zsmul_eq_smul_cast \u211a,\n      \u2190 zsmul_eq_smul_cast \u211a]\n  \u00b7 -- To prove that `finrank K E \u2264 finrank \u2124 L`, we use the fact `b` generates `E` over `K`\n    -- and thus `finrank K E \u2264 card b = finrank \u2124 L`\n    rw [\u2190 topEquiv.finrank_eq, \u2190 h_spanE]\n    convert finrank_span_le_card (R := K) (Set.range b)\n\nopen Module\n\nvariable {\u03b9 : Type*} [hs : IsZlattice K L] (b : Basis \u03b9 \u2124 L)\n/-- Any `\u2124`-basis of `L` is also a `K`-basis of `E`. -/\ndef Basis.ofZlatticeBasis :\n    Basis \u03b9 K E := by\n  have : Finite \u2124 L := Zlattice.module_finite K L\n  have : Free \u2124 L := Zlattice.module_free K L\n  let e :=  Basis.indexEquiv (Free.chooseBasis \u2124 L) b\n  have : Fintype \u03b9 := Fintype.ofEquiv _ e\n  refine basisOfTopLeSpanOfCardEqFinrank (L.subtype.toIntLinearMap \u2218 b) ?_ ?_\n  \u00b7 rw [\u2190 span_span_of_tower \u2124, Set.range_comp, \u2190 map_span, Basis.span_eq, Submodule.map_top,\n      top_le_iff, AddMonoidHom.coe_toIntLinearMap_range, AddSubgroup.subtype_range,\n      AddSubgroup.coe_toIntSubmodule, hs.span_top]\n  \u00b7 rw [\u2190 Fintype.card_congr e, \u2190 finrank_eq_card_chooseBasisIndex, Zlattice.rank K L]\n\n@[simp]\ntheorem Basis.ofZlatticeBasis_apply (i : \u03b9) :\n    b.ofZlatticeBasis K L i =  b i := by simp [Basis.ofZlatticeBasis]\n\n@[simp]\ntheorem Basis.ofZlatticeBasis_repr_apply (x : L) (i : \u03b9) :\n    (b.ofZlatticeBasis K L).repr x i = b.repr x i := by\n  suffices ((b.ofZlatticeBasis K L).repr.toLinearMap.restrictScalars \u2124) \u2218\u2097 L.subtype.toIntLinearMap\n      = Finsupp.mapRange.linearMap (Algebra.linearMap \u2124 K) \u2218\u2097 b.repr.toLinearMap by\n    exact DFunLike.congr_fun (LinearMap.congr_fun this x) i\n  refine Basis.ext b fun i \u21a6 ?_\n  simp_rw [LinearMap.coe_comp, Function.comp_apply, LinearMap.coe_restrictScalars,\n    LinearEquiv.coe_coe, AddMonoidHom.coe_toIntLinearMap, AddSubgroup.coeSubtype,\n    \u2190 b.ofZlatticeBasis_apply K, repr_self, Finsupp.mapRange.linearMap_apply,\n    Finsupp.mapRange_single, Algebra.linearMap_apply, map_one]\n\ntheorem Basis.ofZlatticeBasis_span :\n    (span \u2124 (Set.range (b.ofZlatticeBasis K))).toAddSubgroup = L := by\n  calc (span \u2124 (Set.range (b.ofZlatticeBasis K))).toAddSubgroup\n    _ = (span \u2124 (L.subtype.toIntLinearMap '' (Set.range b))).toAddSubgroup := by congr; ext; simp\n    _ = (map L.subtype.toIntLinearMap (span \u2124 (Set.range b))).toAddSubgroup := by\n        rw [Submodule.map_span]\n    _ = L := by simp [b.span_eq]\n\n", "theoremStatement": "theorem Zlattice.isAddFundamentalDomain {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {L : AddSubgroup E} [DiscreteTopology L] [IsZlattice \u211d L] [Finite \u03b9]\n    (b : Basis \u03b9 \u2124 L) [MeasurableSpace E] [OpensMeasurableSpace E] (\u03bc : MeasureTheory.Measure E) :\n    MeasureTheory.IsAddFundamentalDomain L (Zspan.fundamentalDomain (b.ofZlatticeBasis \u211d)) \u03bc", "theoremName": "Zlattice.isAddFundamentalDomain", "fileCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "theoremCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/Zlattice/Basic.lean", "positionMetadata": {"lineInFile": 621, "tokenPositionInFile": 30285, "theoremPositionInFile": 53}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  convert Zspan.isAddFundamentalDomain (b.ofZlatticeBasis \u211d) \u03bc\n  all_goals exact (b.ofZlatticeBasis_span \u211d).symm", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 115}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2023 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n/-!\n# \u2124-lattices\n\nLet `E` be a finite dimensional vector space over a `NormedLinearOrderedField` `K` with a solid\nnorm that is also a `FloorRing`, e.g. `\u211d`. A (full) `\u2124`-lattice `L` of `E` is a discrete\nsubgroup of `E` such that `L` spans `E` over `K`.\n\nA `\u2124`-lattice `L` can be defined in two ways:\n* For `b` a basis of `E`, then `L = Submodule.span \u2124 (Set.range b)` is a \u2124-lattice of `E`\n* As an `AddSubgroup E` with the additional properties:\n  * `DiscreteTopology L`, that is `L` is discrete\n  * `Submodule.span \u211d (L : Set E) = \u22a4`, that is `L` spans `E` over `K`.\n\nResults about the first point of view are in the `Zspan` namespace and results about the second\npoint of view are in the `Zlattice` namespace.\n\n## Main results\n\n* `Zspan.isAddFundamentalDomain`: for a \u2124-lattice `Submodule.span \u2124 (Set.range b)`, proves that\nthe set defined by `Zspan.fundamentalDomain` is a fundamental domain.\n* `Zlattice.module_free`: an AddSubgroup of `E` that is discrete and spans `E` over `K` is a free\n`\u2124`-module\n* `Zlattice.rank`:  an AddSubgroup of `E` that is discrete and spans `E` over `K` is a free\n`\u2124`-module of `\u2124`-rank equal to the `K`-rank of `E`\n-/\n\n\nopen scoped BigOperators\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n/-- The fundamental domain of the \u2124-lattice spanned by `b`. See `Zspan.isAddFundamentalDomain`\nfor the proof that it is a fundamental domain. -/\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\ntheorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, \u2190 mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, \u2190 Set.mem_image_equiv]\n  rfl\n\n@[simp]\ntheorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]\n\nlemma fundamentalDomain_pi_basisFun [Fintype \u03b9] :\n    fundamentalDomain (Pi.basisFun \u211d \u03b9) = Set.pi Set.univ fun _ : \u03b9 \u21a6 Set.Ico (0 : \u211d) 1 := by\n  ext; simp\n\nvariable [FloorRing K]\n\nsection Fintype\n\nvariable [Fintype \u03b9]\n\n/-- The map that sends a vector of `E` to the element of the \u2124-lattice spanned by `b` obtained\nby rounding down its coordinates on the basis `b`. -/\ndef floor (m : E) : span \u2124 (Set.range b) := \u2211 i, \u230ab.repr m i\u230b \u2022 b.restrictScalars \u2124 i\n#align zspan.floor Zspan.floor\n\n/-- The map that sends a vector of `E` to the element of the \u2124-lattice spanned by `b` obtained\nby rounding up its coordinates on the basis `b`. -/\ndef ceil (m : E) : span \u2124 (Set.range b) := \u2211 i, \u2308b.repr m i\u2309 \u2022 b.restrictScalars \u2124 i\n#align zspan.ceil Zspan.ceil\n\n@[simp]\ntheorem repr_floor_apply (m : E) (i : \u03b9) : b.repr (floor b m) i = \u230ab.repr m i\u230b := by\n  classical simp only [floor, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_floor_apply Zspan.repr_floor_apply\n\n@[simp]\ntheorem repr_ceil_apply (m : E) (i : \u03b9) : b.repr (ceil b m) i = \u2308b.repr m i\u2309 := by\n  classical simp only [ceil, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_ceil_apply Zspan.repr_ceil_apply\n\n@[simp]\ntheorem floor_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (floor b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_floor_apply b]\n  intro i\n  obtain \u27e8z, hz\u27e9 := (b.mem_span_iff_repr_mem \u2124 _).mp h i\n  rw [\u2190 hz]\n  exact congr_arg (Int.cast : \u2124 \u2192 K) (Int.floor_intCast z)\n#align zspan.floor_eq_self_of_mem Zspan.floor_eq_self_of_mem\n\n@[simp]\ntheorem ceil_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (ceil b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_ceil_apply b]\n  intro i\n  obtain \u27e8z, hz\u27e9 := (b.mem_span_iff_repr_mem \u2124 _).mp h i\n  rw [\u2190 hz]\n  exact congr_arg (Int.cast : \u2124 \u2192 K) (Int.ceil_intCast z)\n#align zspan.ceil_eq_self_of_mem Zspan.ceil_eq_self_of_mem\n\n/-- The map that sends a vector `E` to the `fundamentalDomain` of the lattice,\nsee `Zspan.fract_mem_fundamentalDomain`, and `fractRestrict` for the map with the codomain\nrestricted to `fundamentalDomain`. -/\ndef fract (m : E) : E := m - floor b m\n#align zspan.fract Zspan.fract\n\ntheorem fract_apply (m : E) : fract b m = m - floor b m := rfl\n#align zspan.fract_apply Zspan.fract_apply\n\n@[simp]\ntheorem repr_fract_apply (m : E) (i : \u03b9) : b.repr (fract b m) i = Int.fract (b.repr m i) := by\n  rw [fract, LinearEquiv.map_sub, Finsupp.coe_sub, Pi.sub_apply, repr_floor_apply, Int.fract]\n#align zspan.repr_fract_apply Zspan.repr_fract_apply\n\n@[simp]\ntheorem fract_fract (m : E) : fract b (fract b m) = fract b m :=\n  Basis.ext_elem b fun _ => by classical simp only [repr_fract_apply, Int.fract_fract]\n#align zspan.fract_fract Zspan.fract_fract\n\n@[simp]\ntheorem fract_zspan_add (m : E) {v : E} (h : v \u2208 span \u2124 (Set.range b)) :\n    fract b (v + m) = fract b m := by\n  classical\n  refine (Basis.ext_elem_iff b).mpr fun i => ?_\n  simp_rw [repr_fract_apply, Int.fract_eq_fract]\n  use (b.restrictScalars \u2124).repr \u27e8v, h\u27e9 i\n  rw [map_add, Finsupp.coe_add, Pi.add_apply, add_tsub_cancel_right,\n    \u2190 eq_intCast (algebraMap \u2124 K) _, Basis.restrictScalars_repr_apply, coe_mk]\n#align zspan.fract_zspan_add Zspan.fract_zspan_add\n\n@[simp]\ntheorem fract_add_zspan (m : E) {v : E} (h : v \u2208 span \u2124 (Set.range b)) :\n    fract b (m + v) = fract b m := by rw [add_comm, fract_zspan_add b m h]\n#align zspan.fract_add_zspan Zspan.fract_add_zspan\n\nvariable {b}\n\ntheorem fract_eq_self {x : E} : fract b x = x \u2194 x \u2208 fundamentalDomain b := by\n  classical simp only [Basis.ext_elem_iff b, repr_fract_apply, Int.fract_eq_self,\n    mem_fundamentalDomain, Set.mem_Ico]\n#align zspan.fract_eq_self Zspan.fract_eq_self\n\nvariable (b)\n\ntheorem fract_mem_fundamentalDomain (x : E) : fract b x \u2208 fundamentalDomain b :=\n  fract_eq_self.mp (fract_fract b _)\n#align zspan.fract_mem_fundamental_domain Zspan.fract_mem_fundamentalDomain\n\n/-- The map `fract` with codomain restricted to `fundamentalDomain`. -/\ndef fractRestrict (x : E) : fundamentalDomain b := \u27e8fract b x, fract_mem_fundamentalDomain b x\u27e9\n\ntheorem fractRestrict_surjective : Function.Surjective (fractRestrict b) :=\n  fun x => \u27e8\u2191x, Subtype.eq (fract_eq_self.mpr (Subtype.mem x))\u27e9\n\n@[simp]\ntheorem fractRestrict_apply (x : E) : (fractRestrict b x : E) = fract b x := rfl\n\ntheorem fract_eq_fract (m n : E) : fract b m = fract b n \u2194 -m + n \u2208 span \u2124 (Set.range b) := by\n  classical\n  rw [eq_comm, Basis.ext_elem_iff b]\n  simp_rw [repr_fract_apply, Int.fract_eq_fract, eq_comm, Basis.mem_span_iff_repr_mem,\n    sub_eq_neg_add, map_add, LinearEquiv.map_neg, Finsupp.coe_add, Finsupp.coe_neg, Pi.add_apply,\n    Pi.neg_apply, \u2190 eq_intCast (algebraMap \u2124 K) _, Set.mem_range]\n#align zspan.fract_eq_fract Zspan.fract_eq_fract\n\ntheorem norm_fract_le [HasSolidNorm K] (m : E) : \u2016fract b m\u2016 \u2264 \u2211 i, \u2016b i\u2016 := by\n  classical\n  calc\n    \u2016fract b m\u2016 = \u2016\u2211 i, b.repr (fract b m) i \u2022 b i\u2016 := by rw [b.sum_repr]\n    _ = \u2016\u2211 i, Int.fract (b.repr m i) \u2022 b i\u2016 := by simp_rw [repr_fract_apply]\n    _ \u2264 \u2211 i, \u2016Int.fract (b.repr m i) \u2022 b i\u2016 := norm_sum_le _ _\n    _ = \u2211 i, \u2016Int.fract (b.repr m i)\u2016 * \u2016b i\u2016 := by simp_rw [norm_smul]\n    _ \u2264 \u2211 i, \u2016b i\u2016 := Finset.sum_le_sum fun i _ => ?_\n  suffices \u2016Int.fract ((b.repr m) i)\u2016 \u2264 1 by\n    convert mul_le_mul_of_nonneg_right this (norm_nonneg _ : 0 \u2264 \u2016b i\u2016)\n    exact (one_mul _).symm\n  rw [(norm_one.symm : 1 = \u2016(1 : K)\u2016)]\n  apply norm_le_norm_of_abs_le_abs\n  rw [abs_one, Int.abs_fract]\n  exact le_of_lt (Int.fract_lt_one _)\n#align zspan.norm_fract_le Zspan.norm_fract_le\n\nsection Unique\n\nvariable [Unique \u03b9]\n\n@[simp]\ntheorem coe_floor_self (k : K) : (floor (Basis.singleton \u03b9 K) k : K) = \u230ak\u230b :=\n  Basis.ext_elem _ fun _ => by rw [repr_floor_apply, Basis.singleton_repr, Basis.singleton_repr]\n#align zspan.coe_floor_self Zspan.coe_floor_self\n\n@[simp]\ntheorem coe_fract_self (k : K) : (fract (Basis.singleton \u03b9 K) k : K) = Int.fract k :=\n  Basis.ext_elem _ fun _ => by rw [repr_fract_apply, Basis.singleton_repr, Basis.singleton_repr]\n#align zspan.coe_fract_self Zspan.coe_fract_self\n\nend Unique\n\nend Fintype\n\ntheorem fundamentalDomain_isBounded [Finite \u03b9] [HasSolidNorm K] :\n    IsBounded (fundamentalDomain b) := by\n  cases nonempty_fintype \u03b9\n  refine isBounded_iff_forall_norm_le.2 \u27e8\u2211 j, \u2016b j\u2016, fun x hx \u21a6 ?_\u27e9\n  rw [\u2190 fract_eq_self.mpr hx]\n  apply norm_fract_le\n#align zspan.fundamental_domain_bounded Zspan.fundamentalDomain_isBounded\n\ntheorem vadd_mem_fundamentalDomain [Fintype \u03b9] (y : span \u2124 (Set.range b)) (x : E) :\n    y +\u1d65 x \u2208 fundamentalDomain b \u2194 y = -floor b x := by\n  rw [Subtype.ext_iff, \u2190 add_right_inj x, NegMemClass.coe_neg, \u2190 sub_eq_add_neg, \u2190 fract_apply,\n    \u2190 fract_zspan_add b _ (Subtype.mem y), add_comm, \u2190 vadd_eq_add, \u2190 vadd_def, eq_comm, \u2190\n    fract_eq_self]\n#align zspan.vadd_mem_fundamental_domain Zspan.vadd_mem_fundamentalDomain\n\ntheorem exist_unique_vadd_mem_fundamentalDomain [Finite \u03b9] (x : E) :\n    \u2203! v : span \u2124 (Set.range b), v +\u1d65 x \u2208 fundamentalDomain b := by\n  cases nonempty_fintype \u03b9\n  refine \u27e8-floor b x, ?_, fun y h => ?_\u27e9\n  \u00b7 exact (vadd_mem_fundamentalDomain b (-floor b x) x).mpr rfl\n  \u00b7 exact (vadd_mem_fundamentalDomain b y x).mp h\n#align zspan.exist_unique_vadd_mem_fundamental_domain Zspan.exist_unique_vadd_mem_fundamentalDomain\n\n/-- The map `Zspan.fractRestrict` defines an equiv map between `E \u29f8 span \u2124 (Set.range b)`\nand `Zspan.fundamentalDomain b`. -/\ndef quotientEquiv [Fintype \u03b9] :\n    E \u29f8 span \u2124 (Set.range b) \u2243 (fundamentalDomain b) := by\n  refine Equiv.ofBijective ?_ \u27e8fun x y => ?_, fun x => ?_\u27e9\n  \u00b7 refine fun q => Quotient.liftOn q (fractRestrict b) (fun _ _ h => ?_)\n    rw [Subtype.mk.injEq, fractRestrict_apply, fractRestrict_apply, fract_eq_fract]\n    exact QuotientAddGroup.leftRel_apply.mp h\n  \u00b7 refine Quotient.inductionOn\u2082 x y (fun _ _ hxy => ?_)\n    rw [Quotient.liftOn_mk (s := quotientRel (span \u2124 (Set.range b))), fractRestrict,\n      Quotient.liftOn_mk (s := quotientRel (span \u2124 (Set.range b))),  fractRestrict,\n      Subtype.mk.injEq] at hxy\n    apply Quotient.sound'\n    rwa [QuotientAddGroup.leftRel_apply, mem_toAddSubgroup, \u2190 fract_eq_fract]\n  \u00b7 obtain \u27e8a, rfl\u27e9 := fractRestrict_surjective b x\n    exact \u27e8Quotient.mk'' a, rfl\u27e9\n\n@[simp]\ntheorem quotientEquiv_apply_mk [Fintype \u03b9] (x : E) :\n    quotientEquiv b (Submodule.Quotient.mk x) = fractRestrict b x := rfl\n\n@[simp]\ntheorem quotientEquiv.symm_apply [Fintype \u03b9] (x : fundamentalDomain b) :\n    (quotientEquiv b).symm x = Submodule.Quotient.mk \u2191x := by\n  rw [Equiv.symm_apply_eq, quotientEquiv_apply_mk b \u2191x, Subtype.ext_iff, fractRestrict_apply]\n  exact (fract_eq_self.mpr x.prop).symm\n\nend NormedLatticeField\n\nsection Real\n\ntheorem discreteTopology_pi_basisFun [Finite \u03b9] :\n    DiscreteTopology (span \u2124 (Set.range (Pi.basisFun \u211d \u03b9))) := by\n  cases nonempty_fintype \u03b9\n  refine discreteTopology_iff_isOpen_singleton_zero.mpr \u27e8Metric.ball 0 1, Metric.isOpen_ball, ?_\u27e9\n  ext x\n  rw [Set.mem_preimage, mem_ball_zero_iff, pi_norm_lt_iff zero_lt_one, Set.mem_singleton_iff]\n  simp_rw [\u2190 coe_eq_zero, Function.funext_iff, Pi.zero_apply, Real.norm_eq_abs]\n  refine forall_congr' (fun i => ?_)\n  rsuffices \u27e8y, hy\u27e9 : \u2203 (y : \u2124), (y : \u211d) = (x : \u03b9 \u2192 \u211d) i\n  \u00b7 rw [\u2190 hy, \u2190 Int.cast_abs, \u2190 Int.cast_one,  Int.cast_lt, Int.abs_lt_one_iff, Int.cast_eq_zero]\n  exact ((Pi.basisFun \u211d \u03b9).mem_span_iff_repr_mem \u2124 x).mp (SetLike.coe_mem x) i\n\nvariable [NormedAddCommGroup E] [NormedSpace \u211d E] (b : Basis \u03b9 \u211d E)\n\ntheorem fundamentalDomain_subset_parallelepiped [Fintype \u03b9] :\n    fundamentalDomain b \u2286 parallelepiped b := by\n  rw [fundamentalDomain, parallelepiped_basis_eq, Set.setOf_subset_setOf]\n  exact fun _ h i \u21a6 Set.Ico_subset_Icc_self (h i)\n\ninstance [Finite \u03b9] : DiscreteTopology (span \u2124 (Set.range b)) := by\n  have h : Set.MapsTo b.equivFun (span \u2124 (Set.range b)) (span \u2124 (Set.range (Pi.basisFun \u211d \u03b9))) := by\n    intro _ hx\n    rwa [SetLike.mem_coe, Basis.mem_span_iff_repr_mem] at hx \u22a2\n  convert DiscreteTopology.of_continuous_injective ((continuous_equivFun_basis b).restrict h) ?_\n  \u00b7 exact discreteTopology_pi_basisFun\n  \u00b7 refine Subtype.map_injective _ (Basis.equivFun b).injective\n\ninstance [Finite \u03b9] : DiscreteTopology (span \u2124 (Set.range b)).toAddSubgroup :=\n  inferInstanceAs <| DiscreteTopology (span \u2124 (Set.range b))\n\n@[measurability]\ntheorem fundamentalDomain_measurableSet [MeasurableSpace E] [OpensMeasurableSpace E] [Finite \u03b9] :\n    MeasurableSet (fundamentalDomain b) := by\n  cases nonempty_fintype \u03b9\n  haveI : FiniteDimensional \u211d E := FiniteDimensional.of_fintype_basis b\n  let D : Set (\u03b9 \u2192 \u211d) := Set.pi Set.univ fun _ : \u03b9 => Set.Ico (0 : \u211d) 1\n  rw [(_ : fundamentalDomain b = b.equivFun.toLinearMap \u207b\u00b9' D)]\n  \u00b7 refine measurableSet_preimage (LinearMap.continuous_of_finiteDimensional _).measurable ?_\n    exact MeasurableSet.pi Set.countable_univ fun _ _ => measurableSet_Ico\n  \u00b7 ext\n    simp only [D, fundamentalDomain, Set.mem_Ico, Set.mem_setOf_eq, LinearEquiv.coe_coe,\n      Set.mem_preimage, Basis.equivFun_apply, Set.mem_pi, Set.mem_univ, forall_true_left]\n#align zspan.fundamental_domain_measurable_set Zspan.fundamentalDomain_measurableSet\n\n/-- For a \u2124-lattice `Submodule.span \u2124 (Set.range b)`, proves that the set defined\nby `Zspan.fundamentalDomain` is a fundamental domain. -/\nprotected theorem isAddFundamentalDomain [Finite \u03b9] [MeasurableSpace E] [OpensMeasurableSpace E]\n    (\u03bc : Measure E) :\n    IsAddFundamentalDomain (span \u2124 (Set.range b)).toAddSubgroup (fundamentalDomain b) \u03bc := by\n  cases nonempty_fintype \u03b9\n  exact IsAddFundamentalDomain.mk' (nullMeasurableSet (fundamentalDomain_measurableSet b))\n    fun x => exist_unique_vadd_mem_fundamentalDomain b x\n#align zspan.is_add_fundamental_domain Zspan.isAddFundamentalDomain\n\ntheorem measure_fundamentalDomain_ne_zero [Finite \u03b9] [MeasurableSpace E] [BorelSpace E]\n    {\u03bc : Measure E} [Measure.IsAddHaarMeasure \u03bc] :\n    \u03bc (fundamentalDomain b) \u2260 0 := by\n  convert (Zspan.isAddFundamentalDomain b \u03bc).measure_ne_zero (NeZero.ne \u03bc)\n  simp only [mem_toAddSubgroup]\n  infer_instance\n\ntheorem measure_fundamentalDomain [Fintype \u03b9] [DecidableEq \u03b9] [MeasurableSpace E] (\u03bc : Measure E)\n    [BorelSpace E] [Measure.IsAddHaarMeasure \u03bc] (b\u2080 : Basis \u03b9 \u211d E) :\n    \u03bc (fundamentalDomain b) = ENNReal.ofReal |b\u2080.det b| * \u03bc (fundamentalDomain b\u2080) := by\n  have : FiniteDimensional \u211d E := FiniteDimensional.of_fintype_basis b\n  convert \u03bc.addHaar_preimage_linearEquiv (b.equiv b\u2080 (Equiv.refl \u03b9)) (fundamentalDomain b\u2080)\n  \u00b7 rw [Set.eq_preimage_iff_image_eq (LinearEquiv.bijective _), map_fundamentalDomain,\n      Basis.map_equiv, Equiv.refl_symm, Basis.reindex_refl]\n  \u00b7 rw [\u2190 LinearMap.det_toMatrix b\u2080, Basis.equiv_symm, Equiv.refl_symm, Basis.det_apply]\n    congr\n    ext\n    simp [Basis.toMatrix_apply, LinearMap.toMatrix_apply, LinearEquiv.coe_coe, Basis.equiv_apply]\n\n@[simp]\ntheorem volume_fundamentalDomain [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u211d (\u03b9 \u2192 \u211d)) :\n    volume (fundamentalDomain b) = ENNReal.ofReal |(Matrix.of b).det| := by\n  rw [measure_fundamentalDomain b volume (b\u2080 := Pi.basisFun \u211d \u03b9), fundamentalDomain_pi_basisFun,\n    volume_pi, Measure.pi_pi, Real.volume_Ico, sub_zero, ENNReal.ofReal_one, Finset.prod_const_one,\n    mul_one, \u2190 Matrix.det_transpose]\n  rfl\n\ntheorem fundamentalDomain_ae_parallelepiped [Fintype \u03b9] [MeasurableSpace E] (\u03bc : Measure E)\n    [BorelSpace E] [Measure.IsAddHaarMeasure \u03bc] :\n    fundamentalDomain b =\u1d50[\u03bc] parallelepiped b := by\n  classical\n  have : FiniteDimensional \u211d E := FiniteDimensional.of_fintype_basis b\n  rw [\u2190 measure_symmDiff_eq_zero_iff, symmDiff_of_le (fundamentalDomain_subset_parallelepiped b)]\n  suffices (parallelepiped b \\ fundamentalDomain b) \u2286 \u22c3 i,\n      AffineSubspace.mk' (b i) (span \u211d (b '' (Set.univ \\ {i}))) by\n    refine measure_mono_null this\n      (measure_iUnion_null_iff.mpr fun i \u21a6 Measure.addHaar_affineSubspace \u03bc _ ?_)\n    refine (ne_of_mem_of_not_mem' (AffineSubspace.mem_top _ _ 0)\n      (AffineSubspace.mem_mk'_iff_vsub_mem.not.mpr ?_)).symm\n    simp_rw [vsub_eq_sub, zero_sub, neg_mem_iff]\n    exact linearIndependent_iff_not_mem_span.mp b.linearIndependent i\n  intro x hx\n  simp_rw [parallelepiped_basis_eq, Set.mem_Icc, Set.mem_diff, Set.mem_setOf_eq,\n    mem_fundamentalDomain, Set.mem_Ico, not_forall, not_and, not_lt] at hx\n  obtain \u27e8i, hi\u27e9 := hx.2\n  have : b.repr x i = 1 := le_antisymm (hx.1 i).2 (hi (hx.1 i).1)\n  rw [\u2190 b.sum_repr x, \u2190 Finset.sum_erase_add _ _ (Finset.mem_univ i), this, one_smul, \u2190 vadd_eq_add]\n  refine Set.mem_iUnion.mpr \u27e8i, AffineSubspace.vadd_mem_mk' _\n    (sum_smul_mem _ _ (fun i hi \u21a6 Submodule.subset_span ?_))\u27e9\n  exact \u27e8i, Set.mem_diff_singleton.mpr \u27e8trivial, Finset.ne_of_mem_erase hi\u27e9, rfl\u27e9\n\nend Real\n\nend Zspan\n\nsection Zlattice\n\nopen Submodule FiniteDimensional\n\n-- TODO: generalize this class to other rings than `\u2124`\n/-- An `L : Addsubgroup E` where `E` is a vector space over a normed field `K` is a `\u2124`-lattice if\nit is discrete and spans `E` over `K`. -/\nclass IsZlattice (K : Type*) [NormedField K] {E : Type*} [NormedAddCommGroup E] [NormedSpace K E]\n    (L : AddSubgroup E) [DiscreteTopology L] : Prop where\n  /-- `L` spans the full space `E` over `K`. -/\n  span_top : span K (L : Set E) = \u22a4\n\ntheorem _root_.Zspan.isZlattice {E \u03b9 : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [Finite \u03b9] (b : Basis \u03b9 \u211d E) :\n    IsZlattice \u211d (span \u2124 (Set.range b)).toAddSubgroup where\n  span_top := Zspan.span_top b\n\nvariable (K : Type*) [NormedLinearOrderedField K] [HasSolidNorm K] [FloorRing K]\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]\nvariable [ProperSpace E] (L : AddSubgroup E) [DiscreteTopology L]\n\ntheorem Zlattice.FG [hs : IsZlattice K L] : AddSubgroup.FG L := by\n  suffices (AddSubgroup.toIntSubmodule L).FG by exact (fg_iff_add_subgroup_fg _).mp this\n  obtain \u27e8s, \u27e8h_incl, \u27e8h_span, h_lind\u27e9\u27e9\u27e9 := exists_linearIndependent K (L : Set E)\n  -- Let `s` be a maximal `K`-linear independent family of elements of `L`. We show that\n  -- `L` is finitely generated (as a \u2124-module) because it fits in the exact sequence\n  -- `0 \u2192 span \u2124 s \u2192 L \u2192 L \u29f8 span \u2124 s \u2192 0` with `span \u2124 s` and `L \u29f8 span \u2124 s` finitely generated.\n  refine fg_of_fg_map_of_fg_inf_ker (span \u2124 s).mkQ ?_ ?_\n  \u00b7 -- Let `b` be the `K`-basis of `E` formed by the vectors in `s`. The elements of\n    -- `L \u29f8 span \u2124 s = L \u29f8 span \u2124 b` are in bijection with elements of `L \u2229 fundamentalDomain b`\n    -- so there are finitely many since `fundamentalDomain b` is bounded.\n    refine fg_def.mpr \u27e8map (span \u2124 s).mkQ (AddSubgroup.toIntSubmodule L), ?_, span_eq _\u27e9\n    let b := Basis.mk h_lind (by\n      rw [\u2190 hs.span_top, \u2190 h_span]\n      exact span_mono (by simp only [Subtype.range_coe_subtype, Set.setOf_mem_eq, subset_rfl]))\n    rw [show span \u2124 s = span \u2124 (Set.range b) by simp [b, Basis.coe_mk, Subtype.range_coe_subtype]]\n    have : Fintype s := h_lind.setFinite.fintype\n    refine Set.Finite.of_finite_image (f := ((\u2191) : _ \u2192  E) \u2218 Zspan.quotientEquiv b) ?_\n      (Function.Injective.injOn (Subtype.coe_injective.comp (Zspan.quotientEquiv b).injective) _)\n    have : Set.Finite ((Zspan.fundamentalDomain b) \u2229 L) :=\n      Metric.finite_isBounded_inter_isClosed (Zspan.fundamentalDomain_isBounded b) inferInstance\n    refine Set.Finite.subset this ?_\n    rintro _ \u27e8_, \u27e8\u27e8x, \u27e8h_mem, rfl\u27e9\u27e9, rfl\u27e9\u27e9\n    rw [Function.comp_apply, mkQ_apply, Zspan.quotientEquiv_apply_mk, Zspan.fractRestrict_apply]\n    refine \u27e8?_, ?_\u27e9\n    \u00b7 exact Zspan.fract_mem_fundamentalDomain b x\n    \u00b7 rw [Zspan.fract, SetLike.mem_coe, sub_eq_add_neg]\n      refine AddSubgroup.add_mem _ h_mem\n        (neg_mem (Set.mem_of_subset_of_mem ?_ (Subtype.mem (Zspan.floor b x))))\n      rw [show (L : Set E) = AddSubgroup.toIntSubmodule L by rfl]\n      rw [SetLike.coe_subset_coe, Basis.coe_mk, Subtype.range_coe_subtype, Set.setOf_mem_eq]\n      exact span_le.mpr h_incl\n  \u00b7 -- `span \u2124 s` is finitely generated because `s` is finite\n    rw [ker_mkQ, inf_of_le_right (span_le.mpr h_incl)]\n    exact fg_span (LinearIndependent.setFinite h_lind)\n\ntheorem Zlattice.module_finite [IsZlattice K L] : Module.Finite \u2124 L :=\n  Module.Finite.iff_addGroup_fg.mpr ((AddGroup.fg_iff_addSubgroup_fg L).mpr (FG K L))\n\ninstance instModuleFinite_of_discrete_addSubgroup {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace \u211d E] [FiniteDimensional \u211d E] (L : AddSubgroup E) [DiscreteTopology L] :\n    Module.Finite \u2124 L := by\n  let f := (span \u211d (L : Set E)).subtype\n  let L\u2080 := (AddSubgroup.toIntSubmodule L).comap (f.restrictScalars \u2124)\n  have h_img : f '' L\u2080 = L := by\n    rw [\u2190 LinearMap.coe_restrictScalars \u2124 f, \u2190 Submodule.map_coe (f.restrictScalars \u2124),\n      Submodule.map_comap_eq_self, AddSubgroup.coe_toIntSubmodule]\n    exact fun x hx \u21a6 LinearMap.mem_range.mpr \u27e8\u27e8x, Submodule.subset_span hx\u27e9, rfl\u27e9\n  suffices Module.Finite \u2124 L\u2080 by\n    have : L\u2080.map (f.restrictScalars \u2124) = (AddSubgroup.toIntSubmodule L) :=\n      SetLike.ext'_iff.mpr h_img\n    convert this \u25b8 Module.Finite.map L\u2080 (f.restrictScalars \u2124)\n  have : DiscreteTopology L\u2080.toAddSubgroup := by\n    refine DiscreteTopology.preimage_of_continuous_injective (L : Set E) ?_ (injective_subtype _)\n    exact LinearMap.continuous_of_finiteDimensional f\n  have : IsZlattice \u211d L\u2080.toAddSubgroup := \u27e8by\n    rw [\u2190 (Submodule.map_injective_of_injective (injective_subtype _)).eq_iff, Submodule.map_span,\n      Submodule.map_top, range_subtype, coe_toAddSubgroup, h_img]\u27e9\n  exact Zlattice.module_finite \u211d L\u2080.toAddSubgroup\n\ntheorem Zlattice.module_free [IsZlattice K L] : Module.Free \u2124 L := by\n  have : Module.Finite \u2124 L := module_finite K L\n  have : Module \u211a E := Module.compHom E (algebraMap \u211a K)\n  have : NoZeroSMulDivisors \u2124 E := RatModule.noZeroSMulDivisors\n  have : NoZeroSMulDivisors \u2124 L := by\n    change NoZeroSMulDivisors \u2124 (AddSubgroup.toIntSubmodule L)\n    exact noZeroSMulDivisors _\n  infer_instance\n\ninstance instModuleFree_of_discrete_addSubgroup {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace \u211d E] [FiniteDimensional \u211d E] (L : AddSubgroup E) [DiscreteTopology L] :\n    Module.Free \u2124 L := by\n  have : Module \u211a E := Module.compHom E (algebraMap \u211a \u211d)\n  have : NoZeroSMulDivisors \u2124 E := RatModule.noZeroSMulDivisors\n  have : NoZeroSMulDivisors \u2124 L := by\n    change NoZeroSMulDivisors \u2124 (AddSubgroup.toIntSubmodule L)\n    exact noZeroSMulDivisors _\n  infer_instance\n\ntheorem Zlattice.rank [hs : IsZlattice K L] : finrank \u2124 L = finrank K E := by\n  classical\n  have : Module.Finite \u2124 L := module_finite K L\n  have : Module.Free \u2124 L := module_free K L\n  have : Module \u211a E := Module.compHom E (algebraMap \u211a K)\n  let b\u2080 := Module.Free.chooseBasis \u2124 L\n  -- Let `b` be a `\u2124`-basis of `L` formed of vectors of `E`\n  let b := Subtype.val \u2218 b\u2080\n  have : LinearIndependent \u2124 b :=\n    LinearIndependent.map' b\u2080.linearIndependent (L.toIntSubmodule.subtype) (ker_subtype _)\n  -- We prove some assertions that will be useful later on\n  have h_spanL : span \u2124 (Set.range b) = AddSubgroup.toIntSubmodule L := by\n    convert congrArg (map (Submodule.subtype (AddSubgroup.toIntSubmodule L))) b\u2080.span_eq\n    \u00b7 rw [map_span, Set.range_comp]\n      rfl\n    \u00b7 exact (map_subtype_top _).symm\n  have h_spanE : span K (Set.range b) = \u22a4 := by\n    rw [\u2190 span_span_of_tower (R := \u2124), h_spanL]\n    exact hs.span_top\n  have h_card : Fintype.card (Module.Free.ChooseBasisIndex \u2124 L) =\n      (Set.range b).toFinset.card := by\n    rw [Set.toFinset_range, Finset.univ.card_image_of_injective]\n    rfl\n    exact Subtype.coe_injective.comp (Basis.injective _)\n  rw [finrank_eq_card_chooseBasisIndex]\n    -- We prove that `finrank \u2124 L \u2264 finrank K E` and `finrank K E \u2264 finrank \u2124 L`\n  refine le_antisymm ?_ ?_\n  \u00b7 -- To prove that `finrank \u2124 L \u2264 finrank K E`, we proceed by contradiction and prove that, in\n    -- this case, there is a \u2124-relation between the vectors of `b`\n    obtain \u27e8t, \u27e8ht_inc, \u27e8ht_span, ht_lin\u27e9\u27e9\u27e9 := exists_linearIndependent K (Set.range b)\n    -- `e` is a `K`-basis of `E` formed of vectors of `b`\n    let e : Basis t K E := Basis.mk ht_lin (by simp [ht_span, h_spanE])\n    have : Fintype t := Set.Finite.fintype ((Set.range b).toFinite.subset ht_inc)\n    have h : LinearIndependent \u2124 (fun x : (Set.range b) => (x : E)) := by\n      rwa [linearIndependent_subtype_range (Subtype.coe_injective.comp b\u2080.injective)]\n    contrapose! h\n    -- Since `finrank \u2124 L > finrank K E`, there exists a vector `v \u2208 b` with `v \u2209 e`\n    obtain \u27e8v, hv\u27e9 : (Set.range b \\ Set.range e).Nonempty := by\n      rw [Basis.coe_mk, Subtype.range_coe_subtype, Set.setOf_mem_eq, \u2190 Set.toFinset_nonempty]\n      contrapose h\n      rw [Finset.not_nonempty_iff_eq_empty, Set.toFinset_diff,\n        Finset.sdiff_eq_empty_iff_subset] at h\n      replace h := Finset.card_le_card h\n      rwa [not_lt, h_card, \u2190 topEquiv.finrank_eq, \u2190 h_spanE, \u2190 ht_span,\n        finrank_span_set_eq_card ht_lin]\n    -- Assume that `e \u222a {v}` is not `\u2124`-linear independent then we get the contradiction\n    suffices \u00ac LinearIndependent \u2124 (fun x : \u21a5(insert v (Set.range e)) => (x : E)) by\n      contrapose! this\n      refine LinearIndependent.mono ?_ this\n      exact Set.insert_subset (Set.mem_of_mem_diff hv) (by simp [e, ht_inc])\n    -- We prove finally that `e \u222a {v}` is not \u2124-linear independent or, equivalently,\n    -- not \u211a-linear independent by showing that `v \u2208 span \u211a e`.\n    rw [LinearIndependent.iff_fractionRing \u2124 \u211a,\n      linearIndependent_insert (Set.not_mem_of_mem_diff hv),  not_and, not_not]\n    intro _\n    -- But that follows from the fact that there exist `n, m : \u2115`, `n \u2260 m`\n    -- such that `(n - m) \u2022 v \u2208 span \u2124 e` which is true since `n \u21a6 Zspan.fract e (n \u2022 v)`\n    -- takes value into the finite set `fundamentalDomain e \u2229 L`\n    have h_mapsto : Set.MapsTo (fun n : \u2124 => Zspan.fract e (n \u2022 v)) Set.univ\n        (Metric.closedBall 0 (\u2211 i, \u2016e i\u2016) \u2229 (L : Set E)) := by\n      rw [Set.mapsTo_inter, Set.mapsTo_univ_iff, Set.mapsTo_univ_iff]\n      refine \u27e8fun _ \u21a6 mem_closedBall_zero_iff.mpr (Zspan.norm_fract_le e _), fun _ => ?_\u27e9\n      \u00b7 change _ \u2208 AddSubgroup.toIntSubmodule L\n        rw [\u2190 h_spanL]\n        refine sub_mem ?_ ?_\n        \u00b7 exact zsmul_mem (subset_span (Set.diff_subset _ _ hv)) _\n        \u00b7 exact span_mono (by simp [e, ht_inc]) (coe_mem _)\n    have h_finite : Set.Finite (Metric.closedBall 0 (\u2211 i, \u2016e i\u2016) \u2229 (L : Set E)) :=\n      Metric.finite_isBounded_inter_isClosed Metric.isBounded_closedBall inferInstance\n    obtain \u27e8n, -, m, -, h_neq, h_eq\u27e9 := Set.Infinite.exists_ne_map_eq_of_mapsTo\n      Set.infinite_univ h_mapsto h_finite\n    have h_nz : (-n + m : \u211a) \u2260 0 := by\n      rwa [Ne, add_eq_zero_iff_eq_neg.not, neg_inj, Rat.coe_int_inj, \u2190 Ne]\n    apply (smul_mem_iff _ h_nz).mp\n    refine span_subset_span \u2124 \u211a _ ?_\n    rwa [add_smul, neg_smul, SetLike.mem_coe, \u2190 Zspan.fract_eq_fract, \u2190 zsmul_eq_smul_cast \u211a,\n      \u2190 zsmul_eq_smul_cast \u211a]\n  \u00b7 -- To prove that `finrank K E \u2264 finrank \u2124 L`, we use the fact `b` generates `E` over `K`\n    -- and thus `finrank K E \u2264 card b = finrank \u2124 L`\n    rw [\u2190 topEquiv.finrank_eq, \u2190 h_spanE]\n    convert finrank_span_le_card (R := K) (Set.range b)\n\nopen Module\n\nvariable {\u03b9 : Type*} [hs : IsZlattice K L] (b : Basis \u03b9 \u2124 L)\n/-- Any `\u2124`-basis of `L` is also a `K`-basis of `E`. -/\ndef Basis.ofZlatticeBasis :\n    Basis \u03b9 K E := by\n  have : Finite \u2124 L := Zlattice.module_finite K L\n  have : Free \u2124 L := Zlattice.module_free K L\n  let e :=  Basis.indexEquiv (Free.chooseBasis \u2124 L) b\n  have : Fintype \u03b9 := Fintype.ofEquiv _ e\n  refine basisOfTopLeSpanOfCardEqFinrank (L.subtype.toIntLinearMap \u2218 b) ?_ ?_\n  \u00b7 rw [\u2190 span_span_of_tower \u2124, Set.range_comp, \u2190 map_span, Basis.span_eq, Submodule.map_top,\n      top_le_iff, AddMonoidHom.coe_toIntLinearMap_range, AddSubgroup.subtype_range,\n      AddSubgroup.coe_toIntSubmodule, hs.span_top]\n  \u00b7 rw [\u2190 Fintype.card_congr e, \u2190 finrank_eq_card_chooseBasisIndex, Zlattice.rank K L]\n\n@[simp]\ntheorem Basis.ofZlatticeBasis_apply (i : \u03b9) :\n    b.ofZlatticeBasis K L i =  b i := by simp [Basis.ofZlatticeBasis]\n\n@[simp]\ntheorem Basis.ofZlatticeBasis_repr_apply (x : L) (i : \u03b9) :\n    (b.ofZlatticeBasis K L).repr x i = b.repr x i := by\n  suffices ((b.ofZlatticeBasis K L).repr.toLinearMap.restrictScalars \u2124) \u2218\u2097 L.subtype.toIntLinearMap\n      = Finsupp.mapRange.linearMap (Algebra.linearMap \u2124 K) \u2218\u2097 b.repr.toLinearMap by\n    exact DFunLike.congr_fun (LinearMap.congr_fun this x) i\n  refine Basis.ext b fun i \u21a6 ?_\n  simp_rw [LinearMap.coe_comp, Function.comp_apply, LinearMap.coe_restrictScalars,\n    LinearEquiv.coe_coe, AddMonoidHom.coe_toIntLinearMap, AddSubgroup.coeSubtype,\n    \u2190 b.ofZlatticeBasis_apply K, repr_self, Finsupp.mapRange.linearMap_apply,\n    Finsupp.mapRange_single, Algebra.linearMap_apply, map_one]\n\ntheorem Basis.ofZlatticeBasis_span :\n    (span \u2124 (Set.range (b.ofZlatticeBasis K))).toAddSubgroup = L := by\n  calc (span \u2124 (Set.range (b.ofZlatticeBasis K))).toAddSubgroup\n    _ = (span \u2124 (L.subtype.toIntLinearMap '' (Set.range b))).toAddSubgroup := by congr; ext; simp\n    _ = (map L.subtype.toIntLinearMap (span \u2124 (Set.range b))).toAddSubgroup := by\n        rw [Submodule.map_span]\n    _ = L := by simp [b.span_eq]\n\ntheorem Zlattice.isAddFundamentalDomain {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {L : AddSubgroup E} [DiscreteTopology L] [IsZlattice \u211d L] [Finite \u03b9]\n    (b : Basis \u03b9 \u2124 L) [MeasurableSpace E] [OpensMeasurableSpace E] (\u03bc : MeasureTheory.Measure E) :\n    MeasureTheory.IsAddFundamentalDomain L (Zspan.fundamentalDomain (b.ofZlatticeBasis \u211d)) \u03bc := by\n  convert Zspan.isAddFundamentalDomain (b.ofZlatticeBasis \u211d) \u03bc\n  all_goals exact (b.ofZlatticeBasis_span \u211d).symm\n\n", "theoremStatement": "instance instCountable_of_discrete_addSubgroup {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice \u211d L] :\n    Countable L", "theoremName": null, "fileCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "theoremCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/Zlattice/Basic.lean", "positionMetadata": {"lineInFile": 628, "tokenPositionInFile": 30787, "theoremPositionInFile": 54}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [\u2190 (Module.Free.chooseBasis \u2124 L).ofZlatticeBasis_span \u211d]\n  change Countable (span \u2124 (Set.range (Basis.ofZlatticeBasis \u211d L _)))\n  infer_instance", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 151}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Algebra.Module.Zlattice.Basic\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space with an inner product.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `AddSubgroup E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `Zlattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `Zlattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `Zlattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n-/\n\nnoncomputable section\n\nnamespace Zlattice\n\nopen Submodule MeasureTheory FiniteDimensional MeasureTheory Module\n\nsection General\n\nvariable (K : Type*) [NormedLinearOrderedField K] [HasSolidNorm K] [FloorRing K]\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]\nvariable [ProperSpace E] [MeasurableSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice K L]\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`Zlattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Real\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\n", "theoremStatement": "theorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal", "theoremName": "covolume_eq_measure_fundamentalDomain", "fileCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "theoremCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/Zlattice/Covolume.lean", "positionMetadata": {"lineInFile": 55, "tokenPositionInFile": 1809, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 49}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Algebra.Module.Zlattice.Basic\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space with an inner product.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `AddSubgroup E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `Zlattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `Zlattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `Zlattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n-/\n\nnoncomputable section\n\nnamespace Zlattice\n\nopen Submodule MeasureTheory FiniteDimensional MeasureTheory Module\n\nsection General\n\nvariable (K : Type*) [NormedLinearOrderedField K] [HasSolidNorm K] [FloorRing K]\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]\nvariable [ProperSpace E] [MeasurableSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice K L]\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`Zlattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Real\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\n", "theoremStatement": "theorem covolume_ne_zero : covolume L \u03bc \u2260 0", "theoremName": "covolume_ne_zero", "fileCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "theoremCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/Zlattice/Covolume.lean", "positionMetadata": {"lineInFile": 58, "tokenPositionInFile": 1990, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8Zspan.measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (Zspan.fundamentalDomain_isBounded _)", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 276}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Algebra.Module.Zlattice.Basic\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space with an inner product.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `AddSubgroup E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `Zlattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `Zlattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `Zlattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n-/\n\nnoncomputable section\n\nnamespace Zlattice\n\nopen Submodule MeasureTheory FiniteDimensional MeasureTheory Module\n\nsection General\n\nvariable (K : Type*) [NormedLinearOrderedField K] [HasSolidNorm K] [FloorRing K]\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]\nvariable [ProperSpace E] [MeasurableSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice K L]\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`Zlattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Real\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8Zspan.measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (Zspan.fundamentalDomain_isBounded _)\n\n", "theoremStatement": "theorem covolume_pos : 0 < covolume L \u03bc", "theoremName": "covolume_pos", "fileCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "theoremCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/Zlattice/Covolume.lean", "positionMetadata": {"lineInFile": 64, "tokenPositionInFile": 2315, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 64}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Algebra.Module.Zlattice.Basic\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space with an inner product.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `AddSubgroup E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `Zlattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `Zlattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `Zlattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n-/\n\nnoncomputable section\n\nnamespace Zlattice\n\nopen Submodule MeasureTheory FiniteDimensional MeasureTheory Module\n\nsection General\n\nvariable (K : Type*) [NormedLinearOrderedField K] [HasSolidNorm K] [FloorRing K]\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]\nvariable [ProperSpace E] [MeasurableSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice K L]\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`Zlattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Real\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8Zspan.measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (Zspan.fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\n", "theoremStatement": "theorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (Zspan.fundamentalDomain b\u2080)).toReal", "theoremName": "covolume_eq_det_mul_measure", "fileCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "theoremCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/Zlattice/Covolume.lean", "positionMetadata": {"lineInFile": 67, "tokenPositionInFile": 2426, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    Zspan.measure_fundamentalDomain _ _ b\u2080, measure_congr\n    (Zspan.fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul, ENNReal.toReal_ofReal\n    (by positivity)]\n  congr\n  ext\n  exact b.ofZlatticeBasis_apply \u211d L _", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 307}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Algebra.Module.Zlattice.Basic\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space with an inner product.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `AddSubgroup E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `Zlattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `Zlattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `Zlattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n-/\n\nnoncomputable section\n\nnamespace Zlattice\n\nopen Submodule MeasureTheory FiniteDimensional MeasureTheory Module\n\nsection General\n\nvariable (K : Type*) [NormedLinearOrderedField K] [HasSolidNorm K] [FloorRing K]\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]\nvariable [ProperSpace E] [MeasurableSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice K L]\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`Zlattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Real\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : AddSubgroup E) [DiscreteTopology L] [IsZlattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8Zspan.measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (Zspan.fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (Zspan.fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    Zspan.measure_fundamentalDomain _ _ b\u2080, measure_congr\n    (Zspan.fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul, ENNReal.toReal_ofReal\n    (by positivity)]\n  congr\n  ext\n  exact b.ofZlatticeBasis_apply \u211d L _\n\n", "theoremStatement": "theorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : AddSubgroup (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZlattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det|", "theoremName": "covolume_eq_det", "fileCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "theoremCreated": {"commit": "12c27420d4", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/Zlattice/Covolume.lean", "positionMetadata": {"lineInFile": 78, "tokenPositionInFile": 2937, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    Zspan.volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZlatticeBasis_apply \u211d L _", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 218}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.CategoryTheory.Localization.CalculusOfFractions\n\n/-!\n# Lemmas on fractions\n\nLet `W : MorphismProperty C`, and objects `X` and `Y` in `C`. In this file,\nwe introduce structures like `W.LeftFraction\u2082 X Y` which consists of two\nleft fractions with the \"same denominator\" which shall be important in\nthe construction of the preadditive structure on the localized category\nwhen `C` is preadditive and `W` has a left calculus of fractions.\n\nWhen `W` has a left calculus of fractions, we generalize the lemmas\n`RightFraction.exists_leftFraction` as `RightFraction\u2082.exists_leftFraction\u2082`,\n`Localization.exists_leftFraction` as `Localization.exists_leftFraction\u2082` and\n`Localization.exists_leftFraction\u2083`, and\n`LeftFraction.map_eq_iff` as `LeftFraction\u2082.map_eq_iff`.\n\n## Implementation note\n\nThe lemmas in this file are phrased with data that is bundled into structures like\n`LeftFraction\u2082` or `LeftFraction\u2083`. It could have been possible to phrase them\nwith \"unbundled data\". However, this would require introducing 4 or 5 variables instead\nof one. It is also very convenient to use dot notation.\nMany definitions have been made reducible so as to ease rewrites when this API is used.\n\n-/\n\nnamespace CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D] (L : C \u2964 D) (W : MorphismProperty C)\n  [L.IsLocalization W]\n\nnamespace MorphismProperty\n\n/-- This structure contains the data of two left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of three left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2083 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the numerator of the third left fraction -/\n  f'' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of two right fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure RightFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of right fractions -/\n  {X' : C}\n  /-- the denominator of the right fractions -/\n  s : X' \u27f6 X\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n  /-- the numerator of the first right fraction -/\n  f : X' \u27f6 Y\n  /-- the numerator of the second right fraction -/\n  f' : X' \u27f6 Y\n\nvariable {W}\n\n/-- The equivalence relation on tuples of left fractions with the same denominator\nfor a morphism property `W`. The fact it is an equivalence relation is not\nformalized, but it would follow easily from `LeftFraction\u2082.map_eq_iff`. -/\ndef LeftFraction\u2082Rel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction\u2082 X Y) : Prop :=\n  \u2203 (Z : C)  (t\u2081 : z\u2081.Y' \u27f6 Z) (t\u2082 : z\u2082.Y' \u27f6 Z) (_ : z\u2081.s \u226b t\u2081 = z\u2082.s \u226b t\u2082)\n    (_ : z\u2081.f \u226b t\u2081 = z\u2082.f \u226b t\u2082) (_ : z\u2081.f' \u226b t\u2081 = z\u2082.f' \u226b t\u2082), W (z\u2081.s \u226b t\u2081)\n\nnamespace LeftFraction\u2082\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2082 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The exchange of the two fractions. -/\n@[reducible]\ndef symm : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2082\n\nnamespace LeftFraction\u2083\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2083 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The third left fraction. -/\n@[reducible]\ndef thd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the first fraction. -/\n@[reducible]\ndef forgetFst : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the second fraction. -/\n@[reducible]\ndef forgetSnd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the third fraction. -/\n@[reducible]\ndef forgetThd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2083\n\nnamespace LeftFraction\u2082Rel\n\nvariable {X Y : C} {z\u2081 z\u2082 : W.LeftFraction\u2082 X Y} (h : LeftFraction\u2082Rel z\u2081 z\u2082)\n\n", "theoremStatement": "lemma fst : LeftFractionRel z\u2081.fst z\u2082.fst", "theoremName": "fst", "fileCreated": {"commit": "429161409e", "date": "2024-04-18"}, "theoremCreated": {"commit": "429161409e", "date": "2024-04-18"}, "file": "mathlib4/Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean", "positionMetadata": {"lineInFile": 185, "tokenPositionInFile": 5121, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, hft, _, ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 79}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.CategoryTheory.Localization.CalculusOfFractions\n\n/-!\n# Lemmas on fractions\n\nLet `W : MorphismProperty C`, and objects `X` and `Y` in `C`. In this file,\nwe introduce structures like `W.LeftFraction\u2082 X Y` which consists of two\nleft fractions with the \"same denominator\" which shall be important in\nthe construction of the preadditive structure on the localized category\nwhen `C` is preadditive and `W` has a left calculus of fractions.\n\nWhen `W` has a left calculus of fractions, we generalize the lemmas\n`RightFraction.exists_leftFraction` as `RightFraction\u2082.exists_leftFraction\u2082`,\n`Localization.exists_leftFraction` as `Localization.exists_leftFraction\u2082` and\n`Localization.exists_leftFraction\u2083`, and\n`LeftFraction.map_eq_iff` as `LeftFraction\u2082.map_eq_iff`.\n\n## Implementation note\n\nThe lemmas in this file are phrased with data that is bundled into structures like\n`LeftFraction\u2082` or `LeftFraction\u2083`. It could have been possible to phrase them\nwith \"unbundled data\". However, this would require introducing 4 or 5 variables instead\nof one. It is also very convenient to use dot notation.\nMany definitions have been made reducible so as to ease rewrites when this API is used.\n\n-/\n\nnamespace CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D] (L : C \u2964 D) (W : MorphismProperty C)\n  [L.IsLocalization W]\n\nnamespace MorphismProperty\n\n/-- This structure contains the data of two left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of three left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2083 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the numerator of the third left fraction -/\n  f'' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of two right fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure RightFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of right fractions -/\n  {X' : C}\n  /-- the denominator of the right fractions -/\n  s : X' \u27f6 X\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n  /-- the numerator of the first right fraction -/\n  f : X' \u27f6 Y\n  /-- the numerator of the second right fraction -/\n  f' : X' \u27f6 Y\n\nvariable {W}\n\n/-- The equivalence relation on tuples of left fractions with the same denominator\nfor a morphism property `W`. The fact it is an equivalence relation is not\nformalized, but it would follow easily from `LeftFraction\u2082.map_eq_iff`. -/\ndef LeftFraction\u2082Rel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction\u2082 X Y) : Prop :=\n  \u2203 (Z : C)  (t\u2081 : z\u2081.Y' \u27f6 Z) (t\u2082 : z\u2082.Y' \u27f6 Z) (_ : z\u2081.s \u226b t\u2081 = z\u2082.s \u226b t\u2082)\n    (_ : z\u2081.f \u226b t\u2081 = z\u2082.f \u226b t\u2082) (_ : z\u2081.f' \u226b t\u2081 = z\u2082.f' \u226b t\u2082), W (z\u2081.s \u226b t\u2081)\n\nnamespace LeftFraction\u2082\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2082 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The exchange of the two fractions. -/\n@[reducible]\ndef symm : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2082\n\nnamespace LeftFraction\u2083\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2083 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The third left fraction. -/\n@[reducible]\ndef thd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the first fraction. -/\n@[reducible]\ndef forgetFst : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the second fraction. -/\n@[reducible]\ndef forgetSnd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the third fraction. -/\n@[reducible]\ndef forgetThd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2083\n\nnamespace LeftFraction\u2082Rel\n\nvariable {X Y : C} {z\u2081 z\u2082 : W.LeftFraction\u2082 X Y} (h : LeftFraction\u2082Rel z\u2081 z\u2082)\n\nlemma fst : LeftFractionRel z\u2081.fst z\u2082.fst := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, hft, _, ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9\n\n", "theoremStatement": "lemma snd : LeftFractionRel z\u2081.snd z\u2082.snd", "theoremName": "snd", "fileCreated": {"commit": "429161409e", "date": "2024-04-18"}, "theoremCreated": {"commit": "429161409e", "date": "2024-04-18"}, "file": "mathlib4/Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean", "positionMetadata": {"lineInFile": 189, "tokenPositionInFile": 5247, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, _, hft', ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft', ht\u27e9", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 81}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.CategoryTheory.Localization.CalculusOfFractions\n\n/-!\n# Lemmas on fractions\n\nLet `W : MorphismProperty C`, and objects `X` and `Y` in `C`. In this file,\nwe introduce structures like `W.LeftFraction\u2082 X Y` which consists of two\nleft fractions with the \"same denominator\" which shall be important in\nthe construction of the preadditive structure on the localized category\nwhen `C` is preadditive and `W` has a left calculus of fractions.\n\nWhen `W` has a left calculus of fractions, we generalize the lemmas\n`RightFraction.exists_leftFraction` as `RightFraction\u2082.exists_leftFraction\u2082`,\n`Localization.exists_leftFraction` as `Localization.exists_leftFraction\u2082` and\n`Localization.exists_leftFraction\u2083`, and\n`LeftFraction.map_eq_iff` as `LeftFraction\u2082.map_eq_iff`.\n\n## Implementation note\n\nThe lemmas in this file are phrased with data that is bundled into structures like\n`LeftFraction\u2082` or `LeftFraction\u2083`. It could have been possible to phrase them\nwith \"unbundled data\". However, this would require introducing 4 or 5 variables instead\nof one. It is also very convenient to use dot notation.\nMany definitions have been made reducible so as to ease rewrites when this API is used.\n\n-/\n\nnamespace CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D] (L : C \u2964 D) (W : MorphismProperty C)\n  [L.IsLocalization W]\n\nnamespace MorphismProperty\n\n/-- This structure contains the data of two left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of three left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2083 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the numerator of the third left fraction -/\n  f'' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of two right fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure RightFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of right fractions -/\n  {X' : C}\n  /-- the denominator of the right fractions -/\n  s : X' \u27f6 X\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n  /-- the numerator of the first right fraction -/\n  f : X' \u27f6 Y\n  /-- the numerator of the second right fraction -/\n  f' : X' \u27f6 Y\n\nvariable {W}\n\n/-- The equivalence relation on tuples of left fractions with the same denominator\nfor a morphism property `W`. The fact it is an equivalence relation is not\nformalized, but it would follow easily from `LeftFraction\u2082.map_eq_iff`. -/\ndef LeftFraction\u2082Rel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction\u2082 X Y) : Prop :=\n  \u2203 (Z : C)  (t\u2081 : z\u2081.Y' \u27f6 Z) (t\u2082 : z\u2082.Y' \u27f6 Z) (_ : z\u2081.s \u226b t\u2081 = z\u2082.s \u226b t\u2082)\n    (_ : z\u2081.f \u226b t\u2081 = z\u2082.f \u226b t\u2082) (_ : z\u2081.f' \u226b t\u2081 = z\u2082.f' \u226b t\u2082), W (z\u2081.s \u226b t\u2081)\n\nnamespace LeftFraction\u2082\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2082 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The exchange of the two fractions. -/\n@[reducible]\ndef symm : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2082\n\nnamespace LeftFraction\u2083\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2083 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The third left fraction. -/\n@[reducible]\ndef thd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the first fraction. -/\n@[reducible]\ndef forgetFst : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the second fraction. -/\n@[reducible]\ndef forgetSnd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the third fraction. -/\n@[reducible]\ndef forgetThd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2083\n\nnamespace LeftFraction\u2082Rel\n\nvariable {X Y : C} {z\u2081 z\u2082 : W.LeftFraction\u2082 X Y} (h : LeftFraction\u2082Rel z\u2081 z\u2082)\n\nlemma fst : LeftFractionRel z\u2081.fst z\u2082.fst := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, hft, _, ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9\n\nlemma snd : LeftFractionRel z\u2081.snd z\u2082.snd := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, _, hft', ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft', ht\u27e9\n\nend LeftFraction\u2082Rel\n\nnamespace LeftFraction\u2082\n\nvariable (W)\nvariable [W.HasLeftCalculusOfFractions]\n\n", "theoremStatement": "lemma map_eq_iff {X Y : C} (\u03c6 \u03c8 : W.LeftFraction\u2082 X Y) :\n    (\u03c6.fst.map L (Localization.inverts _ _) = \u03c8.fst.map L (Localization.inverts _ _) \u2227\n    \u03c6.snd.map L (Localization.inverts _ _) = \u03c8.snd.map L (Localization.inverts _ _)) \u2194\n      LeftFraction\u2082Rel \u03c6 \u03c8", "theoremName": "map_eq_iff", "fileCreated": {"commit": "429161409e", "date": "2024-04-18"}, "theoremCreated": {"commit": "429161409e", "date": "2024-04-18"}, "file": "mathlib4/Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean", "positionMetadata": {"lineInFile": 200, "tokenPositionInFile": 5476, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp only [LeftFraction.map_eq_iff L W]\n  constructor\n  \u00b7 intro \u27e8h, h'\u27e9\n    obtain \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9 := h\n    obtain \u27e8Z', t\u2081', t\u2082', hst', hft', ht'\u27e9 := h'\n    dsimp at t\u2081 t\u2082 t\u2081' t\u2082' hst hft hst' hft' ht ht'\n    have \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ ht (\u03c6.s \u226b t\u2081')).exists_leftFraction\n    simp only [Category.assoc] at h\u03b1\n    obtain \u27e8Z'', u, hu, fac\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ \u03c6.hs h\u03b1\n    have h\u03b1' : \u03c8.s \u226b t\u2082 \u226b \u03b1.f \u226b u = \u03c8.s \u226b t\u2082' \u226b \u03b1.s \u226b u := by\n      rw [\u2190 reassoc_of% hst, \u2190 reassoc_of% h\u03b1, \u2190 reassoc_of% hst']\n    obtain \u27e8Z''', u', hu', fac'\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ \u03c8.hs h\u03b1'\n    simp only [Category.assoc] at fac fac'\n    refine' \u27e8Z''', t\u2081' \u226b \u03b1.s \u226b u \u226b u', t\u2082' \u226b \u03b1.s \u226b u \u226b u', _, _, _, _\u27e9\n    \u00b7 rw [reassoc_of% hst']\n    \u00b7 rw [reassoc_of% fac, reassoc_of% hft, fac']\n    \u00b7 rw [reassoc_of% hft']\n    \u00b7 rw [\u2190 Category.assoc]\n      exact W.comp_mem _ _ ht' (W.comp_mem _ _ \u03b1.hs (W.comp_mem _ _ hu hu'))\n  \u00b7 intro h\n    exact \u27e8h.fst, h.snd\u27e9", "proofType": "tactic", "proofLengthLines": 22, "proofLengthTokens": 982}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.CategoryTheory.Localization.CalculusOfFractions\n\n/-!\n# Lemmas on fractions\n\nLet `W : MorphismProperty C`, and objects `X` and `Y` in `C`. In this file,\nwe introduce structures like `W.LeftFraction\u2082 X Y` which consists of two\nleft fractions with the \"same denominator\" which shall be important in\nthe construction of the preadditive structure on the localized category\nwhen `C` is preadditive and `W` has a left calculus of fractions.\n\nWhen `W` has a left calculus of fractions, we generalize the lemmas\n`RightFraction.exists_leftFraction` as `RightFraction\u2082.exists_leftFraction\u2082`,\n`Localization.exists_leftFraction` as `Localization.exists_leftFraction\u2082` and\n`Localization.exists_leftFraction\u2083`, and\n`LeftFraction.map_eq_iff` as `LeftFraction\u2082.map_eq_iff`.\n\n## Implementation note\n\nThe lemmas in this file are phrased with data that is bundled into structures like\n`LeftFraction\u2082` or `LeftFraction\u2083`. It could have been possible to phrase them\nwith \"unbundled data\". However, this would require introducing 4 or 5 variables instead\nof one. It is also very convenient to use dot notation.\nMany definitions have been made reducible so as to ease rewrites when this API is used.\n\n-/\n\nnamespace CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D] (L : C \u2964 D) (W : MorphismProperty C)\n  [L.IsLocalization W]\n\nnamespace MorphismProperty\n\n/-- This structure contains the data of two left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of three left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2083 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the numerator of the third left fraction -/\n  f'' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of two right fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure RightFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of right fractions -/\n  {X' : C}\n  /-- the denominator of the right fractions -/\n  s : X' \u27f6 X\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n  /-- the numerator of the first right fraction -/\n  f : X' \u27f6 Y\n  /-- the numerator of the second right fraction -/\n  f' : X' \u27f6 Y\n\nvariable {W}\n\n/-- The equivalence relation on tuples of left fractions with the same denominator\nfor a morphism property `W`. The fact it is an equivalence relation is not\nformalized, but it would follow easily from `LeftFraction\u2082.map_eq_iff`. -/\ndef LeftFraction\u2082Rel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction\u2082 X Y) : Prop :=\n  \u2203 (Z : C)  (t\u2081 : z\u2081.Y' \u27f6 Z) (t\u2082 : z\u2082.Y' \u27f6 Z) (_ : z\u2081.s \u226b t\u2081 = z\u2082.s \u226b t\u2082)\n    (_ : z\u2081.f \u226b t\u2081 = z\u2082.f \u226b t\u2082) (_ : z\u2081.f' \u226b t\u2081 = z\u2082.f' \u226b t\u2082), W (z\u2081.s \u226b t\u2081)\n\nnamespace LeftFraction\u2082\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2082 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The exchange of the two fractions. -/\n@[reducible]\ndef symm : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2082\n\nnamespace LeftFraction\u2083\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2083 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The third left fraction. -/\n@[reducible]\ndef thd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the first fraction. -/\n@[reducible]\ndef forgetFst : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the second fraction. -/\n@[reducible]\ndef forgetSnd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the third fraction. -/\n@[reducible]\ndef forgetThd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2083\n\nnamespace LeftFraction\u2082Rel\n\nvariable {X Y : C} {z\u2081 z\u2082 : W.LeftFraction\u2082 X Y} (h : LeftFraction\u2082Rel z\u2081 z\u2082)\n\nlemma fst : LeftFractionRel z\u2081.fst z\u2082.fst := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, hft, _, ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9\n\nlemma snd : LeftFractionRel z\u2081.snd z\u2082.snd := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, _, hft', ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft', ht\u27e9\n\nend LeftFraction\u2082Rel\n\nnamespace LeftFraction\u2082\n\nvariable (W)\nvariable [W.HasLeftCalculusOfFractions]\n\nlemma map_eq_iff {X Y : C} (\u03c6 \u03c8 : W.LeftFraction\u2082 X Y) :\n    (\u03c6.fst.map L (Localization.inverts _ _) = \u03c8.fst.map L (Localization.inverts _ _) \u2227\n    \u03c6.snd.map L (Localization.inverts _ _) = \u03c8.snd.map L (Localization.inverts _ _)) \u2194\n      LeftFraction\u2082Rel \u03c6 \u03c8 := by\n  simp only [LeftFraction.map_eq_iff L W]\n  constructor\n  \u00b7 intro \u27e8h, h'\u27e9\n    obtain \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9 := h\n    obtain \u27e8Z', t\u2081', t\u2082', hst', hft', ht'\u27e9 := h'\n    dsimp at t\u2081 t\u2082 t\u2081' t\u2082' hst hft hst' hft' ht ht'\n    have \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ ht (\u03c6.s \u226b t\u2081')).exists_leftFraction\n    simp only [Category.assoc] at h\u03b1\n    obtain \u27e8Z'', u, hu, fac\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ \u03c6.hs h\u03b1\n    have h\u03b1' : \u03c8.s \u226b t\u2082 \u226b \u03b1.f \u226b u = \u03c8.s \u226b t\u2082' \u226b \u03b1.s \u226b u := by\n      rw [\u2190 reassoc_of% hst, \u2190 reassoc_of% h\u03b1, \u2190 reassoc_of% hst']\n    obtain \u27e8Z''', u', hu', fac'\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ \u03c8.hs h\u03b1'\n    simp only [Category.assoc] at fac fac'\n    refine' \u27e8Z''', t\u2081' \u226b \u03b1.s \u226b u \u226b u', t\u2082' \u226b \u03b1.s \u226b u \u226b u', _, _, _, _\u27e9\n    \u00b7 rw [reassoc_of% hst']\n    \u00b7 rw [reassoc_of% fac, reassoc_of% hft, fac']\n    \u00b7 rw [reassoc_of% hft']\n    \u00b7 rw [\u2190 Category.assoc]\n      exact W.comp_mem _ _ ht' (W.comp_mem _ _ \u03b1.hs (W.comp_mem _ _ hu hu'))\n  \u00b7 intro h\n    exact \u27e8h.fst, h.snd\u27e9\n\nend LeftFraction\u2082\n\nnamespace RightFraction\u2082\n\nvariable {X Y : C}\nvariable (\u03c6 : W.RightFraction\u2082 X Y)\n\n/-- The first right fraction. -/\n@[reducible]\ndef fst : W.RightFraction X Y where\n  X' := \u03c6.X'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second right fraction. -/\n@[reducible]\ndef snd : W.RightFraction X Y where\n  X' := \u03c6.X'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n", "theoremStatement": "lemma exists_leftFraction\u2082 [W.HasLeftCalculusOfFractions] :\n    \u2203 (\u03c8 : W.LeftFraction\u2082 X Y), \u03c6.f \u226b \u03c8.s = \u03c6.s \u226b \u03c8.f \u2227\n      \u03c6.f' \u226b \u03c8.s = \u03c6.s \u226b \u03c8.f'", "theoremName": "exists_leftFraction\u2082", "fileCreated": {"commit": "429161409e", "date": "2024-04-18"}, "theoremCreated": {"commit": "429161409e", "date": "2024-04-18"}, "file": "mathlib4/Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean", "positionMetadata": {"lineInFile": 249, "tokenPositionInFile": 7086, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8\u03c8\u2081, h\u03c8\u2081\u27e9 := \u03c6.fst.exists_leftFraction\n  obtain \u27e8\u03c8\u2082, h\u03c8\u2082\u27e9 := \u03c6.snd.exists_leftFraction\n  obtain \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ \u03c8\u2081.hs \u03c8\u2082.s).exists_leftFraction\n  dsimp at h\u03c8\u2081 h\u03c8\u2082 h\u03b1\n  refine' \u27e8LeftFraction\u2082.mk (\u03c8\u2081.f \u226b \u03b1.f) (\u03c8\u2082.f \u226b \u03b1.s) (\u03c8\u2082.s \u226b \u03b1.s)\n      (W.comp_mem _ _ \u03c8\u2082.hs \u03b1.hs), _, _\u27e9\n  \u00b7 dsimp\n    rw [h\u03b1, reassoc_of% h\u03c8\u2081]\n  \u00b7 rw [reassoc_of% h\u03c8\u2082]", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 364}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.CategoryTheory.Localization.CalculusOfFractions\n\n/-!\n# Lemmas on fractions\n\nLet `W : MorphismProperty C`, and objects `X` and `Y` in `C`. In this file,\nwe introduce structures like `W.LeftFraction\u2082 X Y` which consists of two\nleft fractions with the \"same denominator\" which shall be important in\nthe construction of the preadditive structure on the localized category\nwhen `C` is preadditive and `W` has a left calculus of fractions.\n\nWhen `W` has a left calculus of fractions, we generalize the lemmas\n`RightFraction.exists_leftFraction` as `RightFraction\u2082.exists_leftFraction\u2082`,\n`Localization.exists_leftFraction` as `Localization.exists_leftFraction\u2082` and\n`Localization.exists_leftFraction\u2083`, and\n`LeftFraction.map_eq_iff` as `LeftFraction\u2082.map_eq_iff`.\n\n## Implementation note\n\nThe lemmas in this file are phrased with data that is bundled into structures like\n`LeftFraction\u2082` or `LeftFraction\u2083`. It could have been possible to phrase them\nwith \"unbundled data\". However, this would require introducing 4 or 5 variables instead\nof one. It is also very convenient to use dot notation.\nMany definitions have been made reducible so as to ease rewrites when this API is used.\n\n-/\n\nnamespace CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D] (L : C \u2964 D) (W : MorphismProperty C)\n  [L.IsLocalization W]\n\nnamespace MorphismProperty\n\n/-- This structure contains the data of two left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of three left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2083 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the numerator of the third left fraction -/\n  f'' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of two right fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure RightFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of right fractions -/\n  {X' : C}\n  /-- the denominator of the right fractions -/\n  s : X' \u27f6 X\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n  /-- the numerator of the first right fraction -/\n  f : X' \u27f6 Y\n  /-- the numerator of the second right fraction -/\n  f' : X' \u27f6 Y\n\nvariable {W}\n\n/-- The equivalence relation on tuples of left fractions with the same denominator\nfor a morphism property `W`. The fact it is an equivalence relation is not\nformalized, but it would follow easily from `LeftFraction\u2082.map_eq_iff`. -/\ndef LeftFraction\u2082Rel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction\u2082 X Y) : Prop :=\n  \u2203 (Z : C)  (t\u2081 : z\u2081.Y' \u27f6 Z) (t\u2082 : z\u2082.Y' \u27f6 Z) (_ : z\u2081.s \u226b t\u2081 = z\u2082.s \u226b t\u2082)\n    (_ : z\u2081.f \u226b t\u2081 = z\u2082.f \u226b t\u2082) (_ : z\u2081.f' \u226b t\u2081 = z\u2082.f' \u226b t\u2082), W (z\u2081.s \u226b t\u2081)\n\nnamespace LeftFraction\u2082\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2082 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The exchange of the two fractions. -/\n@[reducible]\ndef symm : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2082\n\nnamespace LeftFraction\u2083\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2083 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The third left fraction. -/\n@[reducible]\ndef thd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the first fraction. -/\n@[reducible]\ndef forgetFst : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the second fraction. -/\n@[reducible]\ndef forgetSnd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the third fraction. -/\n@[reducible]\ndef forgetThd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2083\n\nnamespace LeftFraction\u2082Rel\n\nvariable {X Y : C} {z\u2081 z\u2082 : W.LeftFraction\u2082 X Y} (h : LeftFraction\u2082Rel z\u2081 z\u2082)\n\nlemma fst : LeftFractionRel z\u2081.fst z\u2082.fst := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, hft, _, ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9\n\nlemma snd : LeftFractionRel z\u2081.snd z\u2082.snd := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, _, hft', ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft', ht\u27e9\n\nend LeftFraction\u2082Rel\n\nnamespace LeftFraction\u2082\n\nvariable (W)\nvariable [W.HasLeftCalculusOfFractions]\n\nlemma map_eq_iff {X Y : C} (\u03c6 \u03c8 : W.LeftFraction\u2082 X Y) :\n    (\u03c6.fst.map L (Localization.inverts _ _) = \u03c8.fst.map L (Localization.inverts _ _) \u2227\n    \u03c6.snd.map L (Localization.inverts _ _) = \u03c8.snd.map L (Localization.inverts _ _)) \u2194\n      LeftFraction\u2082Rel \u03c6 \u03c8 := by\n  simp only [LeftFraction.map_eq_iff L W]\n  constructor\n  \u00b7 intro \u27e8h, h'\u27e9\n    obtain \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9 := h\n    obtain \u27e8Z', t\u2081', t\u2082', hst', hft', ht'\u27e9 := h'\n    dsimp at t\u2081 t\u2082 t\u2081' t\u2082' hst hft hst' hft' ht ht'\n    have \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ ht (\u03c6.s \u226b t\u2081')).exists_leftFraction\n    simp only [Category.assoc] at h\u03b1\n    obtain \u27e8Z'', u, hu, fac\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ \u03c6.hs h\u03b1\n    have h\u03b1' : \u03c8.s \u226b t\u2082 \u226b \u03b1.f \u226b u = \u03c8.s \u226b t\u2082' \u226b \u03b1.s \u226b u := by\n      rw [\u2190 reassoc_of% hst, \u2190 reassoc_of% h\u03b1, \u2190 reassoc_of% hst']\n    obtain \u27e8Z''', u', hu', fac'\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ \u03c8.hs h\u03b1'\n    simp only [Category.assoc] at fac fac'\n    refine' \u27e8Z''', t\u2081' \u226b \u03b1.s \u226b u \u226b u', t\u2082' \u226b \u03b1.s \u226b u \u226b u', _, _, _, _\u27e9\n    \u00b7 rw [reassoc_of% hst']\n    \u00b7 rw [reassoc_of% fac, reassoc_of% hft, fac']\n    \u00b7 rw [reassoc_of% hft']\n    \u00b7 rw [\u2190 Category.assoc]\n      exact W.comp_mem _ _ ht' (W.comp_mem _ _ \u03b1.hs (W.comp_mem _ _ hu hu'))\n  \u00b7 intro h\n    exact \u27e8h.fst, h.snd\u27e9\n\nend LeftFraction\u2082\n\nnamespace RightFraction\u2082\n\nvariable {X Y : C}\nvariable (\u03c6 : W.RightFraction\u2082 X Y)\n\n/-- The first right fraction. -/\n@[reducible]\ndef fst : W.RightFraction X Y where\n  X' := \u03c6.X'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second right fraction. -/\n@[reducible]\ndef snd : W.RightFraction X Y where\n  X' := \u03c6.X'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nlemma exists_leftFraction\u2082 [W.HasLeftCalculusOfFractions] :\n    \u2203 (\u03c8 : W.LeftFraction\u2082 X Y), \u03c6.f \u226b \u03c8.s = \u03c6.s \u226b \u03c8.f \u2227\n      \u03c6.f' \u226b \u03c8.s = \u03c6.s \u226b \u03c8.f' := by\n  obtain \u27e8\u03c8\u2081, h\u03c8\u2081\u27e9 := \u03c6.fst.exists_leftFraction\n  obtain \u27e8\u03c8\u2082, h\u03c8\u2082\u27e9 := \u03c6.snd.exists_leftFraction\n  obtain \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ \u03c8\u2081.hs \u03c8\u2082.s).exists_leftFraction\n  dsimp at h\u03c8\u2081 h\u03c8\u2082 h\u03b1\n  refine' \u27e8LeftFraction\u2082.mk (\u03c8\u2081.f \u226b \u03b1.f) (\u03c8\u2082.f \u226b \u03b1.s) (\u03c8\u2082.s \u226b \u03b1.s)\n      (W.comp_mem _ _ \u03c8\u2082.hs \u03b1.hs), _, _\u27e9\n  \u00b7 dsimp\n    rw [h\u03b1, reassoc_of% h\u03c8\u2081]\n  \u00b7 rw [reassoc_of% h\u03c8\u2082]\n\nend RightFraction\u2082\n\nend MorphismProperty\n\nnamespace Localization\n\nvariable [W.HasLeftCalculusOfFractions]\n\nopen MorphismProperty\n\n", "theoremStatement": "lemma exists_leftFraction\u2082 {X Y : C} (f f' : L.obj X \u27f6 L.obj Y) :\n    \u2203 (\u03c6 : W.LeftFraction\u2082 X Y), f = \u03c6.fst.map L (inverts L W) \u2227\n      f' = \u03c6.snd.map L (inverts L W)", "theoremName": "exists_leftFraction\u2082", "fileCreated": {"commit": "429161409e", "date": "2024-04-18"}, "theoremCreated": {"commit": "429161409e", "date": "2024-04-18"}, "file": "mathlib4/Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean", "positionMetadata": {"lineInFile": 272, "tokenPositionInFile": 7732, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  have \u27e8\u03c6, h\u03c6\u27e9 := exists_leftFraction L W f\n  have \u27e8\u03c6', h\u03c6'\u27e9 := exists_leftFraction L W f'\n  obtain \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ \u03c6.hs \u03c6'.s).exists_leftFraction\n  let \u03c8 : W.LeftFraction\u2082 X Y :=\n    { Y' := \u03b1.Y'\n      f := \u03c6.f \u226b \u03b1.f\n      f' := \u03c6'.f \u226b \u03b1.s\n      s := \u03c6'.s \u226b \u03b1.s\n      hs := W.comp_mem _ _ \u03c6'.hs \u03b1.hs }\n  have := inverts L W _ \u03c6'.hs\n  have := inverts L W _ \u03b1.hs\n  have : IsIso (L.map (\u03c6'.s \u226b \u03b1.s)) := by\n    rw [L.map_comp]\n    infer_instance\n  refine' \u27e8\u03c8, _, _\u27e9\n  \u00b7 rw [\u2190 cancel_mono (L.map (\u03c6'.s \u226b \u03b1.s)), LeftFraction.map_comp_map_s,\n      h\u03b1, L.map_comp, h\u03c6, LeftFraction.map_comp_map_s_assoc,\n      L.map_comp]\n  \u00b7 rw [\u2190 cancel_mono (L.map (\u03c6'.s \u226b \u03b1.s)), h\u03c6']\n    nth_rw 1 [L.map_comp]\n    rw [LeftFraction.map_comp_map_s_assoc, LeftFraction.map_comp_map_s,\n      L.map_comp]", "proofType": "tactic", "proofLengthLines": 23, "proofLengthTokens": 797}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.CategoryTheory.Localization.CalculusOfFractions\n\n/-!\n# Lemmas on fractions\n\nLet `W : MorphismProperty C`, and objects `X` and `Y` in `C`. In this file,\nwe introduce structures like `W.LeftFraction\u2082 X Y` which consists of two\nleft fractions with the \"same denominator\" which shall be important in\nthe construction of the preadditive structure on the localized category\nwhen `C` is preadditive and `W` has a left calculus of fractions.\n\nWhen `W` has a left calculus of fractions, we generalize the lemmas\n`RightFraction.exists_leftFraction` as `RightFraction\u2082.exists_leftFraction\u2082`,\n`Localization.exists_leftFraction` as `Localization.exists_leftFraction\u2082` and\n`Localization.exists_leftFraction\u2083`, and\n`LeftFraction.map_eq_iff` as `LeftFraction\u2082.map_eq_iff`.\n\n## Implementation note\n\nThe lemmas in this file are phrased with data that is bundled into structures like\n`LeftFraction\u2082` or `LeftFraction\u2083`. It could have been possible to phrase them\nwith \"unbundled data\". However, this would require introducing 4 or 5 variables instead\nof one. It is also very convenient to use dot notation.\nMany definitions have been made reducible so as to ease rewrites when this API is used.\n\n-/\n\nnamespace CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D] (L : C \u2964 D) (W : MorphismProperty C)\n  [L.IsLocalization W]\n\nnamespace MorphismProperty\n\n/-- This structure contains the data of two left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of three left fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure LeftFraction\u2083 (X Y : C) where\n  /-- the auxiliary object of left fractions -/\n  {Y' : C}\n  /-- the numerator of the first left fraction -/\n  f : X \u27f6 Y'\n  /-- the numerator of the second left fraction -/\n  f' : X \u27f6 Y'\n  /-- the numerator of the third left fraction -/\n  f'' : X \u27f6 Y'\n  /-- the denominator of the left fractions -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\n/-- This structure contains the data of two right fractions for\n`W : MorphismProperty C` that have the same \"denominator\". -/\nstructure RightFraction\u2082 (X Y : C) where\n  /-- the auxiliary object of right fractions -/\n  {X' : C}\n  /-- the denominator of the right fractions -/\n  s : X' \u27f6 X\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n  /-- the numerator of the first right fraction -/\n  f : X' \u27f6 Y\n  /-- the numerator of the second right fraction -/\n  f' : X' \u27f6 Y\n\nvariable {W}\n\n/-- The equivalence relation on tuples of left fractions with the same denominator\nfor a morphism property `W`. The fact it is an equivalence relation is not\nformalized, but it would follow easily from `LeftFraction\u2082.map_eq_iff`. -/\ndef LeftFraction\u2082Rel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction\u2082 X Y) : Prop :=\n  \u2203 (Z : C)  (t\u2081 : z\u2081.Y' \u27f6 Z) (t\u2082 : z\u2082.Y' \u27f6 Z) (_ : z\u2081.s \u226b t\u2081 = z\u2082.s \u226b t\u2082)\n    (_ : z\u2081.f \u226b t\u2081 = z\u2082.f \u226b t\u2082) (_ : z\u2081.f' \u226b t\u2081 = z\u2082.f' \u226b t\u2082), W (z\u2081.s \u226b t\u2081)\n\nnamespace LeftFraction\u2082\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2082 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The exchange of the two fractions. -/\n@[reducible]\ndef symm : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2082\n\nnamespace LeftFraction\u2083\n\nvariable {X Y : C} (\u03c6 : W.LeftFraction\u2083 X Y)\n\n/-- The first left fraction. -/\n@[reducible]\ndef fst : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second left fraction. -/\n@[reducible]\ndef snd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The third left fraction. -/\n@[reducible]\ndef thd : W.LeftFraction X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the first fraction. -/\n@[reducible]\ndef forgetFst : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f'\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the second fraction. -/\n@[reducible]\ndef forgetSnd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f''\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- Forgets the third fraction. -/\n@[reducible]\ndef forgetThd : W.LeftFraction\u2082 X Y where\n  Y' := \u03c6.Y'\n  f := \u03c6.f\n  f' := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nend LeftFraction\u2083\n\nnamespace LeftFraction\u2082Rel\n\nvariable {X Y : C} {z\u2081 z\u2082 : W.LeftFraction\u2082 X Y} (h : LeftFraction\u2082Rel z\u2081 z\u2082)\n\nlemma fst : LeftFractionRel z\u2081.fst z\u2082.fst := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, hft, _, ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9\n\nlemma snd : LeftFractionRel z\u2081.snd z\u2082.snd := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, _, hft', ht\u27e9 := h\n  exact \u27e8Z, t\u2081, t\u2082, hst, hft', ht\u27e9\n\nend LeftFraction\u2082Rel\n\nnamespace LeftFraction\u2082\n\nvariable (W)\nvariable [W.HasLeftCalculusOfFractions]\n\nlemma map_eq_iff {X Y : C} (\u03c6 \u03c8 : W.LeftFraction\u2082 X Y) :\n    (\u03c6.fst.map L (Localization.inverts _ _) = \u03c8.fst.map L (Localization.inverts _ _) \u2227\n    \u03c6.snd.map L (Localization.inverts _ _) = \u03c8.snd.map L (Localization.inverts _ _)) \u2194\n      LeftFraction\u2082Rel \u03c6 \u03c8 := by\n  simp only [LeftFraction.map_eq_iff L W]\n  constructor\n  \u00b7 intro \u27e8h, h'\u27e9\n    obtain \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9 := h\n    obtain \u27e8Z', t\u2081', t\u2082', hst', hft', ht'\u27e9 := h'\n    dsimp at t\u2081 t\u2082 t\u2081' t\u2082' hst hft hst' hft' ht ht'\n    have \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ ht (\u03c6.s \u226b t\u2081')).exists_leftFraction\n    simp only [Category.assoc] at h\u03b1\n    obtain \u27e8Z'', u, hu, fac\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ \u03c6.hs h\u03b1\n    have h\u03b1' : \u03c8.s \u226b t\u2082 \u226b \u03b1.f \u226b u = \u03c8.s \u226b t\u2082' \u226b \u03b1.s \u226b u := by\n      rw [\u2190 reassoc_of% hst, \u2190 reassoc_of% h\u03b1, \u2190 reassoc_of% hst']\n    obtain \u27e8Z''', u', hu', fac'\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ \u03c8.hs h\u03b1'\n    simp only [Category.assoc] at fac fac'\n    refine' \u27e8Z''', t\u2081' \u226b \u03b1.s \u226b u \u226b u', t\u2082' \u226b \u03b1.s \u226b u \u226b u', _, _, _, _\u27e9\n    \u00b7 rw [reassoc_of% hst']\n    \u00b7 rw [reassoc_of% fac, reassoc_of% hft, fac']\n    \u00b7 rw [reassoc_of% hft']\n    \u00b7 rw [\u2190 Category.assoc]\n      exact W.comp_mem _ _ ht' (W.comp_mem _ _ \u03b1.hs (W.comp_mem _ _ hu hu'))\n  \u00b7 intro h\n    exact \u27e8h.fst, h.snd\u27e9\n\nend LeftFraction\u2082\n\nnamespace RightFraction\u2082\n\nvariable {X Y : C}\nvariable (\u03c6 : W.RightFraction\u2082 X Y)\n\n/-- The first right fraction. -/\n@[reducible]\ndef fst : W.RightFraction X Y where\n  X' := \u03c6.X'\n  f := \u03c6.f\n  s := \u03c6.s\n  hs := \u03c6.hs\n\n/-- The second right fraction. -/\n@[reducible]\ndef snd : W.RightFraction X Y where\n  X' := \u03c6.X'\n  f := \u03c6.f'\n  s := \u03c6.s\n  hs := \u03c6.hs\n\nlemma exists_leftFraction\u2082 [W.HasLeftCalculusOfFractions] :\n    \u2203 (\u03c8 : W.LeftFraction\u2082 X Y), \u03c6.f \u226b \u03c8.s = \u03c6.s \u226b \u03c8.f \u2227\n      \u03c6.f' \u226b \u03c8.s = \u03c6.s \u226b \u03c8.f' := by\n  obtain \u27e8\u03c8\u2081, h\u03c8\u2081\u27e9 := \u03c6.fst.exists_leftFraction\n  obtain \u27e8\u03c8\u2082, h\u03c8\u2082\u27e9 := \u03c6.snd.exists_leftFraction\n  obtain \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ \u03c8\u2081.hs \u03c8\u2082.s).exists_leftFraction\n  dsimp at h\u03c8\u2081 h\u03c8\u2082 h\u03b1\n  refine' \u27e8LeftFraction\u2082.mk (\u03c8\u2081.f \u226b \u03b1.f) (\u03c8\u2082.f \u226b \u03b1.s) (\u03c8\u2082.s \u226b \u03b1.s)\n      (W.comp_mem _ _ \u03c8\u2082.hs \u03b1.hs), _, _\u27e9\n  \u00b7 dsimp\n    rw [h\u03b1, reassoc_of% h\u03c8\u2081]\n  \u00b7 rw [reassoc_of% h\u03c8\u2082]\n\nend RightFraction\u2082\n\nend MorphismProperty\n\nnamespace Localization\n\nvariable [W.HasLeftCalculusOfFractions]\n\nopen MorphismProperty\n\nlemma exists_leftFraction\u2082 {X Y : C} (f f' : L.obj X \u27f6 L.obj Y) :\n    \u2203 (\u03c6 : W.LeftFraction\u2082 X Y), f = \u03c6.fst.map L (inverts L W) \u2227\n      f' = \u03c6.snd.map L (inverts L W) := by\n  have \u27e8\u03c6, h\u03c6\u27e9 := exists_leftFraction L W f\n  have \u27e8\u03c6', h\u03c6'\u27e9 := exists_leftFraction L W f'\n  obtain \u27e8\u03b1, h\u03b1\u27e9 := (RightFraction.mk _ \u03c6.hs \u03c6'.s).exists_leftFraction\n  let \u03c8 : W.LeftFraction\u2082 X Y :=\n    { Y' := \u03b1.Y'\n      f := \u03c6.f \u226b \u03b1.f\n      f' := \u03c6'.f \u226b \u03b1.s\n      s := \u03c6'.s \u226b \u03b1.s\n      hs := W.comp_mem _ _ \u03c6'.hs \u03b1.hs }\n  have := inverts L W _ \u03c6'.hs\n  have := inverts L W _ \u03b1.hs\n  have : IsIso (L.map (\u03c6'.s \u226b \u03b1.s)) := by\n    rw [L.map_comp]\n    infer_instance\n  refine' \u27e8\u03c8, _, _\u27e9\n  \u00b7 rw [\u2190 cancel_mono (L.map (\u03c6'.s \u226b \u03b1.s)), LeftFraction.map_comp_map_s,\n      h\u03b1, L.map_comp, h\u03c6, LeftFraction.map_comp_map_s_assoc,\n      L.map_comp]\n  \u00b7 rw [\u2190 cancel_mono (L.map (\u03c6'.s \u226b \u03b1.s)), h\u03c6']\n    nth_rw 1 [L.map_comp]\n    rw [LeftFraction.map_comp_map_s_assoc, LeftFraction.map_comp_map_s,\n      L.map_comp]\n\n", "theoremStatement": "lemma exists_leftFraction\u2083 {X Y : C} (f f' f'' : L.obj X \u27f6 L.obj Y) :\n    \u2203 (\u03c6 : W.LeftFraction\u2083 X Y), f = \u03c6.fst.map L (inverts L W) \u2227\n      f' = \u03c6.snd.map L (inverts L W) \u2227\n      f'' = \u03c6.thd.map L (inverts L W)", "theoremName": "exists_leftFraction\u2083", "fileCreated": {"commit": "429161409e", "date": "2024-04-18"}, "theoremCreated": {"commit": "429161409e", "date": "2024-04-18"}, "file": "mathlib4/Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean", "positionMetadata": {"lineInFile": 298, "tokenPositionInFile": 8702, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8\u03b1, h\u03b1, h\u03b1'\u27e9 := exists_leftFraction\u2082 L W f f'\n  have \u27e8\u03b2, h\u03b2\u27e9 := exists_leftFraction L W f''\n  obtain \u27e8\u03b3, h\u03b3\u27e9 := (RightFraction.mk _ \u03b1.hs \u03b2.s).exists_leftFraction\n  dsimp at h\u03b3\n  let \u03c8 : W.LeftFraction\u2083 X Y :=\n    { Y' := \u03b3.Y'\n      f := \u03b1.f \u226b \u03b3.f\n      f' := \u03b1.f' \u226b \u03b3.f\n      f'' := \u03b2.f \u226b \u03b3.s\n      s := \u03b2.s \u226b \u03b3.s\n      hs := W.comp_mem _ _ \u03b2.hs \u03b3.hs }\n  have := inverts L W _ \u03b2.hs\n  have := inverts L W _ \u03b3.hs\n  have : IsIso (L.map (\u03b2.s \u226b \u03b3.s)) := by\n    rw [L.map_comp]\n    infer_instance\n  refine' \u27e8\u03c8, _, _, _\u27e9\n  \u00b7 rw [\u2190 cancel_mono (L.map (\u03b2.s \u226b \u03b3.s)), LeftFraction.map_comp_map_s, h\u03b1, h\u03b3,\n      L.map_comp, LeftFraction.map_comp_map_s_assoc, L.map_comp]\n  \u00b7 rw [\u2190 cancel_mono (L.map (\u03b2.s \u226b \u03b3.s)), LeftFraction.map_comp_map_s, h\u03b1', h\u03b3,\n      L.map_comp, LeftFraction.map_comp_map_s_assoc, L.map_comp]\n  \u00b7 rw [\u2190 cancel_mono (L.map (\u03b2.s \u226b \u03b3.s)), h\u03b2]\n    nth_rw 1 [L.map_comp]\n    rw [LeftFraction.map_comp_map_s_assoc, LeftFraction.map_comp_map_s, L.map_comp]", "proofType": "tactic", "proofLengthLines": 25, "proofLengthTokens": 973}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\nimport Mathlib.Algebra.MvPolynomial.Monad\nimport Mathlib.LinearAlgebra.Charpoly.ToMatrix\nimport Mathlib.LinearAlgebra.Dimension.Finrank\nimport Mathlib.LinearAlgebra.Matrix.Charpoly.Univ\n\n/-!\n# Characteristic polynomials of linear families of endomorphisms\n\nThe coefficients of the characteristic polynomials of a linear family of endomorphisms\nare homogeneous polynomials in the parameters.\nThis result is used in Lie theory\nto establish the existence of regular elements and Cartan subalgebras,\nand ultimately a well-defined notion of rank for Lie algebras.\n\nIn this file we prove this result about characteristic polynomials.\nLet `L` and `M` be modules over a nontrivial commutative ring `R`,\nand let `\u03c6 : L \u2192\u2097[R] Module.End R M` be a linear map.\nLet `b` be a basis of `L`, indexed by `\u03b9`.\nThen we define a multivariate polynomial with variables indexed by `\u03b9`\nthat evaluates on elements `x` of `L` to the characteristic polynomial of `\u03c6 x`.\n\n## Main declarations\n\n* `Matrix.toMvPolynomial M i`: the family of multivariate polynomials that evaluates on `c : n \u2192 R`\n  to the dot product of the `i`-th row of `M` with `c`.\n  `Matrix.toMvPolynomial M i` is the sum of the monomials `C (M i j) * X j`.\n* `LinearMap.toMvPolynomial b\u2081 b\u2082 f`: a version of `Matrix.toMvPolynomial` for linear maps `f`\n  with respect to bases `b\u2081` and `b\u2082` of the domain and codomain.\n* `LinearMap.polyCharpoly`: the multivariate polynomial that evaluates on elements `x` of `L`\n  to the characteristic polynomial of `\u03c6 x`.\n* `LinearMap.polyCharpoly_map_eq_charpoly`: the evaluation of `polyCharpoly` on elements `x` of `L`\n  is the characteristic polynomial of `\u03c6 x`.\n* `LinearMap.polyCharpoly_coeff_isHomogeneous`: the coefficients of `polyCharpoly`\n  are homogeneous polynomials in the parameters.\n\n## Implementation details\n\nWe show that `LinearMap.polyCharpoly` does not depend on the choice of basis of the target module.\nThis is done via `LinearMap.polyCharpoly_eq_polyCharpolyAux`\nand `LinearMap.polyCharpolyAux_basisIndep`.\nThe latter is proven by considering\nthe base change of the `R`-linear map `\u03c6 : L \u2192\u2097[R] End R M`\nto the multivariate polynomial ring `MvPolynomial \u03b9 R`,\nand showing that `polyCharpolyAux \u03c6` is equal to the characteristic polynomial of this base change.\nThe proof concludes because characteristic polynomials are independent of the chosen basis.\n\n-/\n\nopen scoped BigOperators Matrix\n\nnamespace Matrix\n\nvariable {m n o R S : Type*}\nvariable [Fintype n] [Fintype o] [CommSemiring R] [CommSemiring S]\n\nopen MvPolynomial\n\n/-- Let `M` be an `(m \u00d7 n)`-matrix over `R`.\nThen `Matrix.toMvPolynomial M` is the family (indexed by `i : m`)\nof multivariate polynomials in `n` variables over `R` that evaluates on `c : n \u2192 R`\nto the dot product of the `i`-th row of `M` with `c`:\n`Matrix.toMvPolynomial M i` is the sum of the monomials `C (M i j) * X j`. -/\nnoncomputable\ndef toMvPolynomial (M : Matrix m n R) (i : m) : MvPolynomial n R :=\n  \u2211 j, monomial (.single j 1) (M i j)\n\n", "theoremStatement": "lemma toMvPolynomial_eval_eq_apply (M : Matrix m n R) (i : m) (c : n \u2192 R) :\n    eval c (M.toMvPolynomial i) = (M *\u1d65 c) i", "theoremName": "toMvPolynomial_eval_eq_apply", "fileCreated": {"commit": "48970a4b9d", "date": "2024-04-17"}, "theoremCreated": {"commit": "48970a4b9d", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/LinearMap/Polynomial.lean", "positionMetadata": {"lineInFile": 72, "tokenPositionInFile": 3127, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp only [toMvPolynomial, map_sum, eval_monomial, pow_zero, Finsupp.prod_single_index, pow_one,\n    mulVec, dotProduct]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 125}, "split": "mathlib"}
{"srcContext": "/-\nCopyright (c) 2024 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\nimport Mathlib.Algebra.MvPolynomial.Monad\nimport Mathlib.LinearAlgebra.Charpoly.ToMatrix\nimport Mathlib.LinearAlgebra.Dimension.Finrank\nimport Mathlib.LinearAlgebra.Matrix.Charpoly.Univ\n\n/-!\n# Characteristic polynomials of linear families of endomorphisms\n\nThe coefficients of the characteristic polynomials of a linear family of endomorphisms\nare homogeneous polynomials in the parameters.\nThis result is used in Lie theory\nto establish the existence of regular elements and Cartan subalgebras,\nand ultimately a well-defined notion of rank for Lie algebras.\n\nIn this file we prove this result about characteristic polynomials.\nLet `L` and `M` be modules over a nontrivial commutative ring `R`,\nand let `\u03c6 : L \u2192\u2097[R] Module.End R M` be a linear map.\nLet `b` be a basis of `L`, indexed by `\u03b9`.\nThen we define a multivariate polynomial with variables indexed by `\u03b9`\nthat evaluates on elements `x` of `L` to the characteristic polynomial of `\u03c6 x`.\n\n## Main declarations\n\n* `Matrix.toMvPolynomial M i`: the family of multivariate polynomials that evaluates on `c : n \u2192 R`\n  to the dot product of the `i`-th row of `M` with `c`.\n  `Matrix.toMvPolynomial M i` is the sum of the monomials `C (M i j) * X j`.\n* `LinearMap.toMvPolynomial b\u2081 b\u2082 f`: a version of `Matrix.toMvPolynomial` for linear maps `f`\n  with respect to bases `b\u2081` and `b\u2082` of the domain and codomain.\n* `LinearMap.polyCharpoly`: the multivariate polynomial that evaluates on elements `x` of `L`\n  to the characteristic polynomial of `\u03c6 x`.\n* `LinearMap.polyCharpoly_map_eq_charpoly`: the evaluation of `polyCharpoly` on elements `x` of `L`\n  is the characteristic polynomial of `\u03c6 x`.\n* `LinearMap.polyCharpoly_coeff_isHomogeneous`: the coefficients of `polyCharpoly`\n  are homogeneous polynomials in the parameters.\n\n## Implementation details\n\nWe show that `LinearMap.polyCharpoly` does not depend on the choice of basis of the target module.\nThis is done via `LinearMap.polyCharpoly_eq_polyCharpolyAux`\nand `LinearMap.polyCharpolyAux_basisIndep`.\nThe latter is proven by considering\nthe base change of the `R`-linear map `\u03c6 : L \u2192\u2097[R] End R M`\nto the multivariate polynomial ring `MvPolynomial \u03b9 R`,\nand showing that `polyCharpolyAux \u03c6` is equal to the characteristic polynomial of this base change.\nThe proof concludes because characteristic polynomials are independent of the chosen basis.\n\n-/\n\nopen scoped BigOperators Matrix\n\nnamespace Matrix\n\nvariable {m n o R S : Type*}\nvariable [Fintype n] [Fintype o] [CommSemiring R] [CommSemiring S]\n\nopen MvPolynomial\n\n/-- Let `M` be an `(m \u00d7 n)`-matrix over `R`.\nThen `Matrix.toMvPolynomial M` is the family (indexed by `i : m`)\nof multivariate polynomials in `n` variables over `R` that evaluates on `c : n \u2192 R`\nto the dot product of the `i`-th row of `M` with `c`:\n`Matrix.toMvPolynomial M i` is the sum of the monomials `C (M i j) * X j`. -/\nnoncomputable\ndef toMvPolynomial (M : Matrix m n R) (i : m) : MvPolynomial n R :=\n  \u2211 j, monomial (.single j 1) (M i j)\n\nlemma toMvPolynomial_eval_eq_apply (M : Matrix m n R) (i : m) (c : n \u2192 R) :\n    eval c (M.toMvPolynomial i) = (M *\u1d65 c) i := by\n  simp only [toMvPolynomial, map_sum, eval_monomial, pow_zero, Finsupp.prod_single_index, pow_one,\n    mulVec, dotProduct]\n\n", "theoremStatement": "lemma toMvPolynomial_map (f : R \u2192+* S) (M : Matrix m n R) (i : m) :\n    (M.map f).toMvPolynomial i = MvPolynomial.map f (M.toMvPolynomial i)", "theoremName": "toMvPolynomial_map", "fileCreated": {"commit": "48970a4b9d", "date": "2024-04-17"}, "theoremCreated": {"commit": "48970a4b9d", "date": "2024-04-17"}, "file": "mathlib4/Mathlib/Algebra/Module/LinearMap/Polynomial.lean", "positionMetadata": {"lineInFile": 77, "tokenPositionInFile": 3378, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "repositoryPremises": true}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp only [toMvPolynomial, map_apply, map_sum, map_monomial]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 65}, "split": "mathlib"}
