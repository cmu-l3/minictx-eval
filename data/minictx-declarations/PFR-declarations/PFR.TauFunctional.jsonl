{"name":"distance_ge_of_min","declaration":"/-- Let `X₁` and `X₂` be tau-minimizers associated to `p`, with $d[X_1,X_2]=k$, then\n$$ d[X'_1;X'_2] \\geq\n    k - \\eta (d[X^0_1;X'_1] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2] - d[X^0_2;X_2] )$$\nfor any $G$-valued random variables $X'_1,X'_2$.\n-/\ntheorem distance_ge_of_min {Ω : Type u_7} {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [AddCommGroup G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω'₁ : Type u_5} {Ω'₂ : Type u_6} [MeasureTheory.MeasureSpace Ω] [hΩ₁ : MeasureTheory.MeasureSpace Ω'₁] [hΩ₂ : MeasureTheory.MeasureSpace Ω'₂] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X₁ : Ω → G} {X₂ : Ω → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G} (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) : d[X₁ # X₂] - p.η * (d[p.X₀₁ # X'₁] - d[p.X₀₁ # X₁]) - p.η * (d[p.X₀₂ # X'₂] - d[p.X₀₂ # X₂]) ≤ d[X'₁ # X'₂]"}
{"name":"«termτ[_#_|_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef «termτ[_#_|_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"«termτ[_;_#_;_|_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef «termτ[_;_#_;_|_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"distance_ge_of_min'","declaration":"/-- Version of `distance_ge_of_min` with the measures made explicit. -/\ntheorem distance_ge_of_min' {Ω : Type u_9} {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [AddCommGroup G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) [MeasureTheory.MeasureSpace Ω] {X₁ : Ω → G} {X₂ : Ω → G} {Ω'₁ : Type u_7} {Ω'₂ : Type u_8} (h : tau_minimizes p X₁ X₂) [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂] {μ : MeasureTheory.Measure Ω'₁} {μ' : MeasureTheory.Measure Ω'₂} [MeasureTheory.IsProbabilityMeasure μ] [MeasureTheory.IsProbabilityMeasure μ'] {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G} (h1 : Measurable X'₁) (h2 : Measurable X'₂) : d[X₁ # X₂] - p.η * (d[p.X₀₁ ; MeasureTheory.volume # X'₁ ; μ] - d[p.X₀₁ # X₁]) -\n    p.η * (d[p.X₀₂ ; MeasureTheory.volume # X'₂ ; μ'] - d[p.X₀₂ # X₂]) ≤\n  d[X'₁ ; μ # X'₂ ; μ']"}
{"name":"refPackage.hmeas1","declaration":"def refPackage.hmeas1 {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G) : Measurable self.X₀₁"}
{"name":"«termτ[_;_#_;_|_]»","declaration":"/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n-/\ndef «termτ[_;_#_;_|_]»  : Lean.ParserDescr"}
{"name":"condRuzsaDistance_ge_of_min","declaration":"/-- For any $G$-valued random variables $X'_1,X'_2$ and random variables $Z,W$, one can lower\nbound $d[X'_1|Z;X'_2|W]$ by\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] ).$$\n-/\ntheorem condRuzsaDistance_ge_of_min {Ω : Type u_9} {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [AddCommGroup G] [Fintype G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω'₁ : Type u_5} {Ω'₂ : Type u_6} [MeasureTheory.MeasureSpace Ω] [hΩ₁ : MeasureTheory.MeasureSpace Ω'₁] [hΩ₂ : MeasureTheory.MeasureSpace Ω'₂] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X₁ : Ω → G} {X₂ : Ω → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G} {S : Type u_7} {T : Type u_8} [MeasurableSingletonClass G] [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S] [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) (Z : Ω'₁ → S) (W : Ω'₂ → T) (hZ : Measurable Z) (hW : Measurable W) : d[X₁ # X₂] - p.η * (d[p.X₀₁ # X'₁ | Z] - d[p.X₀₁ # X₁]) - p.η * (d[p.X₀₂ # X'₂ | W] - d[p.X₀₂ # X₂]) ≤\n  d[X'₁ | Z # X'₂ | W]"}
{"name":"tau","declaration":"/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n-/\ndef tau {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [AddCommGroup G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω₁ : Type u_7} {Ω₂ : Type u_8} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : MeasureTheory.Measure Ω₁) (μ₂ : MeasureTheory.Measure Ω₂) : ℝ"}
{"name":"refPackage.hη'","declaration":"def refPackage.hη' {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G) : 8 * self.η ≤ 1"}
{"name":"refPackage.hmeas2","declaration":"def refPackage.hmeas2 {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G) : Measurable self.X₀₂"}
{"name":"«termτ[_#_|_]»","declaration":"/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n-/\ndef «termτ[_#_|_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.IdentDistrib.tau_minimizes","declaration":"/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\ntheorem ProbabilityTheory.IdentDistrib.tau_minimizes {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [AddCommGroup G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω : Type u_7} {Ω' : Type u_8} [MeasureTheory.MeasureSpace Ω] [MeasureTheory.MeasureSpace Ω'] {X₁ : Ω → G} {X₂ : Ω → G} {X₁' : Ω' → G} {X₂' : Ω' → G} (h₁ : ProbabilityTheory.IdentDistrib X₁ X₁' MeasureTheory.volume MeasureTheory.volume) (h₂ : ProbabilityTheory.IdentDistrib X₂ X₂' MeasureTheory.volume MeasureTheory.volume) : tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂'"}
{"name":"refPackage","declaration":"/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage (Ω₀₁ : Type u_1) (Ω₀₂ : Type u_2) [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] (G : Type uG) [MeasurableSpace G] : Type (max (max uG u_1) u_2)"}
{"name":"continuous_tau_restrict_probabilityMeasure","declaration":"theorem continuous_tau_restrict_probabilityMeasure {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {G : Type uG} [AddCommGroup G] [Fintype G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] : Continuous fun μ => τ[id ; ↑μ.1 # id ; ↑μ.2 | p]"}
{"name":"tau_minimizer_exists","declaration":"/-- A pair of random variables minimizing $τ$ exists. -/\ntheorem tau_minimizer_exists {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {G : Type uG} [AddCommGroup G] [Fintype G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) [MeasurableSingletonClass G] : ∃ Ω mΩ X₁ X₂,\n  Measurable X₁ ∧ Measurable X₂ ∧ MeasureTheory.IsProbabilityMeasure MeasureTheory.volume ∧ tau_minimizes p X₁ X₂"}
{"name":"is_tau_min","declaration":"theorem is_tau_min {Ω : Type u_7} {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [AddCommGroup G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω'₁ : Type u_5} {Ω'₂ : Type u_6} [MeasureTheory.MeasureSpace Ω] [hΩ₁ : MeasureTheory.MeasureSpace Ω'₁] [hΩ₂ : MeasureTheory.MeasureSpace Ω'₂] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X₁ : Ω → G} {X₂ : Ω → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G} (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) : τ[X₁ # X₂ | p] ≤ τ[X'₁ # X'₂ | p]"}
{"name":"ProbabilityTheory.IdentDistrib.tau_eq","declaration":"/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\ntheorem ProbabilityTheory.IdentDistrib.tau_eq {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [AddCommGroup G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω₁ : Type u_3} {Ω₂ : Type u_4} {Ω'₁ : Type u_5} {Ω'₂ : Type u_6} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂] {μ₁ : MeasureTheory.Measure Ω₁} {μ₂ : MeasureTheory.Measure Ω₂} {μ'₁ : MeasureTheory.Measure Ω'₁} {μ'₂ : MeasureTheory.Measure Ω'₂} {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G} (h₁ : ProbabilityTheory.IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : ProbabilityTheory.IdentDistrib X₂ X'₂ μ₂ μ'₂) : τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p]"}
{"name":"refPackage.η","declaration":"def refPackage.η {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G) : ℝ"}
{"name":"tau_minimizes","declaration":"/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [AddCommGroup G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω : Type u_7} [MeasureTheory.MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop"}
{"name":"refPackage.mk","declaration":"ctor refPackage.mk {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [MeasurableSpace G] (X₀₁ : Ω₀₁ → G) (X₀₂ : Ω₀₂ → G) (hmeas1 : Measurable X₀₁) (hmeas2 : Measurable X₀₂) (η : ℝ) (hη : 0 < η) (hη' : 8 * η ≤ 1) : refPackage Ω₀₁ Ω₀₂ G"}
{"name":"tau_min_exists_measure","declaration":"/-- A pair of measures minimizing $\\tau$ exists. -/\ntheorem tau_min_exists_measure {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] [MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {G : Type uG} [AddCommGroup G] [Fintype G] [MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) [MeasurableSingletonClass G] : ∃ μ,\n  MeasureTheory.IsProbabilityMeasure μ.1 ∧\n    MeasureTheory.IsProbabilityMeasure μ.2 ∧\n      ∀ (ν₁ ν₂ : MeasureTheory.Measure G),\n        MeasureTheory.IsProbabilityMeasure ν₁ →\n          MeasureTheory.IsProbabilityMeasure ν₂ → τ[id ; μ.1 # id ; μ.2 | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]"}
{"name":"refPackage.hη","declaration":"def refPackage.hη {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G) : 0 < self.η"}
{"name":"refPackage.X₀₁","declaration":"/-- The first variable in a package. -/\ndef refPackage.X₀₁ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G) : Ω₀₁ → G"}
{"name":"refPackage.X₀₂","declaration":"/-- The second variable in a package. -/\ndef refPackage.X₀₂ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [MeasureTheory.MeasureSpace Ω₀₁] [MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G) : Ω₀₂ → G"}
