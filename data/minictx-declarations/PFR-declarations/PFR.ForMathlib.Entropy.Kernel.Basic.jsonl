{"name":"ProbabilityTheory.kernel.entropy_const","declaration":"theorem ProbabilityTheory.kernel.entropy_const {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (ν : MeasureTheory.Measure S) (μ : MeasureTheory.Measure T) : Hk[ProbabilityTheory.kernel.const T ν , μ] = (↑↑μ Set.univ).toReal * Hm[ν]"}
{"name":"ProbabilityTheory.kernel.entropy_compProd","declaration":"theorem ProbabilityTheory.kernel.entropy_compProd {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {μ : MeasureTheory.Measure T} [MeasureTheory.IsFiniteMeasure μ] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] {η : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel η] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η (MeasureTheory.Measure.compProd μ κ)) : Hk[ProbabilityTheory.kernel.compProd κ η , μ] = Hk[κ , μ] + Hk[η , MeasureTheory.Measure.compProd μ κ]"}
{"name":"ProbabilityTheory.kernel.entropy_prodMkRight","declaration":"theorem ProbabilityTheory.kernel.entropy_prodMkRight {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [MeasurableSpace U] {κ : ↥(ProbabilityTheory.kernel T S)} {η : ↥(ProbabilityTheory.kernel T U)} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.prodMkRight S η , MeasureTheory.Measure.compProd μ κ] = Hk[η , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_snd_le","declaration":"theorem ProbabilityTheory.kernel.entropy_snd_le {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.snd κ , μ] ≤ Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.aefiniteKernelSupport_condDistrib","declaration":"theorem ProbabilityTheory.kernel.aefiniteKernelSupport_condDistrib {Ω : Type u_1} {S : Type u_2} {T : Type u_3} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] (X : Ω → S) (Y : Ω → T) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (hX : Measurable X) (hY : Measurable Y) [FiniteRange X] [FiniteRange Y] : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.condDistrib X Y μ) (MeasureTheory.Measure.map Y μ)"}
{"name":"ProbabilityTheory.kernel.entropy_nonneg","declaration":"theorem ProbabilityTheory.kernel.entropy_nonneg {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (κ : ↥(ProbabilityTheory.kernel T S)) (μ : MeasureTheory.Measure T) : 0 ≤ Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_prodMkLeft_unit","declaration":"theorem ProbabilityTheory.kernel.entropy_prodMkLeft_unit {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] (κ : ↥(ProbabilityTheory.kernel T S)) {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] : Hk[ProbabilityTheory.kernel.prodMkLeft Unit κ , MeasureTheory.Measure.map (Prod.mk ()) μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.chain_rule'","declaration":"theorem ProbabilityTheory.kernel.chain_rule' {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[κ , μ] =\n  Hk[ProbabilityTheory.kernel.snd κ , μ] +\n    Hk[ProbabilityTheory.kernel.condKernel (ProbabilityTheory.kernel.swapRight κ) ,\n      MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.snd κ)]"}
{"name":"ProbabilityTheory.kernel.finiteSupport_of_compProd'","declaration":"/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\ntheorem ProbabilityTheory.kernel.finiteSupport_of_compProd' {S : Type u_2} {T : Type u_3} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure T} [MeasureTheory.IsFiniteMeasure μ] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) : ProbabilityTheory.FiniteSupport (MeasureTheory.Measure.compProd μ κ)"}
{"name":"ProbabilityTheory.kernel.entropy_comap","declaration":"theorem ProbabilityTheory.kernel.entropy_comap {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] {T' : Type u_5} [MeasurableSpace T'] [MeasurableSingletonClass T'] (κ : ↥(ProbabilityTheory.kernel T S)) (μ : MeasureTheory.Measure T) (f : T' → T) (hf : MeasurableEmbedding f) (hf_range : Set.range f =ᶠ[MeasureTheory.Measure.ae μ] Set.univ) [MeasureTheory.IsFiniteMeasure μ] [MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.comap f μ)] (hfμ : ProbabilityTheory.FiniteSupport (MeasureTheory.Measure.comap f μ)) : Hk[ProbabilityTheory.kernel.comap κ f ⋯ , MeasureTheory.Measure.comap f μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.«termHk[_,_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.kernel.«termHk[_,_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.kernel.entropy_comap_swap","declaration":"theorem ProbabilityTheory.kernel.entropy_comap_swap {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] {T' : Type u_5} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T'] (κ : ↥(ProbabilityTheory.kernel (T' × T) S)) {μ : MeasureTheory.Measure (T' × T)} [MeasureTheory.IsFiniteMeasure μ] [ProbabilityTheory.FiniteSupport μ] : Hk[ProbabilityTheory.kernel.comap κ Prod.swap ⋯ , MeasureTheory.Measure.comap Prod.swap μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.chain_rule","declaration":"theorem ProbabilityTheory.kernel.chain_rule {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} [ProbabilityTheory.IsMarkovKernel κ] [hU : Nonempty U] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[κ , μ] =\n  Hk[ProbabilityTheory.kernel.fst κ , μ] +\n    Hk[ProbabilityTheory.kernel.condKernel κ , MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.fst κ)]"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_const","declaration":"/-- Constant kernels with finite support, have finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_const {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (ν : MeasureTheory.Measure S) [ProbabilityTheory.FiniteSupport ν] : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.const T ν)"}
{"name":"ProbabilityTheory.kernel.entropy_map_of_injective","declaration":"theorem ProbabilityTheory.kernel.entropy_map_of_injective {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] (κ : ↥(ProbabilityTheory.kernel T S)) (μ : MeasureTheory.Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) : Hk[ProbabilityTheory.kernel.map κ f hmes , μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_prod","declaration":"theorem ProbabilityTheory.kernel.entropy_prod {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} {η : ↥(ProbabilityTheory.kernel T U)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.IsMarkovKernel η] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η μ) : Hk[ProbabilityTheory.kernel.prod κ η , μ] = Hk[κ , μ] + Hk[η , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_map_le","declaration":"/-- Data-processing inequality for the kernel entropy. -/\ntheorem ProbabilityTheory.kernel.entropy_map_le {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] (f : S → U) [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.map κ f ⋯ , μ] ≤ Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_deterministic","declaration":"theorem ProbabilityTheory.kernel.entropy_deterministic {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] (f : T → S) (μ : MeasureTheory.Measure T) : Hk[ProbabilityTheory.kernel.deterministic f ⋯ , μ] = 0"}
{"name":"ProbabilityTheory.kernel.entropy_fst_le","declaration":"theorem ProbabilityTheory.kernel.entropy_fst_le {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) [ProbabilityTheory.IsMarkovKernel κ] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.fst κ , μ] ≤ Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_zero_measure","declaration":"theorem ProbabilityTheory.kernel.entropy_zero_measure {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (κ : ↥(ProbabilityTheory.kernel T S)) : Hk[κ , 0] = 0"}
{"name":"ProbabilityTheory.kernel.entropy_swapRight","declaration":"theorem ProbabilityTheory.kernel.entropy_swapRight {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) (μ : MeasureTheory.Measure T) : Hk[ProbabilityTheory.kernel.swapRight κ , μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.prodMKLeft_unit_equiv","declaration":"/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef ProbabilityTheory.kernel.prodMKLeft_unit_equiv (T : Type u_5) [MeasurableSpace T] : Unit × T ≃ᵐ T"}
{"name":"ProbabilityTheory.kernel.entropy_prodMkLeft","declaration":"theorem ProbabilityTheory.kernel.entropy_prodMkLeft {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [MeasurableSpace U] {η : ↥(ProbabilityTheory.kernel T U)} {ν : MeasureTheory.Measure S} [MeasureTheory.IsProbabilityMeasure ν] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] [ProbabilityTheory.FiniteSupport ν] : Hk[ProbabilityTheory.kernel.prodMkLeft S η , MeasureTheory.Measure.prod ν μ] = Hk[η , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_of_map_eq_of_map","declaration":"theorem ProbabilityTheory.kernel.entropy_of_map_eq_of_map {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} {η : ↥(ProbabilityTheory.kernel T U)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.IsMarkovKernel η] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] (f : S → U) (g : U → S) (h1 : η = ProbabilityTheory.kernel.map κ f ⋯) (h2 : κ = ProbabilityTheory.kernel.map η g ⋯) [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η μ) : Hk[κ , μ] = Hk[η , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_zero_kernel","declaration":"theorem ProbabilityTheory.kernel.entropy_zero_kernel {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (μ : MeasureTheory.Measure T) : Hk[0 , μ] = 0"}
{"name":"ProbabilityTheory.kernel.entropy_le_log_card","declaration":"theorem ProbabilityTheory.kernel.entropy_le_log_card {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] (κ : ↥(ProbabilityTheory.kernel T S)) (μ : MeasureTheory.Measure T) [Fintype S] [MeasureTheory.IsProbabilityMeasure μ] : Hk[κ , μ] ≤ Real.log ↑(Fintype.card S)"}
{"name":"ProbabilityTheory.kernel.FiniteSupport.comap_equiv","declaration":"theorem ProbabilityTheory.kernel.FiniteSupport.comap_equiv {T : Type u_3} [MeasurableSpace T] [MeasurableSingletonClass T] {T' : Type u_5} [MeasurableSpace T'] [MeasurableSingletonClass T'] {μ : MeasureTheory.Measure T} (f : T' ≃ᵐ T) [ProbabilityTheory.FiniteSupport μ] : ProbabilityTheory.FiniteSupport (MeasureTheory.Measure.comap (⇑f) μ)"}
{"name":"ProbabilityTheory.kernel.entropy","declaration":"/-- Entropy of a kernel with respect to a measure. -/\ndef ProbabilityTheory.kernel.entropy {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (κ : ↥(ProbabilityTheory.kernel T S)) (μ : MeasureTheory.Measure T) : ℝ"}
{"name":"ProbabilityTheory.kernel.«termHk[_,_]»","declaration":"/-- Entropy of a kernel with respect to a measure. -/\ndef ProbabilityTheory.kernel.«termHk[_,_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.kernel.entropy_compProd_aux","declaration":"theorem ProbabilityTheory.kernel.entropy_compProd_aux {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSingletonClass T] [MeasurableSpace U] [MeasurableSingletonClass U] {μ : MeasureTheory.Measure T} [MeasureTheory.IsFiniteMeasure μ] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] {η : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel η] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) (hη : ProbabilityTheory.kernel.FiniteKernelSupport η) : Hk[ProbabilityTheory.kernel.compProd κ η , μ] =\n  Hk[κ , μ] + ∫ (x : T), (fun t => Hk[ProbabilityTheory.kernel.comap η (Prod.mk t) ⋯ , κ t]) x ∂μ"}
{"name":"ProbabilityTheory.kernel.entropy_compProd'","declaration":"theorem ProbabilityTheory.kernel.entropy_compProd' {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [MeasurableSpace U] [MeasurableSingletonClass U] {μ : MeasureTheory.Measure T} [MeasureTheory.IsFiniteMeasure μ] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] {η : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel η] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) (hη : ProbabilityTheory.kernel.FiniteKernelSupport η) : Hk[ProbabilityTheory.kernel.compProd κ η , μ] = Hk[κ , μ] + Hk[η , MeasureTheory.Measure.compProd μ κ]"}
{"name":"ProbabilityTheory.kernel.finiteSupport_of_compProd","declaration":"theorem ProbabilityTheory.kernel.finiteSupport_of_compProd {S : Type u_2} {T : Type u_3} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure T} [MeasureTheory.IsFiniteMeasure μ] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : ProbabilityTheory.FiniteSupport (MeasureTheory.Measure.compProd μ κ)"}
{"name":"ProbabilityTheory.kernel.entropy_prodMkRight'","declaration":"theorem ProbabilityTheory.kernel.entropy_prodMkRight' {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [MeasurableSpace U] {η : ↥(ProbabilityTheory.kernel T U)} {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] {ν : MeasureTheory.Measure S} [MeasureTheory.IsProbabilityMeasure ν] [ProbabilityTheory.FiniteSupport μ] [ProbabilityTheory.FiniteSupport ν] : Hk[ProbabilityTheory.kernel.prodMkRight S η , MeasureTheory.Measure.prod μ ν] = Hk[η , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_comap_equiv","declaration":"theorem ProbabilityTheory.kernel.entropy_comap_equiv {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] {T' : Type u_5} [MeasurableSpace T'] [MeasurableSingletonClass T'] (κ : ↥(ProbabilityTheory.kernel T S)) {μ : MeasureTheory.Measure T} (f : T' ≃ᵐ T) [MeasureTheory.IsFiniteMeasure μ] [ProbabilityTheory.FiniteSupport μ] : Hk[ProbabilityTheory.kernel.comap κ ⇑f ⋯ , MeasureTheory.Measure.comap (⇑f) μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_congr","declaration":"theorem ProbabilityTheory.kernel.entropy_congr {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] {μ : MeasureTheory.Measure T} {κ : ↥(ProbabilityTheory.kernel T S)} {η : ↥(ProbabilityTheory.kernel T S)} (h : ⇑κ =ᶠ[MeasureTheory.Measure.ae μ] ⇑η) : Hk[κ , μ] = Hk[η , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_map_swap","declaration":"theorem ProbabilityTheory.kernel.entropy_map_swap {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) (μ : MeasureTheory.Measure T) : Hk[ProbabilityTheory.kernel.map κ Prod.swap ⋯ , μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_compProd_deterministic","declaration":"theorem ProbabilityTheory.kernel.entropy_compProd_deterministic {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] (κ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsMarkovKernel κ] (μ : MeasureTheory.Measure T) [MeasureTheory.IsFiniteMeasure μ] (f : T × S → U) [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.compProd κ (ProbabilityTheory.kernel.deterministic f ⋯) , μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_snd_compProd_deterministic_of_injective","declaration":"theorem ProbabilityTheory.kernel.entropy_snd_compProd_deterministic_of_injective {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] (κ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsMarkovKernel κ] (μ : MeasureTheory.Measure T) {f : T × S → U} (hf : ∀ (t : T), Function.Injective fun x => f (t, x)) (hmes : Measurable f) : Hk[ProbabilityTheory.kernel.snd (ProbabilityTheory.kernel.compProd κ (ProbabilityTheory.kernel.deterministic f hmes)) ,\n    μ] =\n  Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_eq_integral_sum","declaration":"theorem ProbabilityTheory.kernel.entropy_eq_integral_sum {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (κ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsMarkovKernel κ] (μ : MeasureTheory.Measure T) : Hk[κ , μ] = ∫ (x : T), (fun y => ∑' (x : S), Real.negMulLog (↑↑(κ y) {x}).toReal) x ∂μ"}
