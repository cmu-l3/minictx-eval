{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.fst","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.fst {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSpace U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} {μ : MeasureTheory.Measure T} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.fst κ) μ"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.prodMkRight","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.prodMkRight {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {μ : MeasureTheory.Measure T} {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (ν : MeasureTheory.Measure U) [MeasureTheory.SFinite ν] : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.prodMkRight U κ)\n  (MeasureTheory.Measure.prod μ ν)"}
{"name":"MeasureTheory.Measure.ae_of_ae_compProd","declaration":"theorem MeasureTheory.Measure.ae_of_ae_compProd {α : Type u_5} {β : Type u_6} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {μ : MeasureTheory.Measure α} [MeasureTheory.SFinite μ] {κ : ↥(ProbabilityTheory.kernel α β)} [ProbabilityTheory.IsSFiniteKernel κ] {p : α × β → Prop} (hp : ∀ᵐ (x : α × β) ∂MeasureTheory.Measure.compProd μ κ, p x) : ∀ᵐ (a : α) ∂μ, ∀ᵐ (b : β) ∂κ a, p (a, b)"}
{"name":"ProbabilityTheory.kernel.condKernel_map_prod_mk_left","declaration":"theorem ProbabilityTheory.kernel.condKernel_map_prod_mk_left {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {V : Type u_5} [Nonempty V] [MeasurableSpace V] [DiscreteMeasurableSpace V] [Countable V] (κ : ↥(ProbabilityTheory.kernel T (S × U))) [ProbabilityTheory.IsMarkovKernel κ] (μ : MeasureTheory.Measure T) [MeasureTheory.IsFiniteMeasure μ] (f : S × U → V) : ⇑(ProbabilityTheory.kernel.condKernel\n      (ProbabilityTheory.kernel.map κ (fun p => (p.1, f p))\n        ⋯)) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.fst κ))]\n  ⇑(ProbabilityTheory.kernel.snd\n      (ProbabilityTheory.kernel.compProd (ProbabilityTheory.kernel.condKernel κ)\n        (ProbabilityTheory.kernel.deterministic (fun x => f (x.1.2, x.2)) ⋯)))"}
{"name":"ProbabilityTheory.kernel.condKernel_compProd_ae_eq","declaration":"theorem ProbabilityTheory.kernel.condKernel_compProd_ae_eq {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsFiniteKernel κ] (η : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel η] (μ : MeasureTheory.Measure T) [MeasureTheory.IsFiniteMeasure μ] : ⇑(ProbabilityTheory.kernel.condKernel\n      (ProbabilityTheory.kernel.compProd κ η)) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.compProd μ κ)]\n  ⇑η"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_prodMkLeft","declaration":"/-- prodMkLeft preserves finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_prodMkLeft {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.prodMkLeft U κ)"}
{"name":"ProbabilityTheory.condKernel_condDistrib_ae_eq","declaration":"theorem ProbabilityTheory.condKernel_condDistrib_ae_eq {Ω : Type u_1} {S : Type u_2} {T : Type u_3} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] : ⇑(ProbabilityTheory.kernel.condKernel\n      (ProbabilityTheory.condDistrib (fun a => (X a, Y a)) Z\n        μ)) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.map (fun ω => (Z ω, X ω)) μ)]\n  ⇑(ProbabilityTheory.condDistrib Y (fun ω => (Z ω, X ω)) μ)"}
{"name":"ProbabilityTheory.kernel.aefiniteKernelSupport_iff","declaration":"theorem ProbabilityTheory.kernel.aefiniteKernelSupport_iff {S : Type u_2} {T : Type u_3} [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] {κ : ↥(ProbabilityTheory.kernel T S)} {μ : MeasureTheory.Measure T} : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ ↔\n  ∃ κ', ProbabilityTheory.kernel.FiniteKernelSupport κ' ∧ ⇑κ' =ᶠ[MeasureTheory.Measure.ae μ] ⇑κ"}
{"name":"ProbabilityTheory.kernel.aefiniteKernelSupport_of_cond","declaration":"/-- Conditioning a kernel preserves finite kernel support. -/\ntheorem ProbabilityTheory.kernel.aefiniteKernelSupport_of_cond {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} [hU : Nonempty U] (μ : MeasureTheory.Measure T) [MeasureTheory.IsFiniteMeasure μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) [ProbabilityTheory.IsFiniteKernel κ] : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.condKernel κ)\n  (MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.fst κ))"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_fst","declaration":"/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_fst {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSpace U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.fst κ)"}
{"name":"ProbabilityTheory.kernel.condKernel_apply'","declaration":"theorem ProbabilityTheory.kernel.condKernel_apply' {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [MeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) [ProbabilityTheory.IsFiniteKernel κ] (x : T × S) (hx : ↑↑(κ x.1) (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) : ↑↑((ProbabilityTheory.kernel.condKernel κ) x) s = (↑↑(κ x.1) (Prod.fst ⁻¹' {x.2}))⁻¹ * ↑↑(κ x.1) ({x.2} ×ˢ s)"}
{"name":"MeasureTheory.Measure.compProd_apply_singleton","declaration":"theorem MeasureTheory.Measure.compProd_apply_singleton {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSingletonClass T] (μ : MeasureTheory.Measure T) [MeasureTheory.SFinite μ] (κ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsSFiniteKernel κ] (t : T) (s : S) : ↑↑(MeasureTheory.Measure.compProd μ κ) {(t, s)} = ↑↑(κ t) {s} * ↑↑μ {t}"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.compProd","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.compProd {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} {η : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.IsMarkovKernel η] {μ : MeasureTheory.Measure T} [MeasureTheory.SFinite μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η (MeasureTheory.Measure.compProd μ κ)) : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.compProd κ η) μ"}
{"name":"ProbabilityTheory.condDistrib_snd_ae_eq","declaration":"theorem ProbabilityTheory.condDistrib_snd_ae_eq {Ω : Type u_1} {S : Type u_2} {T : Type u_3} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] : ⇑(ProbabilityTheory.kernel.snd\n      (ProbabilityTheory.condDistrib (fun a => (X a, Y a)) Z\n        μ)) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.map Z μ)]\n  ⇑(ProbabilityTheory.condDistrib Y Z μ)"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.snd","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.snd {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} {μ : MeasureTheory.Measure T} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.snd κ) μ"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.finiteKernelSupport_mk","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.finiteKernelSupport_mk {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure T} [hS : Nonempty S] {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.AEFiniteKernelSupport.mk hκ)"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.map","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.map {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} {μ : MeasureTheory.Measure T} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.map κ f hf) μ"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_prodMkRight","declaration":"/-- prodMkRight preserves finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_prodMkRight {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.prodMkRight U κ)"}
{"name":"ProbabilityTheory.condDistrib_fst_ae_eq","declaration":"theorem ProbabilityTheory.condDistrib_fst_ae_eq {Ω : Type u_1} {S : Type u_2} {T : Type u_3} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] : ⇑(ProbabilityTheory.kernel.fst\n      (ProbabilityTheory.condDistrib (fun a => (X a, Y a)) Z\n        μ)) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.map Z μ)]\n  ⇑(ProbabilityTheory.condDistrib X Z μ)"}
{"name":"instStandardBorelSpace_discreteMeasurableSpace","declaration":"instance instStandardBorelSpace_discreteMeasurableSpace {α : Type u_1} [MeasurableSpace α] [DiscreteMeasurableSpace α] [Countable α] : StandardBorelSpace α"}
{"name":"ProbabilityTheory.condDistrib_snd_of_ne_zero","declaration":"theorem ProbabilityTheory.condDistrib_snd_of_ne_zero {Ω : Type u_1} {S : Type u_2} {T : Type u_3} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (u : U) (hu : ↑↑μ (Z ⁻¹' {u}) ≠ 0) : (ProbabilityTheory.kernel.snd (ProbabilityTheory.condDistrib (fun a => (X a, Y a)) Z μ)) u =\n  (ProbabilityTheory.condDistrib Y Z μ) u"}
{"name":"ProbabilityTheory.kernel.condKernel_compProd_apply","declaration":"theorem ProbabilityTheory.kernel.condKernel_compProd_apply {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [MeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsFiniteKernel κ] (η : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel η] (x : T × S) (hx : ↑↑(κ x.1) {x.2} ≠ 0) : (ProbabilityTheory.kernel.condKernel (ProbabilityTheory.kernel.compProd κ η)) x = η x"}
{"name":"ProbabilityTheory.condDistrib_unit_right","declaration":"theorem ProbabilityTheory.condDistrib_unit_right {Ω : Type u_1} {S : Type u_2} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] {X : Ω → S} (hX : Measurable X) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] : ProbabilityTheory.condDistrib X (fun x => ()) μ = ProbabilityTheory.kernel.const Unit (MeasureTheory.Measure.map X μ)"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.ae_eq_mk","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.ae_eq_mk {S : Type u_2} {T : Type u_3} [Nonempty S] [MeasurableSpace S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure T} {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : ⇑κ =ᶠ[MeasureTheory.Measure.ae μ] ⇑(ProbabilityTheory.kernel.AEFiniteKernelSupport.mk hκ)"}
{"name":"ProbabilityTheory.swap_condDistrib_ae_eq","declaration":"theorem ProbabilityTheory.swap_condDistrib_ae_eq {Ω : Type u_1} {S : Type u_2} {T : Type u_3} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] : ⇑(ProbabilityTheory.kernel.comap (ProbabilityTheory.condDistrib Y (fun a => (X a, Z a)) μ) Prod.swap\n      ⋯) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.map (fun ω => (Z ω, X ω)) μ)]\n  ⇑(ProbabilityTheory.condDistrib Y (fun ω => (Z ω, X ω)) μ)"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_deterministic","declaration":"/-- Deterministic kernels have finite kernel support.-/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_deterministic {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [MeasurableSpace U] [MeasurableSingletonClass U] (f : T × S → U) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.deterministic f ⋯)"}
{"name":"ProbabilityTheory.condDistrib_comp","declaration":"theorem ProbabilityTheory.condDistrib_comp {Ω : Type u_1} {S : Type u_2} {T : Type u_3} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (f : S → U) : ⇑(ProbabilityTheory.condDistrib (f ∘ X) Y μ) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.map Y μ)]\n  ⇑(ProbabilityTheory.kernel.map (ProbabilityTheory.condDistrib X Y μ) f ⋯)"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.comap_equiv","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.comap_equiv {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} {μ : MeasureTheory.Measure T} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.comap κ ⇑f ⋯)\n  (MeasureTheory.Measure.comap (⇑f) μ)"}
{"name":"ProbabilityTheory.condDistrib_fst_of_ne_zero","declaration":"theorem ProbabilityTheory.condDistrib_fst_of_ne_zero {Ω : Type u_1} {S : Type u_2} {T : Type u_3} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (u : U) (hu : ↑↑μ (Z ⁻¹' {u}) ≠ 0) : (ProbabilityTheory.kernel.fst (ProbabilityTheory.condDistrib (fun a => (X a, Y a)) Z μ)) u =\n  (ProbabilityTheory.condDistrib X Z μ) u"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.prod","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.prod {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] {κ : ↥(ProbabilityTheory.kernel T S)} {η : ↥(ProbabilityTheory.kernel T U)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.IsMarkovKernel η] {μ : MeasureTheory.Measure T} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η μ) : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.prod κ η) μ"}
{"name":"ProbabilityTheory.condDistrib_apply","declaration":"theorem ProbabilityTheory.condDistrib_apply {Ω : Type u_1} {S : Type u_2} {T : Type u_3} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [MeasurableSpace T] [DiscreteMeasurableSpace T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (x : T) (hYx : ↑↑μ (Y ⁻¹' {x}) ≠ 0) : (ProbabilityTheory.condDistrib X Y μ) x = MeasureTheory.Measure.map X (ProbabilityTheory.cond μ (Y ⁻¹' {x}))"}
{"name":"ProbabilityTheory.kernel.compProd_congr","declaration":"theorem ProbabilityTheory.kernel.compProd_congr {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] {μ : MeasureTheory.Measure T} [MeasureTheory.SFinite μ] {κ : ↥(ProbabilityTheory.kernel T S)} {κ' : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.IsMarkovKernel κ'] {η : ↥(ProbabilityTheory.kernel (T × S) U)} {η' : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel η] [ProbabilityTheory.IsMarkovKernel η'] (hκ : ⇑κ =ᶠ[MeasureTheory.Measure.ae μ] ⇑κ') (hη : ⇑η =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.compProd μ κ)] ⇑η') : ⇑(ProbabilityTheory.kernel.compProd κ η) =ᶠ[MeasureTheory.Measure.ae μ] ⇑(ProbabilityTheory.kernel.compProd κ' η')"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_finite_range","declaration":"/-- Finite range implies finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_finite_range {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] [Fintype S] (κ : ↥(ProbabilityTheory.kernel T S)) : ProbabilityTheory.kernel.FiniteKernelSupport κ"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.prodMkLeft","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.prodMkLeft {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {μ : MeasureTheory.Measure T} {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (ν : MeasureTheory.Measure U) [MeasureTheory.SFinite μ] : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.prodMkLeft U κ)\n  (MeasureTheory.Measure.prod ν μ)"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_snd","declaration":"/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_snd {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.snd κ)"}
{"name":"ProbabilityTheory.kernel.condKernel_compProd_apply'","declaration":"theorem ProbabilityTheory.kernel.condKernel_compProd_apply' {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [MeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsFiniteKernel κ] (η : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel η] (x : T × S) (hx : ↑↑(κ x.1) {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) : ↑↑((ProbabilityTheory.kernel.condKernel (ProbabilityTheory.kernel.compProd κ η)) x) s = ↑↑(η x) s"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_map","declaration":"/-- maps preserve finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_map {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) {f : S → U} (hf : Measurable f) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.map κ f hf)"}
{"name":"ProbabilityTheory.kernel.FiniteKernelSupport.aefiniteKernelSupport","declaration":"theorem ProbabilityTheory.kernel.FiniteKernelSupport.aefiniteKernelSupport {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) (μ : MeasureTheory.Measure T) : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ"}
{"name":"ProbabilityTheory.condDistrib_eq_prod_of_indepFun","declaration":"theorem ProbabilityTheory.condDistrib_eq_prod_of_indepFun {Ω : Type u_1} {S : Type u_2} {T : Type u_3} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} {V : Type u_5} [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V] {W : Ω → V} (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (h : ProbabilityTheory.IndepFun (fun ω => (X ω, Z ω)) (fun ω => (Y ω, W ω)) μ) : ⇑(ProbabilityTheory.condDistrib (fun ω => (X ω, Y ω)) (fun ω => (Z ω, W ω))\n      μ) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.map (fun ω => (Z ω, W ω)) μ)]\n  ⇑(ProbabilityTheory.kernel.prod (ProbabilityTheory.kernel.prodMkRight V (ProbabilityTheory.condDistrib X Z μ))\n      (ProbabilityTheory.kernel.prodMkLeft U (ProbabilityTheory.condDistrib Y W μ)))"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_swapRight","declaration":"/-- Swapping a kernel right preserves finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_swapRight {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.swapRight κ)"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.isMarkovKernel_mk","declaration":"instance ProbabilityTheory.kernel.AEFiniteKernelSupport.isMarkovKernel_mk {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure T} [hS : Nonempty S] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.kernel.AEFiniteKernelSupport.mk hκ)"}
{"name":"ProbabilityTheory.condDistrib_const_unit","declaration":"theorem ProbabilityTheory.condDistrib_const_unit {Ω : Type u_1} {S : Type u_2} {T : Type u_3} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] : ⇑(ProbabilityTheory.kernel.condKernel\n      (ProbabilityTheory.kernel.const Unit\n        (MeasureTheory.Measure.map (fun ω => (X ω, Y ω))\n          μ))) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.map (fun ω => ((), X ω)) μ)]\n  ⇑(ProbabilityTheory.kernel.prodMkLeft Unit (ProbabilityTheory.condDistrib Y X μ))"}
{"name":"ProbabilityTheory.condDistrib_apply'","declaration":"theorem ProbabilityTheory.condDistrib_apply' {Ω : Type u_1} {S : Type u_2} {T : Type u_3} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [MeasurableSpace T] [DiscreteMeasurableSpace T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (x : T) (hYx : ↑↑μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) : ↑↑((ProbabilityTheory.condDistrib X Y μ) x) s = (↑↑μ (Y ⁻¹' {x}))⁻¹ * ↑↑μ (Y ⁻¹' {x} ∩ X ⁻¹' s)"}
{"name":"ProbabilityTheory.kernel.condKernel_apply","declaration":"theorem ProbabilityTheory.kernel.condKernel_apply {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [MeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) [ProbabilityTheory.IsFiniteKernel κ] (x : T × S) (hx : ↑↑(κ x.1) (Prod.fst ⁻¹' {x.2}) ≠ 0) : (ProbabilityTheory.kernel.condKernel κ) x = (MeasureTheory.Measure.condKernel (κ x.1)) x.2"}
{"name":"ProbabilityTheory.map_compProd_condDistrib","declaration":"theorem ProbabilityTheory.map_compProd_condDistrib {Ω : Type u_1} {S : Type u_2} {U : Type u_4} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {X : Ω → S} {Z : Ω → U} (hX : Measurable X) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] : MeasureTheory.Measure.compProd (MeasureTheory.Measure.map Z μ) (ProbabilityTheory.condDistrib X Z μ) =\n  MeasureTheory.Measure.map (fun ω => (Z ω, X ω)) μ"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.swapRight","declaration":"theorem ProbabilityTheory.kernel.AEFiniteKernelSupport.swapRight {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} {μ : MeasureTheory.Measure T} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : ProbabilityTheory.kernel.AEFiniteKernelSupport (ProbabilityTheory.kernel.swapRight κ) μ"}
{"name":"ProbabilityTheory.condDistrib_ae_eq","declaration":"theorem ProbabilityTheory.condDistrib_ae_eq {Ω : Type u_1} {S : Type u_2} {T : Type u_3} [mΩ : MeasurableSpace Ω] [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [MeasurableSpace T] [DiscreteMeasurableSpace T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] : ⇑(ProbabilityTheory.condDistrib X Y μ) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.map Y μ)] fun x =>\n  MeasureTheory.Measure.map X (ProbabilityTheory.cond μ (Y ⁻¹' {x}))"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_prod","declaration":"/-- Products preserve finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_prod {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} {η : ↥(ProbabilityTheory.kernel T U)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.IsMarkovKernel η] (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) (hη : ProbabilityTheory.kernel.FiniteKernelSupport η) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.prod κ η)"}
{"name":"ProbabilityTheory.kernel.FiniteKernelSupport","declaration":"/-- The analogue of FiniteSupport for probability kernels. -/\ndef ProbabilityTheory.kernel.FiniteKernelSupport {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (κ : ↥(ProbabilityTheory.kernel T S)) : Prop"}
{"name":"MeasureTheory.Measure.ae_of_compProd_eq_zero","declaration":"theorem MeasureTheory.Measure.ae_of_compProd_eq_zero {α : Type u_5} {β : Type u_6} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {μ : MeasureTheory.Measure α} [MeasureTheory.SFinite μ] {κ : ↥(ProbabilityTheory.kernel α β)} [ProbabilityTheory.IsSFiniteKernel κ] {s : Set (α × β)} (hs : ↑↑(MeasureTheory.Measure.compProd μ κ) s = 0) : ∀ᵐ (a : α) ∂μ, ↑↑(κ a) (Prod.mk a ⁻¹' s) = 0"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport","declaration":"def ProbabilityTheory.kernel.AEFiniteKernelSupport {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (κ : ↥(ProbabilityTheory.kernel T S)) (μ : MeasureTheory.Measure T) : Prop"}
{"name":"MeasureTheory.lintegral_piecewise","declaration":"theorem MeasureTheory.lintegral_piecewise {α : Type u_1} {mα : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} (hs : MeasurableSet s) (f : α → ENNReal) (g : α → ENNReal) [(j : α) → Decidable (j ∈ s)] : ∫⁻ (a : α), Set.piecewise s f g a ∂μ = ∫⁻ (a : α) in s, f a ∂μ + ∫⁻ (a : α) in sᶜ, g a ∂μ"}
{"name":"ProbabilityTheory.kernel.disintegration","declaration":"theorem ProbabilityTheory.kernel.disintegration {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [MeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) [ProbabilityTheory.IsFiniteKernel κ] : κ = ProbabilityTheory.kernel.compProd (ProbabilityTheory.kernel.fst κ) (ProbabilityTheory.kernel.condKernel κ)"}
{"name":"ProbabilityTheory.kernel.condKernel_prod_ae_eq","declaration":"theorem ProbabilityTheory.kernel.condKernel_prod_ae_eq {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {μ : MeasureTheory.Measure T} (κ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsFiniteKernel κ] (η : ↥(ProbabilityTheory.kernel T U)) [ProbabilityTheory.IsMarkovKernel η] [MeasureTheory.IsFiniteMeasure μ] : ⇑(ProbabilityTheory.kernel.condKernel\n      (ProbabilityTheory.kernel.prod κ η)) =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.compProd μ κ)]\n  ⇑(ProbabilityTheory.kernel.prodMkRight S η)"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_comap","declaration":"/-- comaps preserve finite kernel support. -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_comap {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) {f : U → T} (hf : Measurable f) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.comap κ f hf)"}
{"name":"ProbabilityTheory.kernel.local_support_of_finiteKernelSupport","declaration":"/-- Finite kernel support locally implies uniform finite kernel support. -/\ntheorem ProbabilityTheory.kernel.local_support_of_finiteKernelSupport {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] {κ : ↥(ProbabilityTheory.kernel T S)} (h : ProbabilityTheory.kernel.FiniteKernelSupport κ) (A : Finset T) : ∃ B, ∀ t ∈ A, ↑↑(κ t) (↑B)ᶜ = 0"}
{"name":"ProbabilityTheory.kernel.ae_eq_condKernel_of_compProd_eq","declaration":"theorem ProbabilityTheory.kernel.ae_eq_condKernel_of_compProd_eq {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [DiscreteMeasurableSpace S] [Countable T] [MeasurableSpace T] [DiscreteMeasurableSpace T] [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U] {μ : MeasureTheory.Measure T} (κ : ↥(ProbabilityTheory.kernel T (S × U))) [ProbabilityTheory.IsFiniteKernel κ] (η : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel η] [MeasureTheory.IsFiniteMeasure μ] (h : ProbabilityTheory.kernel.compProd (ProbabilityTheory.kernel.fst κ) η = κ) : ⇑η =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.fst κ))]\n  ⇑(ProbabilityTheory.kernel.condKernel κ)"}
{"name":"ProbabilityTheory.kernel.finiteKernelSupport_of_compProd","declaration":"/-- Composition-product preserves finite kernel support -/\ntheorem ProbabilityTheory.kernel.finiteKernelSupport_of_compProd {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] {η : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel η] (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) (hη : ProbabilityTheory.kernel.FiniteKernelSupport η) : ProbabilityTheory.kernel.FiniteKernelSupport (ProbabilityTheory.kernel.compProd κ η)"}
{"name":"ProbabilityTheory.kernel.AEFiniteKernelSupport.mk","declaration":"def ProbabilityTheory.kernel.AEFiniteKernelSupport.mk {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure T} [hS : Nonempty S] {κ : ↥(ProbabilityTheory.kernel T S)} (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : ↥(ProbabilityTheory.kernel T S)"}
