{"name":"Mathlib.Tactic.RPowRing.elabRPowRingConv","declaration":"/-- Elaborator for the `rpow_ring` tactic. -/\ndef Mathlib.Tactic.RPowRing.elabRPowRingConv  : Lean.Elab.Tactic.Tactic"}
{"name":"Mathlib.Tactic.RPowRing.instInhabitedSigmaQuotedConstMkStr1NilLevelExProd","declaration":"instance Mathlib.Tactic.RPowRing.instInhabitedSigmaQuotedConstMkStr1NilLevelExProd  : Inhabited ((e : Q(ℝ)) × Mathlib.Tactic.RPowRing.ExProd e)"}
{"name":"Mathlib.Tactic.RPowRing.Context.ctx","declaration":"/-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\ndef Mathlib.Tactic.RPowRing.Context.ctx (self : Mathlib.Tactic.RPowRing.Context) : Lean.Meta.Simp.Context"}
{"name":"Mathlib.Tactic.RPowRing.atom_pow_pf'","declaration":"theorem Mathlib.Tactic.RPowRing.atom_pow_pf' {a : ℝ} {a' : ℝ} (p : a = a') : a = a ^ 1 * 1"}
{"name":"Mathlib.Tactic.RPowRing.M.run","declaration":"/-- Runs a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef Mathlib.Tactic.RPowRing.M.run {α : Type} (s : IO.Ref Mathlib.Tactic.AtomM.State) (cfg : Mathlib.Tactic.RPowRing.Config) (x : Mathlib.Tactic.RPowRing.M α) : Lean.MetaM α"}
{"name":"Mathlib.Tactic.RPowRing.pow_congr","declaration":"theorem Mathlib.Tactic.RPowRing.pow_congr {a : ℝ} {a' : ℝ} {b : ℝ} {c : ℝ} : a = a' → a' ^ b = c → a ^ b = c"}
{"name":"Mathlib.Tactic.RPowRing.Result","declaration":"def Mathlib.Tactic.RPowRing.Result (E : Q(ℝ) → Type) (e : Q(ℝ)) : Type"}
{"name":"Mathlib.Tactic.RPowRing.ExProd.one","declaration":"/-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\nIf `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\nctor Mathlib.Tactic.RPowRing.ExProd.one  : Mathlib.Tactic.RPowRing.ExProd q(1)"}
{"name":"Mathlib.Tactic.RPowRing.fix_cast₁","declaration":"theorem Mathlib.Tactic.RPowRing.fix_cast₁  : ↑(Int.ofNat 1) = 1"}
{"name":"Mathlib.Tactic.RPowRing.delab_ofNat","declaration":"def Mathlib.Tactic.RPowRing.delab_ofNat  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"Mathlib.Tactic.RPowRing.ExBase.pow","declaration":"/-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\nand `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\na polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\nctor Mathlib.Tactic.RPowRing.ExBase.pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < «$x»)) (e : Q(ℝ)) : Mathlib.Tactic.RPowRing.ExBase q(«$x» ^ «$e»)"}
{"name":"Mathlib.Tactic.RPowRing.evalPow","declaration":"def Mathlib.Tactic.RPowRing.evalPow {a : Q(ℝ)} (va : Mathlib.Tactic.RPowRing.ExProd a) (e : Q(ℝ)) : Option (Q(0 < «$a») × Mathlib.Tactic.RPowRing.Result Mathlib.Tactic.RPowRing.ExProd q(«$a» ^ «$e»))"}
{"name":"Mathlib.Tactic.RPowRing.atom_pf","declaration":"theorem Mathlib.Tactic.RPowRing.atom_pf (a : ℝ) : a = a * 1"}
{"name":"Mathlib.Tactic.RPowRing.Context","declaration":"/-- The read-only state of the `RPowRing` monad. -/\nstructure Mathlib.Tactic.RPowRing.Context  : Type"}
{"name":"Mathlib.Tactic.RPowRing.eval","declaration":"opaque Mathlib.Tactic.RPowRing.eval (e : Q(ℝ)) : Mathlib.Tactic.AtomM (Mathlib.Tactic.RPowRing.Result Mathlib.Tactic.RPowRing.ExProd e)"}
{"name":"Mathlib.Tactic.RPowRing.npow_congr","declaration":"theorem Mathlib.Tactic.RPowRing.npow_congr {a : ℝ} {a' : ℝ} {c : ℝ} {b : ℕ} : a = a' → a' ^ ↑b = c → Monoid.npow b a = c"}
{"name":"Mathlib.Tactic.RPowRing.evalMul","declaration":"/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\nopaque Mathlib.Tactic.RPowRing.evalMul {a : Q(ℝ)} {b : Q(ℝ)} (va : Mathlib.Tactic.RPowRing.ExProd a) (vb : Mathlib.Tactic.RPowRing.ExProd b) : Mathlib.Tactic.RPowRing.Result Mathlib.Tactic.RPowRing.ExProd q(«$a» * «$b»)"}
{"name":"Mathlib.Tactic.RPowRing.ExBase.atom","declaration":"/-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\nIf `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\nctor Mathlib.Tactic.RPowRing.ExBase.atom (id : ℕ) (x : Q(ℝ)) : Mathlib.Tactic.RPowRing.ExBase x"}
{"name":"Mathlib.Tactic.RPowRing.rpowRingTarget","declaration":"/-- Use `rpow_ring` to rewrite the main goal. -/\ndef Mathlib.Tactic.RPowRing.rpowRingTarget (s : IO.Ref Mathlib.Tactic.AtomM.State) (cfg : Mathlib.Tactic.RPowRing.Config) : Lean.Elab.Tactic.TacticM Unit"}
{"name":"Mathlib.Tactic.RPowRing.pow_pos","declaration":"theorem Mathlib.Tactic.RPowRing.pow_pos {a : ℝ} {b : ℝ} {e : ℝ} (ha : 0 < a) (hb : 0 < b) : 0 < a ^ e * b"}
{"name":"Real.inv_rpow'","declaration":"theorem Real.inv_rpow' {x : ℝ} (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y)"}
{"name":"Real.pow_neg","declaration":"theorem Real.pow_neg (a : ℝ) (b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b"}
{"name":"Mathlib.Tactic.RPowRing.instInhabitedConfig","declaration":"instance Mathlib.Tactic.RPowRing.instInhabitedConfig  : Inhabited Mathlib.Tactic.RPowRing.Config"}
{"name":"Mathlib.Tactic.RPowRing.rewrite","declaration":"def Mathlib.Tactic.RPowRing.rewrite (parent : Lean.Expr) (root : optParam Bool true) : Mathlib.Tactic.RPowRing.M Lean.Meta.Simp.Result"}
{"name":"Mathlib.Tactic.RPowRing.pow_pf","declaration":"theorem Mathlib.Tactic.RPowRing.pow_pf {a : ℝ} {b : ℝ} {e₂ : ℝ} {b' : ℝ} {e₁ : ℝ} (ha : 0 < a) (hb : 0 < b) : b ^ e₂ = b' → (a ^ e₁ * b) ^ e₂ = a ^ (e₁ * e₂) * b'"}
{"name":"Mathlib.Tactic.RPowRing.mul_pp_pf_overlap","declaration":"theorem Mathlib.Tactic.RPowRing.mul_pp_pf_overlap {x : ℝ} {a₂ : ℝ} {b₂ : ℝ} {c : ℝ} (ea : ℝ) (eb : ℝ) (h : 0 < x) : a₂ * b₂ = c → x ^ ea * a₂ * (x ^ eb * b₂) = x ^ (ea + eb) * c"}
{"name":"Mathlib.Tactic.RPowRing.M","declaration":"/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\ndef Mathlib.Tactic.RPowRing.M (α : Type) : Type"}
{"name":"Mathlib.Tactic.RPowRing.instInhabitedSigmaQuotedConstMkStr1NilLevelExBase","declaration":"instance Mathlib.Tactic.RPowRing.instInhabitedSigmaQuotedConstMkStr1NilLevelExBase  : Inhabited ((e : Q(ℝ)) × Mathlib.Tactic.RPowRing.ExBase e)"}
{"name":"Mathlib.Tactic.RPowRing.Context.simp","declaration":"/-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\nformat. -/\ndef Mathlib.Tactic.RPowRing.Context.simp (self : Mathlib.Tactic.RPowRing.Context) : Lean.Meta.Simp.Result → Lean.Meta.SimpM Lean.Meta.Simp.Result"}
{"name":"Mathlib.Tactic.RPowRing.fix_cast₃","declaration":"theorem Mathlib.Tactic.RPowRing.fix_cast₃ {n : ℕ} [Nat.AtLeastTwo n] : ↑n = n"}
{"name":"Mathlib.Tactic.RPowRing.atom_pf'","declaration":"theorem Mathlib.Tactic.RPowRing.atom_pf' {a : ℝ} {a' : ℝ} (p : a = a') : a = a * 1"}
{"name":"Mathlib.Tactic.RPowRing.evalAtom","declaration":"/-- Evaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef Mathlib.Tactic.RPowRing.evalAtom (e : Q(ℝ)) : Mathlib.Tactic.AtomM (Mathlib.Tactic.RPowRing.Result Mathlib.Tactic.RPowRing.ExProd e)"}
{"name":"Real.rpow_inv","declaration":"theorem Real.rpow_inv {x : ℝ} (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y)"}
{"name":"Mathlib.Tactic.RPowRing.ExBase.id","declaration":"def Mathlib.Tactic.RPowRing.ExBase.id {e : Q(ℝ)} : Mathlib.Tactic.RPowRing.ExBase e → ℕ"}
{"name":"Mathlib.Tactic.RPowRing.tacticRpow_simp__","declaration":"def Mathlib.Tactic.RPowRing.tacticRpow_simp__  : Lean.ParserDescr"}
{"name":"Mathlib.Tactic.RPowRing.mul_pf_right","declaration":"theorem Mathlib.Tactic.RPowRing.mul_pf_right {a : ℝ} {b₂ : ℝ} {c : ℝ} (b₁ : ℝ) : a * b₂ = c → a * (b₁ * b₂) = b₁ * c"}
{"name":"Mathlib.Tactic.RPowRing.ExBase","declaration":"/-- A monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive Mathlib.Tactic.RPowRing.ExBase (e : Q(ℝ)) : Type"}
{"name":"Mathlib.Tactic.RPowRing.elabConfig","declaration":"/-- Function elaborating `RingNF.Config`. -/\ndef Mathlib.Tactic.RPowRing.elabConfig  : Lean.Syntax → Lean.Elab.TermElabM Mathlib.Tactic.RPowRing.Config"}
{"name":"Mathlib.Tactic.RPowRing.Context.mk","declaration":"ctor Mathlib.Tactic.RPowRing.Context.mk (ctx : Lean.Meta.Simp.Context) (simp : Lean.Meta.Simp.Result → Lean.Meta.SimpM Lean.Meta.Simp.Result) : Mathlib.Tactic.RPowRing.Context"}
{"name":"Mathlib.Tactic.RPowRing.inv_congr","declaration":"theorem Mathlib.Tactic.RPowRing.inv_congr {a : ℝ} {a' : ℝ} {b : ℝ} : a = a' → a' ^ (-1) = b → a⁻¹ = b"}
{"name":"Mathlib.Tactic.RPowRing.rpowRing","declaration":"/-- Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\ndef Mathlib.Tactic.RPowRing.rpowRing  : Lean.ParserDescr"}
{"name":"Mathlib.Tactic.RPowRing.tacticRpow_ring!__","declaration":"/-- Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\ndef Mathlib.Tactic.RPowRing.tacticRpow_ring!__  : Lean.ParserDescr"}
{"name":"Mathlib.Tactic.RPowRing.Config.mk","declaration":"ctor Mathlib.Tactic.RPowRing.Config.mk (red : Lean.Meta.TransparencyMode) : Mathlib.Tactic.RPowRing.Config"}
{"name":"Mathlib.Tactic.RPowRing.ExProd.mul","declaration":"/-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\nand `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\na polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\nctor Mathlib.Tactic.RPowRing.ExProd.mul {x : Q(ℝ)} {b : Q(ℝ)} : Mathlib.Tactic.RPowRing.ExBase x → Mathlib.Tactic.RPowRing.ExProd b → Mathlib.Tactic.RPowRing.ExProd q(«$x» * «$b»)"}
{"name":"Mathlib.Tactic.RPowRing.ExProd","declaration":"/-- A monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive Mathlib.Tactic.RPowRing.ExProd (e : Q(ℝ)) : Type"}
{"name":"Mathlib.Tactic.RPowRing.Config","declaration":"/-- Configuration for `ring_nf`. -/\nstructure Mathlib.Tactic.RPowRing.Config  : Type"}
{"name":"Mathlib.Tactic.RPowRing.rpowRingLocalDecl","declaration":"/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef Mathlib.Tactic.RPowRing.rpowRingLocalDecl (s : IO.Ref Mathlib.Tactic.AtomM.State) (cfg : Mathlib.Tactic.RPowRing.Config) (fvarId : Lean.FVarId) : Lean.Elab.Tactic.TacticM Unit"}
{"name":"Mathlib.Tactic.RPowRing.instReprConfig","declaration":"instance Mathlib.Tactic.RPowRing.instReprConfig  : Repr Mathlib.Tactic.RPowRing.Config"}
{"name":"Mathlib.Tactic.RPowRing.Config.red","declaration":"/-- the reducibility setting to use when comparing atoms for defeq -/\ndef Mathlib.Tactic.RPowRing.Config.red (self : Mathlib.Tactic.RPowRing.Config) : Lean.Meta.TransparencyMode"}
{"name":"Mathlib.Tactic.RPowRing.fix_cast₂","declaration":"theorem Mathlib.Tactic.RPowRing.fix_cast₂ {n : ℕ} : ↑(Int.ofNat n) = ↑n"}
{"name":"Mathlib.Tactic.RPowRing.ExBase.toProd","declaration":"/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef Mathlib.Tactic.RPowRing.ExBase.toProd {a : Q(ℝ)} (va : Mathlib.Tactic.RPowRing.ExBase a) : Mathlib.Tactic.RPowRing.ExProd q(«$a» * 1)"}
{"name":"Mathlib.Tactic.RPowRing.instBEqConfig","declaration":"instance Mathlib.Tactic.RPowRing.instBEqConfig  : BEq Mathlib.Tactic.RPowRing.Config"}
{"name":"Mathlib.Tactic.RPowRing.mul_pf_left","declaration":"theorem Mathlib.Tactic.RPowRing.mul_pf_left {a₂ : ℝ} {b : ℝ} {c : ℝ} (a₁ : ℝ) : a₂ * b = c → a₁ * a₂ * b = a₁ * c"}
{"name":"Mathlib.Tactic.RPowRing.rpowRingConv","declaration":"/-- Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\ndef Mathlib.Tactic.RPowRing.rpowRingConv  : Lean.ParserDescr"}
{"name":"Mathlib.Tactic.RPowRing.atom_pow_pf","declaration":"theorem Mathlib.Tactic.RPowRing.atom_pow_pf (a : ℝ) : a = a ^ 1 * 1"}
