{"name":"ProbabilityTheory.kernel.compProd_assoc","declaration":"theorem ProbabilityTheory.kernel.compProd_assoc {V : Type u_5} {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSpace V] (ξ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsMarkovKernel ξ] (κ : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel κ] (η : ↥(ProbabilityTheory.kernel (T × S × U) V)) [ProbabilityTheory.IsMarkovKernel η] : ProbabilityTheory.kernel.map (ProbabilityTheory.kernel.compProd (ProbabilityTheory.kernel.compProd ξ κ) η)\n    ⇑MeasurableEquiv.prodAssoc ⋯ =\n  ProbabilityTheory.kernel.compProd ξ\n    (ProbabilityTheory.kernel.compProd κ (ProbabilityTheory.kernel.comap η ⇑MeasurableEquiv.prodAssoc ⋯))"}
{"name":"ProbabilityTheory.kernel.entropy_triple_add_entropy_le'","declaration":"/-- The submodularity inequality:\n$$ H[X,Y,Z] + H[X] \\leq H[X,Z] + H[X,Y].$$ -/\ntheorem ProbabilityTheory.kernel.entropy_triple_add_entropy_le' {V : Type u_5} {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V] {κ : ↥(ProbabilityTheory.kernel T (S × U × V))} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[κ , μ] + Hk[ProbabilityTheory.kernel.fst κ , μ] ≤\n  Hk[ProbabilityTheory.kernel.deleteMiddle κ , μ] + Hk[ProbabilityTheory.kernel.deleteRight κ , μ]"}
{"name":"ProbabilityTheory.kernel.Measure.compProd_compProd''","declaration":"theorem ProbabilityTheory.kernel.Measure.compProd_compProd'' {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] (ξ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsMarkovKernel ξ] (κ : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel κ] : MeasureTheory.Measure.compProd (MeasureTheory.Measure.compProd μ ξ) κ =\n  MeasureTheory.Measure.comap (⇑MeasurableEquiv.prodAssoc)\n    (MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.compProd ξ κ))"}
{"name":"ProbabilityTheory.kernel.entropy_condKernel_compProd_triple","declaration":"theorem ProbabilityTheory.kernel.entropy_condKernel_compProd_triple {V : Type u_5} {S : Type u_2} {T : Type u_3} {U : Type u_4} [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V] (ξ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsMarkovKernel ξ] (κ : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel κ] (η : ↥(ProbabilityTheory.kernel (T × S × U) V)) [ProbabilityTheory.IsMarkovKernel η] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] : Hk[ProbabilityTheory.kernel.condKernel (ProbabilityTheory.kernel.compProd (ProbabilityTheory.kernel.compProd ξ κ) η) ,\n    MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.compProd ξ κ)] =\n  Hk[η , MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.compProd ξ κ)]"}
{"name":"ProbabilityTheory.kernel.«termIk[_,_]»","declaration":"/-- Mutual information of a kernel into a product space with respect to a measure. -/\ndef ProbabilityTheory.kernel.«termIk[_,_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.kernel.mutualInfo_nonneg","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_nonneg {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} {μ : MeasureTheory.Measure T} [MeasureTheory.IsFiniteMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : 0 ≤ Ik[κ , μ]"}
{"name":"ProbabilityTheory.kernel.mutualInfo_eq_fst_sub","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_eq_fst_sub {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Ik[κ , μ] =\n  Hk[ProbabilityTheory.kernel.fst κ , μ] -\n    Hk[ProbabilityTheory.kernel.condKernel (ProbabilityTheory.kernel.swapRight κ) ,\n      MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.snd κ)]"}
{"name":"ProbabilityTheory.kernel.entropy_reverse","declaration":"theorem ProbabilityTheory.kernel.entropy_reverse {V : Type u_5} {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V] {κ : ↥(ProbabilityTheory.kernel T (S × U × V))} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.reverse κ , μ] = Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.mutualInfo_nonneg'","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_nonneg' {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSingletonClass T] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} {μ : MeasureTheory.Measure T} [MeasureTheory.IsFiniteMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.FiniteKernelSupport κ) : 0 ≤ Ik[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_compProd_triple_add_entropy_le","declaration":"theorem ProbabilityTheory.kernel.entropy_compProd_triple_add_entropy_le {V : Type u_5} {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V] {ξ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel ξ] {κ : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel κ] {η : ↥(ProbabilityTheory.kernel (T × S × U) V)} [ProbabilityTheory.IsMarkovKernel η] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ (MeasureTheory.Measure.compProd μ ξ)) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η\n  (MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.compProd ξ κ))) (hξ : ProbabilityTheory.kernel.AEFiniteKernelSupport ξ μ) : Hk[ProbabilityTheory.kernel.compProd (ProbabilityTheory.kernel.compProd ξ κ) η , μ] + Hk[ξ , μ] ≤\n  Hk[ProbabilityTheory.kernel.compProd ξ\n        (ProbabilityTheory.kernel.snd\n          (ProbabilityTheory.kernel.compProd κ (ProbabilityTheory.kernel.comap η ⇑MeasurableEquiv.prodAssoc ⋯))) ,\n      μ] +\n    Hk[ProbabilityTheory.kernel.compProd ξ κ , μ]"}
{"name":"ProbabilityTheory.kernel.mutualInfo_prod","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_prod {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} {η : ↥(ProbabilityTheory.kernel T U)} [ProbabilityTheory.IsMarkovKernel κ] [ProbabilityTheory.IsMarkovKernel η] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η μ) : Ik[ProbabilityTheory.kernel.prod κ η , μ] = 0"}
{"name":"ProbabilityTheory.kernel.mutualInfo_swapRight","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_swapRight {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) (μ : MeasureTheory.Measure T) : Ik[ProbabilityTheory.kernel.swapRight κ , μ] = Ik[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_condKernel_le_entropy_snd","declaration":"theorem ProbabilityTheory.kernel.entropy_condKernel_le_entropy_snd {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.condKernel κ , MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.fst κ)] ≤\n  Hk[ProbabilityTheory.kernel.snd κ , μ]"}
{"name":"ProbabilityTheory.kernel.mutualInfo_zero_measure","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_zero_measure {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) : Ik[κ , 0] = 0"}
{"name":"ProbabilityTheory.kernel.mutualInfo_def","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_def {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) (μ : MeasureTheory.Measure T) : Ik[κ , μ] = Hk[ProbabilityTheory.kernel.fst κ , μ] + Hk[ProbabilityTheory.kernel.snd κ , μ] - Hk[κ , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_snd_sub_mutualInfo_le_entropy_map_of_injective","declaration":"theorem ProbabilityTheory.kernel.entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {V : Type u_5} [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V] (κ : ↥(ProbabilityTheory.kernel T (S × U))) [ProbabilityTheory.IsMarkovKernel κ] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] (f : S × U → V) (hfi : ∀ (x : S), Function.Injective fun y => f (x, y)) [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.snd κ , μ] - Ik[κ , μ] ≤ Hk[ProbabilityTheory.kernel.map κ f ⋯ , μ]"}
{"name":"ProbabilityTheory.kernel.Measure.compProd_compProd'","declaration":"theorem ProbabilityTheory.kernel.Measure.compProd_compProd' {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] (ξ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsMarkovKernel ξ] (κ : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel κ] : MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.compProd ξ κ) =\n  MeasureTheory.Measure.comap (⇑MeasurableEquiv.prodAssoc.symm)\n    (MeasureTheory.Measure.compProd (MeasureTheory.Measure.compProd μ ξ) κ)"}
{"name":"ProbabilityTheory.kernel.mutualInfo_congr","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_congr {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} {η : ↥(ProbabilityTheory.kernel T (S × U))} {μ : MeasureTheory.Measure T} (h : ⇑κ =ᶠ[MeasureTheory.Measure.ae μ] ⇑η) : Ik[κ , μ] = Ik[η , μ]"}
{"name":"ProbabilityTheory.kernel.entropy_triple_add_entropy_le","declaration":"/-- The submodularity inequality:\n$$ H[X,Y,Z] + H[Z] \\leq H[X,Z] + H[Y,Z].$$ -/\ntheorem ProbabilityTheory.kernel.entropy_triple_add_entropy_le {V : Type u_5} {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V] (κ : ↥(ProbabilityTheory.kernel T (S × U × V))) [ProbabilityTheory.IsMarkovKernel κ] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[κ , μ] + Hk[ProbabilityTheory.kernel.snd (ProbabilityTheory.kernel.snd κ) , μ] ≤\n  Hk[ProbabilityTheory.kernel.deleteMiddle κ , μ] + Hk[ProbabilityTheory.kernel.snd κ , μ]"}
{"name":"ProbabilityTheory.kernel.«termIk[_,_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.kernel.«termIk[_,_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.kernel.mutualInfo_compProd","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_compProd {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel κ] {η : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel η] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η (MeasureTheory.Measure.compProd μ κ)) : Ik[ProbabilityTheory.kernel.compProd κ η , μ] =\n  Hk[κ , μ] + Hk[ProbabilityTheory.kernel.snd (ProbabilityTheory.kernel.compProd κ η) , μ] -\n    Hk[ProbabilityTheory.kernel.compProd κ η , μ]"}
{"name":"ProbabilityTheory.kernel.mutualInfo_eq_snd_sub","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_eq_snd_sub {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] {κ : ↥(ProbabilityTheory.kernel T (S × U))} [ProbabilityTheory.IsMarkovKernel κ] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Ik[κ , μ] =\n  Hk[ProbabilityTheory.kernel.snd κ , μ] -\n    Hk[ProbabilityTheory.kernel.condKernel κ , MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.fst κ)]"}
{"name":"ProbabilityTheory.kernel.Measure.compProd_compProd","declaration":"theorem ProbabilityTheory.kernel.Measure.compProd_compProd {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] (ξ : ↥(ProbabilityTheory.kernel T S)) [ProbabilityTheory.IsMarkovKernel ξ] (κ : ↥(ProbabilityTheory.kernel (T × S) U)) [ProbabilityTheory.IsMarkovKernel κ] : MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.compProd ξ κ) =\n  MeasureTheory.Measure.map (⇑MeasurableEquiv.prodAssoc)\n    (MeasureTheory.Measure.compProd (MeasureTheory.Measure.compProd μ ξ) κ)"}
{"name":"ProbabilityTheory.kernel.entropy_condKernel_le_entropy_fst","declaration":"theorem ProbabilityTheory.kernel.entropy_condKernel_le_entropy_fst {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) [ProbabilityTheory.IsMarkovKernel κ] (μ : MeasureTheory.Measure T) [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ μ) : Hk[ProbabilityTheory.kernel.condKernel (ProbabilityTheory.kernel.swapRight κ) ,\n    MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.snd κ)] ≤\n  Hk[ProbabilityTheory.kernel.fst κ , μ]"}
{"name":"ProbabilityTheory.kernel.mutualInfo_zero_kernel","declaration":"theorem ProbabilityTheory.kernel.mutualInfo_zero_kernel {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (μ : MeasureTheory.Measure T) : Ik[0 , μ] = 0"}
{"name":"ProbabilityTheory.kernel.mutualInfo","declaration":"/-- Mutual information of a kernel into a product space with respect to a measure. -/\ndef ProbabilityTheory.kernel.mutualInfo {S : Type u_2} {T : Type u_3} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (κ : ↥(ProbabilityTheory.kernel T (S × U))) (μ : MeasureTheory.Measure T) : ℝ"}
{"name":"ProbabilityTheory.kernel.entropy_submodular_compProd","declaration":"theorem ProbabilityTheory.kernel.entropy_submodular_compProd {V : Type u_5} {S : Type u_2} {T : Type u_3} {U : Type u_4} [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T] [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U] [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V] {ξ : ↥(ProbabilityTheory.kernel T S)} [ProbabilityTheory.IsMarkovKernel ξ] {κ : ↥(ProbabilityTheory.kernel (T × S) U)} [ProbabilityTheory.IsMarkovKernel κ] {η : ↥(ProbabilityTheory.kernel (T × S × U) V)} [ProbabilityTheory.IsMarkovKernel η] {μ : MeasureTheory.Measure T} [MeasureTheory.IsProbabilityMeasure μ] [ProbabilityTheory.FiniteSupport μ] (hκ : ProbabilityTheory.kernel.AEFiniteKernelSupport κ (MeasureTheory.Measure.compProd μ ξ)) (hη : ProbabilityTheory.kernel.AEFiniteKernelSupport η\n  (MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.compProd ξ κ))) (hξ : ProbabilityTheory.kernel.AEFiniteKernelSupport ξ μ) : Hk[η , MeasureTheory.Measure.compProd μ (ProbabilityTheory.kernel.compProd ξ κ)] ≤\n  Hk[ProbabilityTheory.kernel.snd\n      (ProbabilityTheory.kernel.compProd κ (ProbabilityTheory.kernel.comap η ⇑MeasurableEquiv.prodAssoc ⋯)) ,\n    MeasureTheory.Measure.compProd μ ξ]"}
