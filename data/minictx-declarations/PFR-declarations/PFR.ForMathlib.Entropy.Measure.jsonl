{"name":"ProbabilityTheory.measureEntropy_nonneg","declaration":"theorem ProbabilityTheory.measureEntropy_nonneg {S : Type u_2} [MeasurableSpace S] (μ : MeasureTheory.Measure S) : 0 ≤ Hm[μ]"}
{"name":"ProbabilityTheory.measureEntropy_of_isProbabilityMeasure_finite","declaration":"theorem ProbabilityTheory.measureEntropy_of_isProbabilityMeasure_finite {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} {A : Finset S} (hA : ↑↑μ (↑A)ᶜ = 0) [MeasureTheory.IsProbabilityMeasure μ] : Hm[μ] = Finset.sum A fun s => Real.negMulLog (↑↑μ {s}).toReal"}
{"name":"ProbabilityTheory.finiteSupport_zero","declaration":"instance ProbabilityTheory.finiteSupport_zero {S : Type u_2} [MeasurableSpace S] : ProbabilityTheory.FiniteSupport 0"}
{"name":"ProbabilityTheory.«termHm[_]»","declaration":"/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\ndef ProbabilityTheory.«termHm[_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.finiteSupport_of_prod","declaration":"instance ProbabilityTheory.finiteSupport_of_prod {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] {μ : MeasureTheory.Measure S} [ProbabilityTheory.FiniteSupport μ] {ν : MeasureTheory.Measure T} [MeasureTheory.SigmaFinite ν] [ProbabilityTheory.FiniteSupport ν] : ProbabilityTheory.FiniteSupport (MeasureTheory.Measure.prod μ ν)"}
{"name":"ProbabilityTheory.measureEntropy","declaration":"/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\ndef ProbabilityTheory.measureEntropy {S : Type u_2} [MeasurableSpace S] (μ : autoParam (MeasureTheory.Measure S) _auto✝) : ℝ"}
{"name":"ProbabilityTheory.integrable_of_finiteSupport","declaration":"/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\ntheorem ProbabilityTheory.integrable_of_finiteSupport {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] (μ : MeasureTheory.Measure S) [ProbabilityTheory.FiniteSupport μ] {β : Type u_5} [NormedAddCommGroup β] [MeasureTheory.IsFiniteMeasure μ] [Countable S] {f : S → β} : MeasureTheory.Integrable f μ"}
{"name":"ProbabilityTheory.measureEntropy_zero","declaration":"theorem ProbabilityTheory.measureEntropy_zero {S : Type u_2} [MeasurableSpace S] : Hm[0] = 0"}
{"name":"ProbabilityTheory.measureEntropy_prod","declaration":"/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\ntheorem ProbabilityTheory.measureEntropy_prod {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure S} {ν : MeasureTheory.Measure T} [ProbabilityTheory.FiniteSupport μ] [ProbabilityTheory.FiniteSupport ν] [MeasureTheory.IsProbabilityMeasure μ] [MeasureTheory.IsProbabilityMeasure ν] : Hm[MeasureTheory.Measure.prod μ ν] = Hm[μ] + Hm[ν]"}
{"name":"ProbabilityTheory.FiniteSupport","declaration":"/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass ProbabilityTheory.FiniteSupport {S : Type u_2} [MeasurableSpace S] (μ : autoParam (MeasureTheory.Measure S) _auto✝) : Prop"}
{"name":"ProbabilityTheory.«termIm[_]»","declaration":"/-- The mutual information between the marginals of a measure on a product space. -/\ndef ProbabilityTheory.«termIm[_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.finiteSupport_of_mul","declaration":"instance ProbabilityTheory.finiteSupport_of_mul {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} [ProbabilityTheory.FiniteSupport μ] (c : ENNReal) : ProbabilityTheory.FiniteSupport (c • μ)"}
{"name":"ProbabilityTheory.measureMutualInfo_swap","declaration":"theorem ProbabilityTheory.measureMutualInfo_swap {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSingletonClass T] (μ : MeasureTheory.Measure (S × T)) : Im[MeasureTheory.Measure.map Prod.swap μ] = Im[μ]"}
{"name":"ProbabilityTheory.full_measure_of_finiteRange","declaration":"/-- duplicate of `FiniteRange.null_of_compl` -/\ntheorem ProbabilityTheory.full_measure_of_finiteRange {Ω : Type u_1} {S : Type u_2} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] {μ : MeasureTheory.Measure Ω} {X : Ω → S} (hX : Measurable X) [hX' : FiniteRange X] : ↑↑(MeasureTheory.Measure.map X μ) (↑(FiniteRange.toFinset X))ᶜ = 0"}
{"name":"ProbabilityTheory.finiteSupport_of_finiteRange","declaration":"instance ProbabilityTheory.finiteSupport_of_finiteRange {Ω : Type u_1} {S : Type u_2} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] {μ : MeasureTheory.Measure Ω} {X : Ω → S} [hX' : FiniteRange X] : ProbabilityTheory.FiniteSupport (MeasureTheory.Measure.map X μ)"}
{"name":"ProbabilityTheory.FiniteSupport.finite","declaration":"def ProbabilityTheory.FiniteSupport.finite {S : Type u_2} [MeasurableSpace S] {μ : autoParam (MeasureTheory.Measure S) _auto✝} [self : ProbabilityTheory.FiniteSupport μ] : ∃ A, ↑↑μ (↑A)ᶜ = 0"}
{"name":"ProbabilityTheory.measureEntropy_univ_smul","declaration":"theorem ProbabilityTheory.measureEntropy_univ_smul {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} : Hm[(↑↑μ Set.univ)⁻¹ • μ] = Hm[μ]"}
{"name":"ProbabilityTheory.measureMutualInfo_univ_smul","declaration":"theorem ProbabilityTheory.measureMutualInfo_univ_smul {S : Type u_2} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace U] (μ : MeasureTheory.Measure (S × U)) : Im[(↑↑μ Set.univ)⁻¹ • μ] = Im[μ]"}
{"name":"ProbabilityTheory.FiniteEntropy","declaration":"/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\ndef ProbabilityTheory.FiniteEntropy {S : Type u_2} [MeasurableSpace S] (μ : autoParam (MeasureTheory.Measure S) _auto✝) : Prop"}
{"name":"ProbabilityTheory.measureEntropy_of_isProbabilityMeasure","declaration":"theorem ProbabilityTheory.measureEntropy_of_isProbabilityMeasure {S : Type u_2} [MeasurableSpace S] (μ : MeasureTheory.Measure S) [MeasureTheory.IsProbabilityMeasure μ] : Hm[μ] = ∑' (s : S), Real.negMulLog (↑↑μ {s}).toReal"}
{"name":"ProbabilityTheory.measureMutualInfo_eq_zero_iff","declaration":"theorem ProbabilityTheory.measureMutualInfo_eq_zero_iff {S : Type u_2} {U : Type u_4} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace U] [MeasurableSingletonClass U] {μ : MeasureTheory.Measure (S × U)} [ProbabilityTheory.FiniteSupport μ] [MeasureTheory.IsProbabilityMeasure μ] : Im[μ] = 0 ↔\n  ∀ (p : S × U),\n    μ.real {p} = (MeasureTheory.Measure.map Prod.fst μ).real {p.1} * (MeasureTheory.Measure.map Prod.snd μ).real {p.2}"}
{"name":"ProbabilityTheory.measureEntropy_le_log_card_of_mem","declaration":"theorem ProbabilityTheory.measureEntropy_le_log_card_of_mem {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] {A : Finset S} (μ : MeasureTheory.Measure S) (hμA : ↑↑μ (↑A)ᶜ = 0) : Hm[μ] ≤ Real.log ↑(Nat.card { x // x ∈ A })"}
{"name":"ProbabilityTheory.measureMutualInfo_prod","declaration":"theorem ProbabilityTheory.measureMutualInfo_prod {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace T] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure S} {ν : MeasureTheory.Measure T} [ProbabilityTheory.FiniteSupport μ] [ProbabilityTheory.FiniteSupport ν] [MeasureTheory.IsProbabilityMeasure μ] [MeasureTheory.IsProbabilityMeasure ν] : Im[MeasureTheory.Measure.prod μ ν] = 0"}
{"name":"MeasureTheory.Measure.support","declaration":"def MeasureTheory.Measure.support {S : Type u_2} [MeasurableSpace S] (μ : MeasureTheory.Measure S) [hμ : ProbabilityTheory.FiniteSupport μ] : Finset S"}
{"name":"ProbabilityTheory.finiteSupport_of_dirac","declaration":"instance ProbabilityTheory.finiteSupport_of_dirac {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] (x : S) : ProbabilityTheory.FiniteSupport (MeasureTheory.Measure.dirac x)"}
{"name":"ProbabilityTheory.measureEntropy_of_isProbabilityMeasure_finite'","declaration":"theorem ProbabilityTheory.measureEntropy_of_isProbabilityMeasure_finite' {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} {A : Finset S} (hA : ↑↑μ (↑A)ᶜ = 0) [MeasureTheory.IsProbabilityMeasure μ] : Hm[μ] = Finset.sum A fun s => Real.negMulLog (μ.real {s})"}
{"name":"ProbabilityTheory.measureEntropy_eq_card_iff_measure_eq_aux","declaration":"theorem ProbabilityTheory.measureEntropy_eq_card_iff_measure_eq_aux {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] (μ : MeasureTheory.Measure S) [Fintype S] [MeasureTheory.IsProbabilityMeasure μ] : Hm[μ] = Real.log ↑(Fintype.card S) ↔ ∀ (s : S), ↑↑μ {s} = ↑(↑(Fintype.card S))⁻¹"}
{"name":"ProbabilityTheory.FiniteSupport.mk","declaration":"ctor ProbabilityTheory.FiniteSupport.mk {S : Type u_2} [MeasurableSpace S] {μ : autoParam (MeasureTheory.Measure S) _auto✝} (finite : ∃ A, ↑↑μ (↑A)ᶜ = 0) : ProbabilityTheory.FiniteSupport μ"}
{"name":"ProbabilityTheory.measureEntropy_le_card_aux","declaration":"theorem ProbabilityTheory.measureEntropy_le_card_aux {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] {μ : MeasureTheory.Measure S} [MeasureTheory.IsProbabilityMeasure μ] (A : Finset S) (hμ : ↑↑μ (↑A)ᶜ = 0) : Hm[μ] ≤ Real.log ↑A.card"}
{"name":"ProbabilityTheory.measureEntropy_of_not_isFiniteMeasure","declaration":"theorem ProbabilityTheory.measureEntropy_of_not_isFiniteMeasure {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} (h : ¬MeasureTheory.IsFiniteMeasure μ) : Hm[μ] = 0"}
{"name":"ProbabilityTheory.Measure.ext_iff_measureReal_singleton_finiteSupport","declaration":"theorem ProbabilityTheory.Measure.ext_iff_measureReal_singleton_finiteSupport {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] {μ1 : MeasureTheory.Measure S} {μ2 : MeasureTheory.Measure S} [ProbabilityTheory.FiniteSupport μ1] [ProbabilityTheory.FiniteSupport μ2] [MeasureTheory.IsFiniteMeasure μ1] [MeasureTheory.IsFiniteMeasure μ2] : μ1 = μ2 ↔ ∀ (x : S), μ1.real {x} = μ2.real {x}"}
{"name":"ProbabilityTheory.finiteSupport_of_fintype","declaration":"instance ProbabilityTheory.finiteSupport_of_fintype {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} [Fintype S] : ProbabilityTheory.FiniteSupport μ"}
{"name":"ProbabilityTheory.measureMutualInfo_def","declaration":"theorem ProbabilityTheory.measureMutualInfo_def {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (μ : MeasureTheory.Measure (S × T)) : Im[μ] = Hm[MeasureTheory.Measure.map Prod.fst μ] + Hm[MeasureTheory.Measure.map Prod.snd μ] - Hm[μ]"}
{"name":"ProbabilityTheory.measureMutualInfo","declaration":"/-- The mutual information between the marginals of a measure on a product space. -/\ndef ProbabilityTheory.measureMutualInfo {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] (μ : autoParam (MeasureTheory.Measure (S × T)) _auto✝) : ℝ"}
{"name":"ProbabilityTheory.measureEntropy_def","declaration":"theorem ProbabilityTheory.measureEntropy_def {S : Type u_2} [MeasurableSpace S] (μ : MeasureTheory.Measure S) : Hm[μ] = ∑' (s : S), Real.negMulLog (↑↑((↑↑μ Set.univ)⁻¹ • μ) {s}).toReal"}
{"name":"ProbabilityTheory.measure_compl_support","declaration":"theorem ProbabilityTheory.measure_compl_support {S : Type u_2} [MeasurableSpace S] (μ : MeasureTheory.Measure S) [hμ : ProbabilityTheory.FiniteSupport μ] : ↑↑μ (↑(MeasureTheory.Measure.support μ))ᶜ = 0"}
{"name":"ProbabilityTheory.measureEntropy_le_log_card","declaration":"theorem ProbabilityTheory.measureEntropy_le_log_card {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] [Fintype S] (μ : MeasureTheory.Measure S) : Hm[μ] ≤ Real.log ↑(Fintype.card S)"}
{"name":"ProbabilityTheory.Measure.ext_iff_singleton_finiteSupport","declaration":"/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem ProbabilityTheory.Measure.ext_iff_singleton_finiteSupport {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] {μ1 : MeasureTheory.Measure S} {μ2 : MeasureTheory.Measure S} [ProbabilityTheory.FiniteSupport μ1] [ProbabilityTheory.FiniteSupport μ2] : μ1 = μ2 ↔ ∀ (x : S), ↑↑μ1 {x} = ↑↑μ2 {x}"}
{"name":"ProbabilityTheory.measureEntropy_eq_card_iff_measureReal_eq_aux","declaration":"theorem ProbabilityTheory.measureEntropy_eq_card_iff_measureReal_eq_aux {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] [Fintype S] (μ : MeasureTheory.Measure S) [MeasureTheory.IsProbabilityMeasure μ] : Hm[μ] = Real.log ↑(Fintype.card S) ↔ ∀ (s : S), μ.real {s} = (↑(Fintype.card S))⁻¹"}
{"name":"ProbabilityTheory.measureMutualInfo_of_not_isFiniteMeasure","declaration":"theorem ProbabilityTheory.measureMutualInfo_of_not_isFiniteMeasure {S : Type u_2} {U : Type u_4} [MeasurableSpace S] [MeasurableSpace U] {μ : MeasureTheory.Measure (S × U)} (h : ¬MeasureTheory.IsFiniteMeasure μ) : Im[μ] = 0"}
{"name":"ProbabilityTheory.measureEntropy_def_finite'","declaration":"theorem ProbabilityTheory.measureEntropy_def_finite' {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} {A : Finset S} (hA : ↑↑μ (↑A)ᶜ = 0) : Hm[μ] = Finset.sum A fun s => Real.negMulLog (((μ.real Set.univ)⁻¹ • μ.real) {s})"}
{"name":"ProbabilityTheory.measureEntropy_map_of_injective","declaration":"theorem ProbabilityTheory.measureEntropy_map_of_injective {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] (μ : MeasureTheory.Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) : Hm[MeasureTheory.Measure.map f μ] = Hm[μ]"}
{"name":"ProbabilityTheory.measureEntropy_comap_equiv","declaration":"theorem ProbabilityTheory.measureEntropy_comap_equiv {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] (μ : MeasureTheory.Measure S) (f : T ≃ᵐ S) : Hm[MeasureTheory.Measure.comap (⇑f) μ] = Hm[μ]"}
{"name":"ProbabilityTheory.measureEntropy_comap","declaration":"theorem ProbabilityTheory.measureEntropy_comap {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] (μ : MeasureTheory.Measure S) (f : T → S) (hf : MeasurableEmbedding f) (hf_range : Set.range f =ᶠ[MeasureTheory.Measure.ae μ] Set.univ) : Hm[MeasureTheory.Measure.comap f μ] = Hm[μ]"}
{"name":"ProbabilityTheory.measureEntropy_dirac","declaration":"theorem ProbabilityTheory.measureEntropy_dirac {S : Type u_2} [MeasurableSpace S] [MeasurableSingletonClass S] (x : S) : Hm[MeasureTheory.Measure.dirac x] = 0"}
{"name":"ProbabilityTheory.measureMutualInfo_zero_measure","declaration":"theorem ProbabilityTheory.measureMutualInfo_zero_measure {S : Type u_2} {T : Type u_3} [MeasurableSpace S] [MeasurableSpace T] : Im[0] = 0"}
{"name":"ProbabilityTheory.measureMutualInfo_nonneg_aux","declaration":"/-- An ambitious goal would be to replace FiniteSupport with finite entropy.  Proof is long and slow; needs to be optimized -/\ntheorem ProbabilityTheory.measureMutualInfo_nonneg_aux {S : Type u_2} {U : Type u_4} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace U] [MeasurableSingletonClass U] {μ : MeasureTheory.Measure (S × U)} [ProbabilityTheory.FiniteSupport μ] [MeasureTheory.IsProbabilityMeasure μ] : 0 ≤ Im[μ] ∧\n  (Im[μ] = 0 ↔\n    ∀ (p : S × U),\n      μ.real {p} =\n        (MeasureTheory.Measure.map Prod.fst μ).real {p.1} * (MeasureTheory.Measure.map Prod.snd μ).real {p.2})"}
{"name":"ProbabilityTheory.measureEntropy_def'","declaration":"theorem ProbabilityTheory.measureEntropy_def' {S : Type u_2} [MeasurableSpace S] (μ : MeasureTheory.Measure S) : Hm[μ] = ∑' (s : S), Real.negMulLog (((μ.real Set.univ)⁻¹ • μ.real) {s})"}
{"name":"ProbabilityTheory.measureEntropy_def_finite","declaration":"theorem ProbabilityTheory.measureEntropy_def_finite {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} {A : Finset S} (hA : ↑↑μ (↑A)ᶜ = 0) : Hm[μ] = Finset.sum A fun s => Real.negMulLog (↑↑((↑↑μ Set.univ)⁻¹ • μ) {s}).toReal"}
{"name":"ProbabilityTheory.measureEntropy_of_isProbabilityMeasure'","declaration":"theorem ProbabilityTheory.measureEntropy_of_isProbabilityMeasure' {S : Type u_2} [MeasurableSpace S] (μ : MeasureTheory.Measure S) [MeasureTheory.IsProbabilityMeasure μ] : Hm[μ] = ∑' (s : S), Real.negMulLog (μ.real {s})"}
{"name":"ProbabilityTheory.measureEntropy_eq_card_iff_measureReal_eq","declaration":"theorem ProbabilityTheory.measureEntropy_eq_card_iff_measureReal_eq {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} [MeasurableSingletonClass S] [Fintype S] [MeasureTheory.IsFiniteMeasure μ] [NeZero μ] : Hm[μ] = Real.log ↑(Fintype.card S) ↔ ∀ (s : S), μ.real {s} = μ.real Set.univ / ↑(Fintype.card S)"}
{"name":"ProbabilityTheory.integral_congr_finiteSupport","declaration":"theorem ProbabilityTheory.integral_congr_finiteSupport {Ω : Type u_1} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω} {G : Type u_5} [MeasurableSingletonClass Ω] [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f : Ω → G} {g : Ω → G} [ProbabilityTheory.FiniteSupport μ] [MeasureTheory.IsFiniteMeasure μ] (hfg : ∀ (x : Ω), ↑↑μ {x} ≠ 0 → f x = g x) : ∫ (x : Ω), f x ∂μ = ∫ (x : Ω), g x ∂μ"}
{"name":"ProbabilityTheory.measureMutualInfo_nonneg","declaration":"theorem ProbabilityTheory.measureMutualInfo_nonneg {S : Type u_2} {U : Type u_4} [MeasurableSpace S] [MeasurableSingletonClass S] [MeasurableSpace U] [MeasurableSingletonClass U] {μ : MeasureTheory.Measure (S × U)} [ProbabilityTheory.FiniteSupport μ] : 0 ≤ Im[μ]"}
{"name":"ProbabilityTheory.finiteSupport_of_comp","declaration":"theorem ProbabilityTheory.finiteSupport_of_comp {Ω : Type u_1} {S : Type u_2} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] {μ : MeasureTheory.Measure Ω} [ProbabilityTheory.FiniteSupport μ] {X : Ω → S} (hX : Measurable X) : ProbabilityTheory.FiniteSupport (MeasureTheory.Measure.map X μ)"}
{"name":"ProbabilityTheory.measureEntropy_eq_card_iff_measure_eq","declaration":"theorem ProbabilityTheory.measureEntropy_eq_card_iff_measure_eq {S : Type u_2} [MeasurableSpace S] {μ : MeasureTheory.Measure S} [MeasurableSingletonClass S] [Fintype S] [MeasureTheory.IsFiniteMeasure μ] [NeZero μ] : Hm[μ] = Real.log ↑(Fintype.card S) ↔ ∀ (s : S), ↑↑μ {s} = ↑↑μ Set.univ / ↑(Fintype.card S)"}
