{"name":"ProbabilityTheory.entropy_const","declaration":"/-- The entropy of any constant is zero. -/\ntheorem ProbabilityTheory.entropy_const {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] (c : S) : H[fun x => c ; μ] = 0"}
{"name":"ProbabilityTheory.condEntropy_le_entropy","declaration":"/-- $$ H[X|Y] ≤ H[X] $$ -/\ntheorem ProbabilityTheory.condEntropy_le_entropy {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] {X : Ω → S} {Y : Ω → T} (μ : MeasureTheory.Measure Ω) [MeasurableSingletonClass S] [MeasurableSingletonClass T] (hX : Measurable X) (hY : Measurable Y) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : H[X | Y ; μ] ≤ H[X ; μ]"}
{"name":"ProbabilityTheory.condMutualInfo_eq_kernel_mutualInfo","declaration":"/-- The conditional mutual information agrees with the information of the conditional kernel.\n-/\ntheorem ProbabilityTheory.condMutualInfo_eq_kernel_mutualInfo {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange Z] : I[X : Y|Z;μ] = Ik[ProbabilityTheory.condDistrib (⟨X, Y⟩) Z μ , MeasureTheory.Measure.map Z μ]"}
{"name":"ProbabilityTheory.condMutualInfo_eq_integral_mutualInfo","declaration":"theorem ProbabilityTheory.condMutualInfo_eq_integral_mutualInfo {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} {μ : MeasureTheory.Measure Ω} : I[X : Y|Z;μ] = ∫ (x : U), (fun z => I[X : Y ; ProbabilityTheory.cond μ (Z ⁻¹' {z})]) x ∂MeasureTheory.Measure.map Z μ"}
{"name":"ProbabilityTheory.«termI[_:_|_]»","declaration":"/-- The conditional mutual information $I[X : Y| Z]$ is the mutual information of $X| Z=z$ and\n$Y| Z=z$, integrated over $z$. -/\ndef ProbabilityTheory.«termI[_:_|_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.mutualInfo","declaration":"/-- The mutual information $I[X : Y]$ of two random variables is defined to be $H[X] + H[Y] - H[X ; Y]$. -/\ndef ProbabilityTheory.mutualInfo {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] (X : Ω → S) (Y : Ω → T) (μ : autoParam (MeasureTheory.Measure Ω) _auto✝) : ℝ"}
{"name":"ProbabilityTheory.entropy_pair_eq_add","declaration":"/-- $H[X, Y] = H[X] + H[Y]$ if and only if $X, Y$ are independent. -/\ntheorem ProbabilityTheory.entropy_pair_eq_add {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : H[⟨X, Y⟩ ; μ] = H[X ; μ] + H[Y ; μ] ↔ ProbabilityTheory.IndepFun X Y μ"}
{"name":"ProbabilityTheory.«termI[_:_|_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termI[_:_|_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.condEntropy_le_log_card","declaration":"/-- Conditional entropy is at most the logarithm of the cardinality of the range. -/\ntheorem ProbabilityTheory.condEntropy_le_log_card {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [Fintype S] (X : Ω → S) (Y : Ω → T) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] : H[X | Y ; μ] ≤ Real.log ↑(Fintype.card S)"}
{"name":"ProbabilityTheory.condMutualInfo_comm","declaration":"/-- $I[X : Y | Z] = I[Y : X | Z]$. -/\ntheorem ProbabilityTheory.condMutualInfo_comm {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (Z : Ω → U) (μ : MeasureTheory.Measure Ω) : I[X : Y|Z;μ] = I[Y : X|Z;μ]"}
{"name":"ProbabilityTheory.mutualInfo_eq_entropy_sub_condEntropy'","declaration":"/-- $I[X : Y] = H[Y] - H[Y | X]$. -/\ntheorem ProbabilityTheory.mutualInfo_eq_entropy_sub_condEntropy' {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : I[X : Y ; μ] = H[Y ; μ] - H[Y | X ; μ]"}
{"name":"ProbabilityTheory.entropy_add_entropy_sub_mutualInfo","declaration":"theorem ProbabilityTheory.entropy_add_entropy_sub_mutualInfo {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] (X : Ω → S) (Y : Ω → T) (μ : MeasureTheory.Measure Ω) : H[X ; μ] + H[Y ; μ] - I[X : Y ; μ] = H[⟨X, Y⟩ ; μ]"}
{"name":"ProbabilityTheory.entropy_le_log_card_of_mem","declaration":"/-- Entropy is at most the logarithm of the cardinality of a set in which X almost surely takes values in. -/\ntheorem ProbabilityTheory.entropy_le_log_card_of_mem {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] {A : Finset S} {μ : MeasureTheory.Measure Ω} {X : Ω → S} (hX : Measurable X) (h : ∀ᵐ (ω : Ω) ∂μ, X ω ∈ A) : H[X ; μ] ≤ Real.log ↑(Nat.card { x // x ∈ A })"}
{"name":"ProbabilityTheory.entropy_of_comp_eq_of_comp","declaration":"/-- A Schroder-Bernstein type theorem for entropy : if two random variables are functions of each\nother, then they have the same entropy. Can be used as a substitute for\n`entropy_comp_of_injective` if one doesn't want to establish the injectivity. -/\ntheorem ProbabilityTheory.entropy_of_comp_eq_of_comp {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) (f : S → T) (g : T → S) (h1 : Y = f ∘ X) (h2 : X = g ∘ Y) [FiniteRange X] [FiniteRange Y] : H[X ; μ] = H[Y ; μ]"}
{"name":"ProbabilityTheory.«termH[_;_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termH[_;_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.entropy_eq_sum_finset'","declaration":"theorem ProbabilityTheory.entropy_eq_sum_finset' {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] {X : Ω → S} (hX : Measurable X) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] {A : Finset S} (hA : ↑↑(MeasureTheory.Measure.map X μ) (↑A)ᶜ = 0) : H[X ; μ] = Finset.sum A fun x => Real.negMulLog ((MeasureTheory.Measure.map X μ).real {x})"}
{"name":"ProbabilityTheory.condEntropy_eq_sum_prod","declaration":"/-- Same as previous lemma, but with a sum over a product space rather than a double sum. -/\ntheorem ProbabilityTheory.condEntropy_eq_sum_prod {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] {X : Ω → S} [MeasurableSingletonClass T] (hX : Measurable X) {Y : Ω → T} (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : H[X | Y ; μ] =\n  Finset.sum (FiniteRange.toFinset X ×ˢ FiniteRange.toFinset Y) fun p =>\n    (↑↑(MeasureTheory.Measure.map Y μ) {p.2}).toReal *\n      Real.negMulLog (↑↑(MeasureTheory.Measure.map X (ProbabilityTheory.cond μ (Y ⁻¹' {p.2}))) {p.1}).toReal"}
{"name":"ProbabilityTheory.entropy_eq_sum","declaration":"/-- $H[X] = \\sum_s P[X=s] \\log \\frac{1}{P[X=s]}$. -/\ntheorem ProbabilityTheory.entropy_eq_sum {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] {X : Ω → S} (hX : Measurable X) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] : H[X ; μ] = ∑' (x : S), Real.negMulLog (↑↑(MeasureTheory.Measure.map X μ) {x}).toReal"}
{"name":"ProbabilityTheory.mutualInfo_const","declaration":"/-- The mutual information with a constant is always zero. -/\ntheorem ProbabilityTheory.mutualInfo_const {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} (hX : Measurable X) (c : T) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] : I[X : fun x => c ; μ] = 0"}
{"name":"ProbabilityTheory.condEntropy_eq_sum","declaration":"/-- $H[X|Y] = \\sum_y P[Y=y] H[X|Y=y]$.-/\ntheorem ProbabilityTheory.condEntropy_eq_sum {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] (X : Ω → S) (Y : Ω → T) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (hY : Measurable Y) [FiniteRange Y] : H[X | Y ; μ] =\n  Finset.sum (FiniteRange.toFinset Y) fun y => (↑↑(MeasureTheory.Measure.map Y μ) {y}).toReal * H[X | Y ← y ; μ]"}
{"name":"ProbabilityTheory.const_of_nonpos_entropy","declaration":"/-- If $X$ is an $S$-valued random variable of non-positive entropy, then $X$ is almost surely constant. -/\ntheorem ProbabilityTheory.const_of_nonpos_entropy {S : Type uS} [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] {Ω : Type u_1} [MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] {X : Ω → S} (hX : Measurable X) [FiniteRange X] (hent : H[X ; μ] ≤ 0) : ∃ s, μ.real (X ⁻¹' {s}) = 1"}
{"name":"ProbabilityTheory.IdentDistrib.mutualInfo_eq","declaration":"/-- Substituting variables for ones with the same distributions doesn't change the mutual information. -/\ntheorem ProbabilityTheory.IdentDistrib.mutualInfo_eq {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] {X : Ω → S} {Y : Ω → T} {μ : MeasureTheory.Measure Ω} {Ω' : Type u_1} [MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} {X' : Ω' → S} {Y' : Ω' → T} (hXY : ProbabilityTheory.IdentDistrib (⟨X, Y⟩) (⟨X', Y'⟩) μ μ') : I[X : Y ; μ] = I[X' : Y' ; μ']"}
{"name":"ProbabilityTheory.«termH[_|_;_]»","declaration":"/-- Conditional entropy of a random variable w.r.t. another.\nThis is the expectation under the law of `Y` of the entropy of the law of `X` conditioned on the\nevent `Y = y`. -/\ndef ProbabilityTheory.«termH[_|_;_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.condEntropy_comm","declaration":"/-- $H[X, Y| Z] = H[Y, X| Z]$. -/\ntheorem ProbabilityTheory.condEntropy_comm {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) : H[⟨X, Y⟩ | Z ; μ] = H[⟨Y, X⟩ | Z ; μ]"}
{"name":"ProbabilityTheory.entropy_nonneg","declaration":"/-- Entropy is always non-negative. -/\ntheorem ProbabilityTheory.entropy_nonneg {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] (X : Ω → S) (μ : MeasureTheory.Measure Ω) : 0 ≤ H[X ; μ]"}
{"name":"ProbabilityTheory.«termI[_:_|_;_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termI[_:_|_;_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.entropy_eq_sum'","declaration":"theorem ProbabilityTheory.entropy_eq_sum' {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] {X : Ω → S} (hX : Measurable X) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] : H[X ; μ] = ∑' (x : S), Real.negMulLog ((MeasureTheory.Measure.map X μ).real {x})"}
{"name":"ProbabilityTheory.condEntropy_of_injective","declaration":"/-- If $X : \\Omega \\to S$, $Y : \\Omega \\to T$ are random variables, and $f : T \\times S → U$ is\ninjective for each fixed $t \\in T$, then $H[f(Y, X)|Y] = H[X|Y]$.\nThus for instance $H[X-Y|Y] = H[X|Y]$. -/\ntheorem ProbabilityTheory.condEntropy_of_injective {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} [MeasurableSingletonClass U] (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (hX : Measurable X) (hY : Measurable Y) (f : T → S → U) (hf : ∀ (t : T), Function.Injective (f t)) [FiniteRange Y] : H[fun ω => f (Y ω) (X ω) | Y ; μ] = H[X | Y ; μ]"}
{"name":"ProbabilityTheory.condMutualInfo_eq_sum'","declaration":"/-- A variant of `condMutualInfo_eq_sum` when `Z` has finite codomain. -/\ntheorem ProbabilityTheory.condMutualInfo_eq_sum' {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsFiniteMeasure μ] (hZ : Measurable Z) [Fintype U] : I[X : Y|Z;μ] =\n  Finset.sum Finset.univ fun z => (↑↑μ (Z ⁻¹' {z})).toReal * I[X : Y ; ProbabilityTheory.cond μ (Z ⁻¹' {z})]"}
{"name":"ProbabilityTheory.entropy_sub_mutualInfo_eq_condEntropy'","declaration":"/-- $H[Y] - I[X : Y] = H[Y | X]$. -/\ntheorem ProbabilityTheory.entropy_sub_mutualInfo_eq_condEntropy' {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : H[Y ; μ] - I[X : Y ; μ] = H[Y | X ; μ]"}
{"name":"ProbabilityTheory.«termI[_:_;_]»","declaration":"/-- The mutual information $I[X : Y]$ of two random variables is defined to be $H[X] + H[Y] - H[X ; Y]$. -/\ndef ProbabilityTheory.«termI[_:_;_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.IsUniform.entropy_eq'","declaration":"/-- Variant of `IsUniform.entropy_eq` where `H` is a finite `Set` rather than `Finset`. -/\ntheorem ProbabilityTheory.IsUniform.entropy_eq' {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] {H : Set S} [Finite ↑H] {X : Ω → S} {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] (hX : ProbabilityTheory.IsUniform H X μ) (hX' : Measurable X) : H[X ; μ] = Real.log ↑(Nat.card ↑H)"}
{"name":"ProbabilityTheory.«termH[_|_←_]»","declaration":"/-- Entropy of a random variable with values in a finite measurable space. -/\ndef ProbabilityTheory.«termH[_|_←_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.«termH[_;_]»","declaration":"/-- Entropy of a random variable with values in a finite measurable space. -/\ndef ProbabilityTheory.«termH[_;_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.entropy_congr","declaration":"/-- Two variables that agree almost everywhere, have the same entropy. -/\ntheorem ProbabilityTheory.entropy_congr {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] {μ : MeasureTheory.Measure Ω} {X : Ω → S} {X' : Ω → S} (h : X =ᶠ[MeasureTheory.Measure.ae μ] X') : H[X ; μ] = H[X' ; μ]"}
{"name":"ProbabilityTheory.condEntropy_zero_measure","declaration":"/-- Any random variable on a zero measure space has zero conditional entropy. -/\ntheorem ProbabilityTheory.condEntropy_zero_measure {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] (X : Ω → S) (Y : Ω → T) : H[X | Y ; 0] = 0"}
{"name":"ProbabilityTheory.IdentDistrib.entropy_eq","declaration":"/-- Two variables that have the same distribution, have the same entropy. -/\ntheorem ProbabilityTheory.IdentDistrib.entropy_eq {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] {X : Ω → S} {μ : MeasureTheory.Measure Ω} {Ω' : Type u_1} [MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} {X' : Ω' → S} (h : ProbabilityTheory.IdentDistrib X X' μ μ') : H[X ; μ] = H[X' ; μ']"}
{"name":"ProbabilityTheory.condEntropy","declaration":"/-- Conditional entropy of a random variable w.r.t. another.\nThis is the expectation under the law of `Y` of the entropy of the law of `X` conditioned on the\nevent `Y = y`. -/\ndef ProbabilityTheory.condEntropy {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] (X : Ω → S) (Y : Ω → T) (μ : autoParam (MeasureTheory.Measure Ω) _auto✝) : ℝ"}
{"name":"ProbabilityTheory.entropy_eq_sum_finiteRange","declaration":"theorem ProbabilityTheory.entropy_eq_sum_finiteRange {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] {X : Ω → S} (hX : Measurable X) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] : H[X ; μ] = Finset.sum (FiniteRange.toFinset X) fun x => Real.negMulLog (↑↑(MeasureTheory.Measure.map X μ) {x}).toReal"}
{"name":"ProbabilityTheory.chain_rule''","declaration":"/-- Another form of the chain rule : $H[X|Y] = H[X, Y] - H[Y]$. -/\ntheorem ProbabilityTheory.chain_rule'' {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) [FiniteRange X] [FiniteRange Y] : H[X | Y ; μ] = H[⟨X, Y⟩ ; μ] - H[Y ; μ]"}
{"name":"ProbabilityTheory.IndepFun.condEntropy_eq_entropy","declaration":"theorem ProbabilityTheory.IndepFun.condEntropy_eq_entropy {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : MeasureTheory.Measure Ω} (h : ProbabilityTheory.IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : H[X | Y ; μ] = H[X ; μ]"}
{"name":"ProbabilityTheory.«termH[_|_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termH[_|_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.«termH[_|_←_;_]»","declaration":"/-- Entropy of a random variable with values in a finite measurable space. -/\ndef ProbabilityTheory.«termH[_|_←_;_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.IsUniform.entropy_eq","declaration":"/-- If $X$ is uniformly distributed on $H$, then $H[X] = \\log |H|$.\n-/\ntheorem ProbabilityTheory.IsUniform.entropy_eq {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S] (H : Finset S) (X : Ω → S) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] (hX : ProbabilityTheory.IsUniform (↑H) X μ) (hX' : Measurable X) : H[X ; μ] = Real.log ↑(Nat.card { x // x ∈ H })"}
{"name":"ProbabilityTheory.«termI[_:_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termI[_:_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.cond_chain_rule","declaration":"/-- $$ H[X, Y | Z] = H[Y | Z] + H[X|Y, Z].$$ -/\ntheorem ProbabilityTheory.cond_chain_rule {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [FiniteRange X] [FiniteRange Y] [FiniteRange Z] : H[⟨X, Y⟩ | Z ; μ] = H[Y | Z ; μ] + H[X | ⟨Y, Z⟩ ; μ]"}
{"name":"ProbabilityTheory.mutualInfo_def","declaration":"theorem ProbabilityTheory.mutualInfo_def {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] (X : Ω → S) (Y : Ω → T) (μ : MeasureTheory.Measure Ω) : I[X : Y ; μ] = H[X ; μ] + H[Y ; μ] - H[⟨X, Y⟩ ; μ]"}
{"name":"ProbabilityTheory.IndepFun.mutualInfo_eq_zero","declaration":"/-- **Alias** of the reverse direction of `ProbabilityTheory.mutualInfo_eq_zero`.\n\n---\n\n$I[X : Y] = 0$ iff $X, Y$ are independent. -/\ntheorem ProbabilityTheory.IndepFun.mutualInfo_eq_zero {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : ProbabilityTheory.IndepFun X Y μ → I[X : Y ; μ] = 0"}
{"name":"ProbabilityTheory.entropy_eq_sum_finiteRange'","declaration":"theorem ProbabilityTheory.entropy_eq_sum_finiteRange' {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] {X : Ω → S} (hX : Measurable X) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] : H[X ; μ] = Finset.sum (FiniteRange.toFinset X) fun x => Real.negMulLog ((MeasureTheory.Measure.map X μ).real {x})"}
{"name":"ProbabilityTheory.entropy_comp_le","declaration":"/-- Data-processing inequality for the entropy :\n$$ H[f(X)] \\leq H[X].$$\nTo upgrade this to equality, see `entropy_of_comp_eq_of_comp` or `entropy_comp_of_injective`. -/\ntheorem ProbabilityTheory.entropy_comp_le {Ω : Type uΩ} {S : Type uS} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable U] [Nonempty S] [Nonempty U] [MeasurableSpace S] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass U] {X : Ω → S} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (f : S → U) [FiniteRange X] : H[f ∘ X ; μ] ≤ H[X ; μ]"}
{"name":"ProbabilityTheory.«termH[_|_;_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termH[_|_;_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.map_prod_comap_swap","declaration":"/-- The law of $(X, Z)$ is the image of the law of $(Z, X)$.-/\ntheorem ProbabilityTheory.map_prod_comap_swap {Ω : Type uΩ} {S : Type uS} {U : Type uU} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace U] {Z : Ω → U} {X : Ω → S} (hX : Measurable X) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) : MeasureTheory.Measure.comap Prod.swap (MeasureTheory.Measure.map (fun ω => (X ω, Z ω)) μ) =\n  MeasureTheory.Measure.map (fun ω => (Z ω, X ω)) μ"}
{"name":"ProbabilityTheory.entropy_eq_kernel_entropy","declaration":"/-- Entropy of a random variable is also the kernel entropy of the distribution over a Dirac mass. -/\ntheorem ProbabilityTheory.entropy_eq_kernel_entropy {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] (X : Ω → S) (μ : MeasureTheory.Measure Ω) : H[X ; μ] = Hk[ProbabilityTheory.kernel.const Unit (MeasureTheory.Measure.map X μ) , MeasureTheory.Measure.dirac ()]"}
{"name":"ProbabilityTheory.IndepFun.entropy_pair_eq_add","declaration":"/-- If $X, Y$ are independent, then $H[X, Y] = H[X] + H[Y]$. -/\ntheorem ProbabilityTheory.IndepFun.entropy_pair_eq_add {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : ProbabilityTheory.IndepFun X Y μ → H[⟨X, Y⟩ ; μ] = H[X ; μ] + H[Y ; μ]"}
{"name":"ProbabilityTheory.condMutualInfo_nonneg","declaration":"/-- Conditional information is non-nonegative. -/\ntheorem ProbabilityTheory.condMutualInfo_nonneg {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (Z : Ω → U) (μ : MeasureTheory.Measure Ω) [FiniteRange X] [FiniteRange Y] : 0 ≤ I[X : Y|Z;μ]"}
{"name":"ProbabilityTheory.condMutualInfo_eq'","declaration":"/-- $$ I[X : Y| Z] = H[X| Z] - H[X|Y, Z].$$ -/\ntheorem ProbabilityTheory.condMutualInfo_eq' {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z] : I[X : Y|Z;μ] = H[X | Z ; μ] - H[X | ⟨Y, Z⟩ ; μ]"}
{"name":"ProbabilityTheory.«termI[_:_|_;_]»","declaration":"/-- The conditional mutual information $I[X : Y| Z]$ is the mutual information of $X| Z=z$ and\n$Y| Z=z$, integrated over $z$. -/\ndef ProbabilityTheory.«termI[_:_|_;_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.«termH[_|_←_;_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termH[_|_←_;_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.condEntropy_eq_kernel_entropy","declaration":"/-- Conditional entropy of a random variable is equal to the entropy of its conditional kernel. -/\ntheorem ProbabilityTheory.condEntropy_eq_kernel_entropy {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] [FiniteRange Y] : H[X | Y ; μ] = Hk[ProbabilityTheory.condDistrib X Y μ , MeasureTheory.Measure.map Y μ]"}
{"name":"ProbabilityTheory.chain_rule","declaration":"/-- Another form of the chain rule : $H[X, Y] = H[Y] + H[X|Y]$. -/\ntheorem ProbabilityTheory.chain_rule {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) [FiniteRange X] [FiniteRange Y] : H[⟨X, Y⟩ ; μ] = H[Y ; μ] + H[X | Y ; μ]"}
{"name":"ProbabilityTheory.condEntropy_eq_sum_sum","declaration":"/-- $H[X|Y] = \\sum_y \\sum_x P[Y=y] P[X=x|Y=y] log \\frac{1}{P[X=x|Y=y]}$.-/\ntheorem ProbabilityTheory.condEntropy_eq_sum_sum {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] {X : Ω → S} [MeasurableSingletonClass T] (hX : Measurable X) {Y : Ω → T} (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : H[X | Y ; μ] =\n  Finset.sum (FiniteRange.toFinset Y) fun y =>\n    Finset.sum (FiniteRange.toFinset X) fun x =>\n      (↑↑(MeasureTheory.Measure.map Y μ) {y}).toReal *\n        Real.negMulLog (↑↑(MeasureTheory.Measure.map X (ProbabilityTheory.cond μ (Y ⁻¹' {y}))) {x}).toReal"}
{"name":"ProbabilityTheory.condMutualInfo_def","declaration":"theorem ProbabilityTheory.condMutualInfo_def {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (X : Ω → S) (Y : Ω → T) (Z : Ω → U) (μ : MeasureTheory.Measure Ω) : I[X : Y|Z;μ] =\n  ∫ (x : U), (fun z => H[X | Z ← z ; μ] + H[Y | Z ← z ; μ] - H[⟨X, Y⟩ | Z ← z ; μ]) x ∂MeasureTheory.Measure.map Z μ"}
{"name":"ProbabilityTheory.prob_ge_exp_neg_entropy'","declaration":"/-- If $X$ is an $S$-valued random variable, then there exists $s \\in S$ such that\n$P[X=s] \\geq \\exp(-H[X])$. -/\ntheorem ProbabilityTheory.prob_ge_exp_neg_entropy' {S : Type uS} [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] {Ω : Type u_1} [MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] (X : Ω → S) (hX : Measurable X) [FiniteRange X] : ∃ s, Real.exp (-H[X ; μ]) ≤ μ.real (X ⁻¹' {s})"}
{"name":"ProbabilityTheory.condMutualInfo_of_inj_map","declaration":"/-- If $f(Z, X)$ is injective for each fixed $Z$, then $I[f(Z, X) : Y| Z] = I[X : Y| Z]$.-/\ntheorem ProbabilityTheory.condMutualInfo_of_inj_map {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) {V : Type u_1} [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V] [Countable V] (f : U → S → V) (hf : ∀ (t : U), Function.Injective (f t)) [FiniteRange Z] : I[fun ω => f (Z ω) (X ω) : Y|Z;μ] = I[X : Y|Z;μ]"}
{"name":"ProbabilityTheory.mutualInfo_eq_zero","declaration":"/-- $I[X : Y] = 0$ iff $X, Y$ are independent. -/\ntheorem ProbabilityTheory.mutualInfo_eq_zero {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : I[X : Y ; μ] = 0 ↔ ProbabilityTheory.IndepFun X Y μ"}
{"name":"ProbabilityTheory.condMutualInfo","declaration":"/-- The conditional mutual information $I[X : Y| Z]$ is the mutual information of $X| Z=z$ and\n$Y| Z=z$, integrated over $z$. -/\ndef ProbabilityTheory.condMutualInfo {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] (X : Ω → S) (Y : Ω → T) (Z : Ω → U) (μ : autoParam (MeasureTheory.Measure Ω) _auto✝) : ℝ"}
{"name":"ProbabilityTheory.entropy_submodular","declaration":"/-- $H[X | Y, Z] \\leq H[X | Z]$ -/\ntheorem ProbabilityTheory.entropy_submodular {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [MeasurableSingletonClass S] [MeasurableSingletonClass T] (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [FiniteRange X] [FiniteRange Y] [FiniteRange Z] : H[X | ⟨Y, Z⟩ ; μ] ≤ H[X | Z ; μ]"}
{"name":"ProbabilityTheory.entropy_comp_of_injective","declaration":"/-- If $X$, $Y$ are $S$-valued and $T$-valued random variables, and $Y = f(X)$ for\nsome injection $f : S \\to T$, then $H[Y] = H[X]$. One can also use `entropy_of_comp_eq_of_comp` as an alternative if verifying injectivity is fiddly. For the upper bound only, see `entropy_comp_le`. -/\ntheorem ProbabilityTheory.entropy_comp_of_injective {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} (μ : MeasureTheory.Measure Ω) (hX : Measurable X) (f : S → T) (hf : Function.Injective f) : H[f ∘ X ; μ] = H[X ; μ]"}
{"name":"ProbabilityTheory.entropy_prod_comp","declaration":"/-- $H[X, f(X)] = H[X]$.-/\ntheorem ProbabilityTheory.entropy_prod_comp {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} (hX : Measurable X) (μ : MeasureTheory.Measure Ω) (f : S → T) : H[⟨X, f ∘ X⟩ ; μ] = H[X ; μ]"}
{"name":"ProbabilityTheory.entropy_sub_mutualInfo_eq_condEntropy","declaration":"/-- $H[X] - I[X : Y] = H[X | Y]$. -/\ntheorem ProbabilityTheory.entropy_sub_mutualInfo_eq_condEntropy {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : H[X ; μ] - I[X : Y ; μ] = H[X | Y ; μ]"}
{"name":"ProbabilityTheory.«termH[_]»","declaration":"/-- Entropy of a random variable with values in a finite measurable space. -/\ndef ProbabilityTheory.«termH[_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.IdentDistrib.condEntropy_eq","declaration":"/-- Two pairs of variables that have the same joint distribution, have the same\nconditional entropy. -/\ntheorem ProbabilityTheory.IdentDistrib.condEntropy_eq {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure Ω} {Ω' : Type u_1} [MeasurableSpace Ω'] {X : Ω → S} {Y : Ω → T} {μ' : MeasureTheory.Measure Ω'} {X' : Ω' → S} {Y' : Ω' → T} [MeasureTheory.IsProbabilityMeasure μ] [MeasureTheory.IsProbabilityMeasure μ'] (hX : Measurable X) (hY : Measurable Y) (hX' : Measurable X') (hY' : Measurable Y') (h : ProbabilityTheory.IdentDistrib (⟨X, Y⟩) (⟨X', Y'⟩) μ μ') [FiniteRange X] [FiniteRange Y] [FiniteRange X'] [FiniteRange Y'] : H[X | Y ; μ] = H[X' | Y' ; μ']"}
{"name":"ProbabilityTheory.«termH[_|_]»","declaration":"/-- Conditional entropy of a random variable w.r.t. another.\nThis is the expectation under the law of `Y` of the entropy of the law of `X` conditioned on the\nevent `Y = y`. -/\ndef ProbabilityTheory.«termH[_|_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.entropy_eq_log_card","declaration":"/-- If $X$ is $S$-valued random variable, then $H[X] = \\log |S|$ if and only if $X$ is uniformly\ndistributed. -/\ntheorem ProbabilityTheory.entropy_eq_log_card {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] {X : Ω → S} [Fintype S] (hX : Measurable X) (μ : MeasureTheory.Measure Ω) [hμ : NeZero μ] [MeasureTheory.IsFiniteMeasure μ] : H[X ; μ] = Real.log ↑(Fintype.card S) ↔\n  ∀ (s : S), ↑↑(MeasureTheory.Measure.map X μ) {s} = ↑↑μ Set.univ / ↑(Fintype.card S)"}
{"name":"ProbabilityTheory.cond_chain_rule'","declaration":"/-- If $X : \\Omega \\to S$, $Y : \\Omega \\to T$,$Z : \\Omega \\to U$ are random variables, then\n$$H[X, Y | Z] = H[X | Z] + H[Y|X, Z]$$. -/\ntheorem ProbabilityTheory.cond_chain_rule' {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [FiniteRange X] [FiniteRange Y] [FiniteRange Z] : H[⟨X, Y⟩ | Z ; μ] = H[X | Z ; μ] + H[Y | ⟨X, Z⟩ ; μ]"}
{"name":"ProbabilityTheory.entropy_def","declaration":"/-- Entropy of a random variable agrees with entropy of its distribution. -/\ntheorem ProbabilityTheory.entropy_def {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] (X : Ω → S) (μ : MeasureTheory.Measure Ω) : H[X ; μ] = Hm[MeasureTheory.Measure.map X μ]"}
{"name":"ProbabilityTheory.chain_rule'","declaration":"/-- One form of the chain rule : $H[X, Y] = H[X] + H[Y|X]. -/\ntheorem ProbabilityTheory.chain_rule' {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) [FiniteRange X] [FiniteRange Y] : H[⟨X, Y⟩ ; μ] = H[X ; μ] + H[Y | X ; μ]"}
{"name":"ProbabilityTheory.condEntropy_eq_sum_fintype","declaration":"/-- $H[X|Y] = \\sum_y P[Y=y] H[X|Y=y]$.-/\ntheorem ProbabilityTheory.condEntropy_eq_sum_fintype {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] (X : Ω → S) (Y : Ω → T) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (hY : Measurable Y) [Fintype T] : H[X | Y ; μ] = Finset.sum Finset.univ fun y => (↑↑μ (Y ⁻¹' {y})).toReal * H[X | Y ← y ; μ]"}
{"name":"ProbabilityTheory.condEntropy_eq_zero","declaration":"theorem ProbabilityTheory.condEntropy_eq_zero {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsFiniteMeasure μ] (t : T) (ht : (↑↑(MeasureTheory.Measure.map Y μ) {t}).toReal = 0) : H[X | Y ← t ; μ] = 0"}
{"name":"ProbabilityTheory.entropy_triple_add_entropy_le","declaration":"/-- The submodularity inequality:\n$$ H[X, Y, Z] + H[Z] \\leq H[X, Z] + H[Y, Z].$$ -/\ntheorem ProbabilityTheory.entropy_triple_add_entropy_le {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [Nonempty U] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [MeasurableSingletonClass S] [MeasurableSingletonClass T] (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [FiniteRange X] [FiniteRange Y] [FiniteRange Z] : H[⟨X, ⟨Y, Z⟩⟩ ; μ] + H[Z ; μ] ≤ H[⟨X, Z⟩ ; μ] + H[⟨Y, Z⟩ ; μ]"}
{"name":"ProbabilityTheory.condEntropy_prod_eq_of_indepFun","declaration":"theorem ProbabilityTheory.condEntropy_prod_eq_of_indepFun {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} {μ : MeasureTheory.Measure Ω} [Fintype T] [Fintype U] [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [FiniteRange X] (h : ProbabilityTheory.IndepFun (⟨X, Y⟩) Z μ) : H[X | ⟨Y, Z⟩ ; μ] = H[X | Y ; μ]"}
{"name":"ProbabilityTheory.«termI[_:_;_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termI[_:_;_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.entropy_sub_condEntropy","declaration":"/-- $$ H[X] - H[X|Y] = I[X : Y] $$ -/\ntheorem ProbabilityTheory.entropy_sub_condEntropy {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] {X : Ω → S} {Y : Ω → T} (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [MeasurableSingletonClass S] [MeasurableSingletonClass T] (hX : Measurable X) (hY : Measurable Y) [FiniteRange X] [FiniteRange Y] : H[X ; μ] - H[X | Y ; μ] = I[X : Y ; μ]"}
{"name":"ProbabilityTheory.entropy_zero_measure","declaration":"/-- Any variable on a zero measure space has zero entropy. -/\ntheorem ProbabilityTheory.entropy_zero_measure {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] (X : Ω → S) : H[X ; 0] = 0"}
{"name":"ProbabilityTheory.condMutualInfo_eq_zero","declaration":"/-- $I[X : Y| Z]=0$ iff $X, Y$ are conditionally independent over $Z$. -/\ntheorem ProbabilityTheory.condMutualInfo_eq_zero {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable U] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} [MeasurableSingletonClass S] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure Ω} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z] : I[X : Y|Z;μ] = 0 ↔ ProbabilityTheory.CondIndepFun X Y Z μ"}
{"name":"ProbabilityTheory.entropy_le_log_card","declaration":"/-- Entropy is at most the logarithm of the cardinality of the range. -/\ntheorem ProbabilityTheory.entropy_le_log_card {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] [Fintype S] (X : Ω → S) (μ : MeasureTheory.Measure Ω) : H[X ; μ] ≤ Real.log ↑(Fintype.card S)"}
{"name":"ProbabilityTheory.condEntropy_comp_ge","declaration":"/-- Data-processing inequality for the conditional entropy:\n$$ H[Y|f(X)] \\geq H[Y|X]$$\nTo upgrade this to equality, see `condEntropy_of_injective'` -/\ntheorem ProbabilityTheory.condEntropy_comp_ge {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [Nonempty U] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} [MeasurableSingletonClass S] [MeasurableSingletonClass T] [FiniteRange X] [FiniteRange Y] (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) (f : S → U) : H[Y | f ∘ X ; μ] ≥ H[Y | X ; μ]"}
{"name":"ProbabilityTheory.mutualInfo_comm","declaration":"/-- $I[X : Y] = I[Y : X]$. -/\ntheorem ProbabilityTheory.mutualInfo_comm {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) : I[X : Y ; μ] = I[Y : X ; μ]"}
{"name":"ProbabilityTheory.mutualInfo_nonneg","declaration":"/-- Mutual information is non-negative. -/\ntheorem ProbabilityTheory.mutualInfo_nonneg {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [FiniteRange X] [FiniteRange Y] : 0 ≤ I[X : Y ; μ]"}
{"name":"ProbabilityTheory.ent_of_cond_indep","declaration":"/-- If $X, Y$ are conditionally independent over $Z$, then $H[X, Y, Z] = H[X, Z] + H[Y, Z] - H[Z]$. -/\ntheorem ProbabilityTheory.ent_of_cond_indep {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [Nonempty U] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} [MeasurableSingletonClass S] [MeasurableSingletonClass T] {μ : MeasureTheory.Measure Ω} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : ProbabilityTheory.CondIndepFun X Y Z μ) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z] : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Z⟩ ; μ] + H[⟨Y, Z⟩ ; μ] - H[Z ; μ]"}
{"name":"ProbabilityTheory.condEntropy_nonneg","declaration":"/-- Conditional entropy is non-negative. -/\ntheorem ProbabilityTheory.condEntropy_nonneg {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] (X : Ω → S) (Y : Ω → T) (μ : MeasureTheory.Measure Ω) : 0 ≤ H[X | Y ; μ]"}
{"name":"ProbabilityTheory.condEntropy_comp_self","declaration":"/-- $H[X|f(X)] = H[X] - H[f(X)]$. -/\ntheorem ProbabilityTheory.condEntropy_comp_self {Ω : Type uΩ} {S : Type uS} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable U] [Nonempty S] [Nonempty U] [MeasurableSpace S] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass U] {X : Ω → S} {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) {f : S → U} (hf : Measurable f) [FiniteRange X] : H[X | f ∘ X ; μ] = H[X ; μ] - H[f ∘ X ; μ]"}
{"name":"ProbabilityTheory.condEntropy_of_injective'","declaration":"/-- If $X : \\Omega \\to S$ and $Y : \\Omega \\to T$ are random variables, and $f : T \\to U$ is an\ninjection then $H[X|f(Y)] = H[X|Y]$.\n -/\ntheorem ProbabilityTheory.condEntropy_of_injective' {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [Nonempty U] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} [MeasurableSingletonClass S] (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) (hY : Measurable Y) (f : T → U) (hf : Function.Injective f) (hfY : Measurable (f ∘ Y)) [FiniteRange X] [FiniteRange Y] : H[X | f ∘ Y ; μ] = H[X | Y ; μ]"}
{"name":"ProbabilityTheory.prob_ge_exp_neg_entropy","declaration":"/-- If $X$ is an $S$-valued random variable, then there exists $s \\in S$ such that\n$P[X=s] \\geq \\exp(-H[X])$.  TODO: remove the probability measure hypothesis, which is unncessary here. -/\ntheorem ProbabilityTheory.prob_ge_exp_neg_entropy {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S] (X : Ω → S) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (hX : Measurable X) [hX' : FiniteRange X] : ∃ s, ↑↑(MeasureTheory.Measure.map X μ) {s} ≥ ↑↑μ Set.univ * ↑(Real.toNNReal (Real.exp (-H[X ; μ])))"}
{"name":"ProbabilityTheory.mutualInfo_eq_entropy_sub_condEntropy","declaration":"/-- $I[X : Y] = H[X] - H[X|Y]$. -/\ntheorem ProbabilityTheory.mutualInfo_eq_entropy_sub_condEntropy {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] : I[X : Y ; μ] = H[X ; μ] - H[X | Y ; μ]"}
{"name":"ProbabilityTheory.condMutualInfo_eq_sum","declaration":"theorem ProbabilityTheory.condMutualInfo_eq_sum {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsFiniteMeasure μ] (hZ : Measurable Z) [FiniteRange Z] : I[X : Y|Z;μ] =\n  Finset.sum (FiniteRange.toFinset Z) fun z =>\n    (↑↑μ (Z ⁻¹' {z})).toReal * I[X : Y ; ProbabilityTheory.cond μ (Z ⁻¹' {z})]"}
{"name":"ProbabilityTheory.entropy_assoc","declaration":"/-- $H[(X, Y), Z] = H[X, (Y, Z)]$. -/\ntheorem ProbabilityTheory.entropy_assoc {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨⟨X, Y⟩, Z⟩ ; μ]"}
{"name":"ProbabilityTheory.entropy_eq_sum_finset","declaration":"theorem ProbabilityTheory.entropy_eq_sum_finset {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] {X : Ω → S} (hX : Measurable X) {μ : MeasureTheory.Measure Ω} [MeasureTheory.IsProbabilityMeasure μ] {A : Finset S} (hA : ↑↑(MeasureTheory.Measure.map X μ) (↑A)ᶜ = 0) : H[X ; μ] = Finset.sum A fun x => Real.negMulLog (↑↑(MeasureTheory.Measure.map X μ) {x}).toReal"}
{"name":"ProbabilityTheory.entropy","declaration":"/-- Entropy of a random variable with values in a finite measurable space. -/\ndef ProbabilityTheory.entropy {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] (X : Ω → S) (μ : autoParam (MeasureTheory.Measure Ω) _auto✝) : ℝ"}
{"name":"ProbabilityTheory.entropy_comm","declaration":"/-- $H[X, Y] = H[Y, X]$. -/\ntheorem ProbabilityTheory.entropy_comm {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) : H[⟨X, Y⟩ ; μ] = H[⟨Y, X⟩ ; μ]"}
{"name":"ProbabilityTheory.entropy_pair_le_add","declaration":"/-- Subadditivity of entropy. -/\ntheorem ProbabilityTheory.entropy_pair_le_add {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (μ : MeasureTheory.Measure Ω) [FiniteRange X] [FiniteRange Y] : H[⟨X, Y⟩ ; μ] ≤ H[X ; μ] + H[Y ; μ]"}
{"name":"ProbabilityTheory.entropy_cond_eq_sum","declaration":"/-- $H[X|Y=y] = \\sum_s P[X=s|Y=y] \\log \\frac{1}{P[X=s|Y=y]}$. -/\ntheorem ProbabilityTheory.entropy_cond_eq_sum {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (y : T) : H[X | Y ← y ; μ] =\n  ∑' (x : S), Real.negMulLog (↑↑(MeasureTheory.Measure.map X (ProbabilityTheory.cond μ (Y ⁻¹' {y}))) {x}).toReal"}
{"name":"ProbabilityTheory.condEntropy_comp_of_injective","declaration":"/-- A weaker version of the above lemma in which f is independent of Y. -/\ntheorem ProbabilityTheory.condEntropy_comp_of_injective {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] {X : Ω → S} {Y : Ω → T} [MeasurableSingletonClass S] [MeasurableSingletonClass U] (μ : MeasureTheory.Measure Ω) (hX : Measurable X) (f : S → U) (hf : Function.Injective f) : H[f ∘ X | Y ; μ] = H[X | Y ; μ]"}
{"name":"ProbabilityTheory.condEntropy_def","declaration":"theorem ProbabilityTheory.condEntropy_def {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] (X : Ω → S) (Y : Ω → T) (μ : MeasureTheory.Measure Ω) : H[X | Y ; μ] = ∫ (x : T), (fun y => H[X | Y ← y ; μ]) x ∂MeasureTheory.Measure.map Y μ"}
{"name":"ProbabilityTheory.«termI[_:_]»","declaration":"/-- The mutual information $I[X : Y]$ of two random variables is defined to be $H[X] + H[Y] - H[X ; Y]$. -/\ndef ProbabilityTheory.«termI[_:_]»  : Lean.ParserDescr"}
{"name":"ProbabilityTheory.condEntropy_prod_eq_sum","declaration":"theorem ProbabilityTheory.condEntropy_prod_eq_sum {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSingletonClass T] {T' : Type u_1} {X : Ω → S} {Y : Ω → T} {Z : Ω → T'} [MeasurableSpace T'] [MeasurableSingletonClass T'] (μ : MeasureTheory.Measure Ω) (hY : Measurable Y) (hZ : Measurable Z) [MeasureTheory.IsFiniteMeasure μ] [Fintype T] [Fintype T'] : H[X | ⟨Y, Z⟩ ; μ] =\n  Finset.sum Finset.univ fun z => (↑↑μ (Z ⁻¹' {z})).toReal * H[X | Y ; ProbabilityTheory.cond μ (Z ⁻¹' {z})]"}
{"name":"ProbabilityTheory.«termH[_|_←_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termH[_|_←_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.«termH[_]».delab","declaration":"/-- Pretty printer defined by `notation3` command. -/\ndef ProbabilityTheory.«termH[_]».delab  : Lean.PrettyPrinter.Delaborator.Delab"}
{"name":"ProbabilityTheory.entropy_cond_eq_sum_finiteRange","declaration":"theorem ProbabilityTheory.entropy_cond_eq_sum_finiteRange {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [MeasurableSpace S] [MeasurableSingletonClass S] {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] (y : T) [FiniteRange X] : H[X | Y ← y ; μ] =\n  Finset.sum (FiniteRange.toFinset X) fun x =>\n    Real.negMulLog (↑↑(MeasureTheory.Measure.map X (ProbabilityTheory.cond μ (Y ⁻¹' {y}))) {x}).toReal"}
{"name":"ProbabilityTheory.condMutualInfo_eq","declaration":"/-- $$ I[X : Y| Z] = H[X| Z] + H[Y| Z] - H[X, Y| Z].$$ -/\ntheorem ProbabilityTheory.condMutualInfo_eq {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {X : Ω → S} {Y : Ω → T} {Z : Ω → U} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange Z] : I[X : Y|Z;μ] = H[X | Z ; μ] + H[Y | Z ; μ] - H[⟨X, Y⟩ | Z ; μ]"}
{"name":"ProbabilityTheory.condEntropy_two_eq_kernel_entropy","declaration":"theorem ProbabilityTheory.condEntropy_two_eq_kernel_entropy {Ω : Type uΩ} {S : Type uS} {T : Type uT} {U : Type uU} [mΩ : MeasurableSpace Ω] [Countable S] [Countable T] [Countable U] [Nonempty S] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T] [MeasurableSpace U] [MeasurableSingletonClass S] [MeasurableSingletonClass T] [MeasurableSingletonClass U] {Z : Ω → U} {X : Ω → S} {Y : Ω → T} (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : MeasureTheory.Measure Ω) [MeasureTheory.IsProbabilityMeasure μ] [FiniteRange Y] [FiniteRange Z] : H[X | ⟨Y, Z⟩ ; μ] =\n  Hk[ProbabilityTheory.kernel.condKernel (ProbabilityTheory.condDistrib (fun a => (Y a, X a)) Z μ) ,\n    MeasureTheory.Measure.compProd (MeasureTheory.Measure.map Z μ)\n      (ProbabilityTheory.kernel.fst (ProbabilityTheory.condDistrib (fun a => (Y a, X a)) Z μ))]"}
