{"name":"IsLinearMap.app_zero₂","declaration":"theorem IsLinearMap.app_zero₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) : g 0 0 = 0"}
{"name":"IsLinearMap.neg_pull","declaration":"theorem IsLinearMap.neg_pull {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (x : X) : f (-x) = -f x"}
{"name":"IsLinearMap.sum_push","declaration":"theorem IsLinearMap.sum_push {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (ι : Type) [SciLean.IndexType ι] [SciLean.IndexType ι] (x : ι → X) :  ∑ i, f (x i) = f ( ∑ i, x i)"}
{"name":"IsLinearMap.app_zero","declaration":"theorem IsLinearMap.app_zero {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) : f 0 = 0"}
{"name":"IsLinearMap.sum_pull","declaration":"theorem IsLinearMap.sum_pull {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (ι : Type) [SciLean.IndexType ι] [SciLean.IndexType ι] (x : ι → X) : f ( ∑ i, x i) = ∑ i, f (x i)"}
{"name":"IsLinearMap.smul_pull","declaration":"theorem IsLinearMap.smul_pull {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (x : X) (k : K) : f (k • x) = k • f x"}
{"name":"IsLinearMap.sub_pull₂","declaration":"theorem IsLinearMap.sub_pull₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) (x : X) (x' : X) (y : Y) (y' : Y) : g (x - x') (y - y') = g x y - g x' y'"}
{"name":"IsLinearMap.sub_push","declaration":"theorem IsLinearMap.sub_push {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (x : X) (x' : X) : f x - f x' = f (x - x')"}
{"name":"IsLinearMap.add_pull₂","declaration":"theorem IsLinearMap.add_pull₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) (x : X) (x' : X) (y : Y) (y' : Y) : g (x + x') (y + y') = g x y + g x' y'"}
{"name":"SciLean.generateLinearMapSimp","declaration":"def SciLean.generateLinearMapSimp (ctx : Array Lean.Expr) (isLinearMap : Lean.Expr) (thrmName : Lean.Name) (isSimpAttr : optParam Bool true) (makeSimp : optParam Bool false) : Lean.MetaM Unit"}
{"name":"IsLinearMap.smul_pull₂","declaration":"theorem IsLinearMap.smul_pull₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) (x : X) (y : Y) (k : K) : g (k • x) (k • y) = k • g x y"}
{"name":"IsLinearMap.add_push","declaration":"theorem IsLinearMap.add_push {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (x : X) (x' : X) : f x + f x' = f (x + x')"}
{"name":"IsLinearMap.neg_push","declaration":"theorem IsLinearMap.neg_push {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (x : X) : -f x = f (-x)"}
{"name":"IsLinearMap.add_push₂","declaration":"theorem IsLinearMap.add_push₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) (x : X) (x' : X) (y : Y) (y' : Y) : g x y + g x' y' = g (x + x') (y + y')"}
{"name":"IsLinearMap.smul_push₂","declaration":"theorem IsLinearMap.smul_push₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) (x : X) (y : Y) (k : K) : k • g x y = g (k • x) (k • y)"}
{"name":"IsLinearMap.sub_pull","declaration":"theorem IsLinearMap.sub_pull {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (x : X) (x' : X) : f (x - x') = f x - f x'"}
{"name":"IsLinearMap.neg_pull₂","declaration":"theorem IsLinearMap.neg_pull₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) (x : X) (y : Y) : g (-x) (-y) = -g x y"}
{"name":"IsLinearMap.add_pull","declaration":"theorem IsLinearMap.add_pull {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (x : X) (x' : X) : f (x + x') = f x + f x'"}
{"name":"IsLinearMap.smul_push","declaration":"theorem IsLinearMap.smul_push {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {f : X → Y} (hf : IsLinearMap K f) (x : X) (k : K) : k • f x = f (k • x)"}
{"name":"IsLinearMap.sub_push₂","declaration":"theorem IsLinearMap.sub_push₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) (x : X) (x' : X) (y : Y) (y' : Y) : g x y - g x' y' = g (x - x') (y - y')"}
{"name":"SciLean.genLinMapSimpsNotation","declaration":"/-- This commands generates simp lemmas for given linear function.\n\nThe commands is used as\n```\n#generate_linear_map_simps thrmName\n```\nwhere `thrmName` is a name of a theorem that states that function `f` is linear i.e. `IsLinearMap K f`.\n\nThe command generates theorems\n```\n@[add_push] theorem add_push (x x' : X) : f x + f x' = f (x + x') := ...\n@[add_pull] theorem add_pull (x x' : X) : f (x + x') = f x + f x' := ...\n@[sub_push] theorem sub_push (x x' : X) : f x - f x' = f (x - x') := ...\n@[sub_pull] theorem sub_pull (x x' : X) : f (x - x') = f x - f x' := ...\n@[neg_push] theorem neg_push (x : X)    : - f x = f (- x) := ...\n@[neg_pull] theorem neg_pull (x : X)    : f (- x) = - f x := ...\n@[smul_push] theorem smul_push (x : X) (k : K) : k • f x = f (k • x) := ...\n@[smul_pull] theorem smul_pull (x : X) (k : K) : f (k • x) = k • f x := ...\n@[simp] theorem app_zero : f 0 = 0 := ...\n```\nAll the above attributes are simp attributes. The ideas is that you can propagate\narithmetic operations by calling `simp` e.g. `simp only [add_pull]`.\n\n\nThe command also supports functions jointly linear in two arguments. If we have\n`g : X → Y → Z` and `g_is_linear₂ : IsLinear K fun (x,y) => g x y` then\n```\n#generate_linear_map_simps g_is_linear₂\n```\ngenerates theorems like\n```\n@[add_push] theorem add_push (x x' : X) (y y' : Y) : g x y + g x' y' = g (x + x') (y + y') := ...\n...\n```\n\n-/\ndef SciLean.genLinMapSimpsNotation  : Lean.ParserDescr"}
{"name":"SciLean.generateLinearMapSimps","declaration":"/-- Generates bunch of simp theorems given a proof that function is linear.\n\nThe provided theorem should be in the simple form `IsLinearMap K (fun x => foo x)`\nNot in the composition form `IsLinearMap K (fun x => foo (f x))`\n-/\ndef SciLean.generateLinearMapSimps (isLinearMapTheorem : Lean.Name) : Lean.MetaM Unit"}
{"name":"IsLinearMap.neg_push₂","declaration":"theorem IsLinearMap.neg_push₂ {K : Type u'} [CommSemiring K] {X : Type u} [AddCommGroup X] [Module K X] {Y : Type v} [AddCommGroup Y] [Module K Y] {Z : Type w} [AddCommGroup Z] [Module K Z] {g : X → Y → Z} (hg : IsLinearMap K fun xy => g xy.1 xy.2) (x : X) (y : Y) : -g x y = g (-x) (-y)"}
