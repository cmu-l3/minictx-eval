{"name":"SciLean.Rand.map","declaration":"def SciLean.Rand.map {X : Type} {Y : Type} (r : SciLean.Rand X) (f : X â†’ Y) : SciLean.Rand Y"}
{"name":"SciLean.Rand.ext","declaration":"/-- Extensionality of random variable.\n\nWARNING: This theorem is inconsistent!!! The random generators `x.rand` and `y.rand` might differ.\n   We are not trying to model pseudo-random numbers. We assume that every random number\n   generator is a true random number generator. Thus the result of any probabilistic program\n   should be independent on the exact generator up to some randomness.\n\nTODO: We might quotient all the random number generators corresponding to the measure `x.â„™`  under\nthe assumption that they are all true random generators. I believe that such type would be\na singleton i.e. all the random number generators are all the same.\n-/\naxiom SciLean.Rand.ext {X : Type} (x : SciLean.Rand X) (y : SciLean.Rand X) : Erased.out x.spec = Erased.out y.spec â†’ x = y"}
{"name":"SciLean.Rand.pdf_wrt_self","declaration":"theorem SciLean.Rand.pdf_wrt_self {X : Type} {R : Type u_1} [SciLean.RealScalar R] [MeasurableSpace X] (x : SciLean.Rand X) [SciLean.Rand.LawfulRand x] : SciLean.Rand.pdf R x x.â„™ = 1"}
{"name":"SciLean.Rand.pdf","declaration":"/-- Probability density function of `x` w.r.t. the measure `Î½`. -/\ndef SciLean.Rand.pdf {X : Type} (R : Type u_1) [SciLean.RealScalar R] [MeasurableSpace X] (x : SciLean.Rand X) (Î½ : autoParam (MeasureTheory.Measure X) _autoâœ) : X â†’ R"}
{"name":"SciLean.Rand.LawfulRand.mk","declaration":"ctor SciLean.Rand.LawfulRand.mk {X : Type} {x : SciLean.Rand X} [MeasurableSpace X] (is_measure : Function.IsMeasure (Erased.out x.spec)) (is_prob : MeasureTheory.IsProbabilityMeasure x.â„™) : SciLean.Rand.LawfulRand x"}
{"name":"SciLean.Rand.â„™","declaration":"/-- Probability measure of a random variable -/\ndef SciLean.Rand.â„™ {X : Type} [MeasurableSpace X] (r : SciLean.Rand X) : MeasureTheory.Measure X"}
{"name":"SciLean.Rand.map_â„™","declaration":"theorem SciLean.Rand.map_â„™ {X : Type} {Y : Type} [MeasurableSpace X] [MeasurableSpace Y] (r : SciLean.Rand X) (f : X â†’ Y) : (r.map f).â„™ = MeasureTheory.Measure.map f r.â„™"}
{"name":"SciLean.Rand.LawfulRand.is_prob","declaration":"def SciLean.Rand.LawfulRand.is_prob {X : Type} {x : SciLean.Rand X} [MeasurableSpace X] [self : SciLean.Rand.LawfulRand x] : MeasureTheory.IsProbabilityMeasure x.â„™"}
{"name":"SciLean.Rand.ite_pdf","declaration":"theorem SciLean.Rand.ite_pdf {X : Type} {R : Type u_1} [SciLean.RealScalar R] [MeasurableSpace X] (c : Prop) [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) (Î¼ : MeasureTheory.Measure X) : SciLean.Rand.pdf R (if c then t else e) Î¼ = if c then SciLean.Rand.pdf R t Î¼ else SciLean.Rand.pdf R e Î¼"}
{"name":"SciLean.Rand.mean","declaration":"def SciLean.Rand.mean {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (r : SciLean.Rand X) : X"}
{"name":"SciLean.Rand.instMonadRand","declaration":"instance SciLean.Rand.instMonadRand  : Monad SciLean.Rand"}
{"name":"SciLean.Rand.spec","declaration":"/-- `spec` defines a probability measure by computing an expectation. This means if `x : Rand X`\ncorresponds to a probability measure `Î¼` then for `Ï† : X â†’ â„`\n```\nx.spec.out Ï† = âˆ« x, Ï† x âˆ‚Î¼\n```\n\nUsing `(Xâ†’â„)â†’â„` instead of `Measure X` for the specification of random variables has the\nadvantage that we can reuse Lean's `do` notation.\n-/\ndef SciLean.Rand.spec {X : Type} (self : SciLean.Rand X) : Erased ((X â†’ â„) â†’ â„)"}
{"name":"SciLean.Rand.E_smul","declaration":"theorem SciLean.Rand.E_smul {X : Type} {Y : Type u_1} [MeasurableSpace X] [AddCommGroup Y] [Module â„ Y] (r : SciLean.Rand X) (Ï† : X â†’ â„) (y : Y) : (r.ğ”¼ fun x' => Ï† x' â€¢ y) = r.ğ”¼ Ï† â€¢ y"}
{"name":"SciLean.Rand.instIsProbabilityMeasureâ„™","declaration":"instance SciLean.Rand.instIsProbabilityMeasureâ„™ {X : Type} [MeasurableSpace X] (x : SciLean.Rand X) [inst : SciLean.Rand.LawfulRand x] : MeasureTheory.IsProbabilityMeasure x.â„™"}
{"name":"SciLean.Rand.LawfulRand","declaration":"/-- Specification of `x : Rand X` is really saying that it is a probability measure. -/\nclass SciLean.Rand.LawfulRand {X : Type} (x : SciLean.Rand X) [MeasurableSpace X] : Type"}
{"name":"SciLean.Rand.unexpandRandCombine","declaration":"def SciLean.Rand.unexpandRandCombine  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.Rand.bind_mean","declaration":"theorem SciLean.Rand.bind_mean {X : Type} {Y : Type} [MeasurableSpace X] [MeasurableSpace Y] [AddCommGroup Y] [Module â„ Y] (x : SciLean.Rand X) (f : X â†’ SciLean.Rand Y) : SciLean.Rand.mean (x >>= f) = x.ğ”¼ fun x' => SciLean.Rand.mean (f x')"}
{"name":"SciLean.Rand.LawfulRand.is_measure","declaration":"def SciLean.Rand.LawfulRand.is_measure {X : Type} {x : SciLean.Rand X} [MeasurableSpace X] [self : SciLean.Rand.LawfulRand x] : Function.IsMeasure (Erased.out x.spec)"}
{"name":"SciLean.Rand.pure_ğ”¼","declaration":"theorem SciLean.Rand.pure_ğ”¼ {X : Type} {Y : Type u_1} [MeasurableSpace X] [AddCommGroup Y] [Module â„ Y] (x : X) (Ï† : X â†’ Y) : (pure x).ğ”¼ Ï† = Ï† x"}
{"name":"SciLean.erase_out","declaration":"theorem SciLean.erase_out {Î± : Sort u_1} (a : Î±) : Erased.out (SciLean.erase a) = a"}
{"name":"SciLean.Rand.instLawfulMonadRandInstMonadRand","declaration":"instance SciLean.Rand.instLawfulMonadRandInstMonadRand  : LawfulMonad SciLean.Rand"}
{"name":"SciLean.Rand.E_zero","declaration":"theorem SciLean.Rand.E_zero {X : Type} [MeasurableSpace X] {U : Type u_1} [AddCommGroup U] [Module â„ U] (r : SciLean.Rand X) : (r.ğ”¼ fun x => 0) = 0"}
{"name":"SciLean.Rand.combine_pdf","declaration":"theorem SciLean.Rand.combine_pdf {X : Type} {R : Type} [SciLean.RealScalar R] [MeasurableSpace X] [MeasureTheory.MeasureSpace R] (x : SciLean.Rand X) (y : SciLean.Rand X) (Î¼ : MeasureTheory.Measure X) (Î¸ : R) : SciLean.Rand.pdf R (x +[Î¸] y) Î¼ = fun x' => (1 - Î¸) * SciLean.Rand.pdf R x Î¼ x' + Î¸ * SciLean.Rand.pdf R y Î¼ x'"}
{"name":"SciLean.Rand.instHAddRand_1","declaration":"instance SciLean.Rand.instHAddRand_1 {X : Type} [Add X] : HAdd (SciLean.Rand X) X (SciLean.Rand X)"}
{"name":"SciLean.Rand.fst","declaration":"/-- Marginal distribution for the first component of a pair. -/\ndef SciLean.Rand.fst {X : Type} {Y : Type} (r : SciLean.Rand (X Ã— Y)) : SciLean.Rand X"}
{"name":"SciLean.uniformI","declaration":"def SciLean.uniformI (R : Type) [SciLean.RealScalar R] [MeasureTheory.MeasureSpace R] : SciLean.Rand R"}
{"name":"SciLean.Rand.mean_add","declaration":"theorem SciLean.Rand.mean_add {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (x : SciLean.Rand X) (x' : X) : SciLean.Rand.mean x + x' = SciLean.Rand.mean (x + x')"}
{"name":"SciLean.Rand.instHAddRand","declaration":"instance SciLean.Rand.instHAddRand {X : Type} [Add X] : HAdd X (SciLean.Rand X) (SciLean.Rand X)"}
{"name":"SciLean.Rand.rand","declaration":"/-- `rand` is a pseudo randon number generator implemented using the \"Standard\" number generator\n-/\ndef SciLean.Rand.rand {X : Type} (self : SciLean.Rand X) : StateM StdGen X"}
{"name":"SciLean.erase","declaration":"def SciLean.erase {Î± : Sort u_1} (a : Î±) : Erased Î±"}
{"name":"Function.IsMeasure","declaration":"def Function.IsMeasure {X : Type u_1} [MeasurableSpace X] (F : (X â†’ â„) â†’ â„) : Prop"}
{"name":"SciLean.Rand","declaration":"/-- `x : Rand X` is a random variable of type `X`\n\nYou can:\n  - generate sample with `x.get : IO X`\n  - get probability measure with `x.â„™ : Measure X`\n\nThe internal fields `spec` and `rand` are just an internal implementation of `Rand` and should not\nbe accessed by normal users.\n\nTODO: Hide implementation using quotients or something like that\n-/\nstructure SciLean.Rand (X : Type) : Type"}
{"name":"SciLean.Rand.swap_bind","declaration":"theorem SciLean.Rand.swap_bind {X : Type} {Y : Type} {Z : Type} (f : X â†’ Y â†’ Z) (x : SciLean.Rand X) (y : SciLean.Rand Y) : (do\n    let x' â† x\n    let y' â† y\n    pure (f x' y')) =\n  do\n  let y' â† y\n  let x' â† x\n  pure (f x' y')"}
{"name":"SciLean.Rand.Â«term_+[_]_Â»","declaration":"/-- `x +[Î¸] y` return random variable `(1-Î¸)*x + Î¸*y`.\nIn other words\n- `x` is generated with probability `1-Î¸`\n- `y` is generated with probability `Î¸` -/\ndef SciLean.Rand.Â«term_+[_]_Â»  : Lean.TrailingParserDescr"}
{"name":"SciLean.Rand.expectedValue_as_mean","declaration":"theorem SciLean.Rand.expectedValue_as_mean {X : Type} {Y : Type} [MeasurableSpace X] [MeasurableSpace Y] [AddCommGroup Y] [Module â„ Y] (x : SciLean.Rand X) (Ï† : X â†’ Y) : x.ğ”¼ Ï† = SciLean.Rand.mean (x.map Ï†)"}
{"name":"SciLean.Rand.snd","declaration":"/-- Marginal distribution for the second component of a pair. -/\ndef SciLean.Rand.snd {X : Type} {Y : Type} (r : SciLean.Rand (X Ã— Y)) : SciLean.Rand Y"}
{"name":"SciLean.Rand.pure_mean","declaration":"theorem SciLean.Rand.pure_mean {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (x : X) : SciLean.Rand.mean (pure x) = x"}
{"name":"SciLean.Rand.bind_E","declaration":"theorem SciLean.Rand.bind_E {X : Type} {Y : Type} {Z : Type u_1} [MeasurableSpace X] [MeasurableSpace Y] [AddCommGroup Z] [Module â„ Z] (r : SciLean.Rand X) (f : X â†’ SciLean.Rand Y) (Ï† : Y â†’ Z) : (r >>= f).ğ”¼ Ï† = r.ğ”¼ fun x' => (f x').ğ”¼ Ï†"}
{"name":"SciLean.Rand.mk","declaration":"ctor SciLean.Rand.mk {X : Type} (spec : Erased ((X â†’ â„) â†’ â„)) (rand : StateM StdGen X) : SciLean.Rand X"}
{"name":"SciLean.Rand.get","declaration":"/-- Generate rundom number using IO randomness -/\ndef SciLean.Rand.get {X : Type} (x : SciLean.Rand X) : IO X"}
{"name":"SciLean.Rand.combine","declaration":"def SciLean.Rand.combine {X : Type} {R : Type} [SciLean.RealScalar R] [MeasurableSpace X] [MeasureTheory.MeasureSpace R] (x : SciLean.Rand X) (y : SciLean.Rand X) (Î¸ : R) : SciLean.Rand X"}
{"name":"SciLean.Rand.pure_â„™","declaration":"theorem SciLean.Rand.pure_â„™ {X : Type} [MeasurableSpace X] (x : X) : (pure x).â„™ = MeasureTheory.Measure.dirac x"}
{"name":"SciLean.Rand.reparameterize","declaration":"theorem SciLean.Rand.reparameterize {X : Type} {Y : Type} {Z : Type u_1} [MeasurableSpace X] [MeasurableSpace Y] [AddCommGroup Z] [Module â„ Z] [Nonempty X] (f : X â†’ Y) (hf : Function.Injective f) {r : SciLean.Rand X} {Ï† : X â†’ Z} : r.ğ”¼ Ï† =\n  let invf := Function.invFun f;\n  (r.map f).ğ”¼ fun y => Ï† (invf y)"}
{"name":"SciLean.Rand.bind_pdf","declaration":"theorem SciLean.Rand.bind_pdf {X : Type} {Y : Type} {R : Type u_1} [SciLean.RealScalar R] [MeasurableSpace X] [MeasurableSpace Y] (Î½ : MeasureTheory.Measure Y) (x : SciLean.Rand X) (f : X â†’ SciLean.Rand Y) : SciLean.Rand.pdf R (x >>= f) Î½ = fun y => âˆ« (x' : X), SciLean.Rand.pdf R (f x') Î½ y âˆ‚x.â„™"}
{"name":"SciLean.Rand.mean_add'","declaration":"theorem SciLean.Rand.mean_add' {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (x : SciLean.Rand X) (x' : X) : x' + SciLean.Rand.mean x = SciLean.Rand.mean (x' + x)"}
{"name":"SciLean.Rand.E_add","declaration":"theorem SciLean.Rand.E_add {X : Type} [MeasurableSpace X] {U : Type u_1} [AddCommGroup U] [Module â„ U] (r : SciLean.Rand X) (Ï† : X â†’ U) (Ïˆ : X â†’ U) (hÏ† : SciLean.CIntegrable Ï† r.â„™) (hÏˆ : SciLean.CIntegrable Ïˆ r.â„™) : (r.ğ”¼ fun x => Ï† x + Ïˆ x) = r.ğ”¼ Ï† + r.ğ”¼ Ïˆ"}
{"name":"SciLean.Rand.ğ”¼","declaration":"def SciLean.Rand.ğ”¼ {X : Type} {Y : Type u_1} [MeasurableSpace X] [AddCommGroup Y] [Module â„ Y] (r : SciLean.Rand X) (Ï† : X â†’ Y) : Y"}
