{"name":"SciLean.Rand.map","declaration":"def SciLean.Rand.map {X : Type} {Y : Type} (r : SciLean.Rand X) (f : X → Y) : SciLean.Rand Y"}
{"name":"SciLean.Rand.ext","declaration":"/-- Extensionality of random variable.\n\nWARNING: This theorem is inconsistent!!! The random generators `x.rand` and `y.rand` might differ.\n   We are not trying to model pseudo-random numbers. We assume that every random number\n   generator is a true random number generator. Thus the result of any probabilistic program\n   should be independent on the exact generator up to some randomness.\n\nTODO: We might quotient all the random number generators corresponding to the measure `x.ℙ`  under\nthe assumption that they are all true random generators. I believe that such type would be\na singleton i.e. all the random number generators are all the same.\n-/\naxiom SciLean.Rand.ext {X : Type} (x : SciLean.Rand X) (y : SciLean.Rand X) : Erased.out x.spec = Erased.out y.spec → x = y"}
{"name":"SciLean.Rand.pdf_wrt_self","declaration":"theorem SciLean.Rand.pdf_wrt_self {X : Type} {R : Type u_1} [SciLean.RealScalar R] [MeasurableSpace X] (x : SciLean.Rand X) [SciLean.Rand.LawfulRand x] : SciLean.Rand.pdf R x x.ℙ = 1"}
{"name":"SciLean.Rand.pdf","declaration":"/-- Probability density function of `x` w.r.t. the measure `ν`. -/\ndef SciLean.Rand.pdf {X : Type} (R : Type u_1) [SciLean.RealScalar R] [MeasurableSpace X] (x : SciLean.Rand X) (ν : autoParam (MeasureTheory.Measure X) _auto✝) : X → R"}
{"name":"SciLean.Rand.LawfulRand.mk","declaration":"ctor SciLean.Rand.LawfulRand.mk {X : Type} {x : SciLean.Rand X} [MeasurableSpace X] (is_measure : Function.IsMeasure (Erased.out x.spec)) (is_prob : MeasureTheory.IsProbabilityMeasure x.ℙ) : SciLean.Rand.LawfulRand x"}
{"name":"SciLean.Rand.ℙ","declaration":"/-- Probability measure of a random variable -/\ndef SciLean.Rand.ℙ {X : Type} [MeasurableSpace X] (r : SciLean.Rand X) : MeasureTheory.Measure X"}
{"name":"SciLean.Rand.map_ℙ","declaration":"theorem SciLean.Rand.map_ℙ {X : Type} {Y : Type} [MeasurableSpace X] [MeasurableSpace Y] (r : SciLean.Rand X) (f : X → Y) : (r.map f).ℙ = MeasureTheory.Measure.map f r.ℙ"}
{"name":"SciLean.Rand.LawfulRand.is_prob","declaration":"def SciLean.Rand.LawfulRand.is_prob {X : Type} {x : SciLean.Rand X} [MeasurableSpace X] [self : SciLean.Rand.LawfulRand x] : MeasureTheory.IsProbabilityMeasure x.ℙ"}
{"name":"SciLean.Rand.ite_pdf","declaration":"theorem SciLean.Rand.ite_pdf {X : Type} {R : Type u_1} [SciLean.RealScalar R] [MeasurableSpace X] (c : Prop) [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) (μ : MeasureTheory.Measure X) : SciLean.Rand.pdf R (if c then t else e) μ = if c then SciLean.Rand.pdf R t μ else SciLean.Rand.pdf R e μ"}
{"name":"SciLean.Rand.mean","declaration":"def SciLean.Rand.mean {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (r : SciLean.Rand X) : X"}
{"name":"SciLean.Rand.instMonadRand","declaration":"instance SciLean.Rand.instMonadRand  : Monad SciLean.Rand"}
{"name":"SciLean.Rand.spec","declaration":"/-- `spec` defines a probability measure by computing an expectation. This means if `x : Rand X`\ncorresponds to a probability measure `μ` then for `φ : X → ℝ`\n```\nx.spec.out φ = ∫ x, φ x ∂μ\n```\n\nUsing `(X→ℝ)→ℝ` instead of `Measure X` for the specification of random variables has the\nadvantage that we can reuse Lean's `do` notation.\n-/\ndef SciLean.Rand.spec {X : Type} (self : SciLean.Rand X) : Erased ((X → ℝ) → ℝ)"}
{"name":"SciLean.Rand.E_smul","declaration":"theorem SciLean.Rand.E_smul {X : Type} {Y : Type u_1} [MeasurableSpace X] [AddCommGroup Y] [Module ℝ Y] (r : SciLean.Rand X) (φ : X → ℝ) (y : Y) : (r.𝔼 fun x' => φ x' • y) = r.𝔼 φ • y"}
{"name":"SciLean.Rand.instIsProbabilityMeasureℙ","declaration":"instance SciLean.Rand.instIsProbabilityMeasureℙ {X : Type} [MeasurableSpace X] (x : SciLean.Rand X) [inst : SciLean.Rand.LawfulRand x] : MeasureTheory.IsProbabilityMeasure x.ℙ"}
{"name":"SciLean.Rand.LawfulRand","declaration":"/-- Specification of `x : Rand X` is really saying that it is a probability measure. -/\nclass SciLean.Rand.LawfulRand {X : Type} (x : SciLean.Rand X) [MeasurableSpace X] : Type"}
{"name":"SciLean.Rand.unexpandRandCombine","declaration":"def SciLean.Rand.unexpandRandCombine  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.Rand.bind_mean","declaration":"theorem SciLean.Rand.bind_mean {X : Type} {Y : Type} [MeasurableSpace X] [MeasurableSpace Y] [AddCommGroup Y] [Module ℝ Y] (x : SciLean.Rand X) (f : X → SciLean.Rand Y) : SciLean.Rand.mean (x >>= f) = x.𝔼 fun x' => SciLean.Rand.mean (f x')"}
{"name":"SciLean.Rand.LawfulRand.is_measure","declaration":"def SciLean.Rand.LawfulRand.is_measure {X : Type} {x : SciLean.Rand X} [MeasurableSpace X] [self : SciLean.Rand.LawfulRand x] : Function.IsMeasure (Erased.out x.spec)"}
{"name":"SciLean.Rand.pure_𝔼","declaration":"theorem SciLean.Rand.pure_𝔼 {X : Type} {Y : Type u_1} [MeasurableSpace X] [AddCommGroup Y] [Module ℝ Y] (x : X) (φ : X → Y) : (pure x).𝔼 φ = φ x"}
{"name":"SciLean.erase_out","declaration":"theorem SciLean.erase_out {α : Sort u_1} (a : α) : Erased.out (SciLean.erase a) = a"}
{"name":"SciLean.Rand.instLawfulMonadRandInstMonadRand","declaration":"instance SciLean.Rand.instLawfulMonadRandInstMonadRand  : LawfulMonad SciLean.Rand"}
{"name":"SciLean.Rand.E_zero","declaration":"theorem SciLean.Rand.E_zero {X : Type} [MeasurableSpace X] {U : Type u_1} [AddCommGroup U] [Module ℝ U] (r : SciLean.Rand X) : (r.𝔼 fun x => 0) = 0"}
{"name":"SciLean.Rand.combine_pdf","declaration":"theorem SciLean.Rand.combine_pdf {X : Type} {R : Type} [SciLean.RealScalar R] [MeasurableSpace X] [MeasureTheory.MeasureSpace R] (x : SciLean.Rand X) (y : SciLean.Rand X) (μ : MeasureTheory.Measure X) (θ : R) : SciLean.Rand.pdf R (x +[θ] y) μ = fun x' => (1 - θ) * SciLean.Rand.pdf R x μ x' + θ * SciLean.Rand.pdf R y μ x'"}
{"name":"SciLean.Rand.instHAddRand_1","declaration":"instance SciLean.Rand.instHAddRand_1 {X : Type} [Add X] : HAdd (SciLean.Rand X) X (SciLean.Rand X)"}
{"name":"SciLean.Rand.fst","declaration":"/-- Marginal distribution for the first component of a pair. -/\ndef SciLean.Rand.fst {X : Type} {Y : Type} (r : SciLean.Rand (X × Y)) : SciLean.Rand X"}
{"name":"SciLean.uniformI","declaration":"def SciLean.uniformI (R : Type) [SciLean.RealScalar R] [MeasureTheory.MeasureSpace R] : SciLean.Rand R"}
{"name":"SciLean.Rand.mean_add","declaration":"theorem SciLean.Rand.mean_add {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (x : SciLean.Rand X) (x' : X) : SciLean.Rand.mean x + x' = SciLean.Rand.mean (x + x')"}
{"name":"SciLean.Rand.instHAddRand","declaration":"instance SciLean.Rand.instHAddRand {X : Type} [Add X] : HAdd X (SciLean.Rand X) (SciLean.Rand X)"}
{"name":"SciLean.Rand.rand","declaration":"/-- `rand` is a pseudo randon number generator implemented using the \"Standard\" number generator\n-/\ndef SciLean.Rand.rand {X : Type} (self : SciLean.Rand X) : StateM StdGen X"}
{"name":"SciLean.erase","declaration":"def SciLean.erase {α : Sort u_1} (a : α) : Erased α"}
{"name":"Function.IsMeasure","declaration":"def Function.IsMeasure {X : Type u_1} [MeasurableSpace X] (F : (X → ℝ) → ℝ) : Prop"}
{"name":"SciLean.Rand","declaration":"/-- `x : Rand X` is a random variable of type `X`\n\nYou can:\n  - generate sample with `x.get : IO X`\n  - get probability measure with `x.ℙ : Measure X`\n\nThe internal fields `spec` and `rand` are just an internal implementation of `Rand` and should not\nbe accessed by normal users.\n\nTODO: Hide implementation using quotients or something like that\n-/\nstructure SciLean.Rand (X : Type) : Type"}
{"name":"SciLean.Rand.swap_bind","declaration":"theorem SciLean.Rand.swap_bind {X : Type} {Y : Type} {Z : Type} (f : X → Y → Z) (x : SciLean.Rand X) (y : SciLean.Rand Y) : (do\n    let x' ← x\n    let y' ← y\n    pure (f x' y')) =\n  do\n  let y' ← y\n  let x' ← x\n  pure (f x' y')"}
{"name":"SciLean.Rand.«term_+[_]_»","declaration":"/-- `x +[θ] y` return random variable `(1-θ)*x + θ*y`.\nIn other words\n- `x` is generated with probability `1-θ`\n- `y` is generated with probability `θ` -/\ndef SciLean.Rand.«term_+[_]_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.Rand.expectedValue_as_mean","declaration":"theorem SciLean.Rand.expectedValue_as_mean {X : Type} {Y : Type} [MeasurableSpace X] [MeasurableSpace Y] [AddCommGroup Y] [Module ℝ Y] (x : SciLean.Rand X) (φ : X → Y) : x.𝔼 φ = SciLean.Rand.mean (x.map φ)"}
{"name":"SciLean.Rand.snd","declaration":"/-- Marginal distribution for the second component of a pair. -/\ndef SciLean.Rand.snd {X : Type} {Y : Type} (r : SciLean.Rand (X × Y)) : SciLean.Rand Y"}
{"name":"SciLean.Rand.pure_mean","declaration":"theorem SciLean.Rand.pure_mean {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (x : X) : SciLean.Rand.mean (pure x) = x"}
{"name":"SciLean.Rand.bind_E","declaration":"theorem SciLean.Rand.bind_E {X : Type} {Y : Type} {Z : Type u_1} [MeasurableSpace X] [MeasurableSpace Y] [AddCommGroup Z] [Module ℝ Z] (r : SciLean.Rand X) (f : X → SciLean.Rand Y) (φ : Y → Z) : (r >>= f).𝔼 φ = r.𝔼 fun x' => (f x').𝔼 φ"}
{"name":"SciLean.Rand.mk","declaration":"ctor SciLean.Rand.mk {X : Type} (spec : Erased ((X → ℝ) → ℝ)) (rand : StateM StdGen X) : SciLean.Rand X"}
{"name":"SciLean.Rand.get","declaration":"/-- Generate rundom number using IO randomness -/\ndef SciLean.Rand.get {X : Type} (x : SciLean.Rand X) : IO X"}
{"name":"SciLean.Rand.combine","declaration":"def SciLean.Rand.combine {X : Type} {R : Type} [SciLean.RealScalar R] [MeasurableSpace X] [MeasureTheory.MeasureSpace R] (x : SciLean.Rand X) (y : SciLean.Rand X) (θ : R) : SciLean.Rand X"}
{"name":"SciLean.Rand.pure_ℙ","declaration":"theorem SciLean.Rand.pure_ℙ {X : Type} [MeasurableSpace X] (x : X) : (pure x).ℙ = MeasureTheory.Measure.dirac x"}
{"name":"SciLean.Rand.reparameterize","declaration":"theorem SciLean.Rand.reparameterize {X : Type} {Y : Type} {Z : Type u_1} [MeasurableSpace X] [MeasurableSpace Y] [AddCommGroup Z] [Module ℝ Z] [Nonempty X] (f : X → Y) (hf : Function.Injective f) {r : SciLean.Rand X} {φ : X → Z} : r.𝔼 φ =\n  let invf := Function.invFun f;\n  (r.map f).𝔼 fun y => φ (invf y)"}
{"name":"SciLean.Rand.bind_pdf","declaration":"theorem SciLean.Rand.bind_pdf {X : Type} {Y : Type} {R : Type u_1} [SciLean.RealScalar R] [MeasurableSpace X] [MeasurableSpace Y] (ν : MeasureTheory.Measure Y) (x : SciLean.Rand X) (f : X → SciLean.Rand Y) : SciLean.Rand.pdf R (x >>= f) ν = fun y => ∫ (x' : X), SciLean.Rand.pdf R (f x') ν y ∂x.ℙ"}
{"name":"SciLean.Rand.mean_add'","declaration":"theorem SciLean.Rand.mean_add' {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (x : SciLean.Rand X) (x' : X) : x' + SciLean.Rand.mean x = SciLean.Rand.mean (x' + x)"}
{"name":"SciLean.Rand.E_add","declaration":"theorem SciLean.Rand.E_add {X : Type} [MeasurableSpace X] {U : Type u_1} [AddCommGroup U] [Module ℝ U] (r : SciLean.Rand X) (φ : X → U) (ψ : X → U) (hφ : SciLean.CIntegrable φ r.ℙ) (hψ : SciLean.CIntegrable ψ r.ℙ) : (r.𝔼 fun x => φ x + ψ x) = r.𝔼 φ + r.𝔼 ψ"}
{"name":"SciLean.Rand.𝔼","declaration":"def SciLean.Rand.𝔼 {X : Type} {Y : Type u_1} [MeasurableSpace X] [AddCommGroup Y] [Module ℝ Y] (r : SciLean.Rand X) (φ : X → Y) : Y"}
