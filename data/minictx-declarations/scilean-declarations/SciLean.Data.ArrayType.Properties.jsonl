{"name":"GetElem.getElem.arg_cont.revCDerivProj_rule","declaration":"theorem GetElem.getElem.arg_cont.revCDerivProj_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [DecidableEq Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] {J : Type u_1} {ElemJ : J → Type u_2} [SciLean.StructType Elem J ElemJ] [SciLean.IndexType J] [SciLean.LawfulIndexType J] [DecidableEq J] [(j : J) → SciLean.SemiInnerProductSpace K (ElemJ j)] [SciLean.SemiInnerProductSpaceStruct K Elem J ElemJ] (f : X → Cont) (idx : Idx) (hf : SciLean.HasAdjDiff K f) : (SciLean.revDerivProj K J fun x => (f x)[idx]) = fun x =>\n  let ydf := SciLean.revDerivProj K (Idx × J) f x;\n  (ydf.1[idx], fun j delem => ydf.2 (idx, j) delem)"}
{"name":"LeanColls.Indexed.set.arg_contelem.IsSmoothLinearMap_rule_simple","declaration":"theorem LeanColls.Indexed.set.arg_contelem.IsSmoothLinearMap_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [SciLean.Vec K Elem] (idx : Idx) : SciLean.IsSmoothLinearMap K fun x =>\n  match x with\n  | (cont, elem) => LeanColls.Indexed.set cont idx elem"}
{"name":"LeanColls.Indexed.get.arg_cont.IsContinuousLinearMap_rule_simple","declaration":"theorem LeanColls.Indexed.get.arg_cont.IsContinuousLinearMap_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [NormedAddCommGroup Elem] [NormedSpace K Elem] (idx : Idx) : SciLean.IsContinuousLinearMap K fun cont => cont[idx]"}
{"name":"LeanColls.Indexed.ofFn.arg_cont.revCDerivProjUpdate_rule","declaration":"theorem LeanColls.Indexed.ofFn.arg_cont.revCDerivProjUpdate_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [DecidableEq Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (f : X → Idx → Elem) (hf : SciLean.HasAdjDiff K f) : (SciLean.revDerivProjUpdate K Idx fun x => LeanColls.Indexed.ofFn (f x)) = fun x =>\n  let fdf := SciLean.revDerivProjUpdate K Idx f x;\n  (LeanColls.Indexed.ofFn fdf.1, fdf.2)"}
{"name":"GetElem.getElem.arg_cont.revCDeriv_rule","declaration":"theorem GetElem.getElem.arg_cont.revCDeriv_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [DecidableEq Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (f : X → Cont) (idx : Idx) (hf : SciLean.HasAdjDiff K f) : (SciLean.revDeriv K fun x => (f x)[idx]) = fun x =>\n  let ydf := SciLean.revDerivProj K Idx f x;\n  (ydf.1[idx], fun delem => ydf.2 idx delem)"}
{"name":"LeanColls.Indexed.set.arg_contelem.revCDerivUpdate_rule","declaration":"theorem LeanColls.Indexed.set.arg_contelem.revCDerivUpdate_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (cont : X → Cont) (idx : Idx) (elem : X → Elem) (hcont : SciLean.HasAdjDiff K cont) (helem : SciLean.HasAdjDiff K elem) : (SciLean.revDerivUpdate K fun x => LeanColls.Indexed.set (cont x) idx (elem x)) = fun x =>\n  let cdc := SciLean.revDerivUpdate K cont x;\n  let ede := SciLean.revDerivUpdate K elem x;\n  (LeanColls.Indexed.set cdc.1 idx ede.1, fun dc dx =>\n    let dci := dc[idx];\n    let dc := LeanColls.Indexed.set dc idx 0;\n    ede.2 dci (cdc.2 dc dx))"}
{"name":"LeanColls.Indexed.ofFn.arg_cont.revCDeriv_rule","declaration":"theorem LeanColls.Indexed.ofFn.arg_cont.revCDeriv_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (f : X → Idx → Elem) (hf : SciLean.HasAdjDiff K f) : (SciLean.revDeriv K fun x => LeanColls.Indexed.ofFn (f x)) = fun x =>\n  let fdf := SciLean.revDeriv K f x;\n  (LeanColls.Indexed.ofFn fdf.1, fun dcont => fdf.2 fun idx => dcont[idx])"}
{"name":"GetElem.getElem.arg_cont.HasSemiAdjoint_rule_simple","declaration":"theorem GetElem.getElem.arg_cont.HasSemiAdjoint_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [SciLean.SemiInnerProductSpace K Elem] (idx : Idx) : SciLean.HasSemiAdjoint K fun cont => cont[idx]"}
{"name":"LeanColls.Indexed.ofFn.arg_cont.HasSemiAdjoint_rule_simple","declaration":"theorem LeanColls.Indexed.ofFn.arg_cont.HasSemiAdjoint_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [SciLean.SemiInnerProductSpace K Elem] : SciLean.HasSemiAdjoint K fun f => LeanColls.Indexed.ofFn f"}
{"name":"LeanColls.Indexed.set.arg_contelem.revCDerivProjUpdate_rule","declaration":"theorem LeanColls.Indexed.set.arg_contelem.revCDerivProjUpdate_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [DecidableEq Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (cont : X → Cont) (idx : Idx) (elem : X → Elem) (hcont : SciLean.HasAdjDiff K cont) (helem : SciLean.HasAdjDiff K elem) : (SciLean.revDerivProjUpdate K Idx fun x => LeanColls.Indexed.set (cont x) idx (elem x)) = fun x =>\n  let cdc := SciLean.revDerivProjUpdate K Idx cont x;\n  let ede := SciLean.revDerivUpdate K elem x;\n  (LeanColls.Indexed.set cdc.1 idx ede.1, fun i delem dx => if i = idx then ede.2 delem dx else cdc.2 i delem dx)"}
{"name":"LeanColls.Indexed.ofFn.arg_cont.revCDerivProj_rule","declaration":"theorem LeanColls.Indexed.ofFn.arg_cont.revCDerivProj_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [DecidableEq Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (f : X → Idx → Elem) (hf : SciLean.HasAdjDiff K f) : (SciLean.revDerivProj K Idx fun x => LeanColls.Indexed.ofFn (f x)) = fun x =>\n  let fdf := SciLean.revDerivProj K Idx f x;\n  (LeanColls.Indexed.ofFn fdf.1, fdf.2)"}
{"name":"LeanColls.Indexed.ofFn.arg_f.IsSmoothLinearMap_rule_simple","declaration":"theorem LeanColls.Indexed.ofFn.arg_f.IsSmoothLinearMap_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [SciLean.Vec K Elem] (idx : Idx) : SciLean.IsSmoothLinearMap K fun f => LeanColls.Indexed.ofFn f"}
{"name":"LeanColls.Indexed.set.arg_contelem.IsContinuousLinearMap_rule_simple","declaration":"theorem LeanColls.Indexed.set.arg_contelem.IsContinuousLinearMap_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [NormedAddCommGroup Elem] [NormedSpace K Elem] {idx : Idx} : SciLean.IsContinuousLinearMap K fun x =>\n  match x with\n  | (cont, elem) => LeanColls.Indexed.set cont idx elem"}
{"name":"LeanColls.Indexed.set.arg_cont.semiAdjoint_rule_simple","declaration":"theorem LeanColls.Indexed.set.arg_cont.semiAdjoint_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [SciLean.SemiInnerProductSpace K Elem] (idx : Idx) : (SciLean.semiAdjoint K fun x =>\n    match x with\n    | (cont, elem) => LeanColls.Indexed.set cont idx elem) =\n  fun cont' => (LeanColls.Indexed.set cont' idx 0, cont'[idx])"}
{"name":"LeanColls.Indexed.set.arg_contelem.revCDeriv_rule","declaration":"theorem LeanColls.Indexed.set.arg_contelem.revCDeriv_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (cont : X → Cont) (idx : Idx) (elem : X → Elem) (hcont : SciLean.HasAdjDiff K cont) (helem : SciLean.HasAdjDiff K elem) : (SciLean.revDeriv K fun x => LeanColls.Indexed.set (cont x) idx (elem x)) = fun x =>\n  let cdc := SciLean.revDeriv K cont x;\n  let ede := SciLean.revDerivUpdate K elem x;\n  (LeanColls.Indexed.set cdc.1 idx ede.1, fun dc =>\n    let dci := dc[idx];\n    let dc := LeanColls.Indexed.set dc idx 0;\n    ede.2 dci (cdc.2 dc))"}
{"name":"LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule","declaration":"theorem LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [DecidableEq Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (cont : X → Cont) (idx : Idx) (elem : X → Elem) (hcont : SciLean.HasAdjDiff K cont) (helem : SciLean.HasAdjDiff K elem) : (SciLean.revDerivProj K Idx fun x => LeanColls.Indexed.set (cont x) idx (elem x)) = fun x =>\n  let cdc := SciLean.revDerivProj K Idx cont x;\n  let ede := SciLean.revDeriv K elem x;\n  (LeanColls.Indexed.set cdc.1 idx ede.1, fun i delem => if i = idx then ede.2 delem else cdc.2 i delem)"}
{"name":"LeanColls.Indexed.ofFn.arg_f.IsLinearMap_rule_simple","declaration":"theorem LeanColls.Indexed.ofFn.arg_f.IsLinearMap_rule_simple {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] {R : Type} [CommSemiring R] [AddCommGroup Elem] [Module R Elem] : IsLinearMap R fun f => LeanColls.Indexed.ofFn f"}
{"name":"LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple","declaration":"theorem LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] {R : Type} [CommSemiring R] [AddCommGroup Elem] [Module R Elem] (idx : Idx) : IsLinearMap R fun x =>\n  match x with\n  | (cont, elem) => LeanColls.Indexed.set cont idx elem"}
{"name":"LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple","declaration":"theorem LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [SciLean.SemiInnerProductSpace K Elem] : (SciLean.semiAdjoint K fun f => LeanColls.Indexed.ofFn f) = fun cont idx => cont[idx]"}
{"name":"GetElem.getElem.arg_cont.revCDerivUpdate_rule","declaration":"theorem GetElem.getElem.arg_cont.revCDerivUpdate_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [DecidableEq Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (f : X → Cont) (idx : Idx) (hf : SciLean.HasAdjDiff K f) : (SciLean.revDerivUpdate K fun x => (f x)[idx]) = fun x =>\n  let ydf := SciLean.revDerivProjUpdate K Idx f x;\n  (ydf.1[idx], fun delem dx => ydf.2 idx delem dx)"}
{"name":"LeanColls.Indexed.set.arg_cont.HasSemiAdjoint_rule_simple","declaration":"theorem LeanColls.Indexed.set.arg_cont.HasSemiAdjoint_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [SciLean.SemiInnerProductSpace K Elem] (idx : Idx) : SciLean.HasSemiAdjoint K fun x =>\n  match x with\n  | (cont, elem) => LeanColls.Indexed.set cont idx elem"}
{"name":"GetElem.getElem.arg_cont.IsSmoothLinearMap_rule_simple","declaration":"theorem GetElem.getElem.arg_cont.IsSmoothLinearMap_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [SciLean.Vec K Elem] (idx : Idx) : SciLean.IsSmoothLinearMap K fun xs => xs[idx]"}
{"name":"LeanColls.Indexed.get.arg_cont.IsLinearMap_rule_simple","declaration":"theorem LeanColls.Indexed.get.arg_cont.IsLinearMap_rule_simple {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] {R : Type} [CommSemiring R] [AddCommGroup Elem] [Module R Elem] (idx : Idx) : IsLinearMap R fun xs => xs[idx]"}
{"name":"GetElem.getElem.arg_cont.semiAdjoint_rule_simple","declaration":"theorem GetElem.getElem.arg_cont.semiAdjoint_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [DecidableEq Idx] [SciLean.SemiInnerProductSpace K Elem] (idx : Idx) : (SciLean.semiAdjoint K fun cont => cont[idx]) = fun elem => SciLean.oneHot idx elem"}
{"name":"LeanColls.Indexed.ofFn.arg_cont.revCDerivUpdate_rule","declaration":"theorem LeanColls.Indexed.ofFn.arg_cont.revCDerivUpdate_rule {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] {X : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Elem] (f : X → Idx → Elem) (hf : SciLean.HasAdjDiff K f) : (SciLean.revDerivUpdate K fun x => LeanColls.Indexed.ofFn (f x)) = fun x =>\n  let fdf := SciLean.revDerivUpdate K f x;\n  (LeanColls.Indexed.ofFn fdf.1, fun dcont dx => fdf.2 (fun idx => dcont[idx]) dx)"}
{"name":"LeanColls.Indexed.ofFn.arg_f.IsContinuousLinearMap_rule_simple","declaration":"theorem LeanColls.Indexed.ofFn.arg_f.IsContinuousLinearMap_rule_simple {K : Type} [RCLike K] {Cont : Type} {Idx : outParam Type} {Elem : outParam Type} [SciLean.ArrayType Cont Idx Elem] [SciLean.IndexType Idx] [NormedAddCommGroup Elem] [NormedSpace K Elem] : SciLean.IsContinuousLinearMap K fun f => LeanColls.Indexed.ofFn f"}
