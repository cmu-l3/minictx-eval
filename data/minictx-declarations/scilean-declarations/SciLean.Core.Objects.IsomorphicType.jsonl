{"name":"SciLean.instIsomorphicTypeForAllForAll","declaration":"instance SciLean.instIsomorphicTypeForAllForAll {α : Type u_1} {β : Type u_2} {α' : outParam (Type u_3)} {β' : outParam (Type u_4)} (tag : Lean.Name) [SciLean.IsomorphicType tag α α'] [SciLean.IsomorphicType tag β β'] : SciLean.IsomorphicType tag (α → β) (α' → β')"}
{"name":"SciLean.isomorph.ext","declaration":"theorem SciLean.isomorph.ext {α : Type u_2} {α' : outParam (Type u_1)} (tag : Lean.Name) [SciLean.IsomorphicType tag α α'] (a : α) (b : α) : (SciLean.IsomorphicType.equiv tag) a = (SciLean.IsomorphicType.equiv tag) b → a = b"}
{"name":"SciLean.invIsomorph","declaration":"def SciLean.invIsomorph {α : Type u_1} {β : Type u_2} {α' : outParam (Type u_3)} {β' : outParam (Type u_4)} (tag : Lean.Name) [SciLean.IsomorphicType tag α α'] [SciLean.IsomorphicType tag β β'] (f : α' → β') (a : α) : β"}
{"name":"SciLean.IsomorphicType","declaration":"/-- Type `α` is isomorphic to `α'`.\n\nThink about this class such that for each `tag` we get partial function `Type → Type`.\n\nFor example we have\n\n-/\nclass SciLean.IsomorphicType (tag : Lean.Name) (α : Sort u_1) (α' : outParam (Sort u_2)) : Sort (max (max 1 u_1) u_2)"}
{"name":"SciLean.isomorph.funext","declaration":"theorem SciLean.isomorph.funext {α : Type u_4} {α' : outParam (Type u_3)} (tag : Lean.Name) [SciLean.IsomorphicType tag α α'] {β : Type u_1} {β' : Type u_2} [SciLean.IsomorphicType tag β β'] (f : α → β) (g : α → β) : SciLean.isomorph tag f = SciLean.isomorph tag g → f = g"}
{"name":"SciLean.IsomorphicType.mk","declaration":"ctor SciLean.IsomorphicType.mk {tag : Lean.Name} {α : Sort u_1} {α' : outParam (Sort u_2)} (equiv : α ≃ α') : SciLean.IsomorphicType tag α α'"}
{"name":"SciLean.isomorph","declaration":"def SciLean.isomorph {α : Type u_1} {β : Type u_2} {α' : outParam (Type u_3)} {β' : outParam (Type u_4)} (tag : Lean.Name) [SciLean.IsomorphicType tag α α'] [SciLean.IsomorphicType tag β β'] (f : α → β) (a' : α') : β'"}
{"name":"SciLean.instIsomorphicTypeProdProd","declaration":"instance SciLean.instIsomorphicTypeProdProd {α : Type u_1} {β : Type u_2} {α' : outParam (Type u_3)} {β' : outParam (Type u_4)} (tag : Lean.Name) [SciLean.IsomorphicType tag α α'] [SciLean.IsomorphicType tag β β'] : SciLean.IsomorphicType tag (α × β) (α' × β')"}
{"name":"SciLean.isomorph.app","declaration":"theorem SciLean.isomorph.app {α : Type u_3} {β : Type u_2} {α' : outParam (Type u_4)} {β' : outParam (Type u_1)} (tag : Lean.Name) [SciLean.IsomorphicType tag α α'] [SciLean.IsomorphicType tag β β'] (f : α → β) (x : α) : (SciLean.IsomorphicType.equiv tag) (f x) = SciLean.isomorph tag f ((SciLean.IsomorphicType.equiv tag) x)"}
{"name":"SciLean.instIsomorphicType","declaration":"instance SciLean.instIsomorphicType (tag : Lean.Name) (P : Prop) : SciLean.IsomorphicType tag P P"}
{"name":"SciLean.IsomorphicType.equiv","declaration":"def SciLean.IsomorphicType.equiv (tag : Lean.Name) {α : Sort u_1} {α' : outParam (Sort u_2)} [self : SciLean.IsomorphicType tag α α'] : α ≃ α'"}
