{"name":"SciLean.ArrayType.PowerNotation.dimSpec_","declaration":"def SciLean.ArrayType.PowerNotation.dimSpec_  : Lean.ParserDescr"}
{"name":"SciLean.ArrayType.PowerNotation.typeIntPower","declaration":"/-- `x^[y]` is either array type or iterated function depending on the type of `x`.\n\n**iterated function** `f^[n]` call `f` n-times e.g. `f^[3] = f∘f∘f`\n\n**type product** `Float^[n]` array of n elemts with values in `Float`\n\nThe array notation is quite flexible and allows you to create arrays indexed with various types.\nExamples where `n m k l : USize`, `a b : Int64` and `ι κ : Type` are types with `Index _` instance:\n- `Float^[n]` index type: `Idx n` i.e. numbers `0,...,n-1`\n- `Float^[n,m]` index type: `Idx n × Idx m` i.e. paris `(0,0),(0,1),...,(1,0),(1,1),...,(n-1,m-1)`\n- `Float^[[-a:b]]` index type :`Idx' (-a) b` i.e. closed interval from `-a` to `b` (`={-a, -a+1, ..., b-1, b}`)\n- `Float^[k,l,m]` index type: `Idx k × Idx l × Idx m` - type product is right associated by default\n- `Float^[[k,l],m]` index type: `(Idx k × Idx l) × Idx m`  - left associated product requires explicit brackets\n- `Float^[ι]` index type `ι` - generic type with `Index ι` instances\n- `Float^[ι,[10,[-a:b]],κ]` index type: `ι × (Idx 10 × Idx' (-a) b) × κ` - mix of all above\n-/\ndef SciLean.ArrayType.PowerNotation.typeIntPower  : Lean.TrailingParserDescr"}
{"name":"SciLean.«term⊞_=>_»","declaration":"def SciLean.«term⊞_=>_»  : Lean.ParserDescr"}
{"name":"SciLean.ArrayType.PowerNotation.«dimSpec[_:_]»","declaration":"def SciLean.ArrayType.PowerNotation.«dimSpec[_:_]»  : Lean.ParserDescr"}
{"name":"SciLean.introElemNotation","declaration":"def SciLean.introElemNotation {Cont : Type u_1} {Idx : Type u_2} {Elem : Type u_3} [DecidableEq Idx] [SciLean.ArrayType Cont Idx Elem] [SciLean.ArrayTypeNotation Cont Idx Elem] (f : Idx → Elem) : Cont"}
{"name":"SciLean.ArrayType.PowerNotation.«dimSpec[_]»","declaration":"def SciLean.ArrayType.PowerNotation.«dimSpec[_]»  : Lean.ParserDescr"}
{"name":"SciLean.unexpandIntroElemNotation","declaration":"def SciLean.unexpandIntroElemNotation  : Lean.PrettyPrinter.Unexpander"}
{"name":"Lean.Parser.Category.dimSpec","declaration":"def Lean.Parser.Category.dimSpec  : Lean.Parser.Category"}
{"name":"SciLean.ArrayType.PowerNotation.dimSpec.quot","declaration":"def SciLean.ArrayType.PowerNotation.dimSpec.quot  : Lean.ParserDescr"}
{"name":"SciLean.unexpandArrayToArrayType","declaration":"def SciLean.unexpandArrayToArrayType  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.ArrayTypeNotation","declaration":"class SciLean.ArrayTypeNotation (Cont : outParam (Type u_1)) (Idx : Type u_2) (Elem : Type u_3) : Type"}
{"name":"SciLean.typeOf","declaration":"def SciLean.typeOf {α : Sort u_1} : α → Sort u_1"}
{"name":"SciLean.ArrayTypeNotation.mk","declaration":"ctor SciLean.ArrayTypeNotation.mk {Cont : outParam (Type u_1)} {Idx : Type u_2} {Elem : Type u_3} : SciLean.ArrayTypeNotation Cont Idx Elem"}
{"name":"SciLean.arrayTypeLiteral","declaration":"def SciLean.arrayTypeLiteral  : Lean.ParserDescr"}
{"name":"SciLean.arrayTypeCont","declaration":"def SciLean.arrayTypeCont (Idx : Type u_1) (Elem : Type u_2) {Cont : outParam (Type u_3)} [SciLean.ArrayTypeNotation Cont Idx Elem] : outParam (Type u_3)"}
{"name":"SciLean.ArrayType.PowerNotation.expand'","declaration":"opaque SciLean.ArrayType.PowerNotation.expand' (l : List (Lean.TSyntax `dimSpec)) : Lean.Elab.TermElabM Lean.Expr"}
