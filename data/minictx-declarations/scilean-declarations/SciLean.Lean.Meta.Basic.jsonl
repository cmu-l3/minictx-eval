{"name":"Lean.Meta.getExplicitArgs","declaration":"/-- Is `e` in the form `foo x₀ .. xₙ` where `foo` is some constant\n\nIt returns only explicit arguments and the original expression should be recoverable by `mkAppM foo #[x₀, .., xₙ]`\n-/\ndef Lean.Meta.getExplicitArgs (e : Lean.Expr) : Lean.MetaM (Option (Lean.Name × Array Lean.Expr))"}
{"name":"Lean.Meta.mkAppFoldlM","declaration":"def Lean.Meta.mkAppFoldlM (const : Lean.Name) (xs : Array Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.withLocalDecls'","declaration":"/-- Simpler version of `withLocalDecls` that can't deal with dependent types but has simpler signature -/\ndef Lean.Meta.withLocalDecls' {α : Type} {n : Type → Type u_1} [Inhabited α] [MonadControlT Lean.MetaM n] [Monad n] (names : Array Lean.Name) (bi : Lean.BinderInfo) (types : Array Lean.Expr) (k : Array Lean.Expr → n α) : n α"}
{"name":"Lean.Meta.withLetDecls","declaration":"def Lean.Meta.withLetDecls {n : Type → Type u_1} {α : Type} [MonadControlT Lean.MetaM n] [Monad n] (names : Array Lean.Name) (vals : Array Lean.Expr) (k : Array Lean.Expr → n α) : n α"}
{"name":"Lean.Meta.LambdaSplit.piComp","declaration":"/-- Result of splitting a lambda function as `fun x i₁ ... iₙ => f (g x i₁ ... iₙ)` -/\nctor Lean.Meta.LambdaSplit.piComp (f : Lean.Expr) (g : Lean.Expr) (comp : Lean.Expr → Lean.Expr → Lean.Expr) : Lean.Meta.LambdaSplit"}
{"name":"Lean.Meta.etaExpand'","declaration":"/-- Eta expansion, it also beta reduces the body\n-/\ndef Lean.Meta.etaExpand' (e : Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.reduceProj?'","declaration":"/-- Reduces structure projection but it preserves let bindings unlike `Lean.Meta.reduceProj?`.\n-/\ndef Lean.Meta.reduceProj?' (e : Lean.Expr) : Lean.MetaM (Option Lean.Expr)"}
{"name":"Lean.Meta.reduceProjFn?'","declaration":"/-- Reduces structure projection function but it preserves let bindings unlike `Lean.Meta.Simp.reduceProjFn?`.\n\nTODO: Maybe move to SimpM and recover unfolding of user specified classes\n-/\ndef Lean.Meta.reduceProjFn?' (e : Lean.Expr) : Lean.MetaM (Option Lean.Expr)"}
{"name":"Lean.Meta.mkLocalDecls","declaration":"/-- Make local declarations is we have an array of names and types. -/\ndef Lean.Meta.mkLocalDecls {n : Type → Type u_1} [MonadControlT Lean.MetaM n] [Monad n] (names : Array Lean.Name) (bi : Lean.BinderInfo) (types : Array Lean.Expr) : Array (Lean.Name × Lean.BinderInfo × (Array Lean.Expr → n Lean.Expr))"}
{"name":"Lean.Meta.mkProdSnd","declaration":"def Lean.Meta.mkProdSnd (x : Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.map3MetaM","declaration":"def Lean.Meta.map3MetaM {m : Type → Type} {β : Sort u_1} {γ : Sort u_2} {δ : Sort u_3} [MonadControlT Lean.MetaM m] [Monad m] (f : {α : Type} → (β → γ → δ → Lean.MetaM α) → Lean.MetaM α) {α : Type} (k : β → γ → δ → m α) : m α"}
{"name":"Lean.Meta.reduceProjOfCtor?","declaration":"/-- Reduces structure projection of explicit constructors\n\nFor example, `(x,y,z).2.1.1` reduces to `y.1` even if `y` is reducible definition\nor let fvar.\n-/\ndef Lean.Meta.reduceProjOfCtor? (e : Lean.Expr) : Lean.MetaM (Option Lean.Expr)"}
{"name":"Lean.Meta.mkProdSplitElem","declaration":"def Lean.Meta.mkProdSplitElem (xs : Lean.Expr) (n : Nat) (fst : optParam Lean.Name `Prod.fst) (snd : optParam Lean.Name `Prod.snd) : Lean.MetaM (Array Lean.Expr)"}
{"name":"Lean.Meta.splitLambdaToComp","declaration":"/-- Takes lambda function `fun x => b` and splits it into composition of two functions.\n\nExample:\nfun x => f (g x)      ==>   f ∘ g\nfun x => f x + c      ==>   (fun y => y + c) ∘ f\nfun x => f x + g x    ==>   (fun (y₁,y₂) => y₁ + y₂) ∘ (fun x => (f x, g x))\nfun x i => f (g₁ x i) (g₂ x i) i  ==>   (fun (y₁,y₂) i => f y₁ y₂ i) ∘' (fun x i => (g₁ x i, g₂ x i))\nfun x i => x i        ==>   (fun x i => x i) ∘' (fun x i => x)\n-/\ndef Lean.Meta.splitLambdaToComp (e : Lean.Expr) (mk : optParam Lean.Name `Prod.mk) (fst : optParam Lean.Name `Prod.fst) (snd : optParam Lean.Name `Prod.snd) : Lean.MetaM (Lean.Expr × Lean.Expr)"}
{"name":"Lean.Meta.mkProdProj","declaration":"/-- For `(x₀, .., xₙ₋₁)` return `xᵢ` but as a product projection.\n\nWe need to know the total size of the product to be considered.\n\nFor example for `xyz : X × Y × Z`\n- `mkProdProj xyz 1 3` returns `xyz.snd.fst`.\n- `mkProdProj xyz 1 2` returns `xyz.snd`.\n-/\ndef Lean.Meta.mkProdProj (x : Lean.Expr) (i : Nat) (n : Nat) (fst : optParam Lean.Name `Prod.fst) (snd : optParam Lean.Name `Prod.snd) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.LambdaSplit","declaration":"inductive Lean.Meta.LambdaSplit  : Type"}
{"name":"Lean.Meta.reduceProjOfCtor","declaration":"/-- Reduces structure projection of explicit constructors\n\nExamples:\n```\n((a,b),c).1.2  ==> b\n```\n\n```\n((a,b),c).1.2.1  ==> b.1\n```\neven if `b` is a free variable introduced by a let binding\n-/\ndef Lean.Meta.reduceProjOfCtor (e : Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.isTypeQ","declaration":"def Lean.Meta.isTypeQ (e : Lean.Expr) : Lean.MetaM\n  (Option\n    ((u : Lean.Level) ×\n      let u := u;\n      Q(Type u)))"}
{"name":"Lean.Meta.mkCurryFun","declaration":"def Lean.Meta.mkCurryFun (n : Nat) (f : Lean.Expr) (mk : optParam Lean.Name `Prod.mk) (fst : optParam Lean.Name `Prod.fst) (snd : optParam Lean.Name `Prod.snd) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.map4MetaM","declaration":"def Lean.Meta.map4MetaM {m : Type → Type} {β : Sort u_1} {γ : Sort u_2} {δ : Sort u_3} {ε : Sort u_4} [MonadControlT Lean.MetaM m] [Monad m] (f : {α : Type} → (β → γ → δ → ε → Lean.MetaM α) → Lean.MetaM α) {α : Type} (k : β → γ → δ → ε → m α) : m α"}
{"name":"Lean.Meta.mkProdFst","declaration":"def Lean.Meta.mkProdFst (x : Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.flattenLet","declaration":"/-- Flattens let bindings and splits let binding of pairs.\n\nExample:\n```\nlet a :=\n  let b := (10, 12)\n  (b.1, 3 * b.2)\na.2\n```\nis rewritten to\n```\nlet b₁ := 10;\nlet b₂ := 12;\nlet a₁ := (b₁, b₂).fst;\nlet a₂ := 3 * (b₁, b₂).snd;\n(a₁, a₂).snd\n```\n-/\ndef Lean.Meta.flattenLet (fuel : Nat) (e : Lean.Expr) (splitPairs : optParam Bool true) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.getConstExplicitArgIds","declaration":"def Lean.Meta.getConstExplicitArgIds {m : Type → Type} [Monad m] [Lean.MonadEnv m] [Lean.MonadError m] (constName : Lean.Name) : m (Array Nat)"}
{"name":"Lean.Meta.splitHighOrderLambdaToComp","declaration":"/-- This function decomposes function as\n```\nfun x i₁ .. iₙ => b\n=\nfun x i₁ ... iₙ => f (g x) i₁ ... iₙ\n=\nf ∘ g\n```\n\nFor example, for `f' : Y → I → Z` and `g' : X → I → Y`\n```\nfun x i => f' (g' x i) i\n=\nfun x i => f'' (g' x) i\n=\nf'' ∘ g'\n```\nwhere `f'' = fun (y' : I → Y) i => f' (y' i) i`\n-/\ndef Lean.Meta.splitHighOrderLambdaToComp (e : Lean.Expr) (mk : optParam Lean.Name `Prod.mk) (fst : optParam Lean.Name `Prod.fst) (snd : optParam Lean.Name `Prod.snd) : Lean.MetaM (Lean.Expr × Lean.Expr)"}
{"name":"Lean.Meta.mkAppNoTrailingM","declaration":"/-- Same as `mkAppM` but does not leave trailing implicit arguments.\n\nFor example for `foo : (X : Type) → [OfNat 0 X] → X` the ``mkAppNoTrailingM `foo #[X]`` produces `foo X : X` instead of `@foo X : [OfNat 0 X] → X`\n-/\ndef Lean.Meta.mkAppNoTrailingM (constName : Lean.Name) (xs : Array Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.LambdaSplit.comp","declaration":"/-- Result of splitting a lambda function as `fun x => f (g x)` -/\nctor Lean.Meta.LambdaSplit.comp (f : Lean.Expr) (g : Lean.Expr) : Lean.Meta.LambdaSplit"}
{"name":"Lean.Meta.getConstArgNames.getArgNames","declaration":"def Lean.Meta.getConstArgNames.getArgNames (fixAnonymousNames : optParam Bool false) (e : Lean.Expr) (names : Array Lean.Name) (i : Nat) : Array Lean.Name"}
{"name":"Lean.Meta.elemWiseSplitHighOrderLambdaToComp","declaration":"/-- This function finds decomposition:\n```\nfun x i₁ .. iₙ => b\n=\nfun x i₁ ... iₙ => f (g x i₁ ... iₙ) i₁ ... iₙ\n```\n-/\ndef Lean.Meta.elemWiseSplitHighOrderLambdaToComp (e : Lean.Expr) (mk : optParam Lean.Name `Prod.mk) (fst : optParam Lean.Name `Prod.fst) (snd : optParam Lean.Name `Prod.snd) : Lean.MetaM (Lean.Expr × Lean.Expr)"}
{"name":"Lean.Meta.revertStructureProj","declaration":"/-- Changes structure projection back to function application. Left unchanged if not a projection.\n\nFor example `proj ``Prod 0 xy` is changed to `mkApp ``Prod.fst #[xy]`.\n-/\ndef Lean.Meta.revertStructureProj (e : Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"Lean.LocalContext.toString","declaration":"def Lean.LocalContext.toString (lctx : Lean.LocalContext) : Lean.MetaM String"}
{"name":"Lean.Meta.mkUncurryFun","declaration":"def Lean.Meta.mkUncurryFun (n : Nat) (f : Lean.Expr) (mk : optParam Lean.Name `Prod.mk) (fst : optParam Lean.Name `Prod.fst) (snd : optParam Lean.Name `Prod.snd) : Lean.MetaM Lean.Expr"}
{"name":"Lean.FVarId.usesFVar","declaration":"/-- Does free variable `x` uses free variable `y` in its type or value?\n-/\ndef Lean.FVarId.usesFVar (x : Lean.FVarId) (y : Lean.FVarId) : Lean.MetaM Bool"}
{"name":"Lean.Meta.letTelescope","declaration":"def Lean.Meta.letTelescope {n : Type → Type u_1} [MonadControlT Lean.MetaM n] [Monad n] {α : Type} (e : Lean.Expr) (k : Array Lean.Expr → Lean.Expr → n α) : n α"}
{"name":"Lean.Meta.getConstArgNames","declaration":"def Lean.Meta.getConstArgNames {m : Type → Type} [Monad m] [Lean.MonadEnv m] [Lean.MonadError m] (constName : Lean.Name) (fixAnonymousNames : optParam Bool false) : m (Array Lean.Name)"}
{"name":"Lean.Meta.getConstArity","declaration":"def Lean.Meta.getConstArity {m : Type → Type} [Monad m] [Lean.MonadEnv m] [Lean.MonadError m] (constName : Lean.Name) : m Nat"}
{"name":"Lean.Meta.mkProdElem","declaration":"/-- For `#[x₁, .., xₙ]` create `(x₁, .., xₙ)`.\n-/\ndef Lean.Meta.mkProdElem (xs : Array Lean.Expr) (mk : optParam Lean.Name `Prod.mk) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.etaExpandN","declaration":"/-- Eta expansion, but adds at most `n` binders\n-/\ndef Lean.Meta.etaExpandN (e : Lean.Expr) (n : Nat) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Meta.flatLetTelescope","declaration":"/-- Telescope for let bindings but it flattens let bindings first\n\nExample:\n```\nlet a :=\n  let b := (10, 12)\n  20\nf a b\n```\n\nIt will run `k #[b₁, b₂, a] (f a (b₁,b₂))` where `b₁ := 10, b₂ := 12, a := 20`.\n\n\nIf `splitPairs` is `false`, it will run `k #[b, a] (f a b)`\n-/\ndef Lean.Meta.flatLetTelescope {n : Type → Type u_1} [MonadControlT Lean.MetaM n] [Monad n] {α : Type} (fuel : Nat) (e : Lean.Expr) (k : Array Lean.Expr → Lean.Expr → n α) (splitPairs : optParam Bool true) : n α"}
{"name":"Lean.Meta.getFunHeadConst?","declaration":"/-- Returns name of the head function of an expression\n\nTODO: See through FunLike.coe\n\nExample:\n`getFunHeadConst? q(fun x => x + x) = HAdd.hAdd`\n`getFunHeadConst? q(fun x y => x + y) = HAdd.hAdd`\n`getFunHeadConst? q(HAdd.hAdd 1) = HAdd.hAdd`\n`getFunHeadConst? q(fun xy : X×Y => xy.2) = Prod.snd`\n`getFunHeadConst? q(fun f x => f x) = none`\n-/\ndef Lean.Meta.getFunHeadConst? (e : Lean.Expr) : Lean.MetaM (Option Lean.Name)"}
{"name":"Lean.Meta.mkAppFoldrM","declaration":"def Lean.Meta.mkAppFoldrM (const : Lean.Name) (xs : Array Lean.Expr) : Lean.MetaM Lean.Expr"}
