{"name":"SciLean.ArrayType.instMul","declaration":"instance SciLean.ArrayType.instMul {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Mul Elem] : Mul Cont"}
{"name":"SciLean.ArrayType.mapMono","declaration":"def SciLean.ArrayType.mapMono {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] (f : Elem → Elem) (cont : Cont) : Cont"}
{"name":"SciLean.ArrayType.div_get","declaration":"theorem SciLean.ArrayType.div_get {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Div Elem] (x : Cont) (y : Cont) (i : Idx) : (x / y)[i] = x[i] / y[i]"}
{"name":"SciLean.ArrayType.instZero","declaration":"instance SciLean.ArrayType.instZero {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.ArrayType Cont Idx Elem] [Zero Elem] : Zero Cont"}
{"name":"SciLean.ArrayType.instDecidableEq","declaration":"instance SciLean.ArrayType.instDecidableEq {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [DecidableEq Elem] : DecidableEq Cont"}
{"name":"SciLean.ArrayType.getElem_mapIdxMono","declaration":"theorem SciLean.ArrayType.getElem_mapIdxMono {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] (f : Idx → Elem → Elem) (cont : Cont) (i : Idx) : (SciLean.ArrayType.mapIdxMono f cont)[i] = f i cont[i]"}
{"name":"SciLean.ArrayType.instLE","declaration":"instance SciLean.ArrayType.instLE {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.ArrayType Cont Idx Elem] [LE Elem] : LE Cont"}
{"name":"SciLean.ArrayType.eta","declaration":"theorem SciLean.ArrayType.eta {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.ArrayType Cont Idx Elem] (cont : Cont) : (LeanColls.Indexed.ofFn fun i => cont[i]) = cont"}
{"name":"SciLean.ArrayType.argMinCore","declaration":"def SciLean.ArrayType.argMinCore {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [LT Elem] [(x y : Elem) → Decidable (x < y)] [Inhabited Idx] (cont : Cont) : Idx × Elem"}
{"name":"SciLean.ArrayType.instDecidableLeInstLE","declaration":"instance SciLean.ArrayType.instDecidableLeInstLE {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [LE Elem] [(x y : Elem) → Decidable (x ≤ y)] (f : Cont) (g : Cont) : Decidable (f ≤ g)"}
{"name":"SciLean.ArrayType.mapIdxMono","declaration":"def SciLean.ArrayType.mapIdxMono {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] (f : Idx → Elem → Elem) (cont : Cont) : Cont"}
{"name":"SciLean.ArrayType.idxMax","declaration":"def SciLean.ArrayType.idxMax {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [LT Elem] [(x y : Elem) → Decidable (x < y)] [Inhabited Idx] (cont : Cont) : Idx"}
{"name":"SciLean.ArrayType.instSub","declaration":"instance SciLean.ArrayType.instSub {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Sub Elem] : Sub Cont"}
{"name":"SciLean.ArrayType.zero_get","declaration":"theorem SciLean.ArrayType.zero_get {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.ArrayType Cont Idx Elem] [Zero Elem] (i : Idx) : 0[i] = 0"}
{"name":"SciLean.ArrayType.instToString","declaration":"instance SciLean.ArrayType.instToString {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.ArrayType Cont Idx Elem] [ToString Elem] [SciLean.IndexType Idx] : ToString Cont"}
{"name":"SciLean.ArrayType.instDiv","declaration":"instance SciLean.ArrayType.instDiv {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Div Elem] : Div Cont"}
{"name":"SciLean.ArrayType.instLT","declaration":"instance SciLean.ArrayType.instLT {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.ArrayType Cont Idx Elem] [LT Elem] : LT Cont"}
{"name":"SciLean.ArrayType.sum_ofFn","declaration":"theorem SciLean.ArrayType.sum_ofFn {Cont : Type u_1} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [AddCommMonoid Elem] {ι : Type u_2} [SciLean.IndexType ι] (f : ι → Idx → Elem) : ( ∑ j, LeanColls.Indexed.ofFn fun i => f j i) = LeanColls.Indexed.ofFn fun i =>  ∑ j, f j i"}
{"name":"SciLean.ArrayType.mul_get","declaration":"theorem SciLean.ArrayType.mul_get {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Mul Elem] (x : Cont) (y : Cont) (i : Idx) : (x * y)[i] = x[i] * y[i]"}
{"name":"SciLean.ArrayType.neg_ofFn","declaration":"theorem SciLean.ArrayType.neg_ofFn {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Neg Elem] (f : Idx → Elem) : -LeanColls.Indexed.ofFn f = LeanColls.Indexed.ofFn fun i => -f i"}
{"name":"SciLean.ArrayType.neg_get","declaration":"theorem SciLean.ArrayType.neg_get {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Neg Elem] (x : Cont) (i : Idx) : (-x)[i] = -x[i]"}
{"name":"SciLean.ArrayType.instDecidableLtInstLT","declaration":"instance SciLean.ArrayType.instDecidableLtInstLT {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [LT Elem] [(x y : Elem) → Decidable (x < y)] (f : Cont) (g : Cont) : Decidable (f < g)"}
{"name":"SciLean.ArrayType.getElem_mapMono","declaration":"theorem SciLean.ArrayType.getElem_mapMono {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] (f : Elem → Elem) (cont : Cont) (i : Idx) : (SciLean.ArrayType.mapMono f cont)[i] = f cont[i]"}
{"name":"SciLean.ArrayType.add_ofFn","declaration":"theorem SciLean.ArrayType.add_ofFn {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Add Elem] (f : Idx → Elem) (g : Idx → Elem) : LeanColls.Indexed.ofFn f + LeanColls.Indexed.ofFn g = LeanColls.Indexed.ofFn fun i => f i + g i"}
{"name":"SciLean.ArrayType.smul_get","declaration":"theorem SciLean.ArrayType.smul_get {Cont : Type u_3} {Idx : outParam (Type u_4)} {Elem : outParam (Type u_2)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] {R : Type u_1} [SMul R Elem] (r : R) (x : Cont) (i : Idx) : (r • x)[i] = r • x[i]"}
{"name":"SciLean.ArrayType.instInv","declaration":"instance SciLean.ArrayType.instInv {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Inv Elem] : Inv Cont"}
{"name":"SciLean.ArrayType.instSMul","declaration":"instance SciLean.ArrayType.instSMul {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] {R : Type u_4} [SMul R Elem] : SMul R Cont"}
{"name":"SciLean.ArrayType.instOne","declaration":"instance SciLean.ArrayType.instOne {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.ArrayType Cont Idx Elem] [One Elem] : One Cont"}
{"name":"SciLean.ArrayType.one_get","declaration":"theorem SciLean.ArrayType.one_get {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.ArrayType Cont Idx Elem] [One Elem] (i : Idx) : 1[i] = 1"}
{"name":"SciLean.ArrayType.get_injective","declaration":"def SciLean.ArrayType.get_injective {Cont : Type u} {Idx : outParam (Type v)} {Elem : outParam (Type w)} [self : SciLean.ArrayType Cont Idx Elem] : Function.Injective fun c i => c[i]"}
{"name":"SciLean.ArrayType.argMaxCore","declaration":"def SciLean.ArrayType.argMaxCore {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [LT Elem] [(x y : Elem) → Decidable (x < y)] [Inhabited Idx] (cont : Cont) : Idx × Elem"}
{"name":"Array.toArrayType","declaration":"/-- Converts array to ArrayType -/\ndef Array.toArrayType {Elem : Type u_1} (Cont : Type u) (Idx : Type v) [SciLean.IndexType Idx] [LeanColls.Indexed Cont Idx Elem] (a : Array Elem) (h : SciLean.IndexType.card Idx = Array.size a) : Cont"}
{"name":"SciLean.ArrayType.add_get","declaration":"theorem SciLean.ArrayType.add_get {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Add Elem] (x : Cont) (y : Cont) (i : Idx) : (x + y)[i] = x[i] + y[i]"}
{"name":"SciLean.ArrayType.sub_ofFn","declaration":"theorem SciLean.ArrayType.sub_ofFn {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Sub Elem] (f : Idx → Elem) (g : Idx → Elem) : LeanColls.Indexed.ofFn f - LeanColls.Indexed.ofFn g = LeanColls.Indexed.ofFn fun i => f i - g i"}
{"name":"SciLean.ArrayType.mk","declaration":"ctor SciLean.ArrayType.mk {Cont : Type u} {Idx : outParam (Type v)} {Elem : outParam (Type w)} [toIndexed : LeanColls.Indexed Cont Idx Elem] [toLawfulIndexed : LeanColls.LawfulIndexed Cont Idx Elem] (get_injective : Function.Injective fun c i => c[i]) : SciLean.ArrayType Cont Idx Elem"}
{"name":"SciLean.ArrayType.smul_ofFn","declaration":"theorem SciLean.ArrayType.smul_ofFn {Cont : Type u_3} {Idx : outParam (Type u_4)} {Elem : outParam (Type u_2)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] {K : Type u_1} [SMul K Elem] (f : Idx → Elem) (a : K) : a • LeanColls.Indexed.ofFn f = LeanColls.Indexed.ofFn fun i => a • f i"}
{"name":"SciLean.instStructType","declaration":"instance SciLean.instStructType {Cont : Type u_1} {Idx : Type u_2} {Elem : Type u_3} [SciLean.ArrayType Cont Idx Elem] : SciLean.StructType Cont Idx fun x => Elem"}
{"name":"SciLean.ArrayType","declaration":"/-- This class says that `Cont` behaves like an array with `Elem` values indexed by `Idx`\n\nExamples for `Idx = Fin n` and `Elem = ℝ` are: `ArrayN ℝ n` or `ℝ^{n}`\n\nFor `array : Cont` you can:\n1. get values: `Indexed.get array i : Elem` for `i : Idx`\n2. set values: `Indexed.set array i x : Cont` for `i : Idx` and `x : Elem`\n3. make new a array: `Indexed.ofFn f : Cont` for `f : Idx → Elem`\n\nAlternative notation:\n1. `array[x]`\n2. in `do` block: `array[x] := y`, `array[x] += y`, ...\n3. `λ [x] => f x` this notation works only if the type `Cont` can be infered from the context\n   Common use: `let array : Cont := λ [x] => f x` where the type asscription `: Cont` is important.\n-/\nclass SciLean.ArrayType (Cont : Type u) (Idx : outParam (Type v)) (Elem : outParam (Type w)) : Type (max (max u v) (w + 1))"}
{"name":"SciLean.ArrayType.instNeg","declaration":"instance SciLean.ArrayType.instNeg {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Neg Elem] : Neg Cont"}
{"name":"SciLean.ArrayType.max","declaration":"def SciLean.ArrayType.max {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [LT Elem] [(x y : Elem) → Decidable (x < y)] [Inhabited Idx] (cont : Cont) : Elem"}
{"name":"SciLean.ArrayType.min","declaration":"def SciLean.ArrayType.min {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [LT Elem] [(x y : Elem) → Decidable (x < y)] [Inhabited Idx] (cont : Cont) : Elem"}
{"name":"SciLean.ArrayType.sub_get","declaration":"theorem SciLean.ArrayType.sub_get {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Sub Elem] (x : Cont) (y : Cont) (i : Idx) : (x - y)[i] = x[i] - y[i]"}
{"name":"SciLean.ArrayType.getElem_map","declaration":"theorem SciLean.ArrayType.getElem_map {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] (f : Elem → Elem) (cont : Cont) (i : Idx) : (SciLean.ArrayType.mapMono f cont)[i] = f cont[i]"}
{"name":"SciLean.ArrayType.idxMin","declaration":"def SciLean.ArrayType.idxMin {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [LT Elem] [(x y : Elem) → Decidable (x < y)] [Inhabited Idx] (cont : Cont) : Idx"}
{"name":"SciLean.ArrayType.ext","declaration":"theorem SciLean.ArrayType.ext {Cont : Type u_2} {Idx : outParam (Type u_3)} {Elem : outParam (Type u_1)} [SciLean.ArrayType Cont Idx Elem] (x : Cont) (y : Cont) : (∀ (i : Idx), x[i] = y[i]) → x = y"}
{"name":"SciLean.ArrayType.instAdd","declaration":"instance SciLean.ArrayType.instAdd {Cont : Type u_1} {Idx : outParam (Type u_2)} {Elem : outParam (Type u_3)} [SciLean.IndexType Idx] [SciLean.ArrayType Cont Idx Elem] [Add Elem] : Add Cont"}
