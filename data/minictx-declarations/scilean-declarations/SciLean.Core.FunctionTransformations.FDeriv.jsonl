{"name":"SciLean.fderiv.pi_rule_at","declaration":"theorem SciLean.fderiv.pi_rule_at {K : Type u_3} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] {ι : Type u_4} [Fintype ι] {E : ι → Type u_1} [(i : ι) → NormedAddCommGroup (E i)] [(i : ι) → NormedSpace K (E i)] (f : X → (i : ι) → E i) (x : X) (hf : ∀ (i : ι), DifferentiableAt K (fun x => f x i) x) : fderiv K (fun x i => f x i) x = SciLean.ContinuousLinearMap.mk' K (fun dx i => (fderiv K (fun x => f x i) x) dx) ⋯"}
{"name":"SciLean.fderiv.id_rule","declaration":"theorem SciLean.fderiv.id_rule {K : Type u_2} [RCLike K] {X : Type u_1} [NormedAddCommGroup X] [NormedSpace K X] : (fderiv K fun x => x) = fun x => fun dx =>L[K] dx"}
{"name":"SciLean.fderiv.apply_rule","declaration":"theorem SciLean.fderiv.apply_rule {K : Type u_3} [RCLike K] {ι : Type u_1} [Fintype ι] {E : ι → Type u_2} [(i : ι) → NormedAddCommGroup (E i)] [(i : ι) → NormedSpace K (E i)] (i : ι) : (fderiv K fun x => x i) = fun x => fun dx =>L[K] dx i"}
{"name":"HAdd.hAdd.arg_a0a1.fderiv_rule_at","declaration":"theorem HAdd.hAdd.arg_a0a1.fderiv_rule_at {K : Type u_3} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_1} [NormedAddCommGroup Y] [NormedSpace K Y] (x : X) (f : X → Y) (g : X → Y) (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) : fderiv K (fun x => f x + g x) x = fun dx =>L[K] (fderiv K f x) dx + (fderiv K g x) dx"}
{"name":"HPow.hPow.arg_a0.fderiv_rule_at","declaration":"def HPow.hPow.arg_a0.fderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] (n : ℕ) (x : X) (f : X → K) (hf : DifferentiableAt K f x) : fderiv K (fun x => f x ^ n) x = fun dx =>L[K] ↑n * (fderiv K f x) dx * f x ^ (n - 1)"}
{"name":"Neg.neg.arg_a0.fderiv_rule","declaration":"theorem Neg.neg.arg_a0.fderiv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_2} [NormedAddCommGroup Y] [NormedSpace K Y] (f : X → Y) : (fderiv K fun x => -f x) = fun x => fun dx =>L[K] -(fderiv K f x) dx"}
{"name":"HSub.hSub.arg_a0a1.fderiv_rule_at","declaration":"theorem HSub.hSub.arg_a0a1.fderiv_rule_at {K : Type u_3} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_1} [NormedAddCommGroup Y] [NormedSpace K Y] (x : X) (f : X → Y) (g : X → Y) (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) : fderiv K (fun x => f x - g x) x = fun dx =>L[K] (fderiv K f x) dx - (fderiv K g x) dx"}
{"name":"Prod.snd.arg_self.fderiv_rule_at","declaration":"theorem Prod.snd.arg_self.fderiv_rule_at {K : Type u_4} [RCLike K] {X : Type u_3} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_1} [NormedAddCommGroup Y] [NormedSpace K Y] {Z : Type u_2} [NormedAddCommGroup Z] [NormedSpace K Z] (x : X) (f : X → Y × Z) (hf : DifferentiableAt K f x) : fderiv K (fun x => (f x).2) x = fun dx =>L[K] ((fderiv K f x) dx).2"}
{"name":"Prod.mk.arg_fstsnd.fderiv_rule_at","declaration":"theorem Prod.mk.arg_fstsnd.fderiv_rule_at {K : Type u_3} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_1} [NormedAddCommGroup Y] [NormedSpace K Y] {Z : Type u_4} [NormedAddCommGroup Z] [NormedSpace K Z] (x : X) (g : X → Y) (hg : DifferentiableAt K g x) (f : X → Z) (hf : DifferentiableAt K f x) : fderiv K (fun x => (g x, f x)) x = fun dx =>L[K] ((fderiv K g x) dx, (fderiv K f x) dx)"}
{"name":"HSMul.hSMul.arg_a0a1.fderiv_rule_at","declaration":"theorem HSMul.hSMul.arg_a0a1.fderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_3} [NormedAddCommGroup Y] [NormedSpace K Y] (x : X) (f : X → K) (g : X → Y) (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) : fderiv K (fun x => f x • g x) x =\n  let k := f x;\n  let y := g x;\n  fun dx =>L[K] k • (fderiv K g x) dx + (fderiv K f x) dx • y"}
{"name":"SciLean.fderiv.const_rule","declaration":"theorem SciLean.fderiv.const_rule {K : Type u_3} [RCLike K] {X : Type u_1} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_2} [NormedAddCommGroup Y] [NormedSpace K Y] (x : X) : (fderiv K fun x_1 => x) = fun x => fun x =>L[K] 0"}
{"name":"SciLean.fderiv.let_rule_at","declaration":"theorem SciLean.fderiv.let_rule_at {K : Type u_4} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_3} [NormedAddCommGroup Y] [NormedSpace K Y] {Z : Type u_1} [NormedAddCommGroup Z] [NormedSpace K Z] (f : X → Y → Z) (g : X → Y) (x : X) (hf : DifferentiableAt K (fun xy => f xy.1 xy.2) (x, g x)) (hg : DifferentiableAt K g x) : fderiv K\n    (fun x =>\n      let y := g x;\n      f x y)\n    x =\n  let y := g x;\n  fun dx =>L[K]\n    let dy := (fderiv K g x) dx;\n    let dz := (fderiv K (fun xy => f xy.1 xy.2) (x, y)) (dx, dy);\n    dz"}
{"name":"Prod.fst.arg_self.fderiv_rule_at","declaration":"theorem Prod.fst.arg_self.fderiv_rule_at {K : Type u_4} [RCLike K] {X : Type u_3} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_1} [NormedAddCommGroup Y] [NormedSpace K Y] {Z : Type u_2} [NormedAddCommGroup Z] [NormedSpace K Z] (x : X) (f : X → Y × Z) (hf : DifferentiableAt K f x) : fderiv K (fun x => (f x).1) x = fun dx =>L[K] ((fderiv K f x) dx).1"}
{"name":"HMul.hMul.arg_a0a1.fderiv_rule_at","declaration":"theorem HMul.hMul.arg_a0a1.fderiv_rule_at {K : Type u_2} [RCLike K] {X : Type u_3} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_1} [NormedCommRing Y] [NormedAlgebra K Y] (x : X) (f : X → Y) (g : X → Y) (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) : fderiv K (fun x => f x * g x) x =\n  let fx := f x;\n  let gx := g x;\n  fun dx =>L[K] (fderiv K g x) dx * fx + (fderiv K f x) dx * gx"}
{"name":"isContinuousLinearMap_fderiv","declaration":"theorem isContinuousLinearMap_fderiv {K : Type u_1} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_3} [NormedAddCommGroup Y] [NormedSpace K Y] (f : X → Y) (hf : SciLean.IsContinuousLinearMap K f) : fderiv K f = fun x => fun dx =>L[K] f dx"}
{"name":"HDiv.hDiv.arg_a0a1.fderiv_rule_at","declaration":"theorem HDiv.hDiv.arg_a0a1.fderiv_rule_at {K : Type u_2} [RCLike K] {R : Type u_1} [NontriviallyNormedField R] [NormedAlgebra R K] (x : R) (f : R → K) (g : R → K) (hf : DifferentiableAt R f x) (hg : DifferentiableAt R g x) (hx : g x ≠ 0) : fderiv R (fun x => f x / g x) x =\n  let k := f x;\n  let k' := g x;\n  fun dx =>L[R] ((fderiv R f x) dx * k' - k * (fderiv R g x) dx) / k' ^ 2"}
{"name":"SciLean.fderiv.comp_rule_at","declaration":"theorem SciLean.fderiv.comp_rule_at {K : Type u_3} [RCLike K] {X : Type u_4} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_2} [NormedAddCommGroup Y] [NormedSpace K Y] {Z : Type u_1} [NormedAddCommGroup Z] [NormedSpace K Z] (f : Y → Z) (g : X → Y) (x : X) (hf : DifferentiableAt K f (g x)) (hg : DifferentiableAt K g x) : fderiv K (fun x => f (g x)) x =\n  let y := g x;\n  fun dx =>L[K]\n    let dy := (fderiv K g x) dx;\n    let dz := (fderiv K f y) dy;\n    dz"}
