{"name":"SciLean.instVecSum","declaration":"instance SciLean.instVecSum {K : Type u_1} [RCLike K] (X : Type) (Y : Type) (TX : X → Type) (TY : Y → Type) (xy : X ⊕ Y) [(x : X) → SciLean.Vec K (TX x)] [(y : Y) → SciLean.Vec K (TY y)] : SciLean.Vec K ((TX⊕TY) xy)"}
{"name":"SciLean.instVecForAll","declaration":"instance SciLean.instVecForAll {K : Type u_1} [RCLike K] (α : Type u_2) (X : α → Type u_3) [inst : (a : α) → SciLean.Vec K (X a)] : SciLean.Vec K ((a : α) → X a)"}
{"name":"SciLean.VecProp.smul","declaration":"def SciLean.VecProp.smul {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [self : SciLean.VecProp K P] (r : K) (x : X) : P x → P (r • x)"}
{"name":"SciLean.instNegSubtype","declaration":"instance SciLean.instNegSubtype {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [inst : SciLean.VecProp K P] : Neg { x // P x }"}
{"name":"SciLean.Vec.mkSorryProofs","declaration":"def SciLean.Vec.mkSorryProofs {K : Type u_1} [RCLike K] {α : Type u_2} [Add α] [Sub α] [Neg α] [Zero α] [SMul K α] [UniformSpace α] : SciLean.Vec K α"}
{"name":"SciLean.Vec.mk","declaration":"ctor SciLean.Vec.mk {K : Type u_1} [RCLike K] {X : Type u_2} [toAddCommGroup : AddCommGroup X] [toUniformSpace : UniformSpace X] [toUniformAddGroup : UniformAddGroup X] [toModule : Module K X] [toContinuousSMul : ContinuousSMul K X] (scalar_wise_smooth : ∀ (c : K → X), SciLean.Curve.Smooth c ↔ ∀ (x' : X →L[K] K), SciLean.Curve.Smooth (⇑x' ∘ c)) : SciLean.Vec K X"}
{"name":"SciLean.Curve.DifferentiableAt","declaration":"def SciLean.Curve.DifferentiableAt {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) (x : K) : Prop"}
{"name":"SciLean.Curve.HasDerivAtFilter","declaration":"def SciLean.Curve.HasDerivAtFilter {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) (f' : F) (x : K) (L : Filter K) : Prop"}
{"name":"SciLean.AddCommGroup.mkSorryProofs","declaration":"def SciLean.AddCommGroup.mkSorryProofs {α : Type u_1} [Add α] [Sub α] [Neg α] [Zero α] : AddCommGroup α"}
{"name":"SciLean.VecProp.add","declaration":"def SciLean.VecProp.add {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [self : SciLean.VecProp K P] (x : X) (y : X) : P x → P y → P (x + y)"}
{"name":"SciLean.Vec.scalar_wise_smooth","declaration":"def SciLean.Vec.scalar_wise_smooth {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.Vec K X] (c : K → X) : SciLean.Curve.Smooth c ↔ ∀ (x' : X →L[K] K), SciLean.Curve.Smooth (⇑x' ∘ c)"}
{"name":"SciLean.TopologicalAddGroup.mkSorryProofs","declaration":"def SciLean.TopologicalAddGroup.mkSorryProofs {α : Type u_1} [Add α] [Sub α] [Neg α] [Zero α] [TopologicalSpace α] : TopologicalAddGroup α"}
{"name":"SciLean.Curve.ContDiffAt","declaration":"def SciLean.Curve.ContDiffAt {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) (x : K) (n : ℕ∞) : Prop"}
{"name":"SciLean.SubNegMonoid.mkSorryProofs","declaration":"def SciLean.SubNegMonoid.mkSorryProofs {α : Type u_1} [Add α] [Sub α] [Neg α] [Zero α] : SubNegMonoid α"}
{"name":"SciLean.Curve.SmoothAt","declaration":"def SciLean.Curve.SmoothAt {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) (x : K) : Prop"}
{"name":"SciLean.Curve.HasDerivAt","declaration":"def SciLean.Curve.HasDerivAt {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) (f' : F) (x : K) : Prop"}
{"name":"SciLean.instInhabited","declaration":"instance SciLean.instInhabited {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] : Inhabited X"}
{"name":"SciLean.MulAction.mkSorryProofs","declaration":"def SciLean.MulAction.mkSorryProofs {α : Type u_1} {β : Type u_2} [Monoid α] [SMul α β] : MulAction α β"}
{"name":"SciLean.instZeroSubtype","declaration":"instance SciLean.instZeroSubtype {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [inst : SciLean.VecProp K P] : Zero { x // P x }"}
{"name":"SciLean.UniformAddGroup.mkSorryProofs","declaration":"def SciLean.UniformAddGroup.mkSorryProofs {α : Type u_1} [Add α] [Sub α] [Neg α] [Zero α] [UniformSpace α] : UniformAddGroup α"}
{"name":"SciLean.instVecUnit","declaration":"instance SciLean.instVecUnit {K : Type u_1} [RCLike K] : SciLean.Vec K Unit"}
{"name":"SciLean.VecProp","declaration":"class SciLean.VecProp (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (P : X → Prop) : Prop"}
{"name":"SciLean.Curve.Smooth","declaration":"def SciLean.Curve.Smooth {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) : Prop"}
{"name":"SciLean.Vec","declaration":"/-- Vectors space `X` over field `K`\n\nMore precisely this is Convenient Vector Space which is a special class of vector spaces\nwhich allow very general definition of differentiability. In particular, the space `C∞(ℝ,ℝ)`,\nsmooth functions on real numbers, is Convenient Vector Spaces but fails to be Banach space.\n-/\nclass SciLean.Vec (K : Type u_1) [RCLike K] (X : Type u_2) : Type (max u_1 u_2)"}
{"name":"SciLean.AddSemigroup.mkSorryProofs","declaration":"def SciLean.AddSemigroup.mkSorryProofs {α : Type u_1} [Add α] : AddSemigroup α"}
{"name":"SciLean.ContinuousNeg.mkSorryProofs","declaration":"def SciLean.ContinuousNeg.mkSorryProofs {α : Type u_1} [Neg α] [TopologicalSpace α] : ContinuousNeg α"}
{"name":"SciLean.VecProp.mk","declaration":"ctor SciLean.VecProp.mk {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} (add : ∀ (x y : X), P x → P y → P (x + y)) (neg : ∀ (x : X), P x → P (-x)) (smul : ∀ (r : K) (x : X), P x → P (r • x)) (zero : P 0) : SciLean.VecProp K P"}
{"name":"SciLean.VecProp.zero","declaration":"def SciLean.VecProp.zero {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [self : SciLean.VecProp K P] : P 0"}
{"name":"SciLean.instAddSubtype","declaration":"instance SciLean.instAddSubtype {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [inst : SciLean.VecProp K P] : Add { x // P x }"}
{"name":"SciLean.AddGroup.mkSorryProofs","declaration":"def SciLean.AddGroup.mkSorryProofs {α : Type u_1} [Add α] [Sub α] [Neg α] [Zero α] : AddGroup α"}
{"name":"SciLean.Curve.ContDiffAt'","declaration":"def SciLean.Curve.ContDiffAt' {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) (x : K) (n : ℕ) : Prop"}
{"name":"SciLean.Curve.deriv","declaration":"def SciLean.Curve.deriv {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) (x : K) : F"}
{"name":"SciLean.«term_⊕_»","declaration":"def SciLean.«term_⊕_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.instSubSubtype","declaration":"instance SciLean.instSubSubtype {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [inst : SciLean.VecProp K P] : Sub { x // P x }"}
{"name":"SciLean.VecProp.neg","declaration":"def SciLean.VecProp.neg {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [self : SciLean.VecProp K P] (x : X) : P x → P (-x)"}
{"name":"SciLean.Module.mkSorryProofs","declaration":"def SciLean.Module.mkSorryProofs {α : Type u_1} {β : Type u_2} [Semiring α] [addcommgroup : AddCommGroup β] [SMul α β] : Module α β"}
{"name":"SciLean.instSMulSubtype","declaration":"instance SciLean.instSMulSubtype {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {P : X → Prop} [inst : SciLean.VecProp K P] : SMul K { x // P x }"}
{"name":"SciLean.instVecProd","declaration":"instance SciLean.instVecProd {K : Type u_1} [RCLike K] {U : Type u_2} {V : Type u_3} [instU : SciLean.Vec K U] [instV : SciLean.Vec K V] : SciLean.Vec K (U × V)"}
{"name":"SciLean.Curve.ContDiff","declaration":"def SciLean.Curve.ContDiff {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) (n : ℕ∞) : Prop"}
{"name":"SciLean.Curve.Differentiable","declaration":"def SciLean.Curve.Differentiable {K : Type u} [NontriviallyNormedField K] {F : Type v} [AddCommGroup F] [Module K F] [TopologicalSpace F] (f : K → F) : Prop"}
{"name":"SciLean.DistribMulAction.mkSorryProofs","declaration":"def SciLean.DistribMulAction.mkSorryProofs {α : Type u_1} {β : Type u_2} [Monoid α] [AddMonoid β] [SMul α β] : DistribMulAction α β"}
{"name":"SciLean.ContinuousSMul.mkSorryProofs","declaration":"def SciLean.ContinuousSMul.mkSorryProofs {K : Type u_1} [RCLike K] {α : Type u_2} [SMul K α] [TopologicalSpace α] : ContinuousSMul K α"}
{"name":"SciLean.instVec","declaration":"instance SciLean.instVec {K : Type u_1} [RCLike K] : SciLean.Vec K K"}
{"name":"SciLean.ContinuousAdd.mkSorryProofs","declaration":"def SciLean.ContinuousAdd.mkSorryProofs {α : Type u_1} [Add α] [TopologicalSpace α] : ContinuousAdd α"}
{"name":"SciLean.AddMonoid.mkSorryProofs","declaration":"def SciLean.AddMonoid.mkSorryProofs {α : Type u_1} [Add α] [Zero α] : AddMonoid α"}
