{"name":"SciLean.Meta.StructureDecomposition.q","declaration":"def SciLean.Meta.StructureDecomposition.q (self : SciLean.Meta.StructureDecomposition) : Q(unknown_1 → unknown_2 → unknown_3)"}
{"name":"SciLean.Meta.DomainDecomposition.mk","declaration":"ctor SciLean.Meta.DomainDecomposition.mk {u : Lean.Level} (Y : Q(Type u)) (dec : SciLean.Meta.StructureDecomposition) (f : let a := dec.X;\nQ(unknown_1 → «$Y»)) (f' : let a := dec.X₁;\nQ(unknown_2 → «$Y»)) (proof : let a := dec.p₁;\nQ(∀ (x : unknown_1), «$f'» (unknown_3 x) = «$f» x)) : SciLean.Meta.DomainDecomposition"}
{"name":"SciLean.Meta.splitStructureElem","declaration":"/-- Decomposes an element `e` of possible nested structure and returns a function put it back together.\n\nFor example, calling this function on `x : (Nat×Nat)×Nat` returns `(#[x.1.1, x.1.2, x.1], fun a b c => ((a,b),c))`\n-/\nopaque SciLean.Meta.splitStructureElem (e : Lean.Expr) : Lean.MetaM (Array Lean.Expr × Lean.Expr)"}
{"name":"SciLean.Meta.DomainDecomposition.Y","declaration":"def SciLean.Meta.DomainDecomposition.Y (self : SciLean.Meta.DomainDecomposition) : Q(Type udummy._uniq.1162)"}
{"name":"SciLean.Meta.decomposeStructure","declaration":"/-- Takes a type `X` of a nested structure  and splits it into two `X₁` and `X₂`. Elements `x` for which `split i x` is true are gatherd in `X₁` and rest is in `X₂`.\nReturns function `p₁ : X → X₁`, `p₂ : X → X₂` and `q : X₁ → X₂ → X` that are inverse of each other.\n\nExample:\n```\nsplit ((u,v),(w,x),y) (fun i => i%2==0)\n```\nreturns\n```\np₁ := fun ((a,b),(c,d),e) => (a,c,e)\np₂ := fun ((a,b),(c,d),e) => (b,d)\nq  := fun ((a,c,e),(b,d)) => ((a,b),(c,d),e)\n```\n-/\ndef SciLean.Meta.decomposeStructure (e : Lean.Expr) (split : Nat → Lean.Expr → Bool) : Lean.MetaM (Option SciLean.Meta.StructureDecomposition)"}
{"name":"SciLean.Meta.IsDecomposition.mk","declaration":"ctor SciLean.Meta.IsDecomposition.mk {X : Sort u_1} {X₁ : Sort u_2} {X₂ : Sort u_3} {p₁ : X → X₁} {p₂ : X → X₂} {q : X₁ → X₂ → X} (proj_mk : ∀ (x : X), q (p₁ x) (p₂ x) = x) (mk_proj₁ : ∀ (x₁ : X₁) (x₂ : X₂), p₁ (q x₁ x₂) = x₁) (mk_proj₂ : ∀ (x₁ : X₁) (x₂ : X₂), p₂ (q x₁ x₂) = x₂) : SciLean.Meta.IsDecomposition p₁ p₂ q"}
{"name":"SciLean.Meta.CodomainDecomposition.mk","declaration":"ctor SciLean.Meta.CodomainDecomposition.mk {u : Lean.Level} (X : Q(Type u)) (dec : SciLean.Meta.StructureDecomposition) (f : let a := dec.X;\nQ(«$X» → unknown_1)) (f' : let a := dec.X₁;\nQ(«$X» → unknown_2)) (y₂ : let a := dec.X₂;\nQ(unknown_3)) (proof : let a := dec.q;\nQ(∀ (x : «$X»), unknown_4 («$f'» x) «$y₂» = «$f» x)) : SciLean.Meta.CodomainDecomposition"}
{"name":"SciLean.Meta.factorCodomainThroughProjections","declaration":"/-- Takes a function `f : X → Y` and finds decomposition `q : Y₁ → Y₂ → Y`, element `y : Y₂` and function `f' : X → Y₁` such that `h : f = fun x => q (f' x) y`\n\nreturns `(f', q, y, h)`\n-/\ndef SciLean.Meta.factorCodomainThroughProjections (f : Lean.Expr) : Lean.MetaM (Option SciLean.Meta.CodomainDecomposition)"}
{"name":"SciLean.Meta.StructureDecomposition.p₁","declaration":"def SciLean.Meta.StructureDecomposition.p₁ (self : SciLean.Meta.StructureDecomposition) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.StructureDecomposition.X","declaration":"def SciLean.Meta.StructureDecomposition.X (self : SciLean.Meta.StructureDecomposition) : Q(Type udummy._uniq.1038)"}
{"name":"SciLean.Meta.CodomainDecomposition.f","declaration":"def SciLean.Meta.CodomainDecomposition.f (self : SciLean.Meta.CodomainDecomposition) : let a := self.dec.X;\nQ(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.StructureDecomposition.proof","declaration":"def SciLean.Meta.StructureDecomposition.proof (self : SciLean.Meta.StructureDecomposition) : Q(SciLean.Meta.IsDecomposition unknown_4 unknown_5 unknown_6)"}
{"name":"SciLean.Meta.DomainDecomposition.f","declaration":"def SciLean.Meta.DomainDecomposition.f (self : SciLean.Meta.DomainDecomposition) : let a := self.dec.X;\nQ(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.DomainDecomposition.proof","declaration":"def SciLean.Meta.DomainDecomposition.proof (self : SciLean.Meta.DomainDecomposition) : let a := self.dec.p₁;\nQ(∀ (x : unknown_1), unknown_5 (unknown_6 x) = unknown_8 x)"}
{"name":"SciLean.Meta.StructureDecomposition.X₁","declaration":"def SciLean.Meta.StructureDecomposition.X₁ (self : SciLean.Meta.StructureDecomposition) : Q(Type udummy._uniq.297)"}
{"name":"SciLean.Meta.CodomainDecomposition.X","declaration":"def SciLean.Meta.CodomainDecomposition.X (self : SciLean.Meta.CodomainDecomposition) : Q(Type udummy._uniq.358)"}
{"name":"SciLean.Meta.DomainDecomposition.u","declaration":"def SciLean.Meta.DomainDecomposition.u (self : SciLean.Meta.DomainDecomposition) : Lean.Level"}
{"name":"SciLean.Meta.CodomainDecomposition.f'","declaration":"def SciLean.Meta.CodomainDecomposition.f' (self : SciLean.Meta.CodomainDecomposition) : let a := self.dec.X₁;\nQ(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.CodomainDecomposition.dec","declaration":"def SciLean.Meta.CodomainDecomposition.dec (self : SciLean.Meta.CodomainDecomposition) : SciLean.Meta.StructureDecomposition"}
{"name":"SciLean.Meta.StructureDecomposition.p₂","declaration":"def SciLean.Meta.StructureDecomposition.p₂ (self : SciLean.Meta.StructureDecomposition) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.CodomainDecomposition.y₂","declaration":"def SciLean.Meta.CodomainDecomposition.y₂ (self : SciLean.Meta.CodomainDecomposition) : let a := self.dec.X₂;\nQ(unknown_1)"}
{"name":"SciLean.Meta.simpleDataStructure","declaration":"/-- Is it structure containing only plain data i.e. no propositions, no types, no dependent types, no functions\n-/\ndef SciLean.Meta.simpleDataStructure (structName : Lean.Name) : Lean.MetaM Bool"}
{"name":"SciLean.Meta.StructureDecomposition","declaration":"structure SciLean.Meta.StructureDecomposition  : Type"}
{"name":"SciLean.Meta.StructureDecomposition.X₂","declaration":"def SciLean.Meta.StructureDecomposition.X₂ (self : SciLean.Meta.StructureDecomposition) : Q(Type udummy._uniq.1042)"}
{"name":"SciLean.Meta.StructureDecomposition.u","declaration":"def SciLean.Meta.StructureDecomposition.u (self : SciLean.Meta.StructureDecomposition) : Lean.Level"}
{"name":"SciLean.Meta.IsDecomposition","declaration":"structure SciLean.Meta.IsDecomposition {X : Sort u_1} {X₁ : Sort u_2} {X₂ : Sort u_3} (p₁ : X → X₁) (p₂ : X → X₂) (q : X₁ → X₂ → X) : Prop"}
{"name":"SciLean.Meta.CodomainDecomposition.proof","declaration":"def SciLean.Meta.CodomainDecomposition.proof (self : SciLean.Meta.CodomainDecomposition) : let a := self.dec.q;\nQ(∀ (x : unknown_4), unknown_5 (unknown_9 x) unknown_7 = unknown_11 x)"}
{"name":"SciLean.Meta.IsDecomposition.mk_proj₂","declaration":"def SciLean.Meta.IsDecomposition.mk_proj₂ {X : Sort u_1} {X₁ : Sort u_2} {X₂ : Sort u_3} {p₁ : X → X₁} {p₂ : X → X₂} {q : X₁ → X₂ → X} (self : SciLean.Meta.IsDecomposition p₁ p₂ q) (x₁ : X₁) (x₂ : X₂) : p₂ (q x₁ x₂) = x₂"}
{"name":"SciLean.Meta.DomainDecomposition.f'","declaration":"def SciLean.Meta.DomainDecomposition.f' (self : SciLean.Meta.DomainDecomposition) : let a := self.dec.X₁;\nQ(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.DomainDecomposition","declaration":"/-- Decomposition of the domain of a function `f : X → Y` as `X ≃ X₁×X₂` and provides `f' : X₁ → Y` such that `f = f' ∘ p₁` where `p₁ : X → X₁` is the projection onto the first component.\n`\nIn other words, this claims that `f` does not use the `X₂` part of `X`.\n-/\nstructure SciLean.Meta.DomainDecomposition  : Type"}
{"name":"SciLean.Meta.DomainDecomposition.dec","declaration":"def SciLean.Meta.DomainDecomposition.dec (self : SciLean.Meta.DomainDecomposition) : SciLean.Meta.StructureDecomposition"}
{"name":"SciLean.Meta.StructureDecomposition.mk","declaration":"ctor SciLean.Meta.StructureDecomposition.mk {u : Lean.Level} {v : Lean.Level} {w : Lean.Level} (X : Q(Type u)) (X₁ : Q(Type v)) (X₂ : Q(Type w)) (p₁ : Q(«$X» → «$X₁»)) (p₂ : Q(«$X» → «$X₂»)) (q : Q(«$X₁» → «$X₂» → «$X»)) (proof : Q(SciLean.Meta.IsDecomposition «$p₁» «$p₂» «$q»)) : SciLean.Meta.StructureDecomposition"}
{"name":"SciLean.Meta.IsDecomposition.mk_proj₁","declaration":"def SciLean.Meta.IsDecomposition.mk_proj₁ {X : Sort u_1} {X₁ : Sort u_2} {X₂ : Sort u_3} {p₁ : X → X₁} {p₂ : X → X₂} {q : X₁ → X₂ → X} (self : SciLean.Meta.IsDecomposition p₁ p₂ q) (x₁ : X₁) (x₂ : X₂) : p₁ (q x₁ x₂) = x₁"}
{"name":"SciLean.Meta.factorDomainThroughProjections","declaration":"/-- Take a function `f : X → Y` and find projections `p₁ : X → X₁`, `p₂ : X → X₂` and function `f' : X₁ → Y` such that `h : f = f' ∘ p₁`\n-/\ndef SciLean.Meta.factorDomainThroughProjections (f : Lean.Expr) : Lean.MetaM (Option SciLean.Meta.DomainDecomposition)"}
{"name":"SciLean.Meta.IsDecomposition.proj_mk","declaration":"def SciLean.Meta.IsDecomposition.proj_mk {X : Sort u_1} {X₁ : Sort u_2} {X₂ : Sort u_3} {p₁ : X → X₁} {p₂ : X → X₂} {q : X₁ → X₂ → X} (self : SciLean.Meta.IsDecomposition p₁ p₂ q) (x : X) : q (p₁ x) (p₂ x) = x"}
{"name":"SciLean.Meta.StructureDecomposition.w","declaration":"def SciLean.Meta.StructureDecomposition.w (self : SciLean.Meta.StructureDecomposition) : Lean.Level"}
{"name":"SciLean.Meta.splitByCtors","declaration":"/-- Decomposes an element `e` that is a nested application of constructors\n\nFor example, calling this function on `x : (Nat×Nat)×Nat` returns `(#[x.1.1, x.1.2, x.1], fun a b c => ((a,b),c))`\n-/\nopaque SciLean.Meta.splitByCtors (e : Lean.Expr) : Lean.MetaM (Array Lean.Expr × Array Lean.Expr × Lean.Expr)"}
{"name":"SciLean.Meta.CodomainDecomposition","declaration":"structure SciLean.Meta.CodomainDecomposition  : Type"}
{"name":"SciLean.Meta.CodomainDecomposition.u","declaration":"def SciLean.Meta.CodomainDecomposition.u (self : SciLean.Meta.CodomainDecomposition) : Lean.Level"}
{"name":"SciLean.Meta.StructureDecomposition.v","declaration":"def SciLean.Meta.StructureDecomposition.v (self : SciLean.Meta.StructureDecomposition) : Lean.Level"}
