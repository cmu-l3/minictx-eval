{"name":"SciLean.Rand.uniform_sphere_density","declaration":"theorem SciLean.Rand.uniform_sphere_density (x : SciLean.Vec3) (r : Float) : MeasureTheory.volume.rnDeriv (SciLean.Rand.uniform (SciLean.Rand.sphere x r)).ℙ = fun y =>\n  ENNReal.ofReal (SciLean.Scalar.toReal Float (4 * SciLean.RealScalar.pi * r ^ 2))"}
{"name":"SciLean.Rand.sphere_volume","declaration":"theorem SciLean.Rand.sphere_volume {R : Type u_2} [SciLean.RealScalar R] {ι : Type u_3} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] {X : Type u_1} [SciLean.FinVec ι R X] (x : X) (r : R) : ↑↑MeasureTheory.volume Set.univ = ↑(4 * SciLean.RealScalar.pi * r ^ 2)"}
{"name":"SciLean.Rand.instToStringSphere","declaration":"instance SciLean.Rand.instToStringSphere {R : Type u_1} [SciLean.RealScalar R] {ι : Type u_2} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] {X : Type u_3} [SciLean.FinVec ι R X] (x : X) (r : R) [ToString X] : ToString (SciLean.Rand.sphere x r)"}
{"name":"SciLean.Rand.instMeasureSpaceSphere","declaration":"instance SciLean.Rand.instMeasureSpaceSphere {R : Type u_1} [SciLean.RealScalar R] {ι : Type u_2} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] {X : Type u_3} [SciLean.FinVec ι R X] (x : X) (r : R) : MeasureTheory.MeasureSpace (SciLean.Rand.sphere x r)"}
{"name":"SciLean.Rand.sphereMapDensity","declaration":"def SciLean.Rand.sphereMapDensity (f : SciLean.Vec3 → SciLean.Vec3) (x : SciLean.Vec3) : Float"}
{"name":"SciLean.Rand.mkSphereMap","declaration":"def SciLean.Rand.mkSphereMap (f : SciLean.Vec3 → SciLean.Vec3) (x : SciLean.Vec3) : SciLean.Vec3"}
{"name":"SciLean.Rand.elongate","declaration":"def SciLean.Rand.elongate (s : Float) (v : SciLean.Vec3) (x : SciLean.Vec3) : SciLean.Vec3"}
{"name":"SciLean.Rand.instUniformRandSphereFloatInstRealScalarFloatFinOfNatNatInstOfNatNatInstIndexTypeFinInstLawfulIndexTypeFinInstIndexTypeFinInstDecidableEqFinVec3InstFinVecToRCLikeToScalarInstArrayTypeVec3FinOfNatNatInstOfNatNatFloat","declaration":"instance SciLean.Rand.instUniformRandSphereFloatInstRealScalarFloatFinOfNatNatInstOfNatNatInstIndexTypeFinInstLawfulIndexTypeFinInstIndexTypeFinInstDecidableEqFinVec3InstFinVecToRCLikeToScalarInstArrayTypeVec3FinOfNatNatInstOfNatNatFloat (x : SciLean.Vec3) (r : Float) : SciLean.Rand.UniformRand (SciLean.Rand.sphere x r)"}
{"name":"SciLean.Rand.ball","declaration":"def SciLean.Rand.ball {R : Type u_1} [SciLean.RealScalar R] {ι : Type u_2} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] {X : Type u_3} [SciLean.FinVec ι R X] (x : X) (r : R) : Set X"}
{"name":"SciLean.Rand.sphere","declaration":"def SciLean.Rand.sphere {R : Type u_1} [SciLean.RealScalar R] {ι : Type u_2} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] {X : Type u_3} [SciLean.FinVec ι R X] (x : X) (r : R) : Type u_3"}
{"name":"SciLean.Rand.elongateDensity","declaration":"def SciLean.Rand.elongateDensity (s : Float) (v : SciLean.Vec3) (x : SciLean.Vec3) : Float"}
{"name":"SciLean.Rand.mkSphereMap'","declaration":"/-- On sphere this is identical to `mkSphereMap` but the jacobian of this map is equal to the\ntwo dimensional jacobian of `mkSphereMap f : S² → S²` which we need to compute as -/\ndef SciLean.Rand.mkSphereMap' (f : SciLean.Vec3 → SciLean.Vec3) (x : SciLean.Vec3) : SciLean.Vec3"}
