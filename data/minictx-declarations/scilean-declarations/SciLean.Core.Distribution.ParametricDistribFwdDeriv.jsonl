{"name":"SciLean.parDistribFwdDeriv.bind_rule","declaration":"theorem SciLean.parDistribFwdDeriv.bind_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_7} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {Z : Type u_2} [SciLean.Vec R Z] {U : Type u_5} [SciLean.Vec R U] {V : Type u_3} [SciLean.Vec R V] (f : X → Y → 𝒟'(Z, V)) (g : X → 𝒟'(Y, U)) (L : U ⊸[R] V ⊸[R] W) (hf : SciLean.DistribDifferentiable fun x =>\n  match x with\n  | (x, y) => f x y) (hg : SciLean.DistribDifferentiable g) : (SciLean.parDistribFwdDeriv fun x => SciLean.Distribution.bind (g x) (f x) L) = fun x dx =>\n  let ydy := SciLean.parDistribFwdDeriv g x dx;\n  let zdz := fun y => SciLean.parDistribFwdDeriv (fun x => f x y) x dx;\n  SciLean.Distribution.bind ydy zdz\n    (fun x ⊸[R]\n      match x with\n      | (r, dr) =>\n        fun x ⊸[R]\n          match x with\n          | (s, ds) => ((L r) s, (L r) ds + (L dr) s))"}
{"name":"SciLean.parDistribFwdDeriv","declaration":"def SciLean.parDistribFwdDeriv {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] (f : X → 𝒟'(Y, Z)) (x : X) (dx : X) : 𝒟'(Y, Z × Z)"}
{"name":"SciLean.parDistribFwdDeriv.comp_rule","declaration":"theorem SciLean.parDistribFwdDeriv.comp_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_5} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {Z : Type u_2} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] (f : Y → 𝒟'(Z, U)) (g : X → Y) (hf : SciLean.DistribDifferentiable f) (hg : SciLean.CDifferentiable R g) : (SciLean.parDistribFwdDeriv fun x => f (g x)) = fun x dx =>\n  let ydy := ∂> g x dx;\n  SciLean.parDistribFwdDeriv f ydy.1 ydy.2"}
