{"name":"SciLean.HasUniqueOdeSolution.uniq","declaration":"def SciLean.HasUniqueOdeSolution.uniq {R : Type u_1} [RCLike R] {X : Type u_2} [SciLean.Vec R X] {f : R → X → X} (self : SciLean.HasUniqueOdeSolution f) (t₀ : R) (x₀ : X) (x : R → X) (x' : R → X) : SciLean.IsOdeSolution f t₀ x₀ x → SciLean.IsOdeSolution f t₀ x₀ x' → x = x'"}
{"name":"SciLean.HasOdeSolution.mk","declaration":"ctor SciLean.HasOdeSolution.mk {R : Type u_1} [RCLike R] {X : Type u_2} [SciLean.Vec R X] {f : R → X → X} (ex : ∀ (t₀ : R) (x₀ : X), ∃ x, SciLean.IsOdeSolution f t₀ x₀ x) : SciLean.HasOdeSolution f"}
{"name":"SciLean.odeSolve","declaration":"def SciLean.odeSolve {R : Type u_1} [RCLike R] {X : Type u_2} [SciLean.Vec R X] (f : R → X → X) (t₀ : R) (t : R) (x₀ : X) : X"}
{"name":"SciLean.HasOdeSolution.ex","declaration":"def SciLean.HasOdeSolution.ex {R : Type u_1} [RCLike R] {X : Type u_2} [SciLean.Vec R X] {f : R → X → X} (self : SciLean.HasOdeSolution f) (t₀ : R) (x₀ : X) : ∃ x, SciLean.IsOdeSolution f t₀ x₀ x"}
{"name":"SciLean.IsOdeSolution","declaration":"def SciLean.IsOdeSolution {R : Type u_1} [RCLike R] {X : Type u_2} [SciLean.Vec R X] (f : R → X → X) (t₀ : R) (x₀ : X) (x : R → X) : Prop"}
{"name":"SciLean.odeSolve.arg_x₀.IsContinuousLinearMap_rule","declaration":"theorem SciLean.odeSolve.arg_x₀.IsContinuousLinearMap_rule {R : Type u_1} [RCLike R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] (f : R → X → X) (t₀ : R) (t : R) (x₀ : W → X) (hf : ∀ (t : R), SciLean.IsContinuousLinearMap R (f t)) (hx₀ : SciLean.IsContinuousLinearMap R x₀) : SciLean.IsContinuousLinearMap R fun w => SciLean.odeSolve f t₀ t (x₀ w)"}
{"name":"SciLean.odeSolve.arg_x₀.revCDeriv_rule","declaration":"theorem SciLean.odeSolve.arg_x₀.revCDeriv_rule {R : Type u_1} [RCLike R] {W : Type u_3} [SciLean.SemiInnerProductSpace R W] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] (f : R → X → X) (t₀ : R) (t : R) (x₀ : W → X) (hf : SciLean.HasAdjDiff R fun x =>\n  match x with\n  | (t, x) => f t x) (hx : SciLean.HasAdjDiff R x₀) : <∂ w, SciLean.odeSolve f t₀ t (x₀ w) = fun w =>\n  let x₀dx₀ := <∂ x₀ w;\n  let x := fun s => SciLean.odeSolve f t₀ s x₀dx₀.1;\n  let dfdx := fun s dx' => -∇ (x':=x s;dx'), f s x';\n  (x t, fun dx =>\n    let dx := SciLean.odeSolve dfdx t₀ t dx;\n    x₀dx₀.2 dx)"}
{"name":"SciLean.odeSolve.arg_ft₀tx₀.HasAdjDiff_rule","declaration":"theorem SciLean.odeSolve.arg_ft₀tx₀.HasAdjDiff_rule {R : Type u_1} [RCLike R] {W : Type u_3} [SciLean.SemiInnerProductSpace R W] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] (f : W → R → X → X) (t₀ : W → R) (t : W → R) (x₀ : W → X) (hf : SciLean.HasAdjDiff R fun x =>\n  match x with\n  | (w, t, x) => f w t x) (ht₀ : SciLean.HasAdjDiff R t₀) (ht : SciLean.HasAdjDiff R t) (hx : SciLean.HasAdjDiff R x₀) : SciLean.HasAdjDiff R fun w => SciLean.odeSolve (f w) (t₀ w) (t w) (x₀ w)"}
{"name":"SciLean.odeSolve.arg_ft₀tx₀.CDifferentiable_rule","declaration":"theorem SciLean.odeSolve.arg_ft₀tx₀.CDifferentiable_rule {R : Type u_1} [RCLike R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] (f : W → R → X → X) (t₀ : W → R) (t : W → R) (x₀ : W → X) (hf : SciLean.CDifferentiable R fun x =>\n  match x with\n  | (w, t, x) => f w t x) (ht₀ : SciLean.CDifferentiable R t₀) (ht : SciLean.CDifferentiable R t) (hx : SciLean.CDifferentiable R x₀) : SciLean.CDifferentiable R fun w => SciLean.odeSolve (f w) (t₀ w) (t w) (x₀ w)"}
{"name":"SciLean.odeSolve.arg_ft₀tx₀.fwdDeriv_rule","declaration":"theorem SciLean.odeSolve.arg_ft₀tx₀.fwdDeriv_rule {R : Type u_1} [RCLike R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] (f : W → R → X → X) (t₀ : W → R) (t : W → R) (x₀ : W → X) (hf : SciLean.CDifferentiable R fun x =>\n  match x with\n  | (w, t, x) => f w t x) (ht₀ : SciLean.CDifferentiable R t₀) (ht : SciLean.CDifferentiable R t) (hx : SciLean.CDifferentiable R x₀) : ∂> w, SciLean.odeSolve (f w) (t₀ w) (t w) (x₀ w) = fun w dw =>\n  let t₀dt₀ := ∂> t₀ w dw;\n  let tdt := ∂> t₀ w dw;\n  let x₀dx₀ := ∂> x₀ w dw;\n  let Tf := ∂> wkx, f wkx.1 wkx.2.1 wkx.2.2;\n  let F := fun t xdx =>\n    let x := xdx.1;\n    let dx := xdx.2;\n    Tf (w, t, x) (dw, t₀dt₀.2, dx);\n  let xdx := SciLean.odeSolve F t₀dt₀.1 tdt.1 x₀dx₀;\n  (xdx.1, xdx.2 + tdt.2 • f w tdt.1 xdx.1)"}
{"name":"SciLean.odeSolve.arg_x₀.semiAdjoint_rule","declaration":"theorem SciLean.odeSolve.arg_x₀.semiAdjoint_rule {R : Type u_1} [RCLike R] {W : Type u_3} [SciLean.SemiInnerProductSpace R W] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] (f : R → X → X) (t₀ : R) (t : R) (x₀ : W → X) (hf : ∀ (t : R), SciLean.HasSemiAdjoint R (f t)) (hx₀ : SciLean.HasSemiAdjoint R x₀) : (SciLean.semiAdjoint R fun w => SciLean.odeSolve f t₀ t (x₀ w)) = fun x₀' =>\n  let f' := fun s y => -SciLean.semiAdjoint R (f s) y;\n  let y := SciLean.odeSolve f' t t₀ x₀';\n  SciLean.semiAdjoint R x₀ y"}
{"name":"SciLean.HasUniqueOdeSolution.mk","declaration":"ctor SciLean.HasUniqueOdeSolution.mk {R : Type u_1} [RCLike R] {X : Type u_2} [SciLean.Vec R X] {f : R → X → X} (toHasOdeSolution : SciLean.HasOdeSolution f) (uniq : ∀ (t₀ : R) (x₀ : X) (x x' : R → X), SciLean.IsOdeSolution f t₀ x₀ x → SciLean.IsOdeSolution f t₀ x₀ x' → x = x') : SciLean.HasUniqueOdeSolution f"}
{"name":"SciLean.odeSolve.arg_ft₀tx₀.cderiv_rule","declaration":"theorem SciLean.odeSolve.arg_ft₀tx₀.cderiv_rule {R : Type u_1} [RCLike R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] (f : W → R → X → X) (t₀ : W → R) (t : W → R) (x₀ : W → X) (hf : SciLean.CDifferentiable R fun x =>\n  match x with\n  | (w, t, x) => f w t x) (ht₀ : SciLean.CDifferentiable R t₀) (ht : SciLean.CDifferentiable R t) (hx : SciLean.CDifferentiable R x₀) : ∂ w, SciLean.odeSolve (f w) (t₀ w) (t w) (x₀ w) = fun w dw =>\n  let t₀dt₀ := ∂> t₀ w dw;\n  let tdt := ∂> t₀ w dw;\n  let x₀dx₀ := ∂> x₀ w dw;\n  let Tf := ∂> wkx, f wkx.1 wkx.2.1 wkx.2.2;\n  let F := fun t xdx =>\n    let x := xdx.1;\n    let dx := xdx.2;\n    Tf (w, t, x) (dw, t₀dt₀.2, dx);\n  let xdx := SciLean.odeSolve F t₀dt₀.1 tdt.1 x₀dx₀;\n  xdx.2 + tdt.2 • f w tdt.1 xdx.1"}
{"name":"SciLean.HasOdeSolution","declaration":"structure SciLean.HasOdeSolution {R : Type u_1} [RCLike R] {X : Type u_2} [SciLean.Vec R X] (f : R → X → X) : Prop"}
{"name":"SciLean.HasUniqueOdeSolution","declaration":"structure SciLean.HasUniqueOdeSolution {R : Type u_1} [RCLike R] {X : Type u_2} [SciLean.Vec R X] (f : R → X → X) : Prop"}
{"name":"SciLean.odeSolve.arg_x₀.HasSemiAdjoint_rule","declaration":"theorem SciLean.odeSolve.arg_x₀.HasSemiAdjoint_rule {R : Type u_1} [RCLike R] {W : Type u_3} [SciLean.SemiInnerProductSpace R W] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] (f : R → X → X) (t₀ : R) (t : R) (x₀ : W → X) (hf : ∀ (t : R), SciLean.HasSemiAdjoint R (f t)) (hx₀ : SciLean.HasSemiAdjoint R x₀) : SciLean.HasSemiAdjoint R fun w => SciLean.odeSolve f t₀ t (x₀ w)"}
