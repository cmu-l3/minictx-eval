{"name":"SciLean.Scalar.oftoReal","declaration":"theorem SciLean.Scalar.oftoReal {R : Type u_1} [SciLean.RealScalar R] (x : R) : SciLean.Scalar.ofReal R (SciLean.Scalar.toReal R x) = x"}
{"name":"SciLean.Scalar.real","declaration":"def SciLean.Scalar.real {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : R"}
{"name":"SciLean.Scalar.tan","declaration":"def SciLean.Scalar.tan {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : K"}
{"name":"SciLean.Scalar.make","declaration":"def SciLean.Scalar.make {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] : R → R → K"}
{"name":"SciLean.RealScalar.asin","declaration":"def SciLean.RealScalar.asin {R : semiOutParam (Type u_1)} [self : SciLean.RealScalar R] (x : R) : R"}
{"name":"SciLean.RealScalar","declaration":"/-- `R` behaves as real numbers\n\nThis class allows us to write code independent of particular implementation of real numbers.\n\nSee `Scalar` for motivation for this class.\n-/\nclass SciLean.RealScalar (R : semiOutParam (Type u_1)) : Type u_1"}
{"name":"SciLean.Scalar.sin_def","declaration":"def SciLean.Scalar.sin_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toComplex (SciLean.Scalar.sin x) = Complex.sin (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.Scalar.pow","declaration":"def SciLean.Scalar.pow {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) (y : K) : K"}
{"name":"SciLean.scalar_sqrt_one","declaration":"theorem SciLean.scalar_sqrt_one {R : Type u_1} [SciLean.RealScalar R] : SciLean.Scalar.sqrt 1 = 1"}
{"name":"SciLean.Scalar.real_def","declaration":"def SciLean.Scalar.real_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toReal K (SciLean.Scalar.real x) = RCLike.re (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.Scalar.exp_def","declaration":"def SciLean.Scalar.exp_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toComplex (SciLean.Scalar.exp x) = Complex.exp (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.Scalar.exp","declaration":"def SciLean.Scalar.exp {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : K"}
{"name":"SciLean.Scalar.tanh_def","declaration":"def SciLean.Scalar.tanh_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toComplex (SciLean.Scalar.tanh x) = Complex.tanh (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.Scalar.oftoENNReal","declaration":"theorem SciLean.Scalar.oftoENNReal {R : Type u_1} [SciLean.RealScalar R] (x : R) : ↑↑x = max x 0"}
{"name":"SciLean.Scalar.toENNReal","declaration":"def SciLean.Scalar.toENNReal {R : Type u_1} [SciLean.RealScalar R] (x : R) : ENNReal"}
{"name":"SciLean.Scalar.imag","declaration":"def SciLean.Scalar.imag {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : R"}
{"name":"SciLean.Scalar.abs_def","declaration":"def SciLean.Scalar.abs_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toReal K (SciLean.Scalar.abs x) = Complex.abs (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.scalar_max_one_zero","declaration":"theorem SciLean.scalar_max_one_zero {R : Type u_1} [SciLean.RealScalar R] : max 1 0 = 1"}
{"name":"SciLean.Scalar.make_def","declaration":"def SciLean.Scalar.make_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : R) (y : R) : if ∀ (y : K), RCLike.im y = 0 then\n  SciLean.Scalar.toComplex (SciLean.Scalar.make x y) = { re := SciLean.Scalar.toReal K x, im := 0 }\nelse\n  SciLean.Scalar.toComplex (SciLean.Scalar.make x y) =\n    { re := SciLean.Scalar.toReal K x, im := SciLean.Scalar.toReal K y }"}
{"name":"SciLean.Scalar.ofComplex","declaration":"def SciLean.Scalar.ofComplex {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] : ℂ → K"}
{"name":"SciLean.RealScalar.mk","declaration":"ctor SciLean.RealScalar.mk {R : semiOutParam (Type u_1)} [toScalar : SciLean.Scalar R R] [toMin : Min R] [toMax : Max R] [toOrd : Ord R] (le_total : ∀ (a b : R), a ≤ b ∨ b ≤ a) (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) (decidableEq : DecidableEq R) (decidableLT : DecidableRel fun x x_1 => x < x_1) (min_def : autoParam (∀ (a b : R), min a b = if a ≤ b then a else b) _auto✝) (max_def : autoParam (∀ (a b : R), max a b = if a ≤ b then b else a) _auto✝) (compare_eq_compareOfLessAndEq : autoParam (∀ (a b : R), compare a b = compareOfLessAndEq a b) _auto✝) (is_real : ∀ (x : R), RCLike.im x = 0) (asin : R → R) (asin_def : ∀ (x : R), SciLean.Scalar.toReal R (asin x) = Real.arcsin (SciLean.Scalar.toReal R x)) (acos : R → R) (acos_def : ∀ (x : R), SciLean.Scalar.toReal R (acos x) = Real.arccos (SciLean.Scalar.toReal R x)) (atan : R → R) (atan_def : ∀ (x : R), SciLean.Scalar.toReal R (atan x) = Real.arctan (SciLean.Scalar.toReal R x)) : SciLean.RealScalar R"}
{"name":"SciLean.scalar_abs_one","declaration":"theorem SciLean.scalar_abs_one {R : Type u_1} [SciLean.RealScalar R] : SciLean.Scalar.abs 1 = 1"}
{"name":"SciLean.Scalar.imag_def","declaration":"def SciLean.Scalar.imag_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toReal K (SciLean.Scalar.imag x) = RCLike.im (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.RealScalar.atan","declaration":"def SciLean.RealScalar.atan {R : semiOutParam (Type u_1)} [self : SciLean.RealScalar R] (x : R) : R"}
{"name":"SciLean.Scalar.ofENNReal","declaration":"def SciLean.Scalar.ofENNReal {R : Type u_1} [SciLean.RealScalar R] (x : ENNReal) : R"}
{"name":"SciLean.Scalar.abs","declaration":"def SciLean.Scalar.abs {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : R"}
{"name":"SciLean.Scalar.log_def","declaration":"def SciLean.Scalar.log_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toComplex (SciLean.Scalar.log x) = Complex.log (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.Scalar.pow_def","declaration":"def SciLean.Scalar.pow_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) (y : K) : if ∀ (z : K), RCLike.im z = 0 then\n  SciLean.Scalar.toReal K (SciLean.Scalar.real (SciLean.Scalar.pow x y)) =\n    (SciLean.Scalar.toComplex x ^ SciLean.Scalar.toComplex y).re\nelse SciLean.Scalar.toComplex (SciLean.Scalar.pow x y) = SciLean.Scalar.toComplex x ^ SciLean.Scalar.toComplex y"}
{"name":"SciLean.conj_for_real_scalar","declaration":"theorem SciLean.conj_for_real_scalar {R : Type u_1} [SciLean.RealScalar R] (r : R) : (starRingEnd R) r = r"}
{"name":"SciLean.scalar_abs_neg","declaration":"theorem SciLean.scalar_abs_neg {R : Type u_1} [SciLean.RealScalar R] (r : R) : SciLean.Scalar.abs (-r) = SciLean.Scalar.abs r"}
{"name":"SciLean.scalar_sqrt_zero","declaration":"theorem SciLean.scalar_sqrt_zero {R : Type u_1} [SciLean.RealScalar R] : SciLean.Scalar.sqrt 0 = 0"}
{"name":"SciLean.Scalar.toComplex","declaration":"def SciLean.Scalar.toComplex {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] : K → ℂ"}
{"name":"SciLean.Scalar.toReal","declaration":"def SciLean.Scalar.toReal {R : outParam (Type u_1)} (K : semiOutParam (Type u_2)) [self : SciLean.Scalar R K] : R → ℝ"}
{"name":"SciLean.scalar_min_zero_one","declaration":"theorem SciLean.scalar_min_zero_one {R : Type u_1} [SciLean.RealScalar R] : min 0 1 = 0"}
{"name":"SciLean.instRealScalarReal","declaration":"instance SciLean.instRealScalarReal  : SciLean.RealScalar ℝ"}
{"name":"SciLean.Scalar.log","declaration":"def SciLean.Scalar.log {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : K"}
{"name":"SciLean.scalar_abs_zero","declaration":"theorem SciLean.scalar_abs_zero {R : Type u_1} [SciLean.RealScalar R] : SciLean.Scalar.abs 0 = 0"}
{"name":"SciLean.Scalar.cos","declaration":"def SciLean.Scalar.cos {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : K"}
{"name":"SciLean.scalar_div_one","declaration":"theorem SciLean.scalar_div_one {R : Type u_1} [SciLean.RealScalar R] (x : R) : x / 1 = x"}
{"name":"SciLean.instScalarRealComplex","declaration":"instance SciLean.instScalarRealComplex  : SciLean.Scalar ℝ ℂ"}
{"name":"SciLean.Scalar.sqrt_def","declaration":"def SciLean.Scalar.sqrt_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : if ∀ (y : K), RCLike.im y = 0 then\n  RCLike.re (SciLean.Scalar.toComplex (SciLean.Scalar.sqrt x)) = √(RCLike.re (SciLean.Scalar.toComplex x))\nelse SciLean.Scalar.toComplex (SciLean.Scalar.sqrt x) = Complex.cpow (SciLean.Scalar.toComplex x) (1 / 2)"}
{"name":"SciLean.Scalar.sin","declaration":"def SciLean.Scalar.sin {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : K"}
{"name":"SciLean.RealScalar.pi","declaration":"def SciLean.RealScalar.pi {R : Type u_1} [SciLean.RealScalar R] : R"}
{"name":"SciLean.Scalar.cos_def","declaration":"def SciLean.Scalar.cos_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toComplex (SciLean.Scalar.cos x) = Complex.cos (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.RealScalar.is_real","declaration":"def SciLean.RealScalar.is_real {R : semiOutParam (Type u_1)} [self : SciLean.RealScalar R] (x : R) : RCLike.im x = 0"}
{"name":"SciLean.Scalar","declaration":"/-- `K` are real or complex numbers over real numbers `R`\n\nThis class allows us to write code independent of particular implementation of real or complex numbers.\n\nThe main motivation for this class is to treat floating point numbers as real numbers but to minimize the impact of such unsoundness. We can write code with valid proofs and only at the last step before compilation provide inconsistent instance `Scalar Float Float`.\n\nAn alternative approach to get executable code would be to add a custom compiler step which would replace every occurance of real or complex numbers with their floating point equivalent. Implementing such compiler step turned out to be quite a non-trivial task thus we are taking this type class approach. -/\nclass SciLean.Scalar (R : outParam (Type u_1)) (K : semiOutParam (Type u_2)) : Type (max u_1 u_2)"}
{"name":"SciLean.Scalar.mk","declaration":"ctor SciLean.Scalar.mk {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [toRCLike : RCLike K] (toComplex : K → ℂ) (toReal : R → ℝ) (ofReal : ℝ → R) (ofComplex : ℂ → K) (make : R → R → K) (make_def : ∀ (x y : R),\n  if ∀ (y : K), RCLike.im y = 0 then toComplex (make x y) = { re := toReal x, im := 0 }\n  else toComplex (make x y) = { re := toReal x, im := toReal y }) (real : K → R) (real_def : ∀ (x : K), toReal (real x) = RCLike.re (toComplex x)) (imag : K → R) (imag_def : ∀ (x : K), toReal (imag x) = RCLike.im (toComplex x)) (sin : K → K) (sin_def : ∀ (x : K), toComplex (sin x) = Complex.sin (toComplex x)) (cos : K → K) (cos_def : ∀ (x : K), toComplex (cos x) = Complex.cos (toComplex x)) (tan : K → K) (tan_def : ∀ (x : K), toComplex (tan x) = Complex.tan (toComplex x)) (tanh : K → K) (tanh_def : ∀ (x : K), toComplex (tanh x) = Complex.tanh (toComplex x)) (exp : K → K) (exp_def : ∀ (x : K), toComplex (exp x) = Complex.exp (toComplex x)) (log : K → K) (log_def : ∀ (x : K), toComplex (log x) = Complex.log (toComplex x)) (sqrt : K → K) (sqrt_def : ∀ (x : K),\n  if ∀ (y : K), RCLike.im y = 0 then RCLike.re (toComplex (sqrt x)) = √(RCLike.re (toComplex x))\n  else toComplex (sqrt x) = Complex.cpow (toComplex x) (1 / 2)) (pow : K → K → K) (pow_def : ∀ (x y : K),\n  if ∀ (z : K), RCLike.im z = 0 then toReal (real (pow x y)) = (toComplex x ^ toComplex y).re\n  else toComplex (pow x y) = toComplex x ^ toComplex y) (abs : K → R) (abs_def : ∀ (x : K), toReal (abs x) = Complex.abs (toComplex x)) : SciLean.Scalar R K"}
{"name":"SciLean.Scalar.tan_def","declaration":"def SciLean.Scalar.tan_def {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : SciLean.Scalar.toComplex (SciLean.Scalar.tan x) = Complex.tan (SciLean.Scalar.toComplex x)"}
{"name":"SciLean.RealScalar.atan_def","declaration":"def SciLean.RealScalar.atan_def {R : semiOutParam (Type u_1)} [self : SciLean.RealScalar R] (x : R) : SciLean.Scalar.toReal R (SciLean.RealScalar.atan x) = Real.arctan (SciLean.Scalar.toReal R x)"}
{"name":"SciLean.Scalar.tanh","declaration":"def SciLean.Scalar.tanh {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : K"}
{"name":"SciLean.Scalar.sqrt","declaration":"def SciLean.Scalar.sqrt {R : outParam (Type u_1)} {K : semiOutParam (Type u_2)} [self : SciLean.Scalar R K] (x : K) : K"}
{"name":"SciLean.RealScalar.acos_def","declaration":"def SciLean.RealScalar.acos_def {R : semiOutParam (Type u_1)} [self : SciLean.RealScalar R] (x : R) : SciLean.Scalar.toReal R (SciLean.RealScalar.acos x) = Real.arccos (SciLean.Scalar.toReal R x)"}
{"name":"SciLean.Scalar.ofReal","declaration":"def SciLean.Scalar.ofReal {R : outParam (Type u_1)} (K : semiOutParam (Type u_2)) [self : SciLean.Scalar R K] : ℝ → R"}
{"name":"SciLean.RealScalar.acos","declaration":"def SciLean.RealScalar.acos {R : semiOutParam (Type u_1)} [self : SciLean.RealScalar R] (x : R) : R"}
{"name":"SciLean.scalar_min_one_zero","declaration":"theorem SciLean.scalar_min_one_zero {R : Type u_1} [SciLean.RealScalar R] : min 1 0 = 0"}
{"name":"SciLean.instHPow","declaration":"instance SciLean.instHPow {R : Type u_1} {K : Type u_2} [SciLean.Scalar R K] : HPow K K K"}
{"name":"SciLean.scalar_max_zero_one","declaration":"theorem SciLean.scalar_max_zero_one {R : Type u_1} [SciLean.RealScalar R] : max 0 1 = 1"}
{"name":"SciLean.RealScalar.asin_def","declaration":"def SciLean.RealScalar.asin_def {R : semiOutParam (Type u_1)} [self : SciLean.RealScalar R] (x : R) : SciLean.Scalar.toReal R (SciLean.RealScalar.asin x) = Real.arcsin (SciLean.Scalar.toReal R x)"}
