{"name":"SciLean.ContCDiffMap_apply_right","declaration":"theorem SciLean.ContCDiffMap_apply_right (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) (f : X ⟿[K,n] Y) : SciLean.ContCDiff K n fun x => f x"}
{"name":"SciLean.instVecContCDiffMap","declaration":"instance SciLean.instVecContCDiffMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : SciLean.Vec K (X ⟿[K,n] Y)"}
{"name":"SciLean.ContCDiffMap.mk.arg_f.ContCDiff_rule","declaration":"theorem SciLean.ContCDiffMap.mk.arg_f.ContCDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (f : X → Y → Z) (hf : SciLean.ContCDiff K ⊤ fun xy => f xy.1 xy.2) : SciLean.ContCDiff K ⊤ fun x => fun y ⟿[K,⊤] f x y"}
{"name":"SciLean.ContCDiffMap_eval_CDifferentiable'","declaration":"theorem SciLean.ContCDiffMap_eval_CDifferentiable' (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : SciLean.CDifferentiable K fun fx => fx.1 fx.2"}
{"name":"SciLean.«term_⟿[_]_»","declaration":"def SciLean.«term_⟿[_]_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.ContCDiffMap.smul_apply","declaration":"theorem SciLean.ContCDiffMap.smul_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (n : ℕ∞) (f : X ⟿[K,n] Y) (x : X) (r : K) : (r • f) x = r • f x"}
{"name":"SciLean.instUniformSpaceContCDiffMap","declaration":"instance SciLean.instUniformSpaceContCDiffMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : UniformSpace (X ⟿[K,n] Y)"}
{"name":"SciLean.instAddContCDiffMap","declaration":"instance SciLean.instAddContCDiffMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : Add (X ⟿[K,n] Y)"}
{"name":"SciLean.instNegContCDiffMap","declaration":"instance SciLean.instNegContCDiffMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : Neg (X ⟿[K,n] Y)"}
{"name":"SciLean.ContCDiffMap.mk'","declaration":"def SciLean.ContCDiffMap.mk' (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) (f : X → Y) (hf : SciLean.ContCDiff K n f) : X ⟿[K,n] Y"}
{"name":"SciLean.ContCDiffMap.toFun","declaration":"def SciLean.ContCDiffMap.toFun {K : Type u_1} [RCLike K] {n : ℕ∞} {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (self : X ⟿[K,n] Y) : X → Y"}
{"name":"SciLean.ContCDiffMap_partial","declaration":"theorem SciLean.ContCDiffMap_partial (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (n : ℕ) (f : W → X ⟿[K,↑n] Y) (g : W → X) (hf : SciLean.ContCDiff K (↑n) f) (hg : SciLean.ContCDiff K (↑n) g) : SciLean.ContCDiff K ↑n fun w => (f w) (g w)"}
{"name":"SciLean.«term_⟿[_,_]_»","declaration":"def SciLean.«term_⟿[_,_]_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.ContCDiffMap_apply_CDifferentiable","declaration":"theorem SciLean.ContCDiffMap_apply_CDifferentiable (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : W → X ⟿[K,⊤] Y) (g : W → X) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : SciLean.CDifferentiable K fun w => (f w) (g w)"}
{"name":"SciLean.ContCDiffMap.sub_apply","declaration":"theorem SciLean.ContCDiffMap.sub_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (n : ℕ∞) (f : X ⟿[K,n] Y) (g : X ⟿[K,n] Y) (x : X) : (f - g) x = f x - g x"}
{"name":"SciLean.«term_⟿_»","declaration":"def SciLean.«term_⟿_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.ContCDiffMap","declaration":"structure SciLean.ContCDiffMap (K : Type u_1) [RCLike K] (n : ℕ∞) (X : Type u_2) (Y : Type u_3) [SciLean.Vec K X] [SciLean.Vec K Y] : Type (max u_2 u_3)"}
{"name":"SciLean.instSubContCDiffMap","declaration":"instance SciLean.instSubContCDiffMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : Sub (X ⟿[K,n] Y)"}
{"name":"SciLean.ContCDiffMap.mk'_eval","declaration":"theorem SciLean.ContCDiffMap.mk'_eval {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) (x : X) (f : X → Y) (hf : SciLean.ContCDiff K n f) : { toFun := f, is_cont_cdiff_map := hf } x = f x"}
{"name":"SciLean.ContCDiffMap.mk.arg_f.IsSmoothLinearMap_rule","declaration":"theorem SciLean.ContCDiffMap.mk.arg_f.IsSmoothLinearMap_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_4} [SciLean.Vec K Y] {W : Type u_3} [SciLean.Vec K W] (n : ℕ∞) (f : W → X → Y) (hf₁ : SciLean.CDifferentiable K fun x =>\n  match x with\n  | (w, x) => f w x) (hf₂ : IsLinearMap K f) (hf₃ : ∀ (w : W), SciLean.ContCDiff K n (f w)) : SciLean.IsSmoothLinearMap K fun w => fun x ⟿[K,n] f w x"}
{"name":"SciLean.unexpandContCDiffMap","declaration":"def SciLean.unexpandContCDiffMap  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.instFunLikeContCDiffMap","declaration":"instance SciLean.instFunLikeContCDiffMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : FunLike (X ⟿[K,n] Y) X Y"}
{"name":"SciLean.ContCDiffMap_apply_linearSmoothMap","declaration":"theorem SciLean.ContCDiffMap_apply_linearSmoothMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (n : ℕ∞) (f : W → X ⟿[K,n] Y) (hf : SciLean.IsSmoothLinearMap K f) (x : X) : SciLean.IsSmoothLinearMap K fun w => (f w) x"}
{"name":"SciLean.instZeroContCDiffMap","declaration":"instance SciLean.instZeroContCDiffMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : Zero (X ⟿[K,n] Y)"}
{"name":"SciLean.ContCDiffMap.is_cont_cdiff_map","declaration":"def SciLean.ContCDiffMap.is_cont_cdiff_map {K : Type u_1} [RCLike K] {n : ℕ∞} {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (self : X ⟿[K,n] Y) : SciLean.ContCDiff K n self.toFun"}
{"name":"SciLean.ContCDiffMap_eta","declaration":"theorem SciLean.ContCDiffMap_eta (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) (f : X ⟿[K,n] Y) : (fun x ⟿[K,n] f x) = f"}
{"name":"SciLean.unexpandContCDiffMapMk","declaration":"def SciLean.unexpandContCDiffMapMk  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.ContCDiffMap_apply_CDifferentiableAt","declaration":"theorem SciLean.ContCDiffMap_apply_CDifferentiableAt (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : W → X ⟿[K,⊤] Y) (g : W → X) (w : W) (hf : SciLean.CDifferentiableAt K f w) (hg : SciLean.CDifferentiableAt K g w) : SciLean.CDifferentiableAt K (fun w => (f w) (g w)) w"}
{"name":"SciLean.ContCDiffMap_eval_CDifferentiable","declaration":"theorem SciLean.ContCDiffMap_eval_CDifferentiable (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) (h : 0 < n) : SciLean.CDifferentiable K fun fx => fx.1 fx.2"}
{"name":"SciLean.instSMulContCDiffMap","declaration":"instance SciLean.instSMulContCDiffMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : SMul K (X ⟿[K,n] Y)"}
{"name":"SciLean.ContCDiffMap.mk","declaration":"ctor SciLean.ContCDiffMap.mk {K : Type u_1} [RCLike K] {n : ℕ∞} {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (toFun : X → Y) (is_cont_cdiff_map : SciLean.ContCDiff K n toFun) : X ⟿[K,n] Y"}
{"name":"SciLean.«termFun_⟿_»","declaration":"def SciLean.«termFun_⟿_»  : Lean.ParserDescr"}
{"name":"SciLean.ContCDiffMap.zero_apply","declaration":"theorem SciLean.ContCDiffMap.zero_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (n : ℕ∞) (x : X) : 0 x = 0"}
{"name":"SciLean.ContCDiffMap.neg_apply","declaration":"theorem SciLean.ContCDiffMap.neg_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (n : ℕ∞) (f : X ⟿[K,n] Y) (x : X) : (-f) x = -f x"}
{"name":"SciLean.ContCDiffMap.mk.arg_f.ContCDiff_rule_partial","declaration":"theorem SciLean.ContCDiffMap.mk.arg_f.ContCDiff_rule_partial (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (n : ℕ) (l : ℕ) (k : ℕ) (f : X → Y → Z) (hf : SciLean.ContCDiff K ↑n fun xy => f xy.1 xy.2) (h : l + k ≤ n) : SciLean.ContCDiff K ↑k fun x => fun y ⟿[K,↑l] f x y"}
{"name":"SciLean.ContCDiffMap_apply","declaration":"theorem SciLean.ContCDiffMap_apply (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : W → X ⟿[K,⊤] Y) (g : W → X) (hf : SciLean.ContCDiff K ⊤ f) (hg : SciLean.ContCDiff K ⊤ g) : SciLean.ContCDiff K ⊤ fun w => (f w) (g w)"}
{"name":"SciLean.«termFun_⟿[_,_]_»","declaration":"def SciLean.«termFun_⟿[_,_]_»  : Lean.ParserDescr"}
{"name":"SciLean.ContCDiffMap.eta_reduce","declaration":"theorem SciLean.ContCDiffMap.eta_reduce {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) (f : X ⟿[K,n] Y) : { toFun := f.toFun, is_cont_cdiff_map := ⋯ } = f"}
{"name":"SciLean.ContCDiffMap.add_apply","declaration":"theorem SciLean.ContCDiffMap.add_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (n : ℕ∞) (f : X ⟿[K,n] Y) (g : X ⟿[K,n] Y) (x : X) : (f + g) x = f x + g x"}
{"name":"SciLean.«termFun_⟿[_]_»","declaration":"def SciLean.«termFun_⟿[_]_»  : Lean.ParserDescr"}
