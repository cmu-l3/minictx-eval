{"name":"SciLean.Scalar.log_inv","declaration":"theorem SciLean.Scalar.log_inv {R : Type u_1} [SciLean.RealScalar R] (x : R) : SciLean.Scalar.log x⁻¹ = -SciLean.Scalar.log x"}
{"name":"SciLean.Scalar.log.arg_x.fwdDeriv_rule","declaration":"theorem SciLean.Scalar.log.arg_x.fwdDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (x : W → R) (hx : SciLean.CDifferentiable R x) (hw : ∀ (w : W), x w ≠ 0) : (SciLean.fwdDeriv R fun w => SciLean.Scalar.log (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv R x w dw;\n  let l := SciLean.Scalar.log xdx.1;\n  (l, xdx.2 / SciLean.Scalar.abs xdx.1)"}
{"name":"SciLean.Scalar.log.arg_x.revDeriv_rule","declaration":"theorem SciLean.Scalar.log.arg_x.revDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {U : Type u_2} [SciLean.SemiInnerProductSpace R U] (x : U → R) (hx : SciLean.HasAdjDiff R x) (hu : ∀ (u : U), x u ≠ 0) : (SciLean.revDeriv R fun u => SciLean.Scalar.log (x u)) = fun u =>\n  let xdx := SciLean.revDeriv R x u;\n  (SciLean.Scalar.log xdx.1, fun dy => xdx.2 ((SciLean.Scalar.abs (x u))⁻¹ * dy))"}
{"name":"SciLean.Scalar.exp.arg_x.HasAdjDiff_rule","declaration":"theorem SciLean.Scalar.exp.arg_x.HasAdjDiff_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {U : Type u_2} [SciLean.SemiInnerProductSpace C U] (x : U → C) (hx : SciLean.HasAdjDiff C x) : SciLean.HasAdjDiff C fun u => SciLean.Scalar.exp (x u)"}
{"name":"SciLean.Scalar.log_mul","declaration":"theorem SciLean.Scalar.log_mul {R : Type u_1} [SciLean.RealScalar R] (x : R) (y : R) : SciLean.Scalar.log (x * y) = SciLean.Scalar.log x + SciLean.Scalar.log y"}
{"name":"SciLean.Scalar.exp.arg_x.CDifferentiable_rule","declaration":"theorem SciLean.Scalar.exp.arg_x.CDifferentiable_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : SciLean.CDifferentiable C fun w => SciLean.Scalar.exp (x w)"}
{"name":"SciLean.Scalar.log.arg_x.HasAdjDiff_rule","declaration":"theorem SciLean.Scalar.log.arg_x.HasAdjDiff_rule {R : Type u_1} [SciLean.RealScalar R] {U : Type u_2} [SciLean.SemiInnerProductSpace R U] (x : U → R) (hx : SciLean.HasAdjDiff R x) (hu : ∀ (u : U), x u ≠ 0) : SciLean.HasAdjDiff R fun u => SciLean.Scalar.log (x u)"}
{"name":"SciLean.Scalar.log_div","declaration":"theorem SciLean.Scalar.log_div {R : Type u_1} [SciLean.RealScalar R] (x : R) (y : R) : SciLean.Scalar.log (x / y) = SciLean.Scalar.log x - SciLean.Scalar.log y"}
{"name":"SciLean.Scalar.exp.arg_x.fwdDeriv_rule","declaration":"theorem SciLean.Scalar.exp.arg_x.fwdDeriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : (SciLean.fwdDeriv C fun w => SciLean.Scalar.exp (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv C x w dw;\n  let e := SciLean.Scalar.exp xdx.1;\n  (e, xdx.2 * e)"}
{"name":"SciLean.Scalar.log.arg_x.cderiv_rule_at","declaration":"theorem SciLean.Scalar.log.arg_x.cderiv_rule_at {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (w : W) (x : W → R) (hx : SciLean.CDifferentiableAt R x w) (hw : x w ≠ 0) : SciLean.cderiv R (fun w => SciLean.Scalar.log (x w)) w = fun dw =>\n  let xdx := SciLean.fwdDeriv R x w dw;\n  xdx.2 / SciLean.Scalar.abs xdx.1"}
{"name":"SciLean.Scalar.log.arg_x.revDeriv_rule_at","declaration":"theorem SciLean.Scalar.log.arg_x.revDeriv_rule_at {R : Type u_1} [SciLean.RealScalar R] {U : Type u_2} [SciLean.SemiInnerProductSpace R U] (u : U) (x : U → R) (hx : SciLean.HasAdjDiffAt R x u) (hu : x u ≠ 0) : SciLean.revDeriv R (fun u => SciLean.Scalar.log (x u)) u =\n  let xdx := SciLean.revDeriv R x u;\n  (SciLean.Scalar.log xdx.1, fun dy => xdx.2 ((SciLean.Scalar.abs (x u))⁻¹ * dy))"}
{"name":"SciLean.Scalar.exp.arg_x.ceriv_rule","declaration":"theorem SciLean.Scalar.exp.arg_x.ceriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : (SciLean.cderiv C fun w => SciLean.Scalar.exp (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv C x w dw;\n  let e := SciLean.Scalar.exp xdx.1;\n  xdx.2 * e"}
{"name":"SciLean.Scalar.exp.arg_x.revDeriv_rule","declaration":"theorem SciLean.Scalar.exp.arg_x.revDeriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {U : Type u_2} [SciLean.SemiInnerProductSpace C U] (x : U → C) (hx : SciLean.HasAdjDiff C x) : (SciLean.revDeriv C fun u => SciLean.Scalar.exp (x u)) = fun u =>\n  let xdx := SciLean.revDeriv C x u;\n  (SciLean.Scalar.exp xdx.1, fun dy => xdx.2 ((starRingEnd C) (SciLean.Scalar.exp xdx.1) * dy))"}
{"name":"SciLean.Scalar.log.arg_x.cderiv_rule","declaration":"theorem SciLean.Scalar.log.arg_x.cderiv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (x : W → R) (hx : SciLean.CDifferentiable R x) (hw : ∀ (w : W), x w ≠ 0) : (SciLean.cderiv R fun w => SciLean.Scalar.log (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv R x w dw;\n  xdx.2 / SciLean.Scalar.abs xdx.1"}
{"name":"SciLean.Scalar.log.arg_x.HasAdjDiffAt_rule","declaration":"theorem SciLean.Scalar.log.arg_x.HasAdjDiffAt_rule {R : Type u_1} [SciLean.RealScalar R] {U : Type u_2} [SciLean.SemiInnerProductSpace R U] (u : U) (x : U → R) (hx : SciLean.HasAdjDiffAt R x u) (hu : x u ≠ 0) : SciLean.HasAdjDiffAt R (fun u => SciLean.Scalar.log (x u)) u"}
{"name":"SciLean.Scalar.log_one","declaration":"theorem SciLean.Scalar.log_one {R : Type u_1} [SciLean.RealScalar R] : SciLean.Scalar.log 1 = 0"}
{"name":"SciLean.Scalar.log.arg_x.CDifferentiableAt_rule","declaration":"theorem SciLean.Scalar.log.arg_x.CDifferentiableAt_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (w : W) (x : W → R) (hx : SciLean.CDifferentiableAt R x w) (hw : x w ≠ 0) : SciLean.CDifferentiableAt R (fun w => SciLean.Scalar.log (x w)) w"}
{"name":"SciLean.Scalar.log.arg_x.fwdDeriv_rule_at","declaration":"theorem SciLean.Scalar.log.arg_x.fwdDeriv_rule_at {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (w : W) (x : W → R) (hx : SciLean.CDifferentiableAt R x w) (hw : x w ≠ 0) : SciLean.fwdDeriv R (fun w => SciLean.Scalar.log (x w)) w = fun dw =>\n  let xdx := SciLean.fwdDeriv R x w dw;\n  let l := SciLean.Scalar.log xdx.1;\n  (l, xdx.2 / SciLean.Scalar.abs xdx.1)"}
{"name":"SciLean.Scalar.log_exp","declaration":"theorem SciLean.Scalar.log_exp {R : Type u_1} [SciLean.RealScalar R] (x : R) : SciLean.Scalar.log (SciLean.Scalar.exp x) = x"}
{"name":"SciLean.Scalar.log.arg_x.CDifferentiable_rule","declaration":"theorem SciLean.Scalar.log.arg_x.CDifferentiable_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (x : W → R) (hx : SciLean.CDifferentiable R x) (hw : ∀ (w : W), x w ≠ 0) : SciLean.CDifferentiable R fun w => SciLean.Scalar.log (x w)"}
