{"name":"SciLean.Scalar.sin.arg_x.HasAdjDiff_rule","declaration":"theorem SciLean.Scalar.sin.arg_x.HasAdjDiff_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {U : Type u_2} [SciLean.SemiInnerProductSpace C U] (x : U → C) (hx : SciLean.HasAdjDiff C x) : SciLean.HasAdjDiff C fun u => SciLean.Scalar.sin (x u)"}
{"name":"SciLean.Scalar.cos.arg_x.CDifferentiable_rule","declaration":"theorem SciLean.Scalar.cos.arg_x.CDifferentiable_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : SciLean.CDifferentiable C fun w => SciLean.Scalar.cos (x w)"}
{"name":"SciLean.Scalar.tanh.arg_x.revDeriv_rule","declaration":"theorem SciLean.Scalar.tanh.arg_x.revDeriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {U : Type u_2} [SciLean.SemiInnerProductSpace C U] (x : U → C) (hx : SciLean.HasAdjDiff C x) : (SciLean.revDeriv C fun u => SciLean.Scalar.tanh (x u)) = fun u =>\n  let xdx := SciLean.revDeriv C x u;\n  (SciLean.Scalar.tanh xdx.1, fun dy => xdx.2 ((starRingEnd C) (1 - SciLean.Scalar.tanh xdx.1 ^ 2) * dy))"}
{"name":"SciLean.Scalar.cos.arg_x.ceriv_rule","declaration":"theorem SciLean.Scalar.cos.arg_x.ceriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : (SciLean.cderiv C fun w => SciLean.Scalar.cos (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv C x w dw;\n  let s := -SciLean.Scalar.sin xdx.1;\n  xdx.2 * s"}
{"name":"SciLean.Scalar.cos.arg_x.HasAdjDiff_rule","declaration":"theorem SciLean.Scalar.cos.arg_x.HasAdjDiff_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {U : Type u_2} [SciLean.SemiInnerProductSpace C U] (x : U → C) (hx : SciLean.HasAdjDiff C x) : SciLean.HasAdjDiff C fun u => SciLean.Scalar.cos (x u)"}
{"name":"SciLean.Scalar.sin.arg_x.revDeriv_rule","declaration":"theorem SciLean.Scalar.sin.arg_x.revDeriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {U : Type u_2} [SciLean.SemiInnerProductSpace C U] (x : U → C) (hx : SciLean.HasAdjDiff C x) : (SciLean.revDeriv C fun u => SciLean.Scalar.sin (x u)) = fun u =>\n  let xdx := SciLean.revDeriv C x u;\n  (SciLean.Scalar.sin xdx.1, fun dy => xdx.2 ((starRingEnd C) (SciLean.Scalar.cos xdx.1) * dy))"}
{"name":"SciLean.Scalar.sin.arg_x.ceriv_rule","declaration":"theorem SciLean.Scalar.sin.arg_x.ceriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : (SciLean.cderiv C fun w => SciLean.Scalar.sin (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv C x w dw;\n  let c := SciLean.Scalar.cos xdx.1;\n  xdx.2 * c"}
{"name":"SciLean.Scalar.cos.arg_x.fwdDeriv_rule","declaration":"theorem SciLean.Scalar.cos.arg_x.fwdDeriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : (SciLean.fwdDeriv C fun w => SciLean.Scalar.cos (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv C x w dw;\n  let s := SciLean.Scalar.sin xdx.1;\n  let c := SciLean.Scalar.cos xdx.1;\n  (c, xdx.2 * -s)"}
{"name":"SciLean.Scalar.tanh.arg_x.CDifferentiable_rule","declaration":"theorem SciLean.Scalar.tanh.arg_x.CDifferentiable_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : SciLean.CDifferentiable C fun w => SciLean.Scalar.tanh (x w)"}
{"name":"SciLean.Scalar.tanh.arg_x.ceriv_rule","declaration":"theorem SciLean.Scalar.tanh.arg_x.ceriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : (SciLean.cderiv C fun w => SciLean.Scalar.tanh (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv C x w dw;\n  let t := SciLean.Scalar.tanh xdx.1;\n  let dt := 1 - t ^ 2;\n  xdx.2 * dt"}
{"name":"SciLean.Scalar.tanh.arg_x.fwdDeriv_rule","declaration":"theorem SciLean.Scalar.tanh.arg_x.fwdDeriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : (SciLean.fwdDeriv C fun w => SciLean.Scalar.tanh (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv C x w dw;\n  let t := SciLean.Scalar.tanh xdx.1;\n  let dt := 1 - t ^ 2;\n  (t, xdx.2 * dt)"}
{"name":"SciLean.Scalar.tanh.arg_x.HasAdjDiff_rule","declaration":"theorem SciLean.Scalar.tanh.arg_x.HasAdjDiff_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {U : Type u_2} [SciLean.SemiInnerProductSpace C U] (x : U → C) (hx : SciLean.HasAdjDiff C x) : SciLean.HasAdjDiff C fun u => SciLean.Scalar.tanh (x u)"}
{"name":"SciLean.Scalar.sin.arg_x.fwdDeriv_rule","declaration":"theorem SciLean.Scalar.sin.arg_x.fwdDeriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : (SciLean.fwdDeriv C fun w => SciLean.Scalar.sin (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv C x w dw;\n  let s := SciLean.Scalar.sin xdx.1;\n  let c := SciLean.Scalar.cos xdx.1;\n  (s, xdx.2 * c)"}
{"name":"SciLean.Scalar.cos.arg_x.revDeriv_rule","declaration":"theorem SciLean.Scalar.cos.arg_x.revDeriv_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {U : Type u_2} [SciLean.SemiInnerProductSpace C U] (x : U → C) (hx : SciLean.HasAdjDiff C x) : (SciLean.revDeriv C fun u => SciLean.Scalar.cos (x u)) = fun u =>\n  let xdx := SciLean.revDeriv C x u;\n  (SciLean.Scalar.cos xdx.1, fun dy => xdx.2 (-(starRingEnd C) (SciLean.Scalar.sin xdx.1) * dy))"}
{"name":"SciLean.Scalar.sin.arg_x.CDifferentiable_rule","declaration":"theorem SciLean.Scalar.sin.arg_x.CDifferentiable_rule {R : Type u_3} {C : Type u_1} [SciLean.Scalar R C] {W : Type u_2} [SciLean.Vec C W] (x : W → C) (hx : SciLean.CDifferentiable C x) : SciLean.CDifferentiable C fun w => SciLean.Scalar.sin (x w)"}
