{"name":"SciLean.fwdDeriv.SciLean.norm₂.arg_x.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.SciLean.norm₂.arg_x.fwdDeriv_rule_at {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (x : X) (f : X → Y) (hf : SciLean.CDifferentiableAt R f x) (hx : f x ≠ 0) : SciLean.fwdDeriv R (fun x => ‖f x‖₂[R]) x = fun dx =>\n  let ydy := SciLean.fwdDeriv R f x dx;\n  let ynorm := ‖ydy.1‖₂[R];\n  (ynorm, ynorm⁻¹ * ⟪ydy.2, ydy.1⟫_R)"}
{"name":"SciLean.fwdDeriv.Inner.inner.arg_a0a1.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.Inner.inner.arg_a0a1.fwdDeriv_rule_at {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiableAt R f x) (hg : SciLean.CDifferentiableAt R g x) : SciLean.fwdDeriv R (fun x => ⟪f x, g x⟫_R) x = fun dx =>\n  let y₁dy₁ := SciLean.fwdDeriv R f x dx;\n  let y₂dy₂ := SciLean.fwdDeriv R g x dx;\n  (⟪y₁dy₁.1, y₂dy₂.1⟫_R, ⟪y₁dy₁.2, y₂dy₂.1⟫_R + ⟪y₁dy₁.1, y₂dy₂.2⟫_R)"}
{"name":"SciLean.fwdDeriv.Prod.snd.arg_self.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.Prod.snd.arg_self.fwdDeriv_rule_at {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (x : X) (f : X → Y × Z) (hf : SciLean.CDifferentiableAt K f x) : SciLean.fwdDeriv K (fun x => (f x).2) x = fun dx =>\n  let yzdyz := SciLean.fwdDeriv K f x dx;\n  (yzdyz.1.2, yzdyz.2.2)"}
{"name":"SciLean.fwdDeriv.HMul.hMul.arg_a0a1.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.HMul.hMul.arg_a0a1.fwdDeriv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (x : X) (f : X → K) (g : X → K) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) : SciLean.fwdDeriv K (fun x => f x * g x) x = fun dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  (ydy.1 * zdz.1, zdz.2 * ydy.1 + ydy.2 * zdz.1)"}
{"name":"SciLean.fwdDeriv.HSub.hSub.arg_a0a1.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.HSub.hSub.arg_a0a1.fwdDeriv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) : SciLean.fwdDeriv K (fun x => f x - g x) x = fun dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  ydy - zdz"}
{"name":"SciLean.fwdDeriv.Inner.inner.arg_a0a1.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.Inner.inner.arg_a0a1.fwdDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiable R f) (hg : SciLean.CDifferentiable R g) : (SciLean.fwdDeriv R fun x => ⟪f x, g x⟫_R) = fun x dx =>\n  let y₁dy₁ := SciLean.fwdDeriv R f x dx;\n  let y₂dy₂ := SciLean.fwdDeriv R g x dx;\n  (⟪y₁dy₁.1, y₂dy₂.1⟫_R, ⟪y₁dy₁.2, y₂dy₂.1⟫_R + ⟪y₁dy₁.1, y₂dy₂.2⟫_R)"}
{"name":"SciLean.fwdDeriv.Prod.mk.arg_fstsnd.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.Prod.mk.arg_fstsnd.fwdDeriv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (g : X → Y) (hg : SciLean.CDifferentiable K g) (f : X → Z) (hf : SciLean.CDifferentiable K f) : (SciLean.fwdDeriv K fun x => (g x, f x)) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K g x dx;\n  let zdz := SciLean.fwdDeriv K f x dx;\n  ((ydy.1, zdz.1), ydy.2, zdz.2)"}
{"name":"SciLean.fwdDeriv","declaration":"def SciLean.fwdDeriv (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (x : X) (dx : X) : Y × Y"}
{"name":"SciLean.fwdDeriv.comp_rule","declaration":"theorem SciLean.fwdDeriv.comp_rule {K : Type u_1} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.fwdDeriv K fun x => f (g x)) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K g x dx;\n  let zdz := SciLean.fwdDeriv K f ydy.1 ydy.2;\n  zdz"}
{"name":"SciLean.fwdDeriv.Prod.snd.arg_self.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.Prod.snd.arg_self.fwdDeriv_rule {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (f : X → Y × Z) (hf : SciLean.CDifferentiable K f) : (SciLean.fwdDeriv K fun x => (f x).2) = fun x dx =>\n  let yzdyz := SciLean.fwdDeriv K f x dx;\n  (yzdyz.1.2, yzdyz.2.2)"}
{"name":"SciLean.fwdDeriv.pi_rule","declaration":"theorem SciLean.fwdDeriv.pi_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {ι : Type u_4} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.CDifferentiable K fun x => f x i) : (SciLean.fwdDeriv K fun x i => f x i) = fun x dx =>\n  (fun i => f x i, fun i => (SciLean.fwdDeriv K (fun x => f x i) x dx).2)"}
{"name":"SciLean.fwdDeriv.HAdd.hAdd.arg_a0a1.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.HAdd.hAdd.arg_a0a1.fwdDeriv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.fwdDeriv K fun x => f x + g x) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  ydy + zdz"}
{"name":"SciLean.fwdDeriv.SciLean.Norm2.norm2.arg_a0.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.SciLean.Norm2.norm2.arg_a0.fwdDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (hf : SciLean.CDifferentiable R f) : (SciLean.fwdDeriv R fun x => ‖f x‖₂²) = fun x dx =>\n  let ydy := SciLean.fwdDeriv R f x dx;\n  (‖ydy.1‖₂², 2 * ⟪ydy.2, ydy.1⟫_R)"}
{"name":"SciLean.fwdDeriv.SciLean.norm₂.arg_x.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.SciLean.norm₂.arg_x.fwdDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (hf : SciLean.CDifferentiable R f) (hx : ∀ (x : X), f x ≠ 0) : (SciLean.fwdDeriv R fun x => ‖f x‖₂[R]) = fun x dx =>\n  let ydy := SciLean.fwdDeriv R f x dx;\n  let ynorm := ‖ydy.1‖₂[R];\n  (ynorm, ynorm⁻¹ * ⟪ydy.2, ydy.1⟫_R)"}
{"name":"SciLean.fwdDeriv.Prod.fst.arg_self.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.Prod.fst.arg_self.fwdDeriv_rule {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (f : X → Y × Z) (hf : SciLean.CDifferentiable K f) : (SciLean.fwdDeriv K fun x => (f x).1) = fun x dx =>\n  let yzdyz := SciLean.fwdDeriv K f x dx;\n  (yzdyz.1.1, yzdyz.2.1)"}
{"name":"SciLean.fwdDeriv.const_rule","declaration":"theorem SciLean.fwdDeriv.const_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (y : Y) : (SciLean.fwdDeriv K fun x => y) = fun x dx => (y, 0)"}
{"name":"SciLean.fwdDeriv.comp_rule_at","declaration":"theorem SciLean.fwdDeriv.comp_rule_at {K : Type u_1} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (x : X) (f : Y → Z) (g : X → Y) (hf : SciLean.CDifferentiableAt K f (g x)) (hg : SciLean.CDifferentiableAt K g x) : SciLean.fwdDeriv K (fun x => f (g x)) x = fun dx =>\n  let ydy := SciLean.fwdDeriv K g x dx;\n  let zdz := SciLean.fwdDeriv K f ydy.1 ydy.2;\n  zdz"}
{"name":"SciLean.fwdDeriv.SciLean.Norm2.norm2.arg_a0.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.SciLean.Norm2.norm2.arg_a0.fwdDeriv_rule_at {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (x : X) (f : X → Y) (hf : SciLean.CDifferentiableAt R f x) : SciLean.fwdDeriv R (fun x => ‖f x‖₂²) x = fun dx =>\n  let ydy := SciLean.fwdDeriv R f x dx;\n  (‖ydy.1‖₂², 2 * ⟪ydy.2, ydy.1⟫_R)"}
{"name":"SciLean.fwdDeriv.HMul.hMul.arg_a0a1.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.HMul.hMul.arg_a0a1.fwdDeriv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (g : X → K) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.fwdDeriv K fun x => f x * g x) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  (ydy.1 * zdz.1, zdz.2 * ydy.1 + ydy.2 * zdz.1)"}
{"name":"SciLean.fwdDeriv.HPow.hPow.arg_a0.fwdDeriv_rule_at","declaration":"def SciLean.fwdDeriv.HPow.hPow.arg_a0.fwdDeriv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (n : ℕ) (x : X) (f : X → K) (hf : SciLean.CDifferentiableAt K f x) : SciLean.fwdDeriv K (fun x => f x ^ n) x = fun dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  (ydy.1 ^ n, ↑n * ydy.2 * ydy.1 ^ (n - 1))"}
{"name":"SciLean.fwdDeriv.Prod.mk.arg_fstsnd.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.Prod.mk.arg_fstsnd.fwdDeriv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (x : X) (g : X → Y) (hg : SciLean.CDifferentiableAt K g x) (f : X → Z) (hf : SciLean.CDifferentiableAt K f x) : SciLean.fwdDeriv K (fun x => (g x, f x)) x = fun dx =>\n  let ydy := SciLean.fwdDeriv K g x dx;\n  let zdz := SciLean.fwdDeriv K f x dx;\n  ((ydy.1, zdz.1), ydy.2, zdz.2)"}
{"name":"SciLean.fwdDeriv.ite.arg_te.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.ite.arg_te.fwdDeriv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) : (SciLean.fwdDeriv K fun x => if c then t x else e x) = fun y =>\n  if c then SciLean.fwdDeriv K t y else SciLean.fwdDeriv K e y"}
{"name":"SciLean.fwdDeriv.let_rule_at","declaration":"theorem SciLean.fwdDeriv.let_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (x : X) (f : X → Y → Z) (g : X → Y) (hf : SciLean.CDifferentiableAt K (fun xy => f xy.1 xy.2) (x, g x)) (hg : SciLean.CDifferentiableAt K g x) : SciLean.fwdDeriv K\n    (fun x =>\n      let y := g x;\n      f x y)\n    x =\n  fun dx =>\n  let ydy := SciLean.fwdDeriv K g x dx;\n  let zdz := SciLean.fwdDeriv K (fun xy => f xy.1 xy.2) (x, ydy.1) (dx, ydy.2);\n  zdz"}
{"name":"SciLean.fwdDeriv.HSMul.hSMul.arg_a0a1.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.HSMul.hSMul.arg_a0a1.fwdDeriv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → K) (g : X → Y) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) : SciLean.fwdDeriv K (fun x => f x • g x) x = fun dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  (ydy.1 • zdz.1, ydy.1 • zdz.2 + ydy.2 • zdz.1)"}
{"name":"SciLean.fwdDeriv.HDiv.hDiv.arg_a0a1.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.HDiv.hDiv.arg_a0a1.fwdDeriv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (g : X → K) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) (hx : ∀ (x : X), g x ≠ 0) : (SciLean.fwdDeriv K fun x => f x / g x) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  (ydy.1 / zdz.1, (ydy.2 * zdz.1 - ydy.1 * zdz.2) / zdz.1 ^ 2)"}
{"name":"SciLean.fwdDeriv.HDiv.hDiv.arg_a0a1.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.HDiv.hDiv.arg_a0a1.fwdDeriv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (x : X) (f : X → K) (g : X → K) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) (hx : g x ≠ 0) : SciLean.fwdDeriv K (fun x => f x / g x) x = fun dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  (ydy.1 / zdz.1, (ydy.2 * zdz.1 - ydy.1 * zdz.2) / zdz.1 ^ 2)"}
{"name":"SciLean.fwdDeriv.HAdd.hAdd.arg_a0a1.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.HAdd.hAdd.arg_a0a1.fwdDeriv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) : SciLean.fwdDeriv K (fun x => f x + g x) x = fun dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  ydy + zdz"}
{"name":"SciLean.fwdDeriv.Prod.fst.arg_self.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.Prod.fst.arg_self.fwdDeriv_rule_at {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (x : X) (f : X → Y × Z) (hf : SciLean.CDifferentiableAt K f x) : SciLean.fwdDeriv K (fun x => (f x).1) x = fun dx =>\n  let yzdyz := SciLean.fwdDeriv K f x dx;\n  (yzdyz.1.1, yzdyz.2.1)"}
{"name":"SciLean.fwdDeriv.apply_rule","declaration":"theorem SciLean.fwdDeriv.apply_rule {K : Type u_3} [RCLike K] {ι : Type u_1} {E : ι → Type u_2} [(i : ι) → SciLean.Vec K (E i)] (i : ι) : (SciLean.fwdDeriv K fun x => x i) = fun x dx => (x i, dx i)"}
{"name":"SciLean.fwdDeriv.let_rule","declaration":"theorem SciLean.fwdDeriv.let_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (f : X → Y → Z) (g : X → Y) (hf : SciLean.CDifferentiable K fun xy => f xy.1 xy.2) (hg : SciLean.CDifferentiable K g) : (SciLean.fwdDeriv K fun x =>\n    let y := g x;\n    f x y) =\n  fun x dx =>\n  let ydy := SciLean.fwdDeriv K g x dx;\n  let zdz := SciLean.fwdDeriv K (fun xy => f xy.1 xy.2) (x, ydy.1) (dx, ydy.2);\n  zdz"}
{"name":"SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {ι : Type u_4} [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.CDifferentiable K fun x => f x i) : (SciLean.fwdDeriv K fun x =>  ∑ i, f x i) = fun x dx =>\n  let ydy := fun i => SciLean.fwdDeriv K (fun x => f x i) x dx;\n   ∑ i, ydy i"}
{"name":"SciLean.fwdDeriv.dite.arg_te.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.dite.arg_te.fwdDeriv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (e : ¬c → X → Y) : (SciLean.fwdDeriv K fun x => if x_1 : c then t x_1 x else e x_1 x) = fun y =>\n  if p : c then SciLean.fwdDeriv K (t p) y else SciLean.fwdDeriv K (e p) y"}
{"name":"SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule_at","declaration":"theorem SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {ι : Type u_4} [SciLean.IndexType ι] (x : X) (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.CDifferentiableAt K (fun x => f x i) x) : SciLean.fwdDeriv K (fun x =>  ∑ i, f x i) x = fun dx =>\n  let ydy := fun i => SciLean.fwdDeriv K (fun x => f x i) x dx;\n   ∑ i, ydy i"}
{"name":"SciLean.fwdDeriv.pi_rule_at","declaration":"theorem SciLean.fwdDeriv.pi_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {ι : Type u_4} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (x : X) (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.CDifferentiableAt K (fun x => f x i) x) : SciLean.fwdDeriv K (fun x i => f x i) x = fun dx =>\n  (fun i => f x i, fun i => (SciLean.fwdDeriv K (fun x => f x i) x dx).2)"}
{"name":"SciLean.fwdDeriv.HPow.hPow.arg_a0.fwdDeriv_rule","declaration":"def SciLean.fwdDeriv.HPow.hPow.arg_a0.fwdDeriv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (n : ℕ) (f : X → K) (hf : SciLean.CDifferentiable K f) : (SciLean.fwdDeriv K fun x => f x ^ n) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  (ydy.1 ^ n, ↑n * ydy.2 * ydy.1 ^ (n - 1))"}
{"name":"SciLean.fwdDeriv.HSMul.hSMul.arg_a0a1.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.HSMul.hSMul.arg_a0a1.fwdDeriv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → K) (g : X → Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.fwdDeriv K fun x => f x • g x) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  (ydy.1 • zdz.1, ydy.1 • zdz.2 + ydy.2 • zdz.1)"}
{"name":"SciLean.fwdDeriv.Neg.neg.arg_a0.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.Neg.neg.arg_a0.fwdDeriv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (f : X → Y) : (SciLean.fwdDeriv K fun x => -f x) = fun x dx => -SciLean.fwdDeriv K f x dx"}
{"name":"SciLean.fwdDeriv.HSub.hSub.arg_a0a1.fwdDeriv_rule","declaration":"theorem SciLean.fwdDeriv.HSub.hSub.arg_a0a1.fwdDeriv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.fwdDeriv K fun x => f x - g x) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K f x dx;\n  let zdz := SciLean.fwdDeriv K g x dx;\n  ydy - zdz"}
{"name":"SciLean.fwdDeriv.id_rule","declaration":"theorem SciLean.fwdDeriv.id_rule {K : Type u_2} [RCLike K] {X : Type u_1} [SciLean.Vec K X] : (SciLean.fwdDeriv K fun x => x) = fun x dx => (x, dx)"}
