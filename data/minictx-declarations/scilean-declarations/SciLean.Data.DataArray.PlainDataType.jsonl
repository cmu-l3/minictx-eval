{"name":"SciLean.MProd.bitTypeMProd","declaration":"def SciLean.MProd.bitTypeMProd {α : Type} {β : Type} (ta : SciLean.BitType α) (tb : SciLean.BitType β) : SciLean.BitType (MProd α β) ⊕ SciLean.ByteType (MProd α β)"}
{"name":"SciLean.instPlainDataTypeUInt64_1","declaration":"instance SciLean.instPlainDataTypeUInt64_1  : SciLean.PlainDataType UInt64"}
{"name":"SciLean.instPlainDataTypeUInt32","declaration":"instance SciLean.instPlainDataTypeUInt32  : SciLean.PlainDataType UInt32"}
{"name":"SciLean.instPlainDataTypeUInt8","declaration":"instance SciLean.instPlainDataTypeUInt8  : SciLean.PlainDataType UInt8"}
{"name":"SciLean.ByteType.h_size","declaration":"def SciLean.ByteType.h_size {α : Type} (self : SciLean.ByteType α) : 1 < self.bytes"}
{"name":"SciLean.ByteType.toByteArray","declaration":"/-- Write `a : α` from byte array `b` starting at the byte `i` -/\ndef SciLean.ByteType.toByteArray {α : Type} (self : SciLean.ByteType α) (b : ByteArray) (i : USize) (h : USize.toNat (i + self.bytes) ≤ ByteArray.size b) (a : α) : ByteArray"}
{"name":"USize.toUInt8","declaration":"def USize.toUInt8 (x : USize) : UInt8"}
{"name":"SciLean.PlainDataType.bytes","declaration":"def SciLean.PlainDataType.bytes {α : Type} (pd : SciLean.PlainDataType α) (n : ℕ) : ℕ"}
{"name":"UInt8.toUSize","declaration":"def UInt8.toUSize (x : UInt8) : USize"}
{"name":"SciLean.ByteType.fromByteArray_toByteArray_other","declaration":"/-- `toByteArray` does not affect other bytes -/\ndef SciLean.ByteType.fromByteArray_toByteArray_other {α : Type} (self : SciLean.ByteType α) (a : α) (b : ByteArray) (i : USize) (j : USize) (h : USize.toNat (i + self.bytes) ≤ ByteArray.size b) : j < i ∨ i + self.bytes ≤ j → ByteArray.uget (self.toByteArray b i h a) j ⋯ = ByteArray.uget b j ⋯"}
{"name":"SciLean.BitType.fromByte","declaration":"def SciLean.BitType.fromByte {α : Type} (self : SciLean.BitType α) (b : UInt8) : α"}
{"name":"SciLean.BitType.fromByte_toByte","declaration":"def SciLean.BitType.fromByte_toByte {α : Type} (self : SciLean.BitType α) (a : α) : self.fromByte (self.toByte a) = a"}
{"name":"SciLean.Prod.bitTypeProd","declaration":"def SciLean.Prod.bitTypeProd {α : Type} {β : Type} (ta : SciLean.BitType α) (tb : SciLean.BitType β) : SciLean.BitType (α × β) ⊕ SciLean.ByteType (α × β)"}
{"name":"SciLean.Prod.bitTypeByteTypeProd","declaration":"def SciLean.Prod.bitTypeByteTypeProd {α : Type} {β : Type} (ta : SciLean.BitType α) (tb : SciLean.ByteType β) : SciLean.ByteType (α × β)"}
{"name":"SciLean.ByteType.bytes","declaration":"def SciLean.ByteType.bytes {α : Type} (self : SciLean.ByteType α) : USize"}
{"name":"SciLean.BitType.toByte","declaration":"def SciLean.BitType.toByte {α : Type} (self : SciLean.BitType α) (a : α) : UInt8"}
{"name":"SciLean.Fin.bitType","declaration":"def SciLean.Fin.bitType (n : ℕ) : n ≤ 256 → SciLean.BitType (Fin n)"}
{"name":"SciLean.PlainDataType.capacity","declaration":"/-- How many `α` can fit into a buffer with `byteNum` bytes -/\ndef SciLean.PlainDataType.capacity {α : Type} (pd : SciLean.PlainDataType α) (byteNum : ℕ) : ℕ"}
{"name":"SciLean.instPlainDataTypeFin","declaration":"instance SciLean.instPlainDataTypeFin (n : ℕ) : SciLean.PlainDataType (Fin n)"}
{"name":"SciLean.Fin.byteSize","declaration":"def SciLean.Fin.byteSize (n : ℕ) : ℕ"}
{"name":"SciLean.ByteType.fromByteArray","declaration":"/-- Read `a : α` from byte array `b` starting at the byte `i` -/\ndef SciLean.ByteType.fromByteArray {α : Type} (self : SciLean.ByteType α) (b : ByteArray) (i : USize) (h : USize.toNat (i + self.bytes) ≤ ByteArray.size b) : α"}
{"name":"SciLean.Fin.bitSize","declaration":"/-- Number of bits necessary to store `Fin n` -/\ndef SciLean.Fin.bitSize (n : ℕ) : ℕ"}
{"name":"SciLean.Prod.byteTypeBitTypeProd","declaration":"def SciLean.Prod.byteTypeBitTypeProd {α : Type} {β : Type} (ta : SciLean.ByteType α) (tb : SciLean.BitType β) : SciLean.ByteType (α × β)"}
{"name":"SciLean.MProd.byteTypeMProd","declaration":"def SciLean.MProd.byteTypeMProd {α : Type} {β : Type} (ta : SciLean.ByteType α) (tb : SciLean.ByteType β) : SciLean.ByteType (MProd α β)"}
{"name":"SciLean.instPlainDataTypeUInt64","declaration":"instance SciLean.instPlainDataTypeUInt64  : SciLean.PlainDataType UInt64"}
{"name":"SciLean.MProd.bitTypeByteTypeMProd","declaration":"def SciLean.MProd.bitTypeByteTypeMProd {α : Type} {β : Type} (ta : SciLean.BitType α) (tb : SciLean.ByteType β) : SciLean.ByteType (MProd α β)"}
{"name":"SciLean.Fin.byteType","declaration":"def SciLean.Fin.byteType (n : ℕ) : 256 < n → SciLean.ByteType (Fin n)"}
{"name":"SciLean.instPlainDataTypeBool","declaration":"instance SciLean.instPlainDataTypeBool  : SciLean.PlainDataType Bool"}
{"name":"SciLean.instPlainDataTypeUInt16","declaration":"instance SciLean.instPlainDataTypeUInt16  : SciLean.PlainDataType UInt16"}
{"name":"SciLean.Float.byteType","declaration":"def SciLean.Float.byteType  : SciLean.ByteType Float"}
{"name":"SciLean.PlainDataType.btype","declaration":"def SciLean.PlainDataType.btype {α : Type} [self : SciLean.PlainDataType α] : SciLean.BitType α ⊕ SciLean.ByteType α"}
{"name":"SciLean.instPlainDataTypeFloat","declaration":"instance SciLean.instPlainDataTypeFloat  : SciLean.PlainDataType Float"}
{"name":"SciLean.instPlainDataTypeMProd","declaration":"instance SciLean.instPlainDataTypeMProd {α : Type} {β : Type} [ta : SciLean.PlainDataType α] [tb : SciLean.PlainDataType β] : SciLean.PlainDataType (MProd α β)"}
{"name":"SciLean.Bool.bitType","declaration":"def SciLean.Bool.bitType  : SciLean.BitType Bool"}
{"name":"SciLean.BitType.bits","declaration":"def SciLean.BitType.bits {α : Type} (self : SciLean.BitType α) : UInt8"}
{"name":"SciLean.BitType.mk","declaration":"ctor SciLean.BitType.mk {α : Type} (bits : UInt8) (h_size : bits ≤ 8) (fromByte : UInt8 → α) (toByte : α → UInt8) (fromByte_toByte : ∀ (a : α), fromByte (toByte a) = a) : SciLean.BitType α"}
{"name":"SciLean.ByteType.mk","declaration":"ctor SciLean.ByteType.mk {α : Type} (bytes : USize) (h_size : 1 < bytes) (fromByteArray : (b : ByteArray) → (i : USize) → USize.toNat (i + bytes) ≤ ByteArray.size b → α) (toByteArray : (b : ByteArray) → (i : USize) → USize.toNat (i + bytes) ≤ ByteArray.size b → α → ByteArray) (toByteArray_size : ∀ (b : ByteArray) (i : USize) (h : USize.toNat (i + bytes) ≤ ByteArray.size b) (a : α),\n  ByteArray.size (toByteArray b i h a) = ByteArray.size b) (fromByteArray_toByteArray : ∀ (a : α) (b : ByteArray) (i : USize) (h : USize.toNat (i + bytes) ≤ ByteArray.size b)\n  (h' : USize.toNat (i + bytes) ≤ ByteArray.size (toByteArray b i h a)), fromByteArray (toByteArray b i h a) i h' = a) (fromByteArray_toByteArray_other : ∀ (a : α) (b : ByteArray) (i j : USize) (h : USize.toNat (i + bytes) ≤ ByteArray.size b),\n  j < i ∨ i + bytes ≤ j → ByteArray.uget (toByteArray b i h a) j ⋯ = ByteArray.uget b j ⋯) : SciLean.ByteType α"}
{"name":"SciLean.ByteType.fromByteArray_toByteArray","declaration":"/-- we can recover `a` from bytes -/\ndef SciLean.ByteType.fromByteArray_toByteArray {α : Type} (self : SciLean.ByteType α) (a : α) (b : ByteArray) (i : USize) (h : USize.toNat (i + self.bytes) ≤ ByteArray.size b) (h' : USize.toNat (i + self.bytes) ≤ ByteArray.size (self.toByteArray b i h a)) : self.fromByteArray (self.toByteArray b i h a) i h' = a"}
{"name":"SciLean.PlainDataType","declaration":"/-- This rougly corresponds to Plain Old Data(POD)/Passive Data known from OOP\n\nwiki: https://en.wikipedia.org/wiki/Passive_data_structure\n\nWe distinguish between two main types of POD. `BitType` a type that is smaller or equal to a byte and `ByteType` that takes up multiple bytes. The main motivation is an efficient storage of `Array Bool` where `Bool` takes up only a single bit, so we can fit 8 bools into a single byte and achieve significant memore reduction.\n\nPotentially surprising edge case is array of fixed length, i.e. the type `{a : Array α // a.size = n}`. It is `PlainDataType` if `α` is `PlainDataType`. However, `Array α` is not `PlainDataType`, even if `α` is `PlainDataType`, as it does not have a fixed byte size.\n-/\nclass SciLean.PlainDataType (α : Type) : Type"}
{"name":"SciLean.BitType.h_size","declaration":"def SciLean.BitType.h_size {α : Type} (self : SciLean.BitType α) : self.bits ≤ 8"}
{"name":"SciLean.BitType","declaration":"structure SciLean.BitType (α : Type) : Type"}
{"name":"SciLean.PlainDataType.mk","declaration":"ctor SciLean.PlainDataType.mk {α : Type} (btype : SciLean.BitType α ⊕ SciLean.ByteType α) : SciLean.PlainDataType α"}
{"name":"SciLean.ByteType.toByteArray_size","declaration":"/-- `toByteArray` does not modify ByteArray size -/\ndef SciLean.ByteType.toByteArray_size {α : Type} (self : SciLean.ByteType α) (b : ByteArray) (i : USize) (h : USize.toNat (i + self.bytes) ≤ ByteArray.size b) (a : α) : ByteArray.size (self.toByteArray b i h a) = ByteArray.size b"}
{"name":"SciLean.Prod.byteTypeProd","declaration":"def SciLean.Prod.byteTypeProd {α : Type} {β : Type} (ta : SciLean.ByteType α) (tb : SciLean.ByteType β) : SciLean.ByteType (α × β)"}
{"name":"SciLean.MProd.byteTypeBitTypeMProd","declaration":"def SciLean.MProd.byteTypeBitTypeMProd {α : Type} {β : Type} (ta : SciLean.ByteType α) (tb : SciLean.BitType β) : SciLean.ByteType (MProd α β)"}
{"name":"SciLean.ByteType","declaration":"structure SciLean.ByteType (α : Type) : Type"}
{"name":"SciLean.instPlainDataTypeProd","declaration":"/-- Product of `PlainDataType` is `PlainDataType`\n\n**Instance diamond:** This instance is currently prefered over `instPlainDataTypeEnumtype`.\n\nThis instance makes a diamond together with `instPlainDataTypeEnumtype`  when `α` and `β` are `Enumtype`. Using this instance is less computationally intensive when writting and reading from `DataArra` but it consumes more memory. The `instPlainDataTypeEnumtype` is doing the exact opposite.\n\nExample: `Fin (2^4+1) × Fin (2^4-1)`\n\nAs Product:\nThe type `Fin (2^4+1)` needs 5 bits.\nThe type `Fin (2^4-1)` needs 4 bits.\nThus `Fin (2^4+1) × Fin (2^4-1)` needs 9 bits, thus 2 bytes, as `instPlainDataTypeProd`\n\nAs Enumtype:\n`Fin (2^4+1) × Fin (2^4-1) ≈ Fin (2^8-1)`\nThe type `Fin (2^8-1)` needs 8 bits thus only a single byte as `instPlainDataTypeEnumtype`\n\n-/\ninstance SciLean.instPlainDataTypeProd {α : Type} {β : Type} [ta : SciLean.PlainDataType α] [tb : SciLean.PlainDataType β] : SciLean.PlainDataType (α × β)"}
