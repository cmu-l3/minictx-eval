{"name":"SciLean.SciLean.cderiv.arg_dx.CDifferentiable_rule","declaration":"theorem SciLean.SciLean.cderiv.arg_dx.CDifferentiable_rule {K : Type u_1} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (y : Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : SciLean.CDifferentiable K fun dx' => SciLean.cderiv K f y (g dx')"}
{"name":"SciLean.Prod.fst.arg_self.cderiv_rule_at","declaration":"theorem SciLean.Prod.fst.arg_self.cderiv_rule_at {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (x : X) (f : X → Y × Z) (hf : SciLean.CDifferentiableAt K f x) : SciLean.cderiv K (fun x => (f x).1) x = fun dx => (SciLean.cderiv K f x dx).1"}
{"name":"SciLean.cderiv.arg_dx.IsLinearMap_rule_simple","declaration":"theorem SciLean.cderiv.arg_dx.IsLinearMap_rule_simple {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (x : X) (hf : SciLean.CDifferentiableAt K f x) : IsLinearMap K fun dx => SciLean.cderiv K f x dx"}
{"name":"SciLean.dite.arg_te.cderiv_rule","declaration":"theorem SciLean.dite.arg_te.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (e : ¬c → X → Y) : (SciLean.cderiv K fun x => if x_1 : c then t x_1 x else e x_1 x) = fun y =>\n  if p : c then SciLean.cderiv K (t p) y else SciLean.cderiv K (e p) y"}
{"name":"SciLean.cderiv.arg_dx.IsLinearMap_rule","declaration":"theorem SciLean.cderiv.arg_dx.IsLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : X → Y) (x : X) (dx : W → X) (hf : SciLean.CDifferentiableAt K f x) (hdx : IsLinearMap K dx) : IsLinearMap K fun w => SciLean.cderiv K f x (dx w)"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule","declaration":"theorem SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → K) (g : X → Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.cderiv K fun x => f x • g x) = fun x =>\n  let k := f x;\n  let y := g x;\n  fun dx => k • SciLean.cderiv K g x dx + SciLean.cderiv K f x dx • y"}
{"name":"SciLean.cderiv_apply","declaration":"theorem SciLean.cderiv_apply {K : Type u_2} [RCLike K] {X : Type u_3} [SciLean.Vec K X] {Y : Type u_4} {Z : Type u_1} [SciLean.Vec K Z] (f : X → Y → Z) (x : X) (dx : X) (y : Y) : SciLean.cderiv K f x dx y = SciLean.cderiv K (fun x' => f x' y) x dx"}
{"name":"SciLean.cderiv.arg_f.IsSmoothLinearMap_rule","declaration":"theorem SciLean.cderiv.arg_f.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_3} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (f : X → Y → Z) (hf : SciLean.CDifferentiable K fun x =>\n  match x with\n  | (x, y) => f x y) (hf' : ∀ (y : Y), IsLinearMap K fun x => f x y) : SciLean.IsSmoothLinearMap K fun x => SciLean.cderiv K fun x_1 => f x x_1"}
{"name":"SciLean.IndexType.sum.arg_f.cderiv_rule_at","declaration":"theorem SciLean.IndexType.sum.arg_f.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {ι : Type u_4} [SciLean.IndexType ι] (f : X → ι → Y) (x : X) (hf : ∀ (i : ι), SciLean.CDifferentiableAt K (fun x => f x i) x) : SciLean.cderiv K (fun x =>  ∑ i, f x i) x = fun dx =>  ∑ i, SciLean.cderiv K (fun x => f x i) x dx"}
{"name":"SciLean.HPow.hPow.arg_a0.cderiv_rule_at","declaration":"def SciLean.HPow.hPow.arg_a0.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (n : ℕ) (x : X) (f : X → K) (hf : SciLean.CDifferentiableAt K f x) : SciLean.cderiv K (fun x => f x ^ n) x = fun dx => ↑n * SciLean.cderiv K f x dx * f x ^ (n - 1)"}
{"name":"SciLean.HSub.hSub.arg_a0.cderiv_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (f : X → Y) (y : Y) : (SciLean.cderiv K fun x => f x - y) = fun x dx => SciLean.cderiv K f x dx"}
{"name":"SciLean.Prod.snd.arg_self.cderiv_rule","declaration":"theorem SciLean.Prod.snd.arg_self.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (f : X → Y × Z) (hf : SciLean.CDifferentiable K f) : (SciLean.cderiv K fun x => (f x).2) = fun x dx => (SciLean.cderiv K f x dx).2"}
{"name":"SciLean.cderiv_apply_zero","declaration":"theorem SciLean.cderiv_apply_zero {K : Type u_2} [RCLike K] {X : Type u_3} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (f : X → Y) (x : X) : SciLean.cderiv K f x 0 = 0"}
{"name":"SciLean.Prod.mk.arg_fstsnd.cderiv_rule","declaration":"theorem SciLean.Prod.mk.arg_fstsnd.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (g : X → Y) (hg : SciLean.CDifferentiable K g) (f : X → Z) (hf : SciLean.CDifferentiable K f) : (SciLean.cderiv K fun x => (g x, f x)) = fun x dx => (SciLean.cderiv K g x dx, SciLean.cderiv K f x dx)"}
{"name":"SciLean.HSub.hSub.arg_a1.cderiv_rule","declaration":"theorem SciLean.HSub.hSub.arg_a1.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (f : X → Y) (y : Y) : (SciLean.cderiv K fun x => y - f x) = fun x dx => -SciLean.cderiv K f x dx"}
{"name":"SciLean.HAdd.hAdd.arg_a1.cderiv_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a1.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (f : X → Y) (y : Y) : (SciLean.cderiv K fun x => y + f x) = fun x dx => SciLean.cderiv K f x dx"}
{"name":"SciLean.SciLean.norm₂.arg_x.cderiv_rule","declaration":"theorem SciLean.SciLean.norm₂.arg_x.cderiv_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (hf : SciLean.CDifferentiable R f) (hx : ∀ (x : X), f x ≠ 0) : (SciLean.cderiv R fun x => ‖f x‖₂[R]) = fun x dx =>\n  let y := f x;\n  let dy := SciLean.cderiv R f x dx;\n  ‖y‖₂[R]⁻¹ * ⟪dy, y⟫_R"}
{"name":"SciLean.cderiv.comp_rule_at","declaration":"theorem SciLean.cderiv.comp_rule_at (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (x : X) (hf : SciLean.CDifferentiableAt K f (g x)) (hg : SciLean.CDifferentiableAt K g x) : SciLean.cderiv K (fun x => f (g x)) x =\n  let y := g x;\n  fun dx =>\n  let dy := SciLean.cderiv K g x dx;\n  let dz := SciLean.cderiv K f y dy;\n  dz"}
{"name":"SciLean.Neg.neg.arg_a0.cderiv_rule'","declaration":"theorem SciLean.Neg.neg.arg_a0.cderiv_rule' {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (x : X) (f : X → Y) : SciLean.cderiv K (fun x => -f x) x = fun dx => -SciLean.cderiv K f x dx"}
{"name":"SciLean.IndexType.sum.arg_f.cderiv_rule","declaration":"theorem SciLean.IndexType.sum.arg_f.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {ι : Type u_4} [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.CDifferentiable K fun x => f x i) : (SciLean.cderiv K fun x =>  ∑ i, f x i) = fun x dx =>  ∑ i, SciLean.cderiv K (fun x => f x i) x dx"}
{"name":"SciLean.SciLean.cderiv.arg_dx.cderiv_rule_at","declaration":"theorem SciLean.SciLean.cderiv.arg_dx.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (y : Y) (dx : X) (hf : SciLean.CDifferentiableAt K f y) (hg : SciLean.CDifferentiableAt K g dx) : SciLean.cderiv K (fun dx' => SciLean.cderiv K f y (g dx')) dx = fun ddx =>\n  let ddy := SciLean.cderiv K g dx ddx;\n  SciLean.cderiv K f y ddy"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.cderiv_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.cderiv K fun x => f x + g x) = fun x dx => SciLean.cderiv K f x dx + SciLean.cderiv K g x dx"}
{"name":"SciLean.cderiv_of_linear","declaration":"theorem SciLean.cderiv_of_linear {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.cderiv K f = fun x dx => f dx"}
{"name":"SciLean.cderiv.pi_rule","declaration":"theorem SciLean.cderiv.pi_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {ι : Type u_4} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.CDifferentiable K fun x => f x i) : (SciLean.cderiv K fun x i => f x i) = fun x dx i => SciLean.cderiv K (fun x => f x i) x dx"}
{"name":"SciLean.ite.arg_chte.cderiv_rule","declaration":"theorem SciLean.ite.arg_chte.cderiv_rule {K : Type u_2} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : X → Prop) [dec : (x : X) → Decidable (c x)] (t : X → Y) (e : X → Y) (ht : ∀ x ∈ closure c, SciLean.CDifferentiableAt K t x) (he : ∀ x ∈ (interior c)ᶜ, SciLean.CDifferentiableAt K e x) (hc : ∀ x ∈ frontier c, SciLean.cderiv K t x = SciLean.cderiv K e x) : (SciLean.cderiv K fun x => if c x then t x else e x) = fun y =>\n  if c y then SciLean.cderiv K t y else SciLean.cderiv K e y"}
{"name":"SciLean.Inner.inner.arg_a0a1.cderiv_rule_at","declaration":"theorem SciLean.Inner.inner.arg_a0a1.cderiv_rule_at {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (g : X → Y) (x : X) (hf : SciLean.CDifferentiableAt R f x) (hg : SciLean.CDifferentiableAt R g x) : SciLean.cderiv R (fun x => ⟪f x, g x⟫_R) x = fun dx =>\n  let y₁ := f x;\n  let dy₁ := SciLean.cderiv R f x dx;\n  let y₂ := g x;\n  let dy₂ := SciLean.cderiv R g x dx;\n  ⟪dy₁, y₂⟫_R + ⟪y₁, dy₂⟫_R"}
{"name":"SciLean.Inner.inner.arg_a0a1.cderiv_rule","declaration":"theorem SciLean.Inner.inner.arg_a0a1.cderiv_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiable R f) (hg : SciLean.CDifferentiable R g) : (SciLean.cderiv R fun x => ⟪f x, g x⟫_R) = fun x dx =>\n  let y₁ := f x;\n  let dy₁ := SciLean.cderiv R f x dx;\n  let y₂ := g x;\n  let dy₂ := SciLean.cderiv R g x dx;\n  ⟪dy₁, y₂⟫_R + ⟪y₁, dy₂⟫_R"}
{"name":"SciLean.Neg.neg.arg_a0.cderiv_rule","declaration":"theorem SciLean.Neg.neg.arg_a0.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (f : X → Y) : (SciLean.cderiv K fun x => -f x) = fun x dx => -SciLean.cderiv K f x dx"}
{"name":"SciLean.cderiv.apply_rule","declaration":"theorem SciLean.cderiv.apply_rule (K : Type u_3) [RCLike K] {ι : Type u_1} {E : ι → Type u_2} [(i : ι) → SciLean.Vec K (E i)] (i : ι) : (SciLean.cderiv K fun x => x i) = fun x dx => dx i"}
{"name":"SciLean.HSub.hSub.arg_a0a1.cderiv_rule_at","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) : SciLean.cderiv K (fun x => f x - g x) x = fun dx => SciLean.cderiv K f x dx - SciLean.cderiv K g x dx"}
{"name":"SciLean.SciLean.cderiv.arg_dx.CDifferentiableAt_rule","declaration":"theorem SciLean.SciLean.cderiv.arg_dx.CDifferentiableAt_rule {K : Type u_1} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (y : Y) (dx : X) (hf : SciLean.CDifferentiableAt K f y) (hg : SciLean.CDifferentiableAt K g dx) : SciLean.CDifferentiableAt K (fun dx' => SciLean.cderiv K f y (g dx')) dx"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule_at","declaration":"theorem SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → K) (g : X → Y) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) : SciLean.cderiv K (fun x => f x • g x) x =\n  let k := f x;\n  let y := g x;\n  fun dx => k • SciLean.cderiv K g x dx + SciLean.cderiv K f x dx • y"}
{"name":"SciLean.cderiv.id_rule","declaration":"theorem SciLean.cderiv.id_rule (K : Type u_2) [RCLike K] {X : Type u_1} [SciLean.Vec K X] : (SciLean.cderiv K fun x => x) = fun x dx => dx"}
{"name":"SciLean.SciLean.norm₂.arg_x.cderiv_rule_at","declaration":"theorem SciLean.SciLean.norm₂.arg_x.cderiv_rule_at {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (x : X) (hf : SciLean.CDifferentiableAt R f x) (hx : f x ≠ 0) : SciLean.cderiv R (fun x => ‖f x‖₂[R]) x = fun dx =>\n  let y := f x;\n  let dy := SciLean.cderiv R f x dx;\n  ‖y‖₂[R]⁻¹ * ⟪dy, y⟫_R"}
{"name":"SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule_at","declaration":"theorem SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (x : X) (f : X → K) (g : X → K) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) (hx : g x ≠ 0) : SciLean.cderiv K (fun x => f x / g x) x =\n  let k := f x;\n  let k' := g x;\n  fun dx => (SciLean.cderiv K f x dx * k' - k * SciLean.cderiv K g x dx) / k' ^ 2"}
{"name":"SciLean.cderiv.pi_rule_at","declaration":"theorem SciLean.cderiv.pi_rule_at (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {ι : Type u_4} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (f : X → (i : ι) → E i) (x : X) (hf : ∀ (i : ι), SciLean.CDifferentiableAt K (fun x => f x i) x) : SciLean.cderiv K (fun x i => f x i) x = fun dx i => SciLean.cderiv K (fun x => f x i) x dx"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.cderiv_rule_at","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) : SciLean.cderiv K (fun x => f x + g x) x = fun dx => SciLean.cderiv K f x dx + SciLean.cderiv K g x dx"}
{"name":"SciLean.HMul.hMul.arg_a0a1.cderiv_rule","declaration":"theorem SciLean.HMul.hMul.arg_a0a1.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (g : X → K) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.cderiv K fun x => f x * g x) = fun x =>\n  let fx := f x;\n  let gx := g x;\n  fun dx => SciLean.cderiv K g x dx * fx + SciLean.cderiv K f x dx * gx"}
{"name":"SciLean.ite.arg_te.cderiv_rule","declaration":"theorem SciLean.ite.arg_te.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) : (SciLean.cderiv K fun x => if c then t x else e x) = fun y => if c then SciLean.cderiv K t y else SciLean.cderiv K e y"}
{"name":"SciLean.cderiv.let_rule_at","declaration":"theorem SciLean.cderiv.let_rule_at (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (f : X → Y → Z) (g : X → Y) (x : X) (hf : SciLean.CDifferentiableAt K (↿f) (x, g x)) (hg : SciLean.CDifferentiableAt K g x) : SciLean.cderiv K\n    (fun x =>\n      let y := g x;\n      f x y)\n    x =\n  let y := g x;\n  fun dx =>\n  let dy := SciLean.cderiv K g x dx;\n  let dz := SciLean.cderiv K (fun xy => f xy.1 xy.2) (x, y) (dx, dy);\n  dz"}
{"name":"SciLean.HSub.hSub.arg_a0a1.cderiv_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (g : X → Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.cderiv K fun x => f x - g x) = fun x dx => SciLean.cderiv K f x dx - SciLean.cderiv K g x dx"}
{"name":"SciLean.HPow.hPow.arg_a0.cderiv_rule","declaration":"def SciLean.HPow.hPow.arg_a0.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (n : ℕ) (f : X → K) (hf : SciLean.CDifferentiable K f) : (SciLean.cderiv K fun x => f x ^ n) = fun x dx => ↑n * SciLean.cderiv K f x dx * f x ^ (n - 1)"}
{"name":"SciLean.HMul.hMul.arg_a0a1.cderiv_rule_at","declaration":"theorem SciLean.HMul.hMul.arg_a0a1.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (x : X) (f : X → K) (g : X → K) (hf : SciLean.CDifferentiableAt K f x) (hg : SciLean.CDifferentiableAt K g x) : SciLean.cderiv K (fun x => f x * g x) x =\n  let fx := f x;\n  let gx := g x;\n  fun dx => SciLean.cderiv K g x dx * fx + SciLean.cderiv K f x dx * gx"}
{"name":"SciLean.cderiv.let_rule","declaration":"theorem SciLean.cderiv.let_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (f : X → Y → Z) (g : X → Y) (hf : SciLean.CDifferentiable K fun xy => f xy.1 xy.2) (hg : SciLean.CDifferentiable K g) : (SciLean.cderiv K fun x =>\n    let y := g x;\n    f x y) =\n  fun x =>\n  let y := g x;\n  fun dx =>\n  let dy := SciLean.cderiv K g x dx;\n  let dz := SciLean.cderiv K (fun xy => f xy.1 xy.2) (x, y) (dx, dy);\n  dz"}
{"name":"SciLean.cderiv.const_rule","declaration":"theorem SciLean.cderiv.const_rule (K : Type u_3) [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (x : X) : (SciLean.cderiv K fun x_1 => x) = fun x dx => 0"}
{"name":"SciLean.cderiv.comp_rule","declaration":"theorem SciLean.cderiv.comp_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.cderiv K fun x => f (g x)) = fun x =>\n  let y := g x;\n  fun dx =>\n  let dy := SciLean.cderiv K g x dx;\n  let dz := SciLean.cderiv K f y dy;\n  dz"}
{"name":"SciLean.Prod.snd.arg_self.cderiv_rule_at","declaration":"theorem SciLean.Prod.snd.arg_self.cderiv_rule_at {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (x : X) (f : X → Y × Z) (hf : SciLean.CDifferentiableAt K f x) : SciLean.cderiv K (fun x => (f x).2) x = fun dx => (SciLean.cderiv K f x dx).2"}
{"name":"SciLean.SciLean.cderiv.arg_dx.cderiv_rule","declaration":"theorem SciLean.SciLean.cderiv.arg_dx.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (y : Y) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : (SciLean.cderiv K fun dx => SciLean.cderiv K f y (g dx)) = fun dx ddx =>\n  let ddy := SciLean.cderiv K g dx ddx;\n  SciLean.cderiv K f y ddy"}
{"name":"SciLean.cderiv.arg_f.IsLinearMap_rule","declaration":"theorem SciLean.cderiv.arg_f.IsLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : X → Y → Z) (hf : ∀ (x : X), SciLean.CDifferentiable K fun y => f x y) (hf' : ∀ (y : Y), IsLinearMap K fun x => f x y) : IsLinearMap K fun x => SciLean.cderiv K fun x_1 => f x x_1"}
{"name":"SciLean.cderiv","declaration":"def SciLean.cderiv (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (x : X) (dx : X) : Y"}
{"name":"SciLean.Prod.fst.arg_self.cderiv_rule","declaration":"theorem SciLean.Prod.fst.arg_self.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (f : X → Y × Z) (hf : SciLean.CDifferentiable K f) : (SciLean.cderiv K fun x => (f x).1) = fun x dx => (SciLean.cderiv K f x dx).1"}
{"name":"SciLean.SciLean.Norm2.norm2.arg_a0.cderiv_rule","declaration":"theorem SciLean.SciLean.Norm2.norm2.arg_a0.cderiv_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (hf : SciLean.CDifferentiable R f) : (SciLean.cderiv R fun x => ‖f x‖₂²) = fun x dx =>\n  let y := f x;\n  let dy := SciLean.cderiv R f x dx;\n  2 * ⟪dy, y⟫_R"}
{"name":"SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule","declaration":"theorem SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (g : X → K) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) (hx : ∀ (x : X), g x ≠ 0) : (SciLean.cderiv K fun x => f x / g x) = fun x =>\n  let k := f x;\n  let k' := g x;\n  fun dx => (SciLean.cderiv K f x dx * k' - k * SciLean.cderiv K g x dx) / k' ^ 2"}
{"name":"SciLean.HAdd.hAdd.arg_a0.cderiv_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0.cderiv_rule {K : Type u_3} [RCLike K] {X : Type u_1} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] (f : X → Y) (y : Y) : (SciLean.cderiv K fun x => f x + y) = fun x dx => SciLean.cderiv K f x dx"}
{"name":"SciLean.SciLean.Norm2.norm2.arg_a0.cderiv_rule_at","declaration":"theorem SciLean.SciLean.Norm2.norm2.arg_a0.cderiv_rule_at {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (x : X) (hf : SciLean.CDifferentiableAt R f x) : SciLean.cderiv R (fun x => ‖f x‖₂²) x = fun dx =>\n  let y := f x;\n  let dy := SciLean.cderiv R f x dx;\n  2 * ⟪dy, y⟫_R"}
{"name":"SciLean.Prod.mk.arg_fstsnd.cderiv_rule_at","declaration":"theorem SciLean.Prod.mk.arg_fstsnd.cderiv_rule_at {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (x : X) (g : X → Y) (hg : SciLean.CDifferentiableAt K g x) (f : X → Z) (hf : SciLean.CDifferentiableAt K f x) : SciLean.cderiv K (fun x => (g x, f x)) x = fun dx => (SciLean.cderiv K g x dx, SciLean.cderiv K f x dx)"}
{"name":"SciLean.scalarCDeriv","declaration":"def SciLean.scalarCDeriv (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : K → X) (t : K) : X"}
