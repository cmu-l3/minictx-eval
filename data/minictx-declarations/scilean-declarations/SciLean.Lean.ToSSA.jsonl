{"name":"Lean.Expr.toSSA","declaration":"/-- Converts an expression to single static assigment form w.r.t. bound variables and free variables `fvars`\n\nExamples:\n- `x*x + x ==> let a := x*x; a + x`\n- `fun y => x*y + x*x ==> fun y => let a := x*y; let a_1 := x*x; a + a_1`\n-/\ndef Lean.Expr.toSSA (e : Lean.Expr) (fvars : Array Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"Lean.Expr.toSSA.impl.goApp","declaration":"opaque Lean.Expr.toSSA.impl.goApp (fn : Lean.Expr) (args : Array Lean.Expr) (infos : Array Lean.Meta.ParamInfo) (fvars : Array Lean.Expr) (i : Nat) (lets : Array Lean.Expr) : Lean.MetaM (Lean.Expr × Array Lean.Expr × Lean.LocalContext)"}
{"name":"Lean.Expr.toSSA.impl","declaration":"/-- Turns expression `e` into single-static-assigment w.r.t. to free variables `fvars` and all bound variables\n\nReturns expression, newly introduced let bindings and local context where these bindings live\n\n--TODO: add option to do common subexpression elimination i.e. check if let binding with particular value already exists\n-/\nopaque Lean.Expr.toSSA.impl (e : Lean.Expr) (fvars : Array Lean.Expr) : Lean.MetaM (Lean.Expr × Array Lean.Expr × Lean.LocalContext)"}
