{"name":"SciLean.IsContinuousLinearMap.Prod.snd.arg_self.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.Prod.snd.arg_self.IsContinuousLinearMap_rule {R : Type u_3} [Semiring R] {X : Type u_4} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_1} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {Z : Type u_2} [TopologicalSpace Z] [AddCommMonoid Z] [Module R Z] (f : X → Y × Z) (hf : SciLean.IsContinuousLinearMap R f) : SciLean.IsContinuousLinearMap R fun x => (f x).2"}
{"name":"SciLean.IsContinuousLinearMap.FunLike.coe.arg_a.IsContinuousLinearMap_rule'","declaration":"theorem SciLean.IsContinuousLinearMap.FunLike.coe.arg_a.IsContinuousLinearMap_rule' {R : Type u_3} [Semiring R] {X : Type u_4} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_2} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {Z : Type u_1} [TopologicalSpace Z] [AddCommMonoid Z] [Module R Z] (f : Y →L[R] Z) (g : X → Y) (hg : SciLean.IsContinuousLinearMap R g) : SciLean.IsContinuousLinearMap R fun x => f (g x)"}
{"name":"SciLean.ContinuousLinearMap.eta_reduce","declaration":"theorem SciLean.ContinuousLinearMap.eta_reduce (R : Type u_3) [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_1} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] (f : X →L[R] Y) : SciLean.ContinuousLinearMap.mk' R ⇑f ⋯ = f"}
{"name":"SciLean.IsContinuousLinearMap.id_rule","declaration":"theorem SciLean.IsContinuousLinearMap.id_rule {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] : SciLean.IsContinuousLinearMap R fun x => x"}
{"name":"SciLean.IsContinuousLinearMap.FunLike.coe.arg_a.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.FunLike.coe.arg_a.IsContinuousLinearMap_rule {R : Type u_3} [Semiring R] {Y : Type u_2} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {Z : Type u_1} [TopologicalSpace Z] [AddCommMonoid Z] [Module R Z] (f : Y →L[R] Z) : SciLean.IsContinuousLinearMap R fun y => f y"}
{"name":"SciLean.«termFun_:_=>L[_]_»","declaration":"def SciLean.«termFun_:_=>L[_]_»  : Lean.ParserDescr"}
{"name":"SciLean.IsContinuousLinearMap.cont","declaration":"def SciLean.IsContinuousLinearMap.cont {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {f : X → Y} (self : SciLean.IsContinuousLinearMap R f) : Continuous f"}
{"name":"SciLean.IsContinuousLinearMap.ite.arg_te.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.ite.arg_te.IsContinuousLinearMap_rule {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) (ht : SciLean.IsContinuousLinearMap R t) (he : SciLean.IsContinuousLinearMap R e) : SciLean.IsContinuousLinearMap R fun x => if c then t x else e x"}
{"name":"SciLean.«termFun(_:_)=>L[_]_»","declaration":"def SciLean.«termFun(_:_)=>L[_]_»  : Lean.ParserDescr"}
{"name":"SciLean.IsContinuousLinearMap.HSMul.hSMul.arg_a0.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.HSMul.hSMul.arg_a0.IsContinuousLinearMap_rule {R : Type u_1} [Semiring R] {X : Type u_3} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_2} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] [TopologicalSpace R] [ContinuousSMul R Y] (f : X → R) (hf : SciLean.IsContinuousLinearMap R f) (y : Y) : SciLean.IsContinuousLinearMap R fun x => f x • y"}
{"name":"SciLean.IsContinuousLinearMap.Finset.sum.arg_f.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.Finset.sum.arg_f.IsContinuousLinearMap_rule {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {ι : Type u_4} (f : X → ι → Y) : (∀ (i : ι), SciLean.IsContinuousLinearMap R fun x => f x i) →\n  ∀ (A : Finset ι), SciLean.IsContinuousLinearMap R fun x => Finset.sum A fun i => f x i"}
{"name":"SciLean.«termFun_=>L[_]_»","declaration":"def SciLean.«termFun_=>L[_]_»  : Lean.ParserDescr"}
{"name":"SciLean.IsContinuousLinearMap.ContinuousLinearMap.divRight","declaration":"/-- Creates `fun x =>L[R] g x / y` -/\ndef SciLean.IsContinuousLinearMap.ContinuousLinearMap.divRight {R : Type u_1} [NontriviallyNormedField R] {K : Type u_2} [NontriviallyNormedField K] [NormedAlgebra R K] {X : Type u_3} [TopologicalSpace X] [AddCommMonoid X] [Module R X] (g : X →L[R] K) (y : K) : X →L[R] K"}
{"name":"SciLean.IsContinuousLinearMap.dite.arg_te.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.dite.arg_te.IsContinuousLinearMap_rule {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (ht : ∀ (p : c), SciLean.IsContinuousLinearMap R (t p)) (e : ¬c → X → Y) (he : ∀ (p : ¬c), SciLean.IsContinuousLinearMap R (e p)) : SciLean.IsContinuousLinearMap R fun x => if x_1 : c then t x_1 x else e x_1 x"}
{"name":"SciLean.IsContinuousLinearMap.Prod.mk.arg_fstsnd.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.Prod.mk.arg_fstsnd.IsContinuousLinearMap_rule {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {Z : Type u_4} [TopologicalSpace Z] [AddCommMonoid Z] [Module R Z] (g : X → Y) (hg : SciLean.IsContinuousLinearMap R g) (f : X → Z) (hf : SciLean.IsContinuousLinearMap R f) : SciLean.IsContinuousLinearMap R fun x => (g x, f x)"}
{"name":"SciLean.IsContinuousLinearMap.linear","declaration":"def SciLean.IsContinuousLinearMap.linear {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {f : X → Y} (self : SciLean.IsContinuousLinearMap R f) : IsLinearMap R f"}
{"name":"SciLean.IsContinuousLinearMap.ContinuousLinearMap.mul_right","declaration":"def SciLean.IsContinuousLinearMap.ContinuousLinearMap.mul_right {R : Type u_1} [CommSemiring R] {X : Type u_2} [TopologicalSpace X] [Semiring X] [Algebra R X] [TopologicalSemiring X] (x' : X) : X →L[R] X"}
{"name":"SciLean.IsContinuousLinearMap.const_rule","declaration":"theorem SciLean.IsContinuousLinearMap.const_rule {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] : SciLean.IsContinuousLinearMap R fun x => 0"}
{"name":"SciLean.IsContinuousLinearMap.by_morphism","declaration":"theorem SciLean.IsContinuousLinearMap.by_morphism {R : Type u_3} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_1} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {f : X → Y} (g : X →L[R] Y) (h : ∀ (x : X), f x = g x) : SciLean.IsContinuousLinearMap R f"}
{"name":"SciLean.IsContinuousLinearMap.ContinuousLinearMap.mul_left","declaration":"def SciLean.IsContinuousLinearMap.ContinuousLinearMap.mul_left {R : Type u_1} [CommSemiring R] {X : Type u_2} [TopologicalSpace X] [Semiring X] [Algebra R X] [TopologicalSemiring X] (x' : X) : X →L[R] X"}
{"name":"SciLean.IsContinuousLinearMap.pi_rule","declaration":"theorem SciLean.IsContinuousLinearMap.pi_rule {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {ι : Type u_4} {E : ι → Type u_3} [(i : ι) → TopologicalSpace (E i)] [(i : ι) → AddCommMonoid (E i)] [(i : ι) → Module R (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.IsContinuousLinearMap R fun x => f x i) : SciLean.IsContinuousLinearMap R fun x i => f x i"}
{"name":"SciLean.IsContinuousLinearMap.HSMul.hSMul.arg_a1.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.HSMul.hSMul.arg_a1.IsContinuousLinearMap_rule {R : Type u_1} [CommSemiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] [ContinuousConstSMul R Y] (c : R) (f : X → Y) (hf : SciLean.IsContinuousLinearMap R f) : SciLean.IsContinuousLinearMap R fun x => c • f x"}
{"name":"SciLean.IsContinuousLinearMap.HDiv.hDiv.arg_a0.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.HDiv.hDiv.arg_a0.IsContinuousLinearMap_rule {R : Type u_1} [NontriviallyNormedField R] {K : Type u_2} [NontriviallyNormedField K] [NormedAlgebra R K] {X : Type u_3} [TopologicalSpace X] [AddCommMonoid X] [Module R X] (f : X → K) (hf : SciLean.IsContinuousLinearMap R f) (y : K) : SciLean.IsContinuousLinearMap R fun x => f x / y"}
{"name":"SciLean.IsContinuousLinearMap.isContinuousLinearMap_differentiable","declaration":"theorem SciLean.IsContinuousLinearMap.isContinuousLinearMap_differentiable {K : Type u_1} [RCLike K] {X : Type u_2} [NormedAddCommGroup X] [NormedSpace K X] {Y : Type u_3} [NormedAddCommGroup Y] [NormedSpace K Y] (f : X → Y) (hf : SciLean.IsContinuousLinearMap K f) : Differentiable K f"}
{"name":"SciLean.IsContinuousLinearMap.Neg.neg.arg_a0.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.Neg.neg.arg_a0.IsContinuousLinearMap_rule {R : Type u_1} [Ring R] {X : Type u_2} [TopologicalSpace X] [AddCommGroup X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommGroup Y] [Module R Y] [TopologicalAddGroup Y] (f : X → Y) (hf : SciLean.IsContinuousLinearMap R f) : SciLean.IsContinuousLinearMap R fun x => -f x"}
{"name":"SciLean.IsContinuousLinearMap.apply_rule","declaration":"theorem SciLean.IsContinuousLinearMap.apply_rule {R : Type u_1} [Semiring R] {ι : Type u_2} {E : ι → Type u_3} [(i : ι) → TopologicalSpace (E i)] [(i : ι) → AddCommMonoid (E i)] [(i : ι) → Module R (E i)] (i : ι) : SciLean.IsContinuousLinearMap R fun f => f i"}
{"name":"SciLean.IsContinuousLinearMap","declaration":"structure SciLean.IsContinuousLinearMap (R : Type u_1) [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] (f : X → Y) : Prop"}
{"name":"SciLean.IsContinuousLinearMap.starRingEnd.arg_a.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.starRingEnd.arg_a.IsContinuousLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module K X] (f : X → K) : SciLean.IsContinuousLinearMap K f → SciLean.IsContinuousLinearMap K fun x => (starRingEnd K) (f x)"}
{"name":"SciLean.IsContinuousLinearMap.HMul.hMul.arg_a1.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.HMul.hMul.arg_a1.IsContinuousLinearMap_rule {R : Type u_1} [CommSemiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [Semiring Y] [Algebra R Y] [TopologicalSemiring Y] (f : X → Y) (hf : SciLean.IsContinuousLinearMap R f) (y' : Y) : SciLean.IsContinuousLinearMap R fun x => y' * f x"}
{"name":"SciLean.IsContinuousLinearMap.HAdd.hAdd.arg_a0a1.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.HAdd.hAdd.arg_a0a1.IsContinuousLinearMap_rule {R : Type u_2} [Semiring R] {X : Type u_3} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_1} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] [ContinuousAdd Y] (f : X → Y) (g : X → Y) (hf : SciLean.IsContinuousLinearMap R f) (hg : SciLean.IsContinuousLinearMap R g) : SciLean.IsContinuousLinearMap R fun x => f x + g x"}
{"name":"SciLean.IsContinuousLinearMap.Inner.inner.arg_a0.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.Inner.inner.arg_a0.IsContinuousLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module K X] {Y : Type u_3} [NormedAddCommGroup Y] [InnerProductSpace K Y] [CompleteSpace Y] (f : X → Y) : SciLean.IsContinuousLinearMap K f → ∀ (y : Y), SciLean.IsContinuousLinearMap K fun x => ⟪f x, y⟫_K"}
{"name":"SciLean.IsContinuousLinearMap.Prod.fst.arg_self.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.Prod.fst.arg_self.IsContinuousLinearMap_rule {R : Type u_3} [Semiring R] {X : Type u_4} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_1} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {Z : Type u_2} [TopologicalSpace Z] [AddCommMonoid Z] [Module R Z] (f : X → Y × Z) (hf : SciLean.IsContinuousLinearMap R f) : SciLean.IsContinuousLinearMap R fun x => (f x).1"}
{"name":"SciLean.IsContinuousLinearMap.ContinuousLinearMap.smulLeft","declaration":"/-- Creates `fun x =>L[R] r • g x` -/\ndef SciLean.IsContinuousLinearMap.ContinuousLinearMap.smulLeft {R : Type u_1} [CommSemiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] [ContinuousConstSMul R Y] (g : X →L[R] Y) (r : R) : X →L[R] Y"}
{"name":"SciLean.IsContinuousLinearMap.ContinuousLinearMap.div_right","declaration":"def SciLean.IsContinuousLinearMap.ContinuousLinearMap.div_right {R : Type u_1} [NontriviallyNormedField R] {K : Type u_2} [NontriviallyNormedField K] [NormedAlgebra R K] {X : Type u_3} [TopologicalSpace X] [AddCommMonoid X] [Module R X] (g : X →L[R] K) (y : K) (x : X) : (SciLean.IsContinuousLinearMap.ContinuousLinearMap.divRight g y) x = g x / y"}
{"name":"SciLean.unexpandContinuousLinearMapMk","declaration":"def SciLean.unexpandContinuousLinearMapMk  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.IsContinuousLinearMap.HMul.hMul.arg_a0.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.HMul.hMul.arg_a0.IsContinuousLinearMap_rule {R : Type u_1} [CommSemiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [Semiring Y] [Algebra R Y] [TopologicalSemiring Y] (f : X → Y) (hf : SciLean.IsContinuousLinearMap R f) (y' : Y) : SciLean.IsContinuousLinearMap R fun x => f x * y'"}
{"name":"SciLean.IsContinuousLinearMap.mk","declaration":"ctor SciLean.IsContinuousLinearMap.mk {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {f : X → Y} (linear : IsLinearMap R f) (cont : autoParam (Continuous f) _auto✝) : SciLean.IsContinuousLinearMap R f"}
{"name":"SciLean.IsContinuousLinearMap.Inner.inner.arg_a1.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.Inner.inner.arg_a1.IsContinuousLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module K X] {Y : Type u_3} [NormedAddCommGroup Y] [InnerProductSpace K Y] [CompleteSpace Y] (f : X → Y) : SciLean.IsContinuousLinearMap K f → ∀ (y : Y), SciLean.IsContinuousLinearMap K fun x => ⟪y, f x⟫_K"}
{"name":"SciLean.ContinuousLinearMap.mk'_eval","declaration":"theorem SciLean.ContinuousLinearMap.mk'_eval (R : Type u_1) [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] (x : X) (f : X → Y) (hf : SciLean.IsContinuousLinearMap R f) : (SciLean.ContinuousLinearMap.mk' R f hf) x = f x"}
{"name":"SciLean.ContinuousLinearMap.mk'","declaration":"def SciLean.ContinuousLinearMap.mk' (R : Type u_1) [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] (f : X → Y) (hf : SciLean.IsContinuousLinearMap R f) : X →L[R] Y"}
{"name":"SciLean.IsContinuousLinearMap.comp_rule","declaration":"theorem SciLean.IsContinuousLinearMap.comp_rule {R : Type u_1} [Semiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] {Z : Type u_4} [TopologicalSpace Z] [AddCommMonoid Z] [Module R Z] (g : X → Y) (hg : SciLean.IsContinuousLinearMap R g) (f : Y → Z) (hf : SciLean.IsContinuousLinearMap R f) : SciLean.IsContinuousLinearMap R fun x => f (g x)"}
{"name":"SciLean.IsContinuousLinearMap.ContinuousLinearMap.smul_left","declaration":"def SciLean.IsContinuousLinearMap.ContinuousLinearMap.smul_left {R : Type u_1} [CommSemiring R] {X : Type u_2} [TopologicalSpace X] [AddCommMonoid X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommMonoid Y] [Module R Y] [ContinuousConstSMul R Y] (g : X →L[R] Y) (r : R) (x : X) : (SciLean.IsContinuousLinearMap.ContinuousLinearMap.smulLeft g r) x = r • g x"}
{"name":"SciLean.IsContinuousLinearMap.HSub.hSub.arg_a0a1.IsContinuousLinearMap_rule","declaration":"theorem SciLean.IsContinuousLinearMap.HSub.hSub.arg_a0a1.IsContinuousLinearMap_rule {R : Type u_1} [Ring R] {X : Type u_2} [TopologicalSpace X] [AddCommGroup X] [Module R X] {Y : Type u_3} [TopologicalSpace Y] [AddCommGroup Y] [Module R Y] [TopologicalAddGroup Y] (f : X → Y) (g : X → Y) (hf : SciLean.IsContinuousLinearMap R f) (hg : SciLean.IsContinuousLinearMap R g) : SciLean.IsContinuousLinearMap R fun x => f x - g x"}
