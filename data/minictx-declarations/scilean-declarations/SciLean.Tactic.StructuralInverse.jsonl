{"name":"SciLean.Meta.RightInverse.right_inv","declaration":"def SciLean.Meta.RightInverse.right_inv (self : SciLean.Meta.RightInverse) : Q(∀ (x₁ : unknown_1), Function.RightInverse (unknown_6 x₁) unknown_7)"}
{"name":"SciLean.Meta.RightInverse.decX","declaration":"def SciLean.Meta.RightInverse.decX (self : SciLean.Meta.RightInverse) : SciLean.Meta.StructureDecomposition"}
{"name":"SciLean.Meta.FullInverse","declaration":"structure SciLean.Meta.FullInverse  : Type"}
{"name":"SciLean.Meta.FullInverse.is_inv","declaration":"def SciLean.Meta.FullInverse.is_inv (self : SciLean.Meta.FullInverse) : Q(Function.Inverse unknown_3 unknown_4)"}
{"name":"SciLean.Meta.FullInverse.mk","declaration":"ctor SciLean.Meta.FullInverse.mk {u : Lean.Level} {v : Lean.Level} {X : Q(Type u)} {Y : Q(Type v)} (f : Q(«$X» → «$Y»)) (invFun : Q(«$Y» → «$X»)) (is_inv : Q(Function.Inverse «$invFun» «$f»)) : SciLean.Meta.FullInverse"}
{"name":"SciLean.Meta.RightInverse.left_inv","declaration":"def SciLean.Meta.RightInverse.left_inv (self : SciLean.Meta.RightInverse) : let a := self.decX.q;\nlet a_1 := self.decX.p₂;\nQ(∀ (x₁ : unknown_1), Function.LeftInverse (fun y => unknown_5 (unknown_8 x₁ y)) fun x₂ => unknown_9 (unknown_10 x₁ x₂))"}
{"name":"SciLean.Meta.RightInverse.v","declaration":"def SciLean.Meta.RightInverse.v (self : SciLean.Meta.RightInverse) : Lean.Level"}
{"name":"SciLean.Meta.FunctionInverse","declaration":"inductive SciLean.Meta.FunctionInverse  : Type"}
{"name":"SciLean.Meta.FullInverse.v","declaration":"def SciLean.Meta.FullInverse.v (self : SciLean.Meta.FullInverse) : Lean.Level"}
{"name":"SciLean.Meta.FullInverse.X","declaration":"def SciLean.Meta.FullInverse.X (self : SciLean.Meta.FullInverse) : Q(Type udummy._uniq.513)"}
{"name":"SciLean.Meta.FunctionInverse.full","declaration":"ctor SciLean.Meta.FunctionInverse.full (inv : SciLean.Meta.FullInverse) : SciLean.Meta.FunctionInverse"}
{"name":"SciLean.Meta.FunctionInverse.right","declaration":"ctor SciLean.Meta.FunctionInverse.right (inv : SciLean.Meta.RightInverse) : SciLean.Meta.FunctionInverse"}
{"name":"SciLean.Meta.RightInverse.mk","declaration":"ctor SciLean.Meta.RightInverse.mk {v : Lean.Level} {decX : SciLean.Meta.StructureDecomposition} {Y : Q(Type v)} (f : let a := decX.X;\nQ(unknown_1 → «$Y»)) (invFun : let a := decX.X;\nlet a_1 := decX.X₁;\nQ(unknown_2 → «$Y» → unknown_1)) (right_inv : Q(∀ (x₁ : unknown_2), Function.RightInverse («$invFun» x₁) «$f»)) (left_inv : let a := decX.q;\nlet a_1 := decX.p₂;\nQ(∀ (x₁ : unknown_2), Function.LeftInverse (fun y => unknown_4 («$invFun» x₁ y)) fun x₂ => «$f» (unknown_5 x₁ x₂))) : SciLean.Meta.RightInverse"}
{"name":"SciLean.Meta.RightInverse","declaration":"/-- Holds right inverse to the function `f : X → Y`.\n\nFurther more it provides decomposition `X ≃ X₁×X₂` such that `f` restricted to only `X₂` is fully invertible.\n-/\nstructure SciLean.Meta.RightInverse  : Type"}
{"name":"SciLean.Meta.RightInverse.invFun","declaration":"def SciLean.Meta.RightInverse.invFun (self : SciLean.Meta.RightInverse) : let a := self.decX.X;\nlet a_1 := self.decX.X₁;\nQ(unknown_1 → unknown_2 → unknown_3)"}
{"name":"SciLean.Meta.RightInverse.Y","declaration":"def SciLean.Meta.RightInverse.Y (self : SciLean.Meta.RightInverse) : Q(Type udummy._uniq.497)"}
{"name":"SciLean.Meta.FullInverse.invFun","declaration":"def SciLean.Meta.FullInverse.invFun (self : SciLean.Meta.FullInverse) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.structuralInverse","declaration":"/-- Compute inverse of a function `f : X → Y` where both `X` and `Y` are possible nested strustures\n\nFor example\n```\nfun (x,(y,z)) => ((x+y, x), z)\n==>\nfun ((x',y'),z') => (y', (x' - y', z'))\n```\n\nIt can also compute right inverses\n```\nfun (x,y,z) => x+y+z)\n==>\nfun (y,z) x' => (x'-y-z, y, z)\n```\nthe right inverse `f⁻¹` is parametrized by a type `X₁` and for every `x₁ : X₁` the `f⁻¹ x₁` is right inverse of `f`\n\nReturns also a list of pending goals proving that individual inversions are possible.\n-/\ndef SciLean.Meta.structuralInverse (f : Lean.Expr) : Lean.MetaM (Option (SciLean.Meta.FunctionInverse × Array Lean.MVarId))"}
{"name":"SciLean.Meta.FullInverse.f","declaration":"def SciLean.Meta.FullInverse.f (self : SciLean.Meta.FullInverse) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.FullInverse.Y","declaration":"def SciLean.Meta.FullInverse.Y (self : SciLean.Meta.FullInverse) : Q(Type udummy._uniq.493)"}
{"name":"SciLean.Meta.RightInverse.f","declaration":"def SciLean.Meta.RightInverse.f (self : SciLean.Meta.RightInverse) : let a := self.decX.X;\nQ(unknown_1 → unknown_2)"}
{"name":"SciLean.Meta.instOrdProdNatExprFVarIdSet","declaration":"/-- This comparison is used to select the FVarIdSet with the least number of element but non-empty one! Thus zero size sets are bigger then everything else\n-/\ndef SciLean.Meta.instOrdProdNatExprFVarIdSet  : Ord (ℕ × Lean.Expr × Lean.FVarIdSet)"}
{"name":"SciLean.Meta.FullInverse.u","declaration":"def SciLean.Meta.FullInverse.u (self : SciLean.Meta.FullInverse) : Lean.Level"}
