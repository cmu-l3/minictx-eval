{"name":"SciLean.IsSmoothLinearMap","declaration":"def SciLean.IsSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) : Prop"}
{"name":"SciLean.IsSmoothLinearMap.HMul.hMul.arg_a0.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.HMul.hMul.arg_a0.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (hf : SciLean.IsSmoothLinearMap K f) (y' : K) : SciLean.IsSmoothLinearMap K fun x => f x * y'"}
{"name":"SciLean.IsSmoothLinearMap.pi_rule","declaration":"theorem SciLean.IsSmoothLinearMap.pi_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {ι : Type u_4} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.IsSmoothLinearMap K fun x => f x i) : SciLean.IsSmoothLinearMap K fun x i => f x i"}
{"name":"SciLean.IsSmoothLinearMap.ite.arg_te.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.ite.arg_te.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) (ht : SciLean.IsSmoothLinearMap K t) (he : SciLean.IsSmoothLinearMap K e) : SciLean.IsSmoothLinearMap K fun x => if c then t x else e x"}
{"name":"SciLean.IsSmoothLinearMap.const_zero_rule","declaration":"theorem SciLean.IsSmoothLinearMap.const_zero_rule (K : Type u_1) [RCLike K] (X : Type u_2) [SciLean.Vec K X] (Y : Type u_3) [SciLean.Vec K Y] : SciLean.IsSmoothLinearMap K fun x => 0"}
{"name":"SciLean.IsSmoothLinearMap.isLinearMap","declaration":"theorem SciLean.IsSmoothLinearMap.isLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {f : X → Y} (hf : SciLean.IsSmoothLinearMap K f) : IsLinearMap K f"}
{"name":"SciLean.IsSmoothLinearMap.HSMul.hSMul.arg_a1.IsSmoothLinearMap_rule_nat","declaration":"theorem SciLean.IsSmoothLinearMap.HSMul.hSMul.arg_a1.IsSmoothLinearMap_rule_nat {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : ℕ) (f : X → Y) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.IsSmoothLinearMap K fun x => c • f x"}
{"name":"SciLean.IsSmoothLinearMap.cdifferentiable","declaration":"theorem SciLean.IsSmoothLinearMap.cdifferentiable (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {f : X → Y} (hf : SciLean.IsSmoothLinearMap K f) : SciLean.CDifferentiable K f"}
{"name":"SciLean.IsSmoothLinearMap.Prod.fst.arg_self.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.Prod.fst.arg_self.IsSmoothLinearMap_rule {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (f : X → Y × Z) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.IsSmoothLinearMap K fun x => (f x).1"}
{"name":"SciLean.IsSmoothLinearMap.HSMul.hSMul.arg_a1.IsSmoothLinearMap_rule_int","declaration":"theorem SciLean.IsSmoothLinearMap.HSMul.hSMul.arg_a1.IsSmoothLinearMap_rule_int {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : ℤ) (f : X → Y) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.IsSmoothLinearMap K fun x => c • f x"}
{"name":"SciLean.IsSmoothLinearMap.dite.arg_te.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.dite.arg_te.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (ht : ∀ (p : c), SciLean.IsSmoothLinearMap K (t p)) (e : ¬c → X → Y) (he : ∀ (p : ¬c), SciLean.IsSmoothLinearMap K (e p)) : SciLean.IsSmoothLinearMap K fun x => if x_1 : c then t x_1 x else e x_1 x"}
{"name":"SciLean.IsSmoothLinearMap.HSMul.hSMul.arg_a1.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.HSMul.hSMul.arg_a1.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : K) (f : X → Y) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.IsSmoothLinearMap K fun x => c • f x"}
{"name":"SciLean.IsSmoothLinearMap.HSMul.hSMul.arg_a0.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.HSMul.hSMul.arg_a0.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → K) (y : Y) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.IsSmoothLinearMap K fun x => f x • y"}
{"name":"SciLean.IsSmoothLinearMap.HAdd.hAdd.arg_a0a1.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.HAdd.hAdd.arg_a0a1.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (g : X → Y) (hf : SciLean.IsSmoothLinearMap K f) (hg : SciLean.IsSmoothLinearMap K g) : SciLean.IsSmoothLinearMap K fun x => f x + g x"}
{"name":"SciLean.IsSmoothLinearMap.SciLean.BasisDuality.fromDual.arg_x.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.SciLean.BasisDuality.fromDual.arg_x.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {IX : Type u_3} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] : SciLean.IsSmoothLinearMap K fun x => SciLean.BasisDuality.fromDual x"}
{"name":"SciLean.IsSmoothLinearMap.SciLean.Basis.proj.arg_x.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.SciLean.Basis.proj.arg_x.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {IX : Type u_3} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) : SciLean.IsSmoothLinearMap K fun x => ℼ i x"}
{"name":"SciLean.IsSmoothLinearMap.id_rule","declaration":"theorem SciLean.IsSmoothLinearMap.id_rule (K : Type u_1) [RCLike K] (X : Type u_2) [SciLean.Vec K X] : SciLean.IsSmoothLinearMap K fun x => x"}
{"name":"SciLean.IsSmoothLinearMap.Prod.mk.arg_fstsnd.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.Prod.mk.arg_fstsnd.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_4} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : X → Z) (g : X → Y) (hf : SciLean.IsSmoothLinearMap K f) (hg : SciLean.IsSmoothLinearMap K g) : SciLean.IsSmoothLinearMap K fun x => (g x, f x)"}
{"name":"SciLean.IsSmoothLinearMap.HMul.hMul.arg_a1.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.HMul.hMul.arg_a1.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (hf : SciLean.IsSmoothLinearMap K f) (y' : K) : SciLean.IsSmoothLinearMap K fun x => y' * f x"}
{"name":"SciLean.IsSmoothLinearMap.HSub.hSub.arg_a0a1.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.HSub.hSub.arg_a0a1.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (g : X → Y) (hf : SciLean.IsSmoothLinearMap K f) (hg : SciLean.IsSmoothLinearMap K g) : SciLean.IsSmoothLinearMap K fun x => f x - g x"}
{"name":"SciLean.IsSmoothLinearMap.SciLean.BasisDuality.toDual.arg_x.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.SciLean.BasisDuality.toDual.arg_x.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {IX : Type u_3} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] : SciLean.IsSmoothLinearMap K fun x => SciLean.BasisDuality.toDual x"}
{"name":"SciLean.IsSmoothLinearMap.apply_rule","declaration":"theorem SciLean.IsSmoothLinearMap.apply_rule (K : Type u_1) [RCLike K] {ι : Type u_2} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (i : ι) : SciLean.IsSmoothLinearMap K fun x => x i"}
{"name":"SciLean.IsSmoothLinearMap.IndexType.sum.arg_f.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.IndexType.sum.arg_f.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {ι : Type u_4} [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.IsSmoothLinearMap K fun x => f x i) : SciLean.IsSmoothLinearMap K fun x =>  ∑ i, f x i"}
{"name":"SciLean.IsSmoothLinearMap.Neg.neg.arg_a0.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.Neg.neg.arg_a0.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.IsSmoothLinearMap K fun x => -f x"}
{"name":"SciLean.IsSmoothLinearMap.comp_rule","declaration":"theorem SciLean.IsSmoothLinearMap.comp_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (hf : SciLean.IsSmoothLinearMap K f) (hg : SciLean.IsSmoothLinearMap K g) : SciLean.IsSmoothLinearMap K fun x => f (g x)"}
{"name":"SciLean.IsSmoothLinearMap.SciLean.DualBasis.dualProj.arg_x.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.SciLean.DualBasis.dualProj.arg_x.IsSmoothLinearMap_rule {K : Type u_1} [RCLike K] {IX : Type u_3} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) : SciLean.IsSmoothLinearMap K fun x => ℼ' i x"}
{"name":"SciLean.IsSmoothLinearMap.Prod.snd.arg_self.IsSmoothLinearMap_rule","declaration":"theorem SciLean.IsSmoothLinearMap.Prod.snd.arg_self.IsSmoothLinearMap_rule {K : Type u_3} [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (f : X → Y × Z) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.IsSmoothLinearMap K fun x => (f x).2"}
