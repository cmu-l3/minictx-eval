{"name":"SciLean.Distribution.restrict.arg_T.parDistribDeriv_rule","declaration":"theorem SciLean.Distribution.restrict.arg_T.parDistribDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : W ‚Üí ùíü'(X, Y)) (A : Set X) (hT : SciLean.DistribDifferentiable T) : (SciLean.parDistribDeriv fun w => (T w).restrict A) = fun w dw => (SciLean.parDistribDeriv T w dw).restrict A"}
{"name":"SciLean.dirac.arg_xy.DistribDiffrentiable_rule","declaration":"theorem SciLean.dirac.arg_xy.DistribDiffrentiable_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] (x : W ‚Üí X) (hx : SciLean.CDifferentiable R x) : SciLean.DistribDifferentiable fun w => SciLean.dirac (x w)"}
{"name":"SciLean.Distribution.restrict.arg_T.IsSmoothLinearMap_rule_simple","declaration":"theorem SciLean.Distribution.restrict.arg_T.IsSmoothLinearMap_rule_simple {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) : SciLean.IsSmoothLinearMap R fun T => T.restrict A"}
{"name":"SciLean.Bind.bind.arg_fx.DistribDifferentiable_rule","declaration":"theorem SciLean.Bind.bind.arg_fx.DistribDifferentiable_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_7} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {Z : Type u_2} [SciLean.Vec R Z] {U : Type u_5} [SciLean.Vec R U] {V : Type u_3} [SciLean.Vec R V] (f : X ‚Üí Y ‚Üí ùíü'(Z, V)) (g : X ‚Üí ùíü'(Y, U)) (L : U ‚ä∏[R] V ‚ä∏[R] W) (hf : SciLean.DistribDifferentiable fun x =>\n  match x with\n  | (x, y) => f x y) (hg : SciLean.DistribDifferentiable g) : SciLean.DistribDifferentiable fun x => SciLean.Distribution.bind (g x) (f x) L"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.parDistribDeriv_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.parDistribDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (f : W ‚Üí ùíü'(X, Y)) (g : W ‚Üí ùíü'(X, Y)) (hf : SciLean.DistribDifferentiable f) (hg : SciLean.DistribDifferentiable g) : (SciLean.parDistribDeriv fun w => f w + g w) = fun w dw =>\n  let dy := SciLean.parDistribDeriv f w dw;\n  let dz := SciLean.parDistribDeriv g w dw;\n  dy + dz"}
{"name":"SciLean.cintegral.arg_f.parDistribDeriv_rule","declaration":"theorem SciLean.cintegral.arg_f.parDistribDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_5} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] [Module ‚Ñù Z] [MeasureTheory.MeasureSpace X] [MeasureTheory.MeasureSpace Y] (f : W ‚Üí X ‚Üí Y ‚Üí Z) : (SciLean.parDistribDeriv fun w => ‚Üëfun x => ‚à´' y, f w x y ‚àÇMeasureTheory.volume) = fun w dw =>\n  let Tf := fun w => ‚Üëfun x => ‚Üëfun y => f w x y;\n  SciLean.Distribution.postComp (SciLean.parDistribDeriv Tf w dw)\n    (fun T ‚ä∏[R] T.extAction (fun x => 1) (fun z ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ z))"}
{"name":"SciLean.DistribDiffrentiable.const_rule","declaration":"theorem SciLean.DistribDiffrentiable.const_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) : SciLean.DistribDifferentiable fun x => T"}
{"name":"SciLean.distribDifferentiableAt_const_test_fun","declaration":"theorem SciLean.distribDifferentiableAt_const_test_fun {R : Type u_1} [SciLean.RealScalar R] {X : Type u_4} [SciLean.Vec R X] {Y : Type u_2} [SciLean.Vec R Y] {Z : Type u_3} [SciLean.Vec R Z] {f : X ‚Üí ùíü'(Y, Z)} {x : X} (hf : SciLean.DistribDifferentiableAt f x) {œÜ : ùíü Y} : SciLean.CDifferentiableAt R (fun x => (f x) œÜ) x"}
{"name":"SciLean.DistribDifferentiableAt","declaration":"def SciLean.DistribDifferentiableAt {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] (f : X ‚Üí ùíü'(Y, Z)) (x : X) : Prop"}
{"name":"SciLean.cintegral.arg_f.cderiv_distrib_rule'","declaration":"theorem SciLean.cintegral.arg_f.cderiv_distrib_rule' {R : Type u_2} [SciLean.RealScalar R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_1} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (f : W ‚Üí X ‚Üí R) (A : Set X) : ‚àÇ w, ‚à´' x, f w x ‚àÇMeasureTheory.volume.restrict A = fun w dw =>\n  ((SciLean.parDistribDeriv (fun w => ‚Üëfun x => f w x) w dw).restrict A).extAction (fun x => 1)\n    (fun y ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ y)"}
{"name":"SciLean.parDistribDeriv.const_rule","declaration":"theorem SciLean.parDistribDeriv.const_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) : (SciLean.parDistribDeriv fun x => T) = fun w dw => 0"}
{"name":"SciLean.action_parDistribDeriv","declaration":"theorem SciLean.action_parDistribDeriv {R : Type u_1} [SciLean.RealScalar R] {X : Type u_4} [SciLean.Vec R X] {Y : Type u_2} [SciLean.Vec R Y] {Z : Type u_3} [SciLean.Vec R Z] (f : X ‚Üí ùíü'(Y, Z)) (x : X) (dx : X) (œÜ : ùíü Y) : (SciLean.parDistribDeriv f x dx) œÜ = ‚àÇ (x':=x;dx), (f x') œÜ"}
{"name":"SciLean.HSub.hSub.arg_a0a1.parDistribDeriv_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.parDistribDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (f : W ‚Üí ùíü'(X, Y)) (g : W ‚Üí ùíü'(X, Y)) : (SciLean.parDistribDeriv fun w => f w - g w) = fun w dw =>\n  let dy := SciLean.parDistribDeriv f w dw;\n  let dz := SciLean.parDistribDeriv g w dw;\n  dy - dz"}
{"name":"SciLean.DistribDiffrentiable.comp_rule","declaration":"theorem SciLean.DistribDiffrentiable.comp_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_5} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {Z : Type u_2} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] (f : Y ‚Üí ùíü'(Z, U)) (g : X ‚Üí Y) (hf : SciLean.DistribDifferentiable f) (hg : SciLean.CDifferentiable R g) : SciLean.DistribDifferentiable fun x => f (g x)"}
{"name":"SciLean.dirac.arg_x.parDistribDeriv_rule","declaration":"theorem SciLean.dirac.arg_x.parDistribDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] (x : W ‚Üí X) (hx : SciLean.CDifferentiable R x) : (SciLean.parDistribDeriv fun w => SciLean.dirac (x w)) = fun w dw =>\n  let xdx := ‚àÇ> x w dw;\n  SciLean.diracDeriv xdx.1 xdx.2"}
{"name":"SciLean.HSub.hSub.arg_a0a1.DistribDifferentiable_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.DistribDifferentiable_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (f : W ‚Üí ùíü'(X, Y)) (g : W ‚Üí ùíü'(X, Y)) : SciLean.DistribDifferentiable fun w => f w - g w"}
{"name":"SciLean.Bind.bind.arg_fx.parDistribDiff_rule","declaration":"theorem SciLean.Bind.bind.arg_fx.parDistribDiff_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_4} [SciLean.Vec R X] {Y : Type u_2} [SciLean.Vec R Y] {U : Type u_5} [SciLean.Vec R U] {V : Type u_3} [SciLean.Vec R V] {x : W} (f : W ‚Üí X ‚Üí ùíü'(Y, V)) (g : W ‚Üí ùíü'(X, U)) (L : U ‚ä∏[R] V ‚ä∏[R] W) (hf : SciLean.DistribDifferentiable fun x =>\n  match x with\n  | (w, x) => f w x) (hg : SciLean.DistribDifferentiable g) : (SciLean.parDistribDeriv fun w => SciLean.Distribution.bind (g w) (f w) L) = fun w dw =>\n  SciLean.Distribution.bind (SciLean.parDistribDeriv g w dw) (fun x_1 => f x x_1) L +\n    SciLean.Distribution.bind (g w) (fun x => SciLean.parDistribDeriv (fun x_1 => f x_1 x) w dw) L"}
{"name":"SciLean.parDistribDeriv.comp_rule","declaration":"theorem SciLean.parDistribDeriv.comp_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_5} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {Z : Type u_2} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] (f : Y ‚Üí ùíü'(Z, U)) (g : X ‚Üí Y) (hf : SciLean.DistribDifferentiable f) (hg : SciLean.CDifferentiable R g) : (SciLean.parDistribDeriv fun x => f (g x)) = fun x dx =>\n  let ydy := ‚àÇ> g x dx;\n  SciLean.parDistribDeriv f ydy.1 ydy.2"}
{"name":"SciLean.diracDeriv","declaration":"def SciLean.diracDeriv {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] (x : X) (dx : X) : ùíü'(X, R)"}
{"name":"SciLean.parDistribDeriv","declaration":"def SciLean.parDistribDeriv {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] (f : X ‚Üí ùíü'(Y, Z)) (x : X) (dx : X) : ùíü'(Y, Z)"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.DistribDifferentiable_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.DistribDifferentiable_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (f : W ‚Üí ùíü'(X, Y)) (g : W ‚Üí ùíü'(X, Y)) (hf : SciLean.DistribDifferentiable f) (hg : SciLean.DistribDifferentiable g) : SciLean.DistribDifferentiable fun w => f w + g w"}
{"name":"SciLean.cintegral.arg_f.parDistribDeriv_rule'","declaration":"theorem SciLean.cintegral.arg_f.parDistribDeriv_rule' {R : Type u_2} [SciLean.RealScalar R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_4} [SciLean.Vec R X] {Y : Type u_1} [SciLean.Vec R Y] {Z : Type u_5} [SciLean.Vec R Z] [Module ‚Ñù Z] [MeasureTheory.MeasureSpace X] [MeasureTheory.MeasureSpace Y] (f : W ‚Üí X ‚Üí Y ‚Üí Z) (B : X ‚Üí Set Y) : (SciLean.parDistribDeriv fun w => ‚Üëfun x => ‚à´' y, f w x y ‚àÇMeasureTheory.volume.restrict (B x)) = fun w dw =>\n  let Tf := fun w => ‚Üëfun x => (‚Üëfun y => f w x y).restrict (B x);\n  SciLean.Distribution.postComp (SciLean.parDistribDeriv Tf w dw)\n    (fun T ‚ä∏[R] T.extAction (fun x => 1) (fun z ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ z))"}
{"name":"SciLean.cintegral.arg_f.cderiv_distrib_rule","declaration":"theorem SciLean.cintegral.arg_f.cderiv_distrib_rule {R : Type u_3} [SciLean.RealScalar R] {W : Type u_1} [SciLean.Vec R W] {X : Type u_4} [SciLean.Vec R X] {Y : Type u_2} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (f : W ‚Üí X ‚Üí Y) : ‚àÇ w, ‚à´' x, f w x ‚àÇMeasureTheory.volume = fun w dw =>\n  (SciLean.parDistribDeriv (fun w => ‚Üëfun x => f w x) w dw).extAction (fun x => 1) (fun y ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ y)"}
{"name":"SciLean.Function.toDistribution.arg_f.cderiv_rule","declaration":"theorem SciLean.Function.toDistribution.arg_f.cderiv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_4} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] (f : W ‚Üí X ‚Üí Y) (hf : ‚àÄ (x : X), SciLean.CDifferentiable R fun x_1 => f x_1 x) : (‚àÇ w, ‚Üëfun x => f w x) = fun w dw =>\n  ‚Üëfun x =>\n    let dy := ‚àÇ (x_1:=w;dw), f x_1 x;\n    dy"}
{"name":"SciLean.Distribution.restrict.arg_T.IsSmoothLinearMap_rule","declaration":"theorem SciLean.Distribution.restrict.arg_T.IsSmoothLinearMap_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : W ‚Üí ùíü'(X, Y)) (A : Set X) (hT : SciLean.IsSmoothLinearMap R T) : SciLean.IsSmoothLinearMap R fun w => (T w).restrict A"}
{"name":"SciLean.DistribDifferentiable","declaration":"def SciLean.DistribDifferentiable {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] (f : X ‚Üí ùíü'(Y, Z)) : Prop"}
{"name":"SciLean.Function.toDistribution.arg_f.CDifferentiable_rule","declaration":"theorem SciLean.Function.toDistribution.arg_f.CDifferentiable_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_4} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] (f : W ‚Üí X ‚Üí Y) (hf : ‚àÄ (x : X), SciLean.CDifferentiable R fun x_1 => f x_1 x) : SciLean.CDifferentiable R fun w => ‚Üëfun x => f w x"}
{"name":"SciLean.toDistribution.linear_parDistribDeriv_rule","declaration":"theorem SciLean.toDistribution.linear_parDistribDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_5} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] {Y : Type u_2} [SciLean.Vec R Y] [Module ‚Ñù Y] {Z : Type u_3} [SciLean.Vec R Z] [Module ‚Ñù Z] (f : W ‚Üí X ‚Üí Y) (L : Y ‚Üí Z) (hL : SciLean.IsSmoothLinearMap R L) : (SciLean.parDistribDeriv fun w => ‚Üëfun x => L (f w x)) = fun w dw =>\n  SciLean.Distribution.postComp (SciLean.parDistribDeriv (fun w => ‚Üëfun x => f w x) w dw) (fun y ‚ä∏[R] L y)"}
