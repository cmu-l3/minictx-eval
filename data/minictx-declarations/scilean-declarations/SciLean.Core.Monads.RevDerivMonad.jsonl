{"name":"dite.arg_te.revDerivM_rule","declaration":"theorem dite.arg_te.revDerivM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : c → X → m Y) (e : ¬c → X → m Y) : (SciLean.revDerivM K fun x => if h : c then t h x else e h x) = fun y =>\n  if h : c then SciLean.revDerivM K (t h) y else SciLean.revDerivM K (e h) y"}
{"name":"Pure.pure.arg_a0.revDerivM_rule","declaration":"theorem Pure.pure.arg_a0.revDerivM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] (a0 : X → Y) (ha0 : SciLean.HasAdjDiff K a0) : (SciLean.revDerivM K fun x => pure (a0 x)) = fun x =>\n  let ydf := SciLean.revDeriv K a0 x;\n  pure (ydf.1, fun dy => pure (ydf.2 dy))"}
{"name":"ite.arg_te.revDerivM_rule","declaration":"theorem ite.arg_te.revDerivM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : X → m Y) (e : X → m Y) : (SciLean.revDerivM K fun x => if c then t x else e x) = fun y =>\n  if c then SciLean.revDerivM K t y else SciLean.revDerivM K e y"}
{"name":"dite.arg_te.HasAdjDiffM_rule","declaration":"theorem dite.arg_te.HasAdjDiffM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : c → X → m Y) (e : ¬c → X → m Y) (ht : ∀ (h : c), SciLean.HasAdjDiffM K (t h)) (he : ∀ (h : ¬c), SciLean.HasAdjDiffM K (e h)) : SciLean.HasAdjDiffM K fun x => if h : c then t h x else e h x"}
{"name":"SciLean.revDerivM.let_rule","declaration":"theorem SciLean.revDerivM.let_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] {Z : Type} [SciLean.SemiInnerProductSpace K Z] (f : X → Y → m Z) (g : X → Y) (hf : SciLean.HasAdjDiffM K fun xy => f xy.1 xy.2) (hg : SciLean.HasAdjDiff K g) : (SciLean.revDerivM K fun x =>\n    let y := g x;\n    f x y) =\n  fun x =>\n  let ydg := SciLean.revDeriv K g x;\n  do\n  let zdf ← SciLean.revDerivM K (fun xy => f xy.1 xy.2) (x, ydg.1)\n  pure\n      (zdf.1, fun dz => do\n        let dxy ← zdf.2 dz\n        let dx : X := ydg.2 dxy.2\n        pure (dxy.1 + dx))"}
{"name":"SciLean.RevDerivMonad.mk","declaration":"ctor SciLean.RevDerivMonad.mk {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] (revDerivM : {X Y : Type} →\n  [inst : SciLean.SemiInnerProductSpace K X] →\n    [inst : SciLean.SemiInnerProductSpace K Y] → (X → m Y) → X → m (Y × (Y → m' X))) (HasAdjDiffM : {X Y : Type} →\n  [inst : SciLean.SemiInnerProductSpace K X] → [inst : SciLean.SemiInnerProductSpace K Y] → (X → m Y) → Prop) (revDerivM_pure : ∀ {X Y : Type} [inst : SciLean.SemiInnerProductSpace K X] [inst_1 : SciLean.SemiInnerProductSpace K Y] (f : X → Y),\n  SciLean.HasAdjDiff K f →\n    (revDerivM fun x => pure (f x)) = fun x =>\n      let ydf := SciLean.revDeriv K f x;\n      pure (ydf.1, fun dy => pure (ydf.2 dy))) (revDerivM_bind : ∀ {X Y Z : Type} [inst : SciLean.SemiInnerProductSpace K X] [inst_1 : SciLean.SemiInnerProductSpace K Y]\n  [inst_2 : SciLean.SemiInnerProductSpace K Z] (f : Y → m Z) (g : X → m Y),\n  HasAdjDiffM f →\n    HasAdjDiffM g →\n      (revDerivM fun x => g x >>= f) = fun x => do\n        let ydg ← revDerivM g x\n        let zdf ← revDerivM f ydg.1\n        pure (zdf.1, fun dz => zdf.2 dz >>= ydg.2)) (revDerivM_pair : ∀ {X Y : Type} [inst : SciLean.SemiInnerProductSpace K X] [inst_1 : SciLean.SemiInnerProductSpace K Y] (f : X → m Y),\n  HasAdjDiffM f →\n    (revDerivM fun x => do\n        let y ← f x\n        pure (x, y)) =\n      fun x => do\n      let ydf ← revDerivM f x\n      pure\n          ((x, ydf.1), fun dxy => do\n            let dx ← ydf.2 dxy.2\n            pure (dxy.1 + dx))) (HasAdjDiffM_pure : ∀ {X Y : Type} [inst : SciLean.SemiInnerProductSpace K X] [inst_1 : SciLean.SemiInnerProductSpace K Y] (f : X → Y),\n  SciLean.HasAdjDiff K f → HasAdjDiffM fun x => pure (f x)) (HasAdjDiffM_bind : ∀ {X Y Z : Type} [inst : SciLean.SemiInnerProductSpace K X] [inst_1 : SciLean.SemiInnerProductSpace K Y]\n  [inst_2 : SciLean.SemiInnerProductSpace K Z] (f : Y → m Z) (g : X → m Y),\n  HasAdjDiffM f → HasAdjDiffM g → HasAdjDiffM fun x => g x >>= f) (HasAdjDiffM_pair : ∀ {X Y : Type} [inst : SciLean.SemiInnerProductSpace K X] [inst_1 : SciLean.SemiInnerProductSpace K Y] (f : X → m Y),\n  HasAdjDiffM f →\n    HasAdjDiffM fun x => do\n      let y ← f x\n      pure (x, y)) : SciLean.RevDerivMonad K m m'"}
{"name":"Pure.pure.HasAdjDiffValM_rule","declaration":"theorem Pure.pure.HasAdjDiffValM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] (x : X) : SciLean.HasAdjDiffValM K (pure x)"}
{"name":"SciLean.RevDerivMonad.HasAdjDiffM_pair","declaration":"def SciLean.RevDerivMonad.HasAdjDiffM_pair {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.RevDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] (f : X → m Y) (hf : SciLean.HasAdjDiffM K f) : SciLean.HasAdjDiffM K fun x => do\n  let y ← f x\n  pure (x, y)"}
{"name":"SciLean.RevDerivMonad.revDerivM_pair","declaration":"def SciLean.RevDerivMonad.revDerivM_pair {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.RevDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] (f : X → m Y) (hf : SciLean.HasAdjDiffM K f) : (SciLean.revDerivM K fun x => do\n    let y ← f x\n    pure (x, y)) =\n  fun x => do\n  let ydf ← SciLean.revDerivM K f x\n  pure\n      ((x, ydf.1), fun dxy => do\n        let dx ← ydf.2 dxy.2\n        pure (dxy.1 + dx))"}
{"name":"SciLean.revDerivM.const_rule","declaration":"theorem SciLean.revDerivM.const_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] (y : m Y) (hy : SciLean.HasAdjDiffValM K y) : (SciLean.revDerivM K fun x => y) = fun x => do\n  let ydy ← SciLean.revDerivValM K y\n  pure\n      (ydy.1, fun dy' => do\n        let __discr ← ydy.2 dy'\n        let x : Unit := __discr\n        pure 0)"}
{"name":"SciLean.HasAdjDiffM.let_rule","declaration":"theorem SciLean.HasAdjDiffM.let_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] {Z : Type} [SciLean.SemiInnerProductSpace K Z] (f : X → Y → m Z) (g : X → Y) (hf : SciLean.HasAdjDiffM K fun xy => f xy.1 xy.2) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiffM K fun x =>\n  let y := g x;\n  f x y"}
{"name":"SciLean.RevDerivMonad.revDerivM_pure","declaration":"def SciLean.RevDerivMonad.revDerivM_pure {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.RevDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasAdjDiff K f) : (SciLean.revDerivM K fun x => pure (f x)) = fun x =>\n  let ydf := SciLean.revDeriv K f x;\n  pure (ydf.1, fun dy => pure (ydf.2 dy))"}
{"name":"SciLean.HasAdjDiffM.comp_rule","declaration":"theorem SciLean.HasAdjDiffM.comp_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] {Z : Type} [SciLean.SemiInnerProductSpace K Z] (f : Y → m Z) (g : X → Y) (hf : SciLean.HasAdjDiffM K f) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiffM K fun x => f (g x)"}
{"name":"SciLean.RevDerivMonad.HasAdjDiffM_pure","declaration":"def SciLean.RevDerivMonad.HasAdjDiffM_pure {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.RevDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasAdjDiff K f) : SciLean.HasAdjDiffM K fun x => pure (f x)"}
{"name":"Bind.bind.arg_a0a1.revDerivM_rule","declaration":"theorem Bind.bind.arg_a0a1.revDerivM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] {Z : Type} [SciLean.SemiInnerProductSpace K Z] (a0 : X → m Y) (a1 : X → Y → m Z) (ha0 : SciLean.HasAdjDiffM K a0) (ha1 : SciLean.HasAdjDiffM K fun xy => a1 xy.1 xy.2) : (SciLean.revDerivM K fun x => a0 x >>= a1 x) = fun x => do\n  let ydg ← SciLean.revDerivM K a0 x\n  let zdf ← SciLean.revDerivM K (fun xy => a1 xy.1 xy.2) (x, ydg.1)\n  pure\n      (zdf.1, fun dz => do\n        let dxy ← zdf.2 dz\n        let dx ← ydg.2 dxy.2\n        pure (dxy.1 + dx))"}
{"name":"SciLean.RevDerivMonad","declaration":"class SciLean.RevDerivMonad (K : Type) [RCLike K] (m : Type → Type) (m' : outParam (Type → Type)) [Monad m] [Monad m'] : Type 1"}
{"name":"ite.arg_te.HasAdjDiffM_rule","declaration":"theorem ite.arg_te.HasAdjDiffM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : X → m Y) (e : X → m Y) (ht : SciLean.HasAdjDiffM K t) (he : SciLean.HasAdjDiffM K e) : SciLean.HasAdjDiffM K fun x => if c then t x else e x"}
{"name":"SciLean.revDerivM.comp_rule","declaration":"theorem SciLean.revDerivM.comp_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] {Z : Type} [SciLean.SemiInnerProductSpace K Z] (f : Y → m Z) (g : X → Y) (hf : SciLean.HasAdjDiffM K f) (hg : SciLean.HasAdjDiff K g) : (SciLean.revDerivM K fun x => f (g x)) = fun x =>\n  let ydg := SciLean.revDeriv K g x;\n  do\n  let zdf ← SciLean.revDerivM K f ydg.1\n  pure\n      (zdf.1, fun dz => do\n        let dy ← zdf.2 dz\n        pure (ydg.2 dy))"}
{"name":"SciLean.HasAdjDiffValM","declaration":"def SciLean.HasAdjDiffValM (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] (x : m X) : Prop"}
{"name":"SciLean.RevDerivMonad.HasAdjDiffM_bind","declaration":"def SciLean.RevDerivMonad.HasAdjDiffM_bind {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.RevDerivMonad K m m'] {X : Type} {Y : Type} {Z : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] [SciLean.SemiInnerProductSpace K Z] (f : Y → m Z) (g : X → m Y) (hf : SciLean.HasAdjDiffM K f) (hg : SciLean.HasAdjDiffM K g) : SciLean.HasAdjDiffM K fun x => g x >>= f"}
{"name":"Pure.pure.arg_a0.HasAdjDiffM_rule","declaration":"theorem Pure.pure.arg_a0.HasAdjDiffM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] (a0 : X → Y) (ha0 : SciLean.HasAdjDiff K a0) : SciLean.HasAdjDiffM K fun x => pure (a0 x)"}
{"name":"Pure.pure.arg.revDerivValM_rule","declaration":"theorem Pure.pure.arg.revDerivValM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] (x : X) : SciLean.revDerivValM K (pure x) = pure (x, fun dy => pure 0)"}
{"name":"SciLean.RevDerivMonad.revDerivM","declaration":"def SciLean.RevDerivMonad.revDerivM (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.RevDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] (f : X → m Y) (x : X) : m (Y × (Y → m' X))"}
{"name":"Bind.bind.arg_a0a1.HasAdjDiffM_rule","declaration":"theorem Bind.bind.arg_a0a1.HasAdjDiffM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] {Z : Type} [SciLean.SemiInnerProductSpace K Z] (a0 : X → m Y) (a1 : X → Y → m Z) (ha0 : SciLean.HasAdjDiffM K a0) (ha1 : SciLean.HasAdjDiffM K fun xy => a1 xy.1 xy.2) : SciLean.HasAdjDiffM K fun x => a0 x >>= a1 x"}
{"name":"SciLean.revDerivValM","declaration":"def SciLean.revDerivValM (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] {X : Type} [SciLean.SemiInnerProductSpace K X] (x : m X) : m (X × (X → m' Unit))"}
{"name":"SciLean.RevDerivMonad.revDerivM_bind","declaration":"def SciLean.RevDerivMonad.revDerivM_bind {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.RevDerivMonad K m m'] {X : Type} {Y : Type} {Z : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] [SciLean.SemiInnerProductSpace K Z] (f : Y → m Z) (g : X → m Y) (hf : SciLean.HasAdjDiffM K f) (hg : SciLean.HasAdjDiffM K g) : (SciLean.revDerivM K fun x => g x >>= f) = fun x => do\n  let ydg ← SciLean.revDerivM K g x\n  let zdf ← SciLean.revDerivM K f ydg.1\n  pure (zdf.1, fun dz => zdf.2 dz >>= ydg.2)"}
{"name":"SciLean.RevDerivMonad.HasAdjDiffM","declaration":"def SciLean.RevDerivMonad.HasAdjDiffM (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.RevDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] (f : X → m Y) : Prop"}
{"name":"SciLean.HasAdjDiffM.const_rule","declaration":"theorem SciLean.HasAdjDiffM.const_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.SemiInnerProductSpace K X] {Y : Type} [SciLean.SemiInnerProductSpace K Y] (y : m Y) (hy : SciLean.HasAdjDiffValM K y) : SciLean.HasAdjDiffM K fun x => y"}
