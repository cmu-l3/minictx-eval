{"name":"Prod.snd.arg_self.IsAffineMap_rule","declaration":"theorem Prod.snd.arg_self.IsAffineMap_rule {R : Type u_3} {X : Type u_4} {Y : Type u_1} {Z : Type u_2} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : X → Y × Z) (hf : IsAffineMap R f) : IsAffineMap R fun x => (f x).2"}
{"name":"HSMul.hSMul.arg_a1.IsAffineMap_rule'","declaration":"theorem HSMul.hSMul.arg_a1.IsAffineMap_rule' {R : Type u_4} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] {S : Type u_1} [CommRing S] [Module S X] [Module S Y] [SMul S R] [IsScalarTower S R Y] (c : R) (f : X → Y) (hf : IsAffineMap R f) : IsAffineMap S fun x => c • f x"}
{"name":"IsAffineMap.IsAffineMap_const","declaration":"theorem IsAffineMap.IsAffineMap_const {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (y : Y) : IsAffineMap R fun x => y"}
{"name":"Prod.fst.arg_self.IsAffineMap_rule","declaration":"theorem Prod.fst.arg_self.IsAffineMap_rule {R : Type u_3} {X : Type u_4} {Y : Type u_1} {Z : Type u_2} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : X → Y × Z) (hf : IsAffineMap R f) : IsAffineMap R fun x => (f x).1"}
{"name":"HSub.hSub.arg_a0a1.IsAffineMap_rule","declaration":"theorem HSub.hSub.arg_a0a1.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → Y) (g : X → Y) (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R fun x => f x - g x"}
{"name":"SciLean.BasisDuality.toDual.arg_x.IsAffineMap_rule","declaration":"theorem SciLean.BasisDuality.toDual.arg_x.IsAffineMap_rule {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] : IsAffineMap K fun x => SciLean.BasisDuality.toDual x"}
{"name":"HAdd.hAdd.arg_a0a1.IsAffineMap_rule","declaration":"theorem HAdd.hAdd.arg_a0a1.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → Y) (g : X → Y) (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R fun x => f x + g x"}
{"name":"HSMul.hSMul.arg_a0.IsAffineMap_rule","declaration":"theorem HSMul.hSMul.arg_a0.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → R) (y : Y) (hf : IsAffineMap R f) : IsAffineMap R fun x => f x • y"}
{"name":"HSMul.hSMul.arg_a1.IsAffineMap_rule_int","declaration":"theorem HSMul.hSMul.arg_a1.IsAffineMap_rule_int {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : ℤ) (f : X → Y) (hf : IsAffineMap R f) : IsAffineMap R fun x => c • f x"}
{"name":"Prod.mk.arg_fstsnd.IsAffineMap_rule","declaration":"theorem Prod.mk.arg_fstsnd.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_4} {Z : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : X → Z) (g : X → Y) (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R fun x => (g x, f x)"}
{"name":"HSMul.hSMul.arg_a1.IsAffineMap_rule","declaration":"theorem HSMul.hSMul.arg_a1.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : R) (f : X → Y) (hf : IsAffineMap R f) : IsAffineMap R fun x => c • f x"}
{"name":"HSMul.hSMul.arg_a1.IsAffineMap_rule_nat","declaration":"theorem HSMul.hSMul.arg_a1.IsAffineMap_rule_nat {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : ℕ) (f : X → Y) (hf : IsAffineMap R f) : IsAffineMap R fun x => c • f x"}
{"name":"IsAffineMap.IsAffineMap_comp","declaration":"theorem IsAffineMap.IsAffineMap_comp {R : Type u_1} {X : Type u_4} {Y : Type u_2} {Z : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] {f : Y → Z} {g : X → Y} (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R fun x => f (g x)"}
{"name":"IndexType.sum.arg_f.IsAffineMap_rule","declaration":"theorem IndexType.sum.arg_f.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} {ι : Type u_4} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), IsAffineMap R fun x => f x i) : IsAffineMap R fun x =>  ∑ i, f x i"}
{"name":"SciLean.Basis.proj.arg_x.IsAffineMap_rule","declaration":"theorem SciLean.Basis.proj.arg_x.IsAffineMap_rule {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) : IsAffineMap K fun x => ℼ i x"}
{"name":"HMul.hMul.arg_a1.IsAffineMap_rule","declaration":"theorem HMul.hMul.arg_a1.IsAffineMap_rule {R : Type u_1} {X : Type u_2} [CommRing R] [AddCommGroup X] [Module R X] (f : X → R) (hf : IsAffineMap R f) (y' : R) : IsAffineMap R fun x => y' * f x"}
{"name":"IsAffineMap","declaration":"structure IsAffineMap (R : Type u_1) {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → Y) : Prop"}
{"name":"Neg.neg.arg_a0.IsAffineMap_rule","declaration":"theorem Neg.neg.arg_a0.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → Y) (hf : IsAffineMap R f) : IsAffineMap R fun x => -f x"}
{"name":"IsAffineMap.IsAffineMap_pi","declaration":"theorem IsAffineMap.IsAffineMap_pi {R : Type u_1} {X : Type u_2} {ι : Type u_4} {E : ι → Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [(i : ι) → AddCommGroup (E i)] [(i : ι) → Module R (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), IsAffineMap R fun x => f x i) : IsAffineMap R fun x i => f x i"}
{"name":"SciLean.DualBasis.dualProj.arg_x.IsAffineMap_rule","declaration":"theorem SciLean.DualBasis.dualProj.arg_x.IsAffineMap_rule {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) : IsAffineMap K fun x => ℼ' i x"}
{"name":"IsAffineMap.IsAffineMap_apply","declaration":"theorem IsAffineMap.IsAffineMap_apply {R : Type u_1} {ι : Type u_2} {E : ι → Type u_3} [CommRing R] [(i : ι) → AddCommGroup (E i)] [(i : ι) → Module R (E i)] (i : ι) : IsAffineMap R fun f => f i"}
{"name":"dite.arg_te.IsAffineMap_rule","declaration":"theorem dite.arg_te.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (ht : ∀ (p : c), IsAffineMap R (t p)) (e : ¬c → X → Y) (he : ∀ (p : ¬c), IsAffineMap R (e p)) : IsAffineMap R fun x => if x_1 : c then t x_1 x else e x_1 x"}
{"name":"IsAffineMap.IsAffineMap_id","declaration":"theorem IsAffineMap.IsAffineMap_id {R : Type u_1} {X : Type u_2} [CommRing R] [AddCommGroup X] [Module R X] : IsAffineMap R fun x => x"}
{"name":"HMul.hMul.arg_a0.IsAffineMap_rule","declaration":"theorem HMul.hMul.arg_a0.IsAffineMap_rule {R : Type u_1} {X : Type u_2} [CommRing R] [AddCommGroup X] [Module R X] (f : X → R) (hf : IsAffineMap R f) (y' : R) : IsAffineMap R fun x => f x * y'"}
{"name":"ite.arg_te.IsAffineMap_rule","declaration":"theorem ite.arg_te.IsAffineMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) (ht : IsAffineMap R t) (he : IsAffineMap R e) : IsAffineMap R fun x => if c then t x else e x"}
{"name":"IsAffineMap.mk","declaration":"ctor IsAffineMap.mk {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] {f : X → Y} (is_affine : IsLinearMap R fun x => f x - f 0) : IsAffineMap R f"}
{"name":"IsAffineMap.is_affine","declaration":"def IsAffineMap.is_affine {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommRing R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] {f : X → Y} (self : IsAffineMap R f) : IsLinearMap R fun x => f x - f 0"}
{"name":"SciLean.BasisDuality.fromDual.arg_x.IsAffineMap_rule","declaration":"theorem SciLean.BasisDuality.fromDual.arg_x.IsAffineMap_rule {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] : IsAffineMap K fun x => SciLean.BasisDuality.fromDual x"}
