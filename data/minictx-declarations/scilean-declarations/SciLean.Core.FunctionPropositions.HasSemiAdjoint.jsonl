{"name":"SciLean.semiAdjoint_choose","declaration":"theorem SciLean.semiAdjoint_choose (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {f : X → Y} (hf : SciLean.HasSemiAdjoint K f) : SciLean.semiAdjoint K f = Classical.choose ⋯"}
{"name":"SciLean.HasSemiAdjoint.SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {W : Type u_2} [SciLean.SemiInnerProductSpace K W] (f : X → Y) (a0 : W → Y) (ha0 : SciLean.HasSemiAdjoint K a0) : SciLean.HasSemiAdjoint K fun w => SciLean.semiAdjoint K f (a0 w)"}
{"name":"SciLean.HasSemiAdjoint.IsLinearMap","declaration":"theorem SciLean.HasSemiAdjoint.IsLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) : IsLinearMap K f"}
{"name":"SciLean.HasSemiAdjoint.const_rule","declaration":"theorem SciLean.HasSemiAdjoint.const_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] : SciLean.HasSemiAdjoint K fun x => 0"}
{"name":"SciLean.HasSemiAdjoint.Neg.neg.arg_a0.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.Neg.neg.arg_a0.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) : SciLean.HasSemiAdjoint K fun x => -f x"}
{"name":"SciLean.HasSemiAdjoint.id_rule","declaration":"theorem SciLean.HasSemiAdjoint.id_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] : SciLean.HasSemiAdjoint K fun x => x"}
{"name":"SciLean.HasSemiAdjoint.pi_rule","declaration":"theorem SciLean.HasSemiAdjoint.pi_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {ι : Type u_4} [SciLean.IndexType ι] {E : ι → Type u_3} [(i : ι) → SciLean.SemiInnerProductSpace K (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.HasSemiAdjoint K fun x => f x i) : SciLean.HasSemiAdjoint K fun x i => f x i"}
{"name":"SciLean.HasSemiAdjoint.HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] [ContinuousAdd Y] (f : X → Y) (g : X → Y) (hf : SciLean.HasSemiAdjoint K f) (hg : SciLean.HasSemiAdjoint K g) : SciLean.HasSemiAdjoint K fun x => f x + g x"}
{"name":"SciLean.HasSemiAdjoint.HDiv.hDiv.arg_a0.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.HDiv.hDiv.arg_a0.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (f : X → K) (hf : SciLean.HasSemiAdjoint K f) (y : K) : SciLean.HasSemiAdjoint K fun x => f x / y"}
{"name":"SciLean.semiAdjoint.arg_y.CDifferentiable_rule","declaration":"theorem SciLean.semiAdjoint.arg_y.CDifferentiable_rule (K : Type u_1) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) : SciLean.CDifferentiable K fun y => SciLean.semiAdjoint K f y"}
{"name":"SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a0.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a0.HasSemiAdjoint_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiHilbert K Y] (f : X → K) (y : Y) (hf : SciLean.HasSemiAdjoint K f) : SciLean.HasSemiAdjoint K fun x => f x • y"}
{"name":"SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a1.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a1.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (c : K) (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) : SciLean.HasSemiAdjoint K fun x => c • f x"}
{"name":"SciLean.HasSemiAdjoint.mk","declaration":"ctor SciLean.HasSemiAdjoint.mk {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {f : X → Y} (semiAdjoint_exists : ∃ f', ∀ (x : X) (y : Y), SciLean.TestFunction x → ⟪y, f x⟫_K = ⟪f' y, x⟫_K) (is_differentiable : SciLean.CDifferentiable K f) : SciLean.HasSemiAdjoint K f"}
{"name":"SciLean.HasSemiAdjoint.HSub.hSub.arg_a0a1.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.HSub.hSub.arg_a0a1.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (g : X → Y) (hf : SciLean.HasSemiAdjoint K f) (hg : SciLean.HasSemiAdjoint K g) : SciLean.HasSemiAdjoint K fun x => f x - g x"}
{"name":"SciLean.HasSemiAdjoint.Prod.snd.arg_self.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.Prod.snd.arg_self.HasSemiAdjoint_rule (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_2} [SciLean.SemiInnerProductSpace K Z] (f : X → Y × Z) (hf : SciLean.HasSemiAdjoint K f) : SciLean.HasSemiAdjoint K fun x => (f x).2"}
{"name":"SciLean.semiAdjoint","declaration":"/-- Generalization of adjoint of linear map `f : X → Y`.\n\nIf `f : X → Y` is linear map between Hilbert spaces then `semiAdjoint K f = adjoint K f`.\n\n`semiAdjoint` is a generalization of adjoint to spaces that are not necessarily complete\nand might have inner product defined only on a dense subset, see `SemiInnerProductSpace`\nfor more information.\n -/\ndef SciLean.semiAdjoint (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (y : Y) : X"}
{"name":"SciLean.HasSemiAdjoint.semiAdjoint_exists","declaration":"def SciLean.HasSemiAdjoint.semiAdjoint_exists {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {f : X → Y} (self : SciLean.HasSemiAdjoint K f) : ∃ f', ∀ (x : X) (y : Y), SciLean.TestFunction x → ⟪y, f x⟫_K = ⟪f' y, x⟫_K"}
{"name":"SciLean.HasSemiAdjoint","declaration":"structure SciLean.HasSemiAdjoint (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) : Prop"}
{"name":"SciLean.HasSemiAdjoint.SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {ι : Type u_4} [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.HasSemiAdjoint K fun x => f x i) : SciLean.HasSemiAdjoint K fun x =>  ∑ i, f x i"}
{"name":"SciLean.HasSemiAdjoint.dite.arg_te.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.dite.arg_te.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (ht : ∀ (p : c), SciLean.HasSemiAdjoint K (t p)) (e : ¬c → X → Y) (he : ∀ (p : ¬c), SciLean.HasSemiAdjoint K (e p)) : SciLean.HasSemiAdjoint K fun x => if x_1 : c then t x_1 x else e x_1 x"}
{"name":"SciLean.HasSemiAdjoint.HMul.hMul.arg_a1.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.HMul.hMul.arg_a1.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (y' : K) (f : X → K) (hf : SciLean.HasSemiAdjoint K f) : SciLean.HasSemiAdjoint K fun x => y' * f x"}
{"name":"SciLean.HasSemiAdjoint.Prod.mk.arg_fstsnd.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.Prod.mk.arg_fstsnd.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_4} [SciLean.SemiInnerProductSpace K Z] (g : X → Y) (hg : SciLean.HasSemiAdjoint K g) (f : X → Z) (hf : SciLean.HasSemiAdjoint K f) : SciLean.HasSemiAdjoint K fun x => (g x, f x)"}
{"name":"SciLean.semiAdjoint_move","declaration":"def SciLean.semiAdjoint_move (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (x : X) (y : Y) (hx : SciLean.TestFunction x) (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) : ⟪SciLean.semiAdjoint K f y, x⟫_K = ⟪y, f x⟫_K"}
{"name":"SciLean.semiAdjoint_unique","declaration":"def SciLean.semiAdjoint_unique (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) (f' : Y → X) (hf' : ∀ (x : X) (y : Y), SciLean.TestFunction x → ⟪y, f x⟫_K = ⟪f' y, x⟫_K) : f' = SciLean.semiAdjoint K f"}
{"name":"SciLean.HasSemiAdjoint.ite.arg_te.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.ite.arg_te.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) (ht : SciLean.HasSemiAdjoint K t) (he : SciLean.HasSemiAdjoint K e) : SciLean.HasSemiAdjoint K fun x => if c then t x else e x"}
{"name":"SciLean.HasSemiAdjoint.Inner.inner.arg_a0.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.Inner.inner.arg_a0.HasSemiAdjoint_rule {K : Type u_1} [SciLean.RealScalar K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiHilbert K Y] (f : X → Y) : SciLean.HasSemiAdjoint K f → ∀ (y : Y), SciLean.HasSemiAdjoint K fun x => ⟪f x, y⟫_K"}
{"name":"SciLean.HasSemiAdjoint.CDifferentiable","declaration":"theorem SciLean.HasSemiAdjoint.CDifferentiable (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) : SciLean.CDifferentiable K f"}
{"name":"SciLean.HasSemiAdjoint.is_differentiable","declaration":"def SciLean.HasSemiAdjoint.is_differentiable {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {f : X → Y} (self : SciLean.HasSemiAdjoint K f) : SciLean.CDifferentiable K f"}
{"name":"SciLean.semiAdjoint.arg_fy.CDifferentiable_rule","declaration":"theorem SciLean.semiAdjoint.arg_fy.CDifferentiable_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_4} [SciLean.SemiInnerProductSpace K Y] {W : Type u_3} [SciLean.SemiInnerProductSpace K W] (f : W → X → Y) (y : W → Y) (hf₁ : SciLean.CDifferentiable K fun x =>\n  match x with\n  | (w, x) => f w x) (hf₂ : ∀ (w : W), SciLean.HasSemiAdjoint K fun x => f w x) (hy : SciLean.CDifferentiable K y) : SciLean.CDifferentiable K fun w => SciLean.semiAdjoint K (f w) (y w)"}
{"name":"SciLean.HasSemiAdjoint.Prod.fst.arg_self.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.Prod.fst.arg_self.HasSemiAdjoint_rule (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_2} [SciLean.SemiInnerProductSpace K Z] (f : X → Y × Z) (hf : SciLean.HasSemiAdjoint K f) : SciLean.HasSemiAdjoint K fun x => (f x).1"}
{"name":"SciLean.semiAdjoint.arg_y.IsSmoothLinearMap_rule","declaration":"theorem SciLean.semiAdjoint.arg_y.IsSmoothLinearMap_rule (K : Type u_1) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) : SciLean.IsSmoothLinearMap K fun y => SciLean.semiAdjoint K f y"}
{"name":"SciLean.semiAdjoint.arg_y.IsLinearMap_rule","declaration":"/-- `semiAdjoint K f ·` is always linear because either `f` has adjoint and is linear or\n`semiAdjoint K f ·` is zero function and thus linear too. -/\ntheorem SciLean.semiAdjoint.arg_y.IsLinearMap_rule (K : Type u_1) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) : IsLinearMap K fun y => SciLean.semiAdjoint K f y"}
{"name":"SciLean.HasSemiAdjoint.starRingEnd.arg_a.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.starRingEnd.arg_a.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (f : X → K) : SciLean.HasSemiAdjoint K f → SciLean.HasSemiAdjoint K fun x => (starRingEnd K) (f x)"}
{"name":"SciLean.HasSemiAdjoint.Inner.inner.arg_a1.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.Inner.inner.arg_a1.HasSemiAdjoint_rule {K : Type u_1} [SciLean.RealScalar K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiHilbert K Y] (f : X → Y) : SciLean.HasSemiAdjoint K f → ∀ (y : Y), SciLean.HasSemiAdjoint K fun x => ⟪y, f x⟫_K"}
{"name":"SciLean.HasSemiAdjoint.apply_rule","declaration":"theorem SciLean.HasSemiAdjoint.apply_rule (K : Type u_1) [RCLike K] {ι : Type u_2} [SciLean.IndexType ι] [DecidableEq ι] {E : ι → Type u_3} [(i : ι) → SciLean.SemiInnerProductSpace K (E i)] (i : ι) : SciLean.HasSemiAdjoint K fun x => x i"}
{"name":"SciLean.HasSemiAdjoint.comp_rule","declaration":"theorem SciLean.HasSemiAdjoint.comp_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_3} [SciLean.SemiInnerProductSpace K Z] (f : Y → Z) (g : X → Y) (hf : SciLean.HasSemiAdjoint K f) (hg : SciLean.HasSemiAdjoint K g) : SciLean.HasSemiAdjoint K fun x => f (g x)"}
{"name":"SciLean.semiAdjoint.arg_f.IsSmoothLinearMap_rule","declaration":"theorem SciLean.semiAdjoint.arg_f.IsSmoothLinearMap_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {W : Type u_2} [SciLean.SemiInnerProductSpace K W] (f : W → X → Y) (hf₁ : ∀ (x : X), SciLean.IsSmoothLinearMap K fun x_1 => f x_1 x) (hf₂ : ∀ (w : W), SciLean.HasSemiAdjoint K fun x => f w x) : SciLean.IsSmoothLinearMap K fun w => SciLean.semiAdjoint K (f w)"}
{"name":"SciLean.semi_inner_ext","declaration":"def SciLean.semi_inner_ext (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (x : X) (x' : X) : (∀ (φ : X), SciLean.TestFunction φ → ⟪x, φ⟫_K = ⟪x', φ⟫_K) → x = x'"}
{"name":"SciLean.hasSemiAdjoint.IsSmoothLinearMap","declaration":"theorem SciLean.hasSemiAdjoint.IsSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) : SciLean.IsSmoothLinearMap K f"}
{"name":"SciLean.HasSemiAdjoint.Finset.sum.arg_f.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.Finset.sum.arg_f.HasSemiAdjoint_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_4} [SciLean.SemiInnerProductSpace K Y] {ι : Type u_1} [Fintype ι] (f : X → ι → Y) : (∀ (i : ι), SciLean.HasSemiAdjoint K fun x => f x i) →\n  ∀ (A : Finset ι), SciLean.HasSemiAdjoint K fun x => Finset.sum A fun i => f x i"}
{"name":"SciLean.HasSemiAdjoint.HMul.hMul.arg_a0.HasSemiAdjoint_rule","declaration":"theorem SciLean.HasSemiAdjoint.HMul.hMul.arg_a0.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (f : X → K) (y' : K) (hf : SciLean.HasSemiAdjoint K f) : SciLean.HasSemiAdjoint K fun x => f x * y'"}
