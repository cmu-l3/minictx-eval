{"name":"SciLean.Scalar.sqrt.arg_x.cderiv_rule_at","declaration":"theorem SciLean.Scalar.sqrt.arg_x.cderiv_rule_at {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (w : W) (x : W → R) (hx : SciLean.CDifferentiableAt R x w) (hw : 0 < x w) : SciLean.cderiv R (fun w => SciLean.Scalar.sqrt (x w)) w = fun dw =>\n  let xdx := SciLean.fwdDeriv R x w dw;\n  xdx.2 / (2 * SciLean.Scalar.sqrt xdx.1)"}
{"name":"SciLean.Scalar.sqrt.arg_x.HasAdjDiff_rule","declaration":"theorem SciLean.Scalar.sqrt.arg_x.HasAdjDiff_rule {R : Type u_1} [SciLean.RealScalar R] {U : Type u_2} [SciLean.SemiInnerProductSpace R U] (x : U → R) (hx : SciLean.HasAdjDiff R x) (hu : ∀ (u : U), 0 < x u) : SciLean.HasAdjDiff R fun u => SciLean.Scalar.sqrt (x u)"}
{"name":"SciLean.Scalar.sqrt.arg_x.revDeriv_rule_at","declaration":"theorem SciLean.Scalar.sqrt.arg_x.revDeriv_rule_at {R : Type u_1} [SciLean.RealScalar R] {U : Type u_2} [SciLean.SemiInnerProductSpace R U] (u : U) (x : U → R) (hx : SciLean.HasAdjDiffAt R x u) (hu : 0 < x u) : SciLean.revDeriv R (fun u => SciLean.Scalar.sqrt (x u)) u =\n  let xdx := SciLean.revDeriv R x u;\n  let x' := SciLean.Scalar.sqrt xdx.1;\n  (x', fun dy => xdx.2 (dy / (2 * x')))"}
{"name":"SciLean.Scalar.sqrt.arg_x.HasAdjDiffAt_rule","declaration":"theorem SciLean.Scalar.sqrt.arg_x.HasAdjDiffAt_rule {R : Type u_1} [SciLean.RealScalar R] {U : Type u_2} [SciLean.SemiInnerProductSpace R U] (u : U) (x : U → R) (hx : SciLean.HasAdjDiffAt R x u) (hu : 0 < x u) : SciLean.HasAdjDiffAt R (fun u => SciLean.Scalar.sqrt (x u)) u"}
{"name":"SciLean.Scalar.sqrt.arg_x.revDeriv_rule","declaration":"theorem SciLean.Scalar.sqrt.arg_x.revDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {U : Type u_2} [SciLean.SemiInnerProductSpace R U] (x : U → R) (hx : SciLean.HasAdjDiff R x) (hu : ∀ (u : U), 0 < x u) : (SciLean.revDeriv R fun u => SciLean.Scalar.sqrt (x u)) = fun u =>\n  let xdx := SciLean.revDeriv R x u;\n  let x' := SciLean.Scalar.sqrt xdx.1;\n  (x', fun dy => xdx.2 (dy / (2 * x')))"}
{"name":"SciLean.Scalar.sqrt.arg_x.fwdDeriv_rule","declaration":"theorem SciLean.Scalar.sqrt.arg_x.fwdDeriv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (x : W → R) (hx : SciLean.CDifferentiable R x) (hw : ∀ (w : W), 0 < x w) : (SciLean.fwdDeriv R fun w => SciLean.Scalar.sqrt (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv R x w dw;\n  let x' := SciLean.Scalar.sqrt xdx.1;\n  (x', xdx.2 / (2 * x'))"}
{"name":"SciLean.Scalar.sqrt.arg_x.fwdDeriv_rule_at","declaration":"theorem SciLean.Scalar.sqrt.arg_x.fwdDeriv_rule_at {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (w : W) (x : W → R) (hx : SciLean.CDifferentiableAt R x w) (hw : 0 < x w) : SciLean.fwdDeriv R (fun w => SciLean.Scalar.sqrt (x w)) w = fun dw =>\n  let xdx := SciLean.fwdDeriv R x w dw;\n  let x' := SciLean.Scalar.sqrt xdx.1;\n  (x', xdx.2 / (2 * x'))"}
{"name":"SciLean.Scalar.sqrt.arg_x.cderiv_rule","declaration":"theorem SciLean.Scalar.sqrt.arg_x.cderiv_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (x : W → R) (hx : SciLean.CDifferentiable R x) (hw : ∀ (w : W), 0 < x w) : (SciLean.cderiv R fun w => SciLean.Scalar.sqrt (x w)) = fun w dw =>\n  let xdx := SciLean.fwdDeriv R x w dw;\n  xdx.2 / (2 * SciLean.Scalar.sqrt xdx.1)"}
{"name":"SciLean.Scalar.sqrt.arg_x.CDifferentiableAt_rule","declaration":"theorem SciLean.Scalar.sqrt.arg_x.CDifferentiableAt_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (w : W) (x : W → R) (hx : SciLean.CDifferentiableAt R x w) (hw : x w ≠ 0) : SciLean.CDifferentiableAt R (fun w => SciLean.Scalar.sqrt (x w)) w"}
{"name":"SciLean.Scalar.sqrt.arg_x.CDifferentiable_rule","declaration":"theorem SciLean.Scalar.sqrt.arg_x.CDifferentiable_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] (x : W → R) (hx : SciLean.CDifferentiable R x) (hw : ∀ (w : W), x w ≠ 0) : SciLean.CDifferentiable R fun w => SciLean.Scalar.sqrt (x w)"}
