{"name":"SciLean.Rand.ite_pull_mean","declaration":"theorem SciLean.Rand.ite_pull_mean {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) : (if c then SciLean.Rand.mean t else SciLean.Rand.mean e) = SciLean.Rand.mean (if c then t else e)"}
{"name":"SciLean.Rand.push_E_lambda","declaration":"theorem SciLean.Rand.push_E_lambda {X : Type u_1} {Y : Type} [MeasurableSpace Y] {Z : Type u_2} [AddCommGroup Z] [Module â„ Z] (r : SciLean.Rand Y) (f : X â†’ Y â†’ Z) : (r.ğ”¼ fun y x => f x y) = fun x => r.ğ”¼ fun y => f x y"}
{"name":"SciLean.Rand.bind_pull_mean","declaration":"theorem SciLean.Rand.bind_pull_mean {X : Type} [MeasurableSpace X] {Y : Type} [AddCommGroup Y] [Module â„ Y] [MeasurableSpace Y] (x : SciLean.Rand X) (f : X â†’ SciLean.Rand Y) : (SciLean.Rand.mean do\n    let x' â† x\n    pure (SciLean.Rand.mean (f x'))) =\n  SciLean.Rand.mean (x >>= f)"}
{"name":"SciLean.Rand.pull_mean_add_2","declaration":"theorem SciLean.Rand.pull_mean_add_2 {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (x : X) (y : SciLean.Rand X) : x + SciLean.Rand.mean y =\n  SciLean.Rand.mean do\n    let y' â† y\n    pure (x + y')"}
{"name":"SciLean.Rand.pull_E_affine","declaration":"theorem SciLean.Rand.pull_E_affine {X : Type} [MeasurableSpace X] {Y : Type u_1} [AddCommGroup Y] [Module â„ Y] {Z : Type u_2} [AddCommGroup Z] [Module â„ Z] (r : SciLean.Rand X) (Ï† : X â†’ Y) (f : Y â†’ Z) (hf : autoParam (IsAffineMap â„ f) _autoâœ) : f (r.ğ”¼ Ï†) = r.ğ”¼ fun x => f (Ï† x)"}
{"name":"SciLean.Rand.pull_mean_smul","declaration":"theorem SciLean.Rand.pull_mean_smul {R : Type u_1} [SciLean.RealScalar R] {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] [Module R X] (r : R) (x : SciLean.Rand X) : r â€¢ SciLean.Rand.mean x =\n  SciLean.Rand.mean do\n    let x' â† x\n    pure (r â€¢ x')"}
{"name":"SciLean.Rand.pull_E_lambda","declaration":"theorem SciLean.Rand.pull_E_lambda {X : Type u_1} {Y : Type} [MeasurableSpace Y] {Z : Type u_2} [AddCommGroup Z] [Module â„ Z] (r : SciLean.Rand Y) (f : X â†’ Y â†’ Z) : (fun x => r.ğ”¼ fun y => f x y) = r.ğ”¼ fun y x => f x y"}
{"name":"SciLean.Rand.pull_E_list_recOn","declaration":"theorem SciLean.Rand.pull_E_list_recOn {Î± : Type u_1} {C : List Î± â†’ Type} [(n : List Î±) â†’ AddCommGroup (C n)] [(n : List Î±) â†’ Module â„ (C n)] [(n : List Î±) â†’ MeasurableSpace (C n)] {D : List Î± â†’ Type} [(n : List Î±) â†’ MeasurableSpace (D n)] (l : List Î±) (xâ‚€ : C []) (r : (head : Î±) â†’ (tail : List Î±) â†’ SciLean.Rand (D (head :: tail))) (f : (head : Î±) â†’ (tail : List Î±) â†’ C tail â†’ D (head :: tail) â†’ C (head :: tail)) (hf : âˆ€ (head : Î±) (tail : List Î±) (d : D (head :: tail)), IsAffineMap â„ fun x => f head tail x d) : (List.recOn l xâ‚€ fun head tail x => (r head tail).ğ”¼ (f head tail x)) =\n  SciLean.Rand.mean\n    (List.recOn l (pure xâ‚€) fun head tail x => do\n      let x' â† x\n      let y' â† r head tail\n      pure (f head tail x' y'))"}
{"name":"SciLean.Rand.ite_pull_mean_f","declaration":"theorem SciLean.Rand.ite_pull_mean_f {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] {c : Prop} [Decidable c] (t : X) (e : SciLean.Rand X) : (if c then t else SciLean.Rand.mean e) = SciLean.Rand.mean (if c then pure t else e)"}
{"name":"SciLean.Rand.push_E_affine","declaration":"theorem SciLean.Rand.push_E_affine {X : Type} [MeasurableSpace X] {Y : Type u_1} [AddCommGroup Y] [Module â„ Y] {Z : Type u_2} [AddCommGroup Z] [Module â„ Z] (r : SciLean.Rand X) (Ï† : X â†’ Y) (f : Y â†’ Z) (hf : autoParam (IsAffineMap â„ f) _autoâœ) : (r.ğ”¼ fun x => f (Ï† x)) = f (r.ğ”¼ Ï†)"}
{"name":"SciLean.Rand.pull_mean_add","declaration":"theorem SciLean.Rand.pull_mean_add {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (x : SciLean.Rand X) (y : SciLean.Rand X) : SciLean.Rand.mean x + SciLean.Rand.mean y =\n  SciLean.Rand.mean do\n    let x' â† x\n    let y' â† y\n    pure (x' + y')"}
{"name":"SciLean.Rand.pull_mean_sub","declaration":"theorem SciLean.Rand.pull_mean_sub {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (x : SciLean.Rand X) (y : SciLean.Rand X) : SciLean.Rand.mean x - SciLean.Rand.mean y =\n  SciLean.Rand.mean do\n    let x' â† x\n    let y' â† y\n    pure (x' - y')"}
{"name":"SciLean.Rand.pull_mean_mul","declaration":"theorem SciLean.Rand.pull_mean_mul {R : Type} [SciLean.RealScalar R] (r : R) (x : SciLean.Rand R) : r * SciLean.Rand.mean x =\n  SciLean.Rand.mean do\n    let x' â† x\n    pure (r * x')"}
{"name":"SciLean.Rand.pull_mean_add_1","declaration":"theorem SciLean.Rand.pull_mean_add_1 {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (x : SciLean.Rand X) (y : X) : SciLean.Rand.mean x + y =\n  SciLean.Rand.mean do\n    let x' â† x\n    pure (x' + y)"}
{"name":"SciLean.Rand.ite_push_mean","declaration":"theorem SciLean.Rand.ite_push_mean {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) : SciLean.Rand.mean (if c then t else e) = if c then SciLean.Rand.mean t else SciLean.Rand.mean e"}
{"name":"SciLean.Rand.ite_pull_E","declaration":"theorem SciLean.Rand.ite_pull_E {X : Type} [MeasurableSpace X] {Y : Type u_1} [AddCommGroup Y] [Module â„ Y] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) (Ï† : X â†’ Y) (Ïˆ : X â†’ Y) : (if c then t.ğ”¼ Ï† else e.ğ”¼ Ïˆ) = (if c then t else e).ğ”¼ (if c then Ï† else Ïˆ)"}
{"name":"SciLean.Rand.pull_E_nat_recOn","declaration":"theorem SciLean.Rand.pull_E_nat_recOn (C : â„• â†’ Type) [(n : â„•) â†’ AddCommGroup (C n)] [(n : â„•) â†’ Module â„ (C n)] [(n : â„•) â†’ MeasurableSpace (C n)] (D : â„• â†’ Type) [(n : â„•) â†’ MeasurableSpace (D n)] {n : â„•} (xâ‚€ : C 0) (r : (n : â„•) â†’ SciLean.Rand (D n)) (f : (n : â„•) â†’ C n â†’ D n â†’ C (n + 1)) (hf : âˆ€ (n : â„•) (d : D n), IsAffineMap â„ fun x => f n x d) : (Nat.recOn n xâ‚€ fun n x => (r n).ğ”¼ (f n x)) =\n  SciLean.Rand.mean\n    (Nat.recOn n (pure xâ‚€) fun n x => do\n      let x' â† x\n      let y' â† r n\n      pure (f n x' y'))"}
{"name":"SciLean.Rand.ite_push_E","declaration":"theorem SciLean.Rand.ite_push_E {X : Type} [MeasurableSpace X] {Y : Type u_1} [AddCommGroup Y] [Module â„ Y] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) (Ï† : X â†’ Y) : (if c then t else e).ğ”¼ Ï† = if c then t.ğ”¼ Ï† else e.ğ”¼ Ï†"}
{"name":"SciLean.Rand.pull_mean_neg","declaration":"theorem SciLean.Rand.pull_mean_neg {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] (x : SciLean.Rand X) : -SciLean.Rand.mean x =\n  SciLean.Rand.mean do\n    let x' â† x\n    pure (-x')"}
{"name":"SciLean.Rand.ite_pull_mean_t","declaration":"theorem SciLean.Rand.ite_pull_mean_t {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module â„ X] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : X) : (if c then SciLean.Rand.mean t else e) = SciLean.Rand.mean (if c then t else pure e)"}
{"name":"SciLean.Rand.pull_mean_div","declaration":"theorem SciLean.Rand.pull_mean_div {R : Type} [SciLean.RealScalar R] (x : SciLean.Rand R) (y : R) : SciLean.Rand.mean x / y =\n  SciLean.Rand.mean do\n    let x' â† x\n    pure (x' / y)"}
