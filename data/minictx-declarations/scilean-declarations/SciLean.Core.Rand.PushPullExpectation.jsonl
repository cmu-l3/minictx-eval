{"name":"SciLean.Rand.ite_pull_mean","declaration":"theorem SciLean.Rand.ite_pull_mean {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) : (if c then SciLean.Rand.mean t else SciLean.Rand.mean e) = SciLean.Rand.mean (if c then t else e)"}
{"name":"SciLean.Rand.push_E_lambda","declaration":"theorem SciLean.Rand.push_E_lambda {X : Type u_1} {Y : Type} [MeasurableSpace Y] {Z : Type u_2} [AddCommGroup Z] [Module ℝ Z] (r : SciLean.Rand Y) (f : X → Y → Z) : (r.𝔼 fun y x => f x y) = fun x => r.𝔼 fun y => f x y"}
{"name":"SciLean.Rand.bind_pull_mean","declaration":"theorem SciLean.Rand.bind_pull_mean {X : Type} [MeasurableSpace X] {Y : Type} [AddCommGroup Y] [Module ℝ Y] [MeasurableSpace Y] (x : SciLean.Rand X) (f : X → SciLean.Rand Y) : (SciLean.Rand.mean do\n    let x' ← x\n    pure (SciLean.Rand.mean (f x'))) =\n  SciLean.Rand.mean (x >>= f)"}
{"name":"SciLean.Rand.pull_mean_add_2","declaration":"theorem SciLean.Rand.pull_mean_add_2 {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (x : X) (y : SciLean.Rand X) : x + SciLean.Rand.mean y =\n  SciLean.Rand.mean do\n    let y' ← y\n    pure (x + y')"}
{"name":"SciLean.Rand.pull_E_affine","declaration":"theorem SciLean.Rand.pull_E_affine {X : Type} [MeasurableSpace X] {Y : Type u_1} [AddCommGroup Y] [Module ℝ Y] {Z : Type u_2} [AddCommGroup Z] [Module ℝ Z] (r : SciLean.Rand X) (φ : X → Y) (f : Y → Z) (hf : autoParam (IsAffineMap ℝ f) _auto✝) : f (r.𝔼 φ) = r.𝔼 fun x => f (φ x)"}
{"name":"SciLean.Rand.pull_mean_smul","declaration":"theorem SciLean.Rand.pull_mean_smul {R : Type u_1} [SciLean.RealScalar R] {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] [Module R X] (r : R) (x : SciLean.Rand X) : r • SciLean.Rand.mean x =\n  SciLean.Rand.mean do\n    let x' ← x\n    pure (r • x')"}
{"name":"SciLean.Rand.pull_E_lambda","declaration":"theorem SciLean.Rand.pull_E_lambda {X : Type u_1} {Y : Type} [MeasurableSpace Y] {Z : Type u_2} [AddCommGroup Z] [Module ℝ Z] (r : SciLean.Rand Y) (f : X → Y → Z) : (fun x => r.𝔼 fun y => f x y) = r.𝔼 fun y x => f x y"}
{"name":"SciLean.Rand.pull_E_list_recOn","declaration":"theorem SciLean.Rand.pull_E_list_recOn {α : Type u_1} {C : List α → Type} [(n : List α) → AddCommGroup (C n)] [(n : List α) → Module ℝ (C n)] [(n : List α) → MeasurableSpace (C n)] {D : List α → Type} [(n : List α) → MeasurableSpace (D n)] (l : List α) (x₀ : C []) (r : (head : α) → (tail : List α) → SciLean.Rand (D (head :: tail))) (f : (head : α) → (tail : List α) → C tail → D (head :: tail) → C (head :: tail)) (hf : ∀ (head : α) (tail : List α) (d : D (head :: tail)), IsAffineMap ℝ fun x => f head tail x d) : (List.recOn l x₀ fun head tail x => (r head tail).𝔼 (f head tail x)) =\n  SciLean.Rand.mean\n    (List.recOn l (pure x₀) fun head tail x => do\n      let x' ← x\n      let y' ← r head tail\n      pure (f head tail x' y'))"}
{"name":"SciLean.Rand.ite_pull_mean_f","declaration":"theorem SciLean.Rand.ite_pull_mean_f {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] {c : Prop} [Decidable c] (t : X) (e : SciLean.Rand X) : (if c then t else SciLean.Rand.mean e) = SciLean.Rand.mean (if c then pure t else e)"}
{"name":"SciLean.Rand.push_E_affine","declaration":"theorem SciLean.Rand.push_E_affine {X : Type} [MeasurableSpace X] {Y : Type u_1} [AddCommGroup Y] [Module ℝ Y] {Z : Type u_2} [AddCommGroup Z] [Module ℝ Z] (r : SciLean.Rand X) (φ : X → Y) (f : Y → Z) (hf : autoParam (IsAffineMap ℝ f) _auto✝) : (r.𝔼 fun x => f (φ x)) = f (r.𝔼 φ)"}
{"name":"SciLean.Rand.pull_mean_add","declaration":"theorem SciLean.Rand.pull_mean_add {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (x : SciLean.Rand X) (y : SciLean.Rand X) : SciLean.Rand.mean x + SciLean.Rand.mean y =\n  SciLean.Rand.mean do\n    let x' ← x\n    let y' ← y\n    pure (x' + y')"}
{"name":"SciLean.Rand.pull_mean_sub","declaration":"theorem SciLean.Rand.pull_mean_sub {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (x : SciLean.Rand X) (y : SciLean.Rand X) : SciLean.Rand.mean x - SciLean.Rand.mean y =\n  SciLean.Rand.mean do\n    let x' ← x\n    let y' ← y\n    pure (x' - y')"}
{"name":"SciLean.Rand.pull_mean_mul","declaration":"theorem SciLean.Rand.pull_mean_mul {R : Type} [SciLean.RealScalar R] (r : R) (x : SciLean.Rand R) : r * SciLean.Rand.mean x =\n  SciLean.Rand.mean do\n    let x' ← x\n    pure (r * x')"}
{"name":"SciLean.Rand.pull_mean_add_1","declaration":"theorem SciLean.Rand.pull_mean_add_1 {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (x : SciLean.Rand X) (y : X) : SciLean.Rand.mean x + y =\n  SciLean.Rand.mean do\n    let x' ← x\n    pure (x' + y)"}
{"name":"SciLean.Rand.ite_push_mean","declaration":"theorem SciLean.Rand.ite_push_mean {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) : SciLean.Rand.mean (if c then t else e) = if c then SciLean.Rand.mean t else SciLean.Rand.mean e"}
{"name":"SciLean.Rand.ite_pull_E","declaration":"theorem SciLean.Rand.ite_pull_E {X : Type} [MeasurableSpace X] {Y : Type u_1} [AddCommGroup Y] [Module ℝ Y] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) (φ : X → Y) (ψ : X → Y) : (if c then t.𝔼 φ else e.𝔼 ψ) = (if c then t else e).𝔼 (if c then φ else ψ)"}
{"name":"SciLean.Rand.pull_E_nat_recOn","declaration":"theorem SciLean.Rand.pull_E_nat_recOn (C : ℕ → Type) [(n : ℕ) → AddCommGroup (C n)] [(n : ℕ) → Module ℝ (C n)] [(n : ℕ) → MeasurableSpace (C n)] (D : ℕ → Type) [(n : ℕ) → MeasurableSpace (D n)] {n : ℕ} (x₀ : C 0) (r : (n : ℕ) → SciLean.Rand (D n)) (f : (n : ℕ) → C n → D n → C (n + 1)) (hf : ∀ (n : ℕ) (d : D n), IsAffineMap ℝ fun x => f n x d) : (Nat.recOn n x₀ fun n x => (r n).𝔼 (f n x)) =\n  SciLean.Rand.mean\n    (Nat.recOn n (pure x₀) fun n x => do\n      let x' ← x\n      let y' ← r n\n      pure (f n x' y'))"}
{"name":"SciLean.Rand.ite_push_E","declaration":"theorem SciLean.Rand.ite_push_E {X : Type} [MeasurableSpace X] {Y : Type u_1} [AddCommGroup Y] [Module ℝ Y] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : SciLean.Rand X) (φ : X → Y) : (if c then t else e).𝔼 φ = if c then t.𝔼 φ else e.𝔼 φ"}
{"name":"SciLean.Rand.pull_mean_neg","declaration":"theorem SciLean.Rand.pull_mean_neg {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] (x : SciLean.Rand X) : -SciLean.Rand.mean x =\n  SciLean.Rand.mean do\n    let x' ← x\n    pure (-x')"}
{"name":"SciLean.Rand.ite_pull_mean_t","declaration":"theorem SciLean.Rand.ite_pull_mean_t {X : Type} [MeasurableSpace X] [AddCommGroup X] [Module ℝ X] {c : Prop} [Decidable c] (t : SciLean.Rand X) (e : X) : (if c then SciLean.Rand.mean t else e) = SciLean.Rand.mean (if c then t else pure e)"}
{"name":"SciLean.Rand.pull_mean_div","declaration":"theorem SciLean.Rand.pull_mean_div {R : Type} [SciLean.RealScalar R] (x : SciLean.Rand R) (y : R) : SciLean.Rand.mean x / y =\n  SciLean.Rand.mean do\n    let x' ← x\n    pure (x' / y)"}
