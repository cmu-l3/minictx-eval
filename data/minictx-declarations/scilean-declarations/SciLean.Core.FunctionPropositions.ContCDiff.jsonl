{"name":"SciLean.Prod.fst.arg_self.ContCDiffAt_rule","declaration":"theorem SciLean.Prod.fst.arg_self.ContCDiffAt_rule (n : ℕ∞) (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (x : X) (f : X → Y × Z) (hf : SciLean.ContCDiffAt K n f x) : SciLean.ContCDiffAt K n (fun x => (f x).1) x"}
{"name":"SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat","declaration":"theorem SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : ℕ) (f : X → Y) (x : X) (hf : SciLean.ContCDiffAt K n f x) : SciLean.ContCDiffAt K n (fun x => c • f x) x"}
{"name":"SciLean.HMul.hMul.arg_a0a1.ContCDiffAt_rule","declaration":"def SciLean.HMul.hMul.arg_a0a1.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (x : X) (f : X → K) (g : X → K) (hf : SciLean.ContCDiffAt K n f x) (hg : SciLean.ContCDiffAt K n g x) : SciLean.ContCDiffAt K n (fun x => f x * g x) x"}
{"name":"SciLean.HDiv.hDiv.arg_a0.ContCDiff_rule","declaration":"def SciLean.HDiv.hDiv.arg_a0.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (r : K) (hf : SciLean.ContCDiff K n f) (hr : r ≠ 0) : SciLean.ContCDiff K n fun x => f x / r"}
{"name":"SciLean.BasisDuality.toDual.arg_x.ContCDiffAt_rule","declaration":"theorem SciLean.BasisDuality.toDual.arg_x.ContCDiffAt_rule (n : ℕ∞) {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (x : X) : SciLean.ContCDiffAt K n (fun x => SciLean.BasisDuality.toDual x) x"}
{"name":"SciLean.HPow.hPow.arg_a0.ContCDiffAt_rule","declaration":"def SciLean.HPow.hPow.arg_a0.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (m : ℕ) (x : X) (f : X → K) (hf : SciLean.ContCDiffAt K n f x) : SciLean.ContCDiffAt K n (fun x => f x ^ m) x"}
{"name":"SciLean.ContCDiffAt.apply_rule","declaration":"theorem SciLean.ContCDiffAt.apply_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {ι : Type u_2} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (i : ι) (x : (i : ι) → E i) : SciLean.ContCDiffAt K n (fun x => x i) x"}
{"name":"SciLean.CDifferentaible.ContCDiff_rule","declaration":"theorem SciLean.CDifferentaible.ContCDiff_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (hf : SciLean.ContCDiff K n f) (h : 0 < n) : SciLean.CDifferentiable K f"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.ContCDiff_rule","declaration":"def SciLean.HSMul.hSMul.arg_a0a1.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → K) (g : X → Y) (hf : SciLean.ContCDiff K n f) (hg : SciLean.ContCDiff K n g) : SciLean.ContCDiff K n fun x => f x • g x"}
{"name":"SciLean.HSub.hSub.arg_a0a1.ContCDiff_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (g : X → Y) (hf : SciLean.ContCDiff K n f) (hg : SciLean.ContCDiff K n g) : SciLean.ContCDiff K n fun x => f x - g x"}
{"name":"SciLean.HSub.hSub.arg_a0a1.ContCDiffAt_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.ContCDiffAt K n f x) (hg : SciLean.ContCDiffAt K n g x) : SciLean.ContCDiffAt K n (fun x => f x - g x) x"}
{"name":"SciLean.BasisDuality.fromDual.arg_x.ContCDiff_rule","declaration":"theorem SciLean.BasisDuality.fromDual.arg_x.ContCDiff_rule (n : ℕ∞) {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] : SciLean.ContCDiff K n fun x => SciLean.BasisDuality.fromDual x"}
{"name":"SciLean.CDifferentaibleAt.ContCDiffAt_rule","declaration":"theorem SciLean.CDifferentaibleAt.ContCDiffAt_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (hf : SciLean.ContCDiffAt K n f x) (h : 0 < n) : SciLean.CDifferentiableAt K f x"}
{"name":"SciLean.ContCDiff.comp_rule","declaration":"theorem SciLean.ContCDiff.comp_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (f : Y → Z) (g : X → Y) (hf : SciLean.ContCDiff K n f) (hg : SciLean.ContCDiff K n g) : SciLean.ContCDiff K n fun x => f (g x)"}
{"name":"SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_int","declaration":"theorem SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_int (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : ℤ) (f : X → Y) (x : X) (hf : SciLean.ContCDiffAt K n f x) : SciLean.ContCDiffAt K n (fun x => c • f x) x"}
{"name":"SciLean.Prod.snd.arg_self.ContCDiff_rule","declaration":"theorem SciLean.Prod.snd.arg_self.ContCDiff_rule (n : ℕ∞) (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (f : X → Y × Z) (hf : SciLean.ContCDiff K n f) : SciLean.ContCDiff K n fun x => (f x).2"}
{"name":"SciLean.ContCDiffAt.pi_rule","declaration":"theorem SciLean.ContCDiffAt.pi_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {ι : Type u_4} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (x : X) (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.ContCDiffAt K n (fun x => f x i) x) : SciLean.ContCDiffAt K n (fun x i => f x i) x"}
{"name":"SciLean.CDifferentaible.ContCDiff_rule'","declaration":"theorem SciLean.CDifferentaible.ContCDiff_rule' (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (hf : SciLean.ContCDiff K ⊤ f) : SciLean.CDifferentiable K f"}
{"name":"SciLean.Prod.mk.arg_fstsnd.ContCDiff_rule","declaration":"theorem SciLean.Prod.mk.arg_fstsnd.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (g : X → Y) (hg : SciLean.ContCDiff K n g) (f : X → Z) (hf : SciLean.ContCDiff K n f) : SciLean.ContCDiff K n fun x => (g x, f x)"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.ContCDiffAt_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.ContCDiffAt K n f x) (hg : SciLean.ContCDiffAt K n g x) : SciLean.ContCDiffAt K n (fun x => f x + g x) x"}
{"name":"SciLean.HSMul.hSMul.arg_a1.ContCDiff_rule_n","declaration":"theorem SciLean.HSMul.hSMul.arg_a1.ContCDiff_rule_n (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : ℕ) (f : X → Y) (hf : SciLean.ContCDiff K n f) : SciLean.ContCDiff K n fun x => c • f x"}
{"name":"SciLean.Norm2.norm2.arg_a0.ContCDiff_rule","declaration":"theorem SciLean.Norm2.norm2.arg_a0.ContCDiff_rule (n : ℕ∞) {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (hf : SciLean.ContCDiff R n f) : SciLean.ContCDiff R n fun x => ‖f x‖₂²"}
{"name":"SciLean.Inner.inner.arg_a0a1.ContCDiff_rule","declaration":"theorem SciLean.Inner.inner.arg_a0a1.ContCDiff_rule (n : ℕ∞) {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (g : X → Y) (hf : SciLean.ContCDiff R n f) (hg : SciLean.ContCDiff R n g) : SciLean.ContCDiff R n fun x => ⟪f x, g x⟫_R"}
{"name":"SciLean.ContCDiffAt.const_rule","declaration":"theorem SciLean.ContCDiffAt.const_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (y : Y) (x : X) : SciLean.ContCDiffAt K n (fun x => y) x"}
{"name":"SciLean.HMul.hMul.arg_a0a1.ContCDiff_rule","declaration":"def SciLean.HMul.hMul.arg_a0a1.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (g : X → K) (hf : SciLean.ContCDiff K n f) (hg : SciLean.ContCDiff K n g) : SciLean.ContCDiff K n fun x => f x * g x"}
{"name":"SciLean.Neg.neg.arg_a0.ContCDiffAt_rule","declaration":"theorem SciLean.Neg.neg.arg_a0.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (hf : SciLean.ContCDiffAt K n f x) : SciLean.ContCDiffAt K n (fun x => -f x) x"}
{"name":"SciLean.DualBasis.dualProj.arg_x.ContCDiff_rule","declaration":"theorem SciLean.DualBasis.dualProj.arg_x.ContCDiff_rule (n : ℕ∞) {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) : SciLean.ContCDiff K n fun x => ℼ' i x"}
{"name":"SciLean.Neg.neg.arg_a0.ContCDiff_rule","declaration":"theorem SciLean.Neg.neg.arg_a0.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (hf : SciLean.ContCDiff K n f) : SciLean.ContCDiff K n fun x => -f x"}
{"name":"SciLean.IndexType.sum.arg_f.ContCDiffAt_rule","declaration":"theorem SciLean.IndexType.sum.arg_f.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {ι : Type u_4} [SciLean.IndexType ι] (f : X → ι → Y) (x : X) (hf : ∀ (i : ι), SciLean.ContCDiffAt K n (fun x => f x i) x) : SciLean.ContCDiffAt K n (fun x =>  ∑ i, f x i) x"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.ContCDiff_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (g : X → Y) (hf : SciLean.ContCDiff K n f) (hg : SciLean.ContCDiff K n g) : SciLean.ContCDiff K n fun x => f x + g x"}
{"name":"SciLean.HSMul.hSMul.arg_a1.ContCDiff_rule_int","declaration":"theorem SciLean.HSMul.hSMul.arg_a1.ContCDiff_rule_int (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (c : ℤ) (f : X → Y) (hf : SciLean.ContCDiff K n f) : SciLean.ContCDiff K n fun x => c • f x"}
{"name":"SciLean.ContCDiff.ContCDiffAt_rule","declaration":"theorem SciLean.ContCDiff.ContCDiffAt_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (hf : SciLean.ContCDiff K n f) : SciLean.ContCDiffAt K n f x"}
{"name":"SciLean.ContCDiff.const_rule","declaration":"theorem SciLean.ContCDiff.const_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (y : Y) : SciLean.ContCDiff K n fun x => y"}
{"name":"SciLean.Basis.proj.arg_x.ContCDiffAt_rule","declaration":"theorem SciLean.Basis.proj.arg_x.ContCDiffAt_rule (n : ℕ∞) {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) (x : X) : SciLean.ContCDiffAt K n (fun x => ℼ i x) x"}
{"name":"SciLean.ContCDiff.id_rule","declaration":"theorem SciLean.ContCDiff.id_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] : SciLean.ContCDiff K n fun x => x"}
{"name":"SciLean.norm₂.arg_x.ContCDiffAt_rule","declaration":"theorem SciLean.norm₂.arg_x.ContCDiffAt_rule (n : ℕ∞) {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (x : X) (hf : SciLean.ContCDiffAt R n f x) (hx : f x ≠ 0) : SciLean.ContCDiffAt R n (fun x => ‖f x‖₂[R]) x"}
{"name":"SciLean.Prod.mk.arg_fstsnd.ContCDiffAt_rule","declaration":"theorem SciLean.Prod.mk.arg_fstsnd.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (x : X) (g : X → Y) (hg : SciLean.ContCDiffAt K n g x) (f : X → Z) (hf : SciLean.ContCDiffAt K n f x) : SciLean.ContCDiffAt K n (fun x => (g x, f x)) x"}
{"name":"SciLean.ContCDiff.le_rule","declaration":"theorem SciLean.ContCDiff.le_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {m : ℕ∞} (f : X → Y) (hf : SciLean.ContCDiff K m f) (h : n ≤ m) : SciLean.ContCDiff K n f"}
{"name":"SciLean.HPow.hPow.arg_a0.ContCDiff_rule","declaration":"def SciLean.HPow.hPow.arg_a0.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (m : ℕ) (f : X → K) (hf : SciLean.ContCDiff K n f) : SciLean.ContCDiff K n fun x => f x ^ m"}
{"name":"SciLean.Inner.inner.arg_a0a1.ContCDiffAt_rule","declaration":"theorem SciLean.Inner.inner.arg_a0a1.ContCDiffAt_rule (n : ℕ∞) {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (g : X → Y) (x : X) (hf : SciLean.ContCDiffAt R n f x) (hg : SciLean.ContCDiffAt R n g x) : SciLean.ContCDiffAt R n (fun x => ⟪f x, g x⟫_R) x"}
{"name":"SciLean.HDiv.hDiv.arg_a0a1.ContCDiffAt_rule","declaration":"def SciLean.HDiv.hDiv.arg_a0a1.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (x : X) (f : X → K) (g : X → K) (hf : SciLean.ContCDiffAt K n f x) (hg : SciLean.ContCDiffAt K n g x) (hx : g x ≠ 0) : SciLean.ContCDiffAt K n (fun x => f x / g x) x"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.ContCDiffAt_rule","declaration":"def SciLean.HSMul.hSMul.arg_a0a1.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → K) (g : X → Y) (hf : SciLean.ContCDiffAt K n f x) (hg : SciLean.ContCDiffAt K n g x) : SciLean.ContCDiffAt K n (fun x => f x • g x) x"}
{"name":"SciLean.Prod.fst.arg_self.ContCDiff_rule","declaration":"theorem SciLean.Prod.fst.arg_self.ContCDiff_rule (n : ℕ∞) (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (f : X → Y × Z) (hf : SciLean.ContCDiff K n f) : SciLean.ContCDiff K n fun x => (f x).1"}
{"name":"SciLean.ContCDiff.pi_rule","declaration":"theorem SciLean.ContCDiff.pi_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {ι : Type u_4} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (x : X) (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.ContCDiff K n fun x => f x i) : SciLean.ContCDiff K n fun x i => f x i"}
{"name":"SciLean.norm₂.arg_x.ContCDiff_rule","declaration":"theorem SciLean.norm₂.arg_x.ContCDiff_rule (n : ℕ∞) {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (hf : SciLean.ContCDiff R n f) (hx : ∀ (x : X), f x ≠ 0) : SciLean.ContCDiff R n fun x => ‖f x‖₂[R]"}
{"name":"SciLean.Prod.snd.arg_self.ContCDiffAt_rule","declaration":"theorem SciLean.Prod.snd.arg_self.ContCDiffAt_rule (n : ℕ∞) (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_2} [SciLean.Vec K Z] (x : X) (f : X → Y × Z) (hf : SciLean.ContCDiffAt K n f x) : SciLean.ContCDiffAt K n (fun x => (f x).2) x"}
{"name":"SciLean.ContCDiffAt.id_rule","declaration":"theorem SciLean.ContCDiffAt.id_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] (x : X) : SciLean.ContCDiffAt K n (fun x => x) x"}
{"name":"SciLean.ContCDiffAt.le_rule","declaration":"theorem SciLean.ContCDiffAt.le_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {m : ℕ∞} (x : X) (f : X → Y) (hf : SciLean.ContCDiffAt K m f x) (h : n ≤ m) : SciLean.ContCDiffAt K n f x"}
{"name":"SciLean.Basis.proj.arg_x.ContCDiff_rule","declaration":"theorem SciLean.Basis.proj.arg_x.ContCDiff_rule (n : ℕ∞) {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) : SciLean.ContCDiff K n fun x => ℼ i x"}
{"name":"SciLean.ContCDiffAt.comp_rule","declaration":"theorem SciLean.ContCDiffAt.comp_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_4} [SciLean.Vec K X] {Y : Type u_2} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] (x : X) (f : Y → Z) (g : X → Y) (hf : SciLean.ContCDiffAt K n f (g x)) (hg : SciLean.ContCDiffAt K n g x) : SciLean.ContCDiffAt K n (fun x => f (g x)) x"}
{"name":"SciLean.ContCDiff","declaration":"/-- `ContCDiff f` - conveniently differentiable function `f`.  -/\ndef SciLean.ContCDiff (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) : Prop"}
{"name":"SciLean.DualBasis.dualProj.arg_x.ContCDiffAt_rule","declaration":"theorem SciLean.DualBasis.dualProj.arg_x.ContCDiffAt_rule (n : ℕ∞) {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) (x : X) : SciLean.ContCDiffAt K n (fun x => ℼ' i x) x"}
{"name":"SciLean.Norm2.norm2.arg_a0.ContCDiffAt_rule","declaration":"theorem SciLean.Norm2.norm2.arg_a0.ContCDiffAt_rule (n : ℕ∞) {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (x : X) (hf : SciLean.ContCDiffAt R n f x) : SciLean.ContCDiffAt R n (fun x => ‖f x‖₂²) x"}
{"name":"SciLean.ContCDiffAt","declaration":"/-- `CDifferentiableAt f x` - conveniently differentiable function `f` at point `x`. -/\ndef SciLean.ContCDiffAt (K : Type u_1) [RCLike K] (n : ℕ∞) {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (x : X) : Prop"}
{"name":"SciLean.IndexType.sum.arg_f.ContCDiff_rule","declaration":"theorem SciLean.IndexType.sum.arg_f.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {ι : Type u_4} [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.ContCDiff K n fun x => f x i) : SciLean.ContCDiff K n fun x =>  ∑ i, f x i"}
{"name":"SciLean.CDifferentaibleAt.ContCDiffAt_rule'","declaration":"theorem SciLean.CDifferentaibleAt.ContCDiffAt_rule' (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (hf : SciLean.ContCDiffAt K ⊤ f x) : SciLean.CDifferentiableAt K f x"}
{"name":"SciLean.BasisDuality.toDual.arg_x.ContCDiff_rule","declaration":"theorem SciLean.BasisDuality.toDual.arg_x.ContCDiff_rule (n : ℕ∞) {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] : SciLean.ContCDiff K n fun x => SciLean.BasisDuality.toDual x"}
{"name":"SciLean.HDiv.hDiv.arg_a0.ContCDiffAt_rule","declaration":"def SciLean.HDiv.hDiv.arg_a0.ContCDiffAt_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (x : X) (f : X → K) (r : K) (hf : SciLean.ContCDiffAt K n f x) (hr : r ≠ 0) : SciLean.ContCDiffAt K n (fun x => f x / r) x"}
{"name":"SciLean.BasisDuality.fromDual.arg_x.ContCDiffAt_rule","declaration":"theorem SciLean.BasisDuality.fromDual.arg_x.ContCDiffAt_rule (n : ℕ∞) {K : Type u_1} [RCLike K] {IX : Type} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (x : X) : SciLean.ContCDiffAt K n (fun x => SciLean.BasisDuality.fromDual x) x"}
{"name":"SciLean.ContCDiff.apply_rule","declaration":"theorem SciLean.ContCDiff.apply_rule (K : Type u_1) [RCLike K] (n : ℕ∞) {ι : Type u_2} {E : ι → Type u_3} [(i : ι) → SciLean.Vec K (E i)] (i : ι) : SciLean.ContCDiff K n fun x => x i"}
{"name":"SciLean.HDiv.hDiv.arg_a0a1.ContCDiff_rule","declaration":"def SciLean.HDiv.hDiv.arg_a0a1.ContCDiff_rule (n : ℕ∞) (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] (f : X → K) (g : X → K) (hf : SciLean.ContCDiff K n f) (hg : SciLean.ContCDiff K n g) (hx : ∀ (x : X), g x ≠ 0) : SciLean.ContCDiff K n fun x => f x / g x"}
