{"name":"SciLean.DualBasis.dualProj.arg_x.IsLinearMap_rule","declaration":"theorem SciLean.DualBasis.dualProj.arg_x.IsLinearMap_rule {K : Type u_1} [RCLike K] {IX : Type u_3} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) : IsLinearMap K fun x => ℼ' i x"}
{"name":"IsLinearMap.isLinearMap_const_zero","declaration":"theorem IsLinearMap.isLinearMap_const_zero {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] : IsLinearMap R fun x => 0"}
{"name":"IsLinearMap.LinearMap_coe.apply_right","declaration":"theorem IsLinearMap.LinearMap_coe.apply_right {R : Type u_3} {X : Type u_4} {Y : Type u_2} {Z : Type u_1} [CommSemiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : X → Y →ₗ[R] Z) (y : Y) (hf : IsLinearMap R f) : IsLinearMap R fun x => (f x) y"}
{"name":"Prod.mk.arg_fstsnd.IsLinearMap_rule","declaration":"theorem Prod.mk.arg_fstsnd.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_4} {Z : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : X → Z) (g : X → Y) (hf : IsLinearMap R f) (hg : IsLinearMap R g) : IsLinearMap R fun x => (g x, f x)"}
{"name":"HAdd.hAdd.arg_a0a1.IsLinearMap_rule","declaration":"theorem HAdd.hAdd.arg_a0a1.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → Y) (g : X → Y) (hf : IsLinearMap R f) (hg : IsLinearMap R g) : IsLinearMap R fun x => f x + g x"}
{"name":"Inner.inner.arg_a0.IsLinearMap_rule","declaration":"theorem Inner.inner.arg_a0.IsLinearMap_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.SemiHilbert R X] (y : X) : IsLinearMap R fun x => ⟪x, y⟫_R"}
{"name":"IndexType.sum.arg_f.IsLinearMap_rule","declaration":"theorem IndexType.sum.arg_f.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} {ι : Type u_4} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), IsLinearMap R fun x => f x i) : IsLinearMap R fun x =>  ∑ i, f x i"}
{"name":"IsLinearMap.isLinearMap_apply","declaration":"theorem IsLinearMap.isLinearMap_apply {R : Type u_1} {ι : Type u_2} {E : ι → Type u_3} [Semiring R] [(i : ι) → AddCommMonoid (E i)] [(i : ι) → Module R (E i)] (i : ι) : IsLinearMap R fun f => f i"}
{"name":"dite.arg_te.IsLinearMap_rule","declaration":"theorem dite.arg_te.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (ht : ∀ (p : c), IsLinearMap R (t p)) (e : ¬c → X → Y) (he : ∀ (p : ¬c), IsLinearMap R (e p)) : IsLinearMap R fun x => if x_1 : c then t x_1 x else e x_1 x"}
{"name":"SciLean.BasisDuality.toDual.arg_x.IsLinearMap_rule","declaration":"theorem SciLean.BasisDuality.toDual.arg_x.IsLinearMap_rule {K : Type u_1} [RCLike K] {IX : Type u_3} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] : IsLinearMap K fun x => SciLean.BasisDuality.toDual x"}
{"name":"HSMul.hSMul.arg_a1.IsLinearMap_rule","declaration":"theorem HSMul.hSMul.arg_a1.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [CommSemiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : R) (f : X → Y) (hf : IsLinearMap R f) : IsLinearMap R fun x => c • f x"}
{"name":"HSMul.hSMul.arg_a1.IsLinearMap_rule_nat","declaration":"theorem HSMul.hSMul.arg_a1.IsLinearMap_rule_nat {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : ℕ) (f : X → Y) (hf : IsLinearMap R f) : IsLinearMap R fun x => c • f x"}
{"name":"HMul.hMul.arg_a1.IsLinearMap_rule","declaration":"theorem HMul.hMul.arg_a1.IsLinearMap_rule {R : Type u_1} {X : Type u_2} [CommSemiring R] [AddCommGroup X] [Module R X] (f : X → R) (hf : IsLinearMap R f) (y' : R) : IsLinearMap R fun x => y' * f x"}
{"name":"HSMul.hSMul.arg_a0.IsLinearMap_rule","declaration":"theorem HSMul.hSMul.arg_a0.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → R) (y : Y) (hf : IsLinearMap R f) : IsLinearMap R fun x => f x • y"}
{"name":"ite.arg_te.IsLinearMap_rule","declaration":"theorem ite.arg_te.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) (ht : IsLinearMap R t) (he : IsLinearMap R e) : IsLinearMap R fun x => if c then t x else e x"}
{"name":"Prod.fst.arg_self.IsLinearMap_rule","declaration":"theorem Prod.fst.arg_self.IsLinearMap_rule {R : Type u_3} {X : Type u_4} {Y : Type u_1} {Z : Type u_2} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : X → Y × Z) (hf : IsLinearMap R f) : IsLinearMap R fun x => (f x).1"}
{"name":"Prod.snd.arg_self.IsLinearMap_rule","declaration":"theorem Prod.snd.arg_self.IsLinearMap_rule {R : Type u_3} {X : Type u_4} {Y : Type u_1} {Z : Type u_2} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : X → Y × Z) (hf : IsLinearMap R f) : IsLinearMap R fun x => (f x).2"}
{"name":"SciLean.Basis.proj.arg_x.IsLinearMap_rule","declaration":"theorem SciLean.Basis.proj.arg_x.IsLinearMap_rule {K : Type u_1} [RCLike K] {IX : Type u_3} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] (i : IX) : IsLinearMap K fun x => ℼ i x"}
{"name":"Prod.snd.arg_self.IsLinearMap_rule_simple","declaration":"theorem Prod.snd.arg_self.IsLinearMap_rule_simple {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] : IsLinearMap R fun xy => xy.2"}
{"name":"IsLinearMap.isLinearMap_id","declaration":"theorem IsLinearMap.isLinearMap_id {R : Type u_1} {X : Type u_2} [Semiring R] [AddCommGroup X] [Module R X] : IsLinearMap R fun x => x"}
{"name":"HMul.hMul.arg_a0.IsLinearMap_rule","declaration":"theorem HMul.hMul.arg_a0.IsLinearMap_rule {R : Type u_1} {X : Type u_2} [CommSemiring R] [AddCommGroup X] [Module R X] (f : X → R) (hf : IsLinearMap R f) (y' : R) : IsLinearMap R fun x => f x * y'"}
{"name":"IsLinearMap.LinearMap_coe.apply_left","declaration":"theorem IsLinearMap.LinearMap_coe.apply_left {R : Type u_3} {X : Type u_4} {Y : Type u_2} {Z : Type u_1} [CommSemiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : Y →ₗ[R] Z) (g : X → Y) (hg : IsLinearMap R g) : IsLinearMap R fun x => f (g x)"}
{"name":"Inner.inner.arg_a1.IsLinearMap_rule","declaration":"theorem Inner.inner.arg_a1.IsLinearMap_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.SemiHilbert R X] (y : X) : IsLinearMap R fun x => ⟪y, x⟫_R"}
{"name":"IsLinearMap.isLinearMap_pi","declaration":"theorem IsLinearMap.isLinearMap_pi {R : Type u_1} {X : Type u_2} {ι : Type u_4} {E : ι → Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [(i : ι) → AddCommMonoid (E i)] [(i : ι) → Module R (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), IsLinearMap R fun x => f x i) : IsLinearMap R fun x i => f x i"}
{"name":"by_linear_map","declaration":"theorem by_linear_map {R : Type u_3} {X : Type u_2} {Y : Type u_1} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] {f : X → Y} (g : X →ₗ[R] Y) (h : ∀ (x : X), f x = g x) : IsLinearMap R f"}
{"name":"IsLinearMap.mk'.arg_f.IsLinearMap_rule","declaration":"theorem IsLinearMap.mk'.arg_f.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_4} {Z : Type u_3} [CommSemiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] (f : X → Y → Z) (hf₁ : ∀ (y : Y), IsLinearMap R fun x => f x y) (hf₂ : ∀ (x : X), IsLinearMap R fun x_1 => f x x_1) : IsLinearMap R fun x => IsLinearMap.mk' (f x) ⋯"}
{"name":"Prod.fst.arg_self.IsLinearMap_rule_simple","declaration":"theorem Prod.fst.arg_self.IsLinearMap_rule_simple {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] : IsLinearMap R fun xy => xy.1"}
{"name":"Prod.mk.arg_fstsnd.IsLinearMap_rule_simple","declaration":"theorem Prod.mk.arg_fstsnd.IsLinearMap_rule_simple {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] : IsLinearMap R fun xy => (xy.1, xy.2)"}
{"name":"IsLinearMap.isLinearMap_comp","declaration":"theorem IsLinearMap.isLinearMap_comp {R : Type u_1} {X : Type u_4} {Y : Type u_2} {Z : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z] {f : Y → Z} {g : X → Y} (hf : IsLinearMap R f) (hg : IsLinearMap R g) : IsLinearMap R fun x => f (g x)"}
{"name":"HSub.hSub.arg_a0a1.IsLinearMap_rule","declaration":"theorem HSub.hSub.arg_a0a1.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → Y) (g : X → Y) (hf : IsLinearMap R f) (hg : IsLinearMap R g) : IsLinearMap R fun x => f x - g x"}
{"name":"HSMul.hSMul.arg_a1.IsLinearMap_rule_int","declaration":"theorem HSMul.hSMul.arg_a1.IsLinearMap_rule_int {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (c : ℤ) (f : X → Y) (hf : IsLinearMap R f) : IsLinearMap R fun x => c • f x"}
{"name":"SciLean.BasisDuality.fromDual.arg_x.IsLinearMap_rule","declaration":"theorem SciLean.BasisDuality.fromDual.arg_x.IsLinearMap_rule {K : Type u_1} [RCLike K] {IX : Type u_3} [SciLean.IndexType IX] [SciLean.LawfulIndexType IX] [DecidableEq IX] {X : Type u_2} [SciLean.FinVec IX K X] : IsLinearMap K fun x => SciLean.BasisDuality.fromDual x"}
{"name":"Neg.neg.arg_a0.IsLinearMap_rule","declaration":"theorem Neg.neg.arg_a0.IsLinearMap_rule {R : Type u_1} {X : Type u_2} {Y : Type u_3} [Semiring R] [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] (f : X → Y) (hf : IsLinearMap R f) : IsLinearMap R fun x => -f x"}
