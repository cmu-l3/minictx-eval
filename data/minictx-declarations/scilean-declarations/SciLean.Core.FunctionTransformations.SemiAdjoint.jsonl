{"name":"SciLean.semiAdjoint.HMul.hMul.arg_a1.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.HMul.hMul.arg_a1.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (c : K) (f : X → K) (hf : SciLean.HasSemiAdjoint K f) : (SciLean.semiAdjoint K fun x => c * f x) = fun y => (starRingEnd K) c • SciLean.semiAdjoint K (fun x => f x) y"}
{"name":"SciLean.semiAdjoint.SciLean.semiAdjoint.arg_y.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.SciLean.semiAdjoint.arg_y.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {W : Type u_4} [SciLean.SemiInnerProductSpace K W] (f : X → Y) (a3 : W → Y) (hf : SciLean.HasSemiAdjoint K f) (ha3 : SciLean.HasSemiAdjoint K a3) : (SciLean.semiAdjoint K fun w => SciLean.semiAdjoint K f (a3 w)) = fun x =>\n  let y := f x;\n  SciLean.semiAdjoint K a3 y"}
{"name":"SciLean.semiAdjoint.HSMul.hSMul.arg_a0.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.HSMul.hSMul.arg_a0.semiAdjoint_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiHilbert K Y] (y' : Y) (f : X → K) (hf : SciLean.HasSemiAdjoint K f) : (SciLean.semiAdjoint K fun x => f x • y') = fun y => SciLean.semiAdjoint K (fun x => f x) ⟪y', y⟫_K"}
{"name":"SciLean.semiAdjoint.Neg.neg.arg_a0.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.Neg.neg.arg_a0.semiAdjoint_rule (K : Type u_3) [RCLike K] {X : Type u_1} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) : (SciLean.semiAdjoint K fun x => -f x) = fun y => -SciLean.semiAdjoint K f y"}
{"name":"SciLean.semiAdjoint.let_rule","declaration":"theorem SciLean.semiAdjoint.let_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_4} [SciLean.SemiInnerProductSpace K Z] (f : X → Y → Z) (g : X → Y) (hf : SciLean.HasSemiAdjoint K ↿f) (hg : SciLean.HasSemiAdjoint K g) : (SciLean.semiAdjoint K fun x =>\n    let y := g x;\n    f x y) =\n  fun z =>\n  let xy := SciLean.semiAdjoint K (fun xy => f xy.1 xy.2) z;\n  let x' := SciLean.semiAdjoint K g xy.2;\n  xy.1 + x'"}
{"name":"SciLean.semiAdjoint.ite.arg_te.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.ite.arg_te.semiAdjoint_rule (K : Type u_3) [RCLike K] {X : Type u_1} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) : (SciLean.semiAdjoint K fun x => if c then t x else e x) = fun y =>\n  if c then SciLean.semiAdjoint K t y else SciLean.semiAdjoint K e y"}
{"name":"SciLean.semiAdjoint.apply_rule","declaration":"theorem SciLean.semiAdjoint.apply_rule (K : Type u_3) [RCLike K] {ι : Type u_1} [SciLean.IndexType ι] {E : ι → Type u_2} [(i : ι) → SciLean.SemiInnerProductSpace K (E i)] [DecidableEq ι] (i : ι) : (SciLean.semiAdjoint K fun f => f i) = fun y j => if h : i = j then h ▸ y else 0"}
{"name":"SciLean.semiAdjoint.starRingEnd.arg_a0.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.starRingEnd.arg_a0.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (f : X → K) : (SciLean.semiAdjoint K fun x => (starRingEnd K) (f x)) = fun z => SciLean.semiAdjoint K f z"}
{"name":"SciLean.semiAdjoint.comp_rule","declaration":"theorem SciLean.semiAdjoint.comp_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_3} [SciLean.SemiInnerProductSpace K Z] (f : Y → Z) (g : X → Y) (hf : SciLean.HasSemiAdjoint K f) (hg : SciLean.HasSemiAdjoint K g) : (SciLean.semiAdjoint K fun x => f (g x)) = fun z =>\n  let y := SciLean.semiAdjoint K f z;\n  let x := SciLean.semiAdjoint K g y;\n  x"}
{"name":"SciLean.semiAdjoint.pi_rule","declaration":"theorem SciLean.semiAdjoint.pi_rule (K : Type u_1) [RCLike K] {X : Type u_1} [SciLean.SemiInnerProductSpace K X] {ι : Type u_3} [SciLean.IndexType ι] {E : ι → Type u_2} [(i : ι) → SciLean.SemiInnerProductSpace K (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.HasSemiAdjoint K fun x => f x i) : (SciLean.semiAdjoint K fun x i => f x i) = fun x' =>  ∑ i, SciLean.semiAdjoint K (fun x => f x i) (x' i)"}
{"name":"SciLean.semiAdjoint.IndexType.sum.arg_f.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.IndexType.sum.arg_f.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] {ι : Type u_3} [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.HasSemiAdjoint K fun x => f x i) : (SciLean.semiAdjoint K fun x =>  ∑ i, f x i) = fun y =>  ∑ i, SciLean.semiAdjoint K (fun x => f x i) y"}
{"name":"SciLean.semiAdjoint.Finset.sum.arg_f.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.Finset.sum.arg_f.semiAdjoint_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_4} [SciLean.SemiInnerProductSpace K Y] {ι : Type u_1} [Fintype ι] (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.HasSemiAdjoint K fun x => f x i) : (SciLean.semiAdjoint K fun x => Finset.sum Finset.univ fun i => f x i) = fun y =>\n  Finset.sum Finset.univ fun i => SciLean.semiAdjoint K (fun x => f x i) y"}
{"name":"SciLean.semiAdjoint.const_rule","declaration":"theorem SciLean.semiAdjoint.const_rule (K : Type u_3) [RCLike K] {X : Type u_1} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] : (SciLean.semiAdjoint K fun x => 0) = fun x => 0"}
{"name":"SciLean.semiAdjoint.dite.arg_te.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.dite.arg_te.semiAdjoint_rule (K : Type u_3) [RCLike K] {X : Type u_1} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (e : ¬c → X → Y) : (SciLean.semiAdjoint K fun x => if x_1 : c then t x_1 x else e x_1 x) = fun y =>\n  if p : c then SciLean.semiAdjoint K (t p) y else SciLean.semiAdjoint K (e p) y"}
{"name":"SciLean.semiAdjoint.HAdd.hAdd.arg_a0a1.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.HAdd.hAdd.arg_a0a1.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (g : X → Y) (hf : SciLean.HasSemiAdjoint K f) (hg : SciLean.HasSemiAdjoint K g) : (SciLean.semiAdjoint K fun x => f x + g x) = fun y =>\n  let x₁ := SciLean.semiAdjoint K f y;\n  let x₂ := SciLean.semiAdjoint K g y;\n  x₁ + x₂"}
{"name":"SciLean.semiAdjoint.HSub.hSub.arg_a0a1.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.HSub.hSub.arg_a0a1.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (g : X → Y) (hf : SciLean.HasSemiAdjoint K f) (hg : SciLean.HasSemiAdjoint K g) : (SciLean.semiAdjoint K fun x => f x - g x) = fun y =>\n  let x₁ := SciLean.semiAdjoint K f y;\n  let x₂ := SciLean.semiAdjoint K g y;\n  x₁ - x₂"}
{"name":"SciLean.semiAdjoint.HMul.hMul.arg_a0.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.HMul.hMul.arg_a0.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (c : K) (f : X → K) (hf : SciLean.HasSemiAdjoint K f) : (SciLean.semiAdjoint K fun x => f x * c) = fun y => (starRingEnd K) c • SciLean.semiAdjoint K (fun x => f x) y"}
{"name":"SciLean.semiAdjoint.HSMul.hSMul.arg_a1.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.HSMul.hSMul.arg_a1.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (c : K) (g : X → Y) (hg : SciLean.HasSemiAdjoint K g) : (SciLean.semiAdjoint K fun x => c • g x) = fun y => (starRingEnd K) c • SciLean.semiAdjoint K g y"}
{"name":"SciLean.semiAdjoint.id_rule","declaration":"theorem SciLean.semiAdjoint.id_rule (K : Type u_2) [RCLike K] {X : Type u_1} [SciLean.SemiInnerProductSpace K X] : (SciLean.semiAdjoint K fun x => x) = fun x => x"}
{"name":"SciLean.semiAdjoint.Prod.fst.arg_self.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.Prod.fst.arg_self.semiAdjoint_rule (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_2} [SciLean.SemiInnerProductSpace K Z] (f : X → Y × Z) (hf : SciLean.HasSemiAdjoint K f) : (SciLean.semiAdjoint K fun x => (f x).1) = fun y => SciLean.semiAdjoint K (fun x => f x) (y, 0)"}
{"name":"SciLean.semiAdjoint.Prod.snd.arg_self.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.Prod.snd.arg_self.semiAdjoint_rule (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_2} [SciLean.SemiInnerProductSpace K Z] (f : X → Y × Z) (hf : SciLean.HasSemiAdjoint K f) : (SciLean.semiAdjoint K fun x => (f x).2) = fun z => SciLean.semiAdjoint K f (0, z)"}
{"name":"SciLean.semiAdjoint.Prod.mk.arg_fstsnd.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.Prod.mk.arg_fstsnd.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_4} [SciLean.SemiInnerProductSpace K Z] (g : X → Y) (f : X → Z) (hg : SciLean.HasSemiAdjoint K g) (hf : SciLean.HasSemiAdjoint K f) : (SciLean.semiAdjoint K fun x => (g x, f x)) = fun yz =>\n  let x₁ := SciLean.semiAdjoint K g yz.1;\n  let x₂ := SciLean.semiAdjoint K f yz.2;\n  x₁ + x₂"}
{"name":"SciLean.semiAdjoint.Inner.inner.arg_a0.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.Inner.inner.arg_a0.semiAdjoint_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiHilbert K Y] (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) (y : Y) : (SciLean.semiAdjoint K fun x => ⟪f x, y⟫_K) = fun z => (starRingEnd K) z • SciLean.semiAdjoint K f y"}
{"name":"SciLean.semiAdjoint.Inner.inner.arg_a1.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.Inner.inner.arg_a1.semiAdjoint_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiHilbert K Y] (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) (y : Y) : (SciLean.semiAdjoint K fun x => ⟪y, f x⟫_K) = fun z => z • SciLean.semiAdjoint K f y"}
{"name":"SciLean.semiAdjoint.HDiv.hDiv.arg_a0.semiAdjoint_rule","declaration":"theorem SciLean.semiAdjoint.HDiv.hDiv.arg_a0.semiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (f : X → K) (c : K) (hf : SciLean.HasSemiAdjoint K f) : (SciLean.semiAdjoint K fun x => f x / c) = fun y => ((starRingEnd K) c)⁻¹ • SciLean.semiAdjoint K f y"}
