{"name":"SciLean.SmoothLinearMap.neg_apply","declaration":"theorem SciLean.SmoothLinearMap.neg_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (f : X ⊸[K] Y) (x : X) : (-f) x = -f x"}
{"name":"SciLean.SmoothLinearMap.mk'.arg_f.CDifferentiable_rule","declaration":"theorem SciLean.SmoothLinearMap.mk'.arg_f.CDifferentiable_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : W → X ⊸[K] Y) (g : W → X) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : SciLean.CDifferentiable K fun w => (f w) (g w)"}
{"name":"SciLean.«term_⊸_»","declaration":"def SciLean.«term_⊸_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.SmoothLinearMap.is_smooth_linear_map","declaration":"def SciLean.SmoothLinearMap.is_smooth_linear_map {K : Type u_1} [RCLike K] {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (self : X ⊸[K] Y) : SciLean.IsSmoothLinearMap K self.toFun"}
{"name":"SciLean.SmoothLinearMap_apply_right","declaration":"theorem SciLean.SmoothLinearMap_apply_right (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X ⊸[K] Y) : SciLean.IsSmoothLinearMap K fun x => f x"}
{"name":"SciLean.SmoothLinearMap.add_apply","declaration":"theorem SciLean.SmoothLinearMap.add_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (f : X ⊸[K] Y) (g : X ⊸[K] Y) (x : X) : (f + g) x = f x + g x"}
{"name":"SciLean.SmoothLinearMap.mk'.arg_f.IsSmoothLinearMap_rule","declaration":"theorem SciLean.SmoothLinearMap.mk'.arg_f.IsSmoothLinearMap_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_4} [SciLean.Vec K Y] {W : Type u_3} [SciLean.Vec K W] (f : W → X → Y) (hf : SciLean.CDifferentiable K fun x =>\n  match x with\n  | (w, x) => f w x) (hf₁ : ∀ (x : X), SciLean.IsSmoothLinearMap K fun x_1 => f x_1 x) (hf₂ : ∀ (w : W), SciLean.IsSmoothLinearMap K fun x => f w x) : SciLean.IsSmoothLinearMap K fun w => fun x ⊸[K] f w x"}
{"name":"SciLean.«term_⊸[_]_»","declaration":"def SciLean.«term_⊸[_]_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.instZeroSmoothLinearMap","declaration":"instance SciLean.instZeroSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : Zero (X ⊸[K] Y)"}
{"name":"SciLean.SmoothLinearMap.indextype_sum_apply","declaration":"theorem SciLean.SmoothLinearMap.indextype_sum_apply (K : Type u_4) [RCLike K] {X : Type u_3} [SciLean.Vec K X] {Y : Type (max u_2 u_3)} [SciLean.Vec K Y] {I : Type u_1} [SciLean.IndexType I] (f : I → X ⊸[K] Y) (x : X) : ( ∑ i, f i) x = ∑ i, (f i) x"}
{"name":"SciLean.unexpandSmoothLinearMapMk'","declaration":"def SciLean.unexpandSmoothLinearMapMk'  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.instVecSmoothLinearMap","declaration":"instance SciLean.instVecSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : SciLean.Vec K (X ⊸[K] Y)"}
{"name":"SciLean.SmoothLinearMap.smul_apply","declaration":"theorem SciLean.SmoothLinearMap.smul_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (f : X ⊸[K] Y) (x : X) (r : K) : (r • f) x = r • f x"}
{"name":"SciLean.instSMulSmoothLinearMap","declaration":"instance SciLean.instSMulSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : SMul K (X ⊸[K] Y)"}
{"name":"SciLean.SmoothLinearMap.eta_reduce","declaration":"theorem SciLean.SmoothLinearMap.eta_reduce {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X ⊸[K] Y) : { toFun := f.toFun, is_smooth_linear_map := ⋯ } = f"}
{"name":"SciLean.instFunLikeSmoothLinearMap","declaration":"instance SciLean.instFunLikeSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : FunLike (X ⊸[K] Y) X Y"}
{"name":"SciLean.«termFun_⊸_»","declaration":"def SciLean.«termFun_⊸_»  : Lean.ParserDescr"}
{"name":"SciLean.SmoothLinearMap.ext","declaration":"theorem SciLean.SmoothLinearMap.ext {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X ⊸[K] Y) (g : X ⊸[K] Y) : (∀ (x : X), f x = g x) → f = g"}
{"name":"SciLean.SmoothLinearMap.fintype_sum_apply","declaration":"theorem SciLean.SmoothLinearMap.fintype_sum_apply (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.Vec K X] {Y : Type u_4} [SciLean.Vec K Y] {I : Type u_1} [Fintype I] (f : I → X ⊸[K] Y) (x : X) : (Finset.sum Finset.univ fun i => f i) x = Finset.sum Finset.univ fun i => (f i) x"}
{"name":"SciLean.instUniformSpaceSmoothLinearMap","declaration":"instance SciLean.instUniformSpaceSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : UniformSpace (X ⊸[K] Y)"}
{"name":"SciLean.instSubSmoothLinearMap","declaration":"instance SciLean.instSubSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : Sub (X ⊸[K] Y)"}
{"name":"SciLean.SmoothLinearMap.mk'_eval","declaration":"theorem SciLean.SmoothLinearMap.mk'_eval (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (hf : SciLean.IsSmoothLinearMap K f) : (SciLean.SmoothLinearMap.mk' K f hf) x = f x"}
{"name":"SciLean.unexpandSmoothLinearMap","declaration":"def SciLean.unexpandSmoothLinearMap  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.unexpandSmoothLinearMapMk","declaration":"def SciLean.unexpandSmoothLinearMapMk  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.instNegSmoothLinearMap","declaration":"instance SciLean.instNegSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : Neg (X ⊸[K] Y)"}
{"name":"SciLean.«termFun_⊸[_]_»","declaration":"def SciLean.«termFun_⊸[_]_»  : Lean.ParserDescr"}
{"name":"SciLean.SmoothLinearMap.mk","declaration":"ctor SciLean.SmoothLinearMap.mk {K : Type u_1} [RCLike K] {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (toFun : X → Y) (is_smooth_linear_map : SciLean.IsSmoothLinearMap K toFun) : X ⊸[K] Y"}
{"name":"SciLean.SmoothLinearMap.sub_apply","declaration":"theorem SciLean.SmoothLinearMap.sub_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (f : X ⊸[K] Y) (g : X ⊸[K] Y) (x : X) : (f - g) x = f x - g x"}
{"name":"SciLean.SmoothLinearMap.mk_eval","declaration":"theorem SciLean.SmoothLinearMap.mk_eval {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (x : X) (f : X → Y) (hf : SciLean.IsSmoothLinearMap K f) : { toFun := f, is_smooth_linear_map := hf } x = f x"}
{"name":"SciLean.SmoothLinearMap_apply_left","declaration":"theorem SciLean.SmoothLinearMap_apply_left (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : W → X ⊸[K] Y) (x : X) (hf : SciLean.IsSmoothLinearMap K f) : SciLean.IsSmoothLinearMap K fun w => (f w) x"}
{"name":"SciLean.SmoothLinearMap.toFun","declaration":"def SciLean.SmoothLinearMap.toFun {K : Type u_1} [RCLike K] {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (self : X ⊸[K] Y) : X → Y"}
{"name":"SciLean.instAddSmoothLinearMap","declaration":"instance SciLean.instAddSmoothLinearMap (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : Add (X ⊸[K] Y)"}
{"name":"SciLean.SmoothLinearMap","declaration":"structure SciLean.SmoothLinearMap (K : Type u_1) [RCLike K] (X : Type u_2) (Y : Type u_3) [SciLean.Vec K X] [SciLean.Vec K Y] : Type (max u_2 u_3)"}
{"name":"SciLean.SmoothLinearMap.mk'","declaration":"def SciLean.SmoothLinearMap.mk' (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X → Y) (hf : SciLean.IsSmoothLinearMap K f) : X ⊸[K] Y"}
{"name":"SciLean.SmoothLinearMap.apply_zero","declaration":"theorem SciLean.SmoothLinearMap.apply_zero (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X ⊸[K] Y) : f 0 = 0"}
{"name":"SciLean.SmoothLinearMap.zero_apply","declaration":"theorem SciLean.SmoothLinearMap.zero_apply (K : Type u_3) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] (x : X) : 0 x = 0"}
