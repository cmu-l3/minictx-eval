{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.getValue","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.getValue (simpThm : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Lean.MetaM Lean.Expr"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.rfl","declaration":"/-- `rfl` is true if `proof` is by `Eq.refl` or `rfl`. -/\ndef SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.rfl (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Bool"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.proof","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.proof (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Lean.Expr"}
{"name":"SciLean.Tactic.RefinedSimp.refinedSimpTheoremsExt","declaration":"/-- -/\nopaque SciLean.Tactic.RefinedSimp.refinedSimpTheoremsExt  : Lean.SimpleScopedEnvExtension SciLean.Tactic.RefinedSimp.RefinedSimpTheorem\n  SciLean.Tactic.RefinedSimp.RefinedSimpTheorems"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.toSimpTheorem","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.toSimpTheorem (simpThm : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Lean.Meta.SimpTheorem"}
{"name":"SciLean.Tactic.RefinedSimp.instBEqRefinedSimpTheorem","declaration":"instance SciLean.Tactic.RefinedSimp.instBEqRefinedSimpTheorem  : BEq SciLean.Tactic.RefinedSimp.RefinedSimpTheorem"}
{"name":"SciLean.Tactic.RefinedSimp.elabGuards","declaration":"def SciLean.Tactic.RefinedSimp.elabGuards (declName : Lean.Name) (guardStx : Lean.Syntax) : Lean.Elab.TermElabM (Array (ℕ × SciLean.Tactic.RefinedSimp.ArgGuard))"}
{"name":"SciLean.Tactic.RefinedSimp.rsimp_guard","declaration":"def SciLean.Tactic.RefinedSimp.rsimp_guard  : Lean.ParserDescr"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.guards","declaration":"/-- Array of `(theorem argument id, argument guard)` specifying additional constraints on when\nto apply this theorem. For example, if the theorem has arugument `(f : X → X)` with index `3` then\n`guards := #[(3,.notId)]` will stop applying this theorem if `f` unifies to identity function. -/\ndef SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.guards (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Array (ℕ × SciLean.Tactic.RefinedSimp.ArgGuard)"}
{"name":"SciLean.Tactic.RefinedSimp.funPropAttr","declaration":"/-- Initialization of `funProp` attribute -/\nopaque SciLean.Tactic.RefinedSimp.funPropAttr  : Unit"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.post","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.post (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Bool"}
{"name":"SciLean.Tactic.RefinedSimp.instInhabitedRefinedSimpTheorems","declaration":"instance SciLean.Tactic.RefinedSimp.instInhabitedRefinedSimpTheorems  : Inhabited SciLean.Tactic.RefinedSimp.RefinedSimpTheorems"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.levelParams","declaration":"/-- It stores universe parameter names for universe polymorphic proofs.\nRecall that it is non-empty only when we elaborate an expression provided by the user.\nWhen `proof` is just a constant, we can use the universe parameter names stored in the declaration.\n-/\ndef SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.levelParams (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Array Lean.Name"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.origin","declaration":"/-- `origin` is mainly relevant for producing trace messages.\nIt is also viewed an `id` used to \"erase\" `simp` theorems from `SimpTheorems`.\n-/\ndef SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.origin (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Lean.Meta.Origin"}
{"name":"SciLean.Tactic.RefinedSimp.ArgGuard","declaration":"/-- Optional guard on simp theorems. You can require that an argument is not for example identity\nfunction or constant function after unification. -/\ninductive SciLean.Tactic.RefinedSimp.ArgGuard  : Type"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem","declaration":"/-- Same as SimpTheorem but works with RefinedDiscrTree rather than with normal DescrTree.\n\nIt has one additional feature and that is argument guard. For example, you can say that do not apply\nthis theorem if theorem argument `f` unifies to identity function.\n-/\nstructure SciLean.Tactic.RefinedSimp.RefinedSimpTheorem  : Type"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorems.post","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheorems.post (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorems) : SciLean.Tactic.RefinedSimp.RefinedSimpTheoremTree"}
{"name":"SciLean.Tactic.RefinedSimp.getTheoremFromConst","declaration":"def SciLean.Tactic.RefinedSimp.getTheoremFromConst (declName : Lean.Name) (prio : optParam ℕ 1000) (post : optParam Bool true) (guards : Array (ℕ × SciLean.Tactic.RefinedSimp.ArgGuard)) : Lean.MetaM SciLean.Tactic.RefinedSimp.RefinedSimpTheorem"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorems.mk","declaration":"ctor SciLean.Tactic.RefinedSimp.RefinedSimpTheorems.mk (pre : SciLean.Tactic.RefinedSimp.RefinedSimpTheoremTree) (post : SciLean.Tactic.RefinedSimp.RefinedSimpTheoremTree) : SciLean.Tactic.RefinedSimp.RefinedSimpTheorems"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.keys","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.keys (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : List Mathlib.Meta.FunProp.RefinedDiscrTree.DTExpr"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorems","declaration":"structure SciLean.Tactic.RefinedSimp.RefinedSimpTheorems  : Type"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheoremTree","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheoremTree  : Type"}
{"name":"SciLean.Tactic.RefinedSimp.rsimp","declaration":"def SciLean.Tactic.RefinedSimp.rsimp  : Lean.ParserDescr"}
{"name":"SciLean.Tactic.RefinedSimp.ArgGuard.notId","declaration":"/-- Argument can't be identity function -/\nctor SciLean.Tactic.RefinedSimp.ArgGuard.notId  : SciLean.Tactic.RefinedSimp.ArgGuard"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorems.pre","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheorems.pre (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorems) : SciLean.Tactic.RefinedSimp.RefinedSimpTheoremTree"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.perm","declaration":"/-- `perm` is true if lhs and rhs are identical modulo permutation of variables. -/\ndef SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.perm (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Bool"}
{"name":"SciLean.refinedRewritePre","declaration":"def SciLean.refinedRewritePre  : Lean.Meta.Simp.Simproc"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.mk","declaration":"ctor SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.mk (keys : List Mathlib.Meta.FunProp.RefinedDiscrTree.DTExpr) (levelParams : Array Lean.Name) (proof : Lean.Expr) (priority : ℕ) (post : Bool) (perm : Bool) (origin : Lean.Meta.Origin) (rfl : Bool) (guards : Array (ℕ × SciLean.Tactic.RefinedSimp.ArgGuard)) : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem"}
{"name":"SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.priority","declaration":"def SciLean.Tactic.RefinedSimp.RefinedSimpTheorem.priority (self : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : ℕ"}
{"name":"SciLean.Tactic.RefinedSimp.instInhabitedArgGuard","declaration":"instance SciLean.Tactic.RefinedSimp.instInhabitedArgGuard  : Inhabited SciLean.Tactic.RefinedSimp.ArgGuard"}
{"name":"SciLean.Tactic.RefinedSimp.instBEqArgGuard","declaration":"instance SciLean.Tactic.RefinedSimp.instBEqArgGuard  : BEq SciLean.Tactic.RefinedSimp.ArgGuard"}
{"name":"SciLean.Tactic.RefinedSimp.instReprArgGuard","declaration":"instance SciLean.Tactic.RefinedSimp.instReprArgGuard  : Repr SciLean.Tactic.RefinedSimp.ArgGuard"}
{"name":"SciLean.Tactic.RefinedSimp.instInhabitedRefinedSimpTheorem","declaration":"instance SciLean.Tactic.RefinedSimp.instInhabitedRefinedSimpTheorem  : Inhabited SciLean.Tactic.RefinedSimp.RefinedSimpTheorem"}
{"name":"SciLean.Tactic.RefinedSimp.refinedRewrite","declaration":"def SciLean.Tactic.RefinedSimp.refinedRewrite (post : Bool) (e : Lean.Expr) : Lean.Meta.SimpM Lean.Meta.Simp.Step"}
{"name":"SciLean.Tactic.RefinedSimp.theoremGuard","declaration":"/-- Check if `thm` can be applied to `e` and if the theorem argument `A : W → Set X` is not\na constant function. -/\ndef SciLean.Tactic.RefinedSimp.theoremGuard (e : Lean.Expr) (thm : SciLean.Tactic.RefinedSimp.RefinedSimpTheorem) : Lean.MetaM Bool"}
{"name":"SciLean.refinedRewritePost","declaration":"def SciLean.refinedRewritePost  : Lean.Meta.Simp.Simproc"}
{"name":"SciLean.Tactic.RefinedSimp.addTheorem","declaration":"def SciLean.Tactic.RefinedSimp.addTheorem (declName : Lean.Name) (attrKind : optParam Lean.AttributeKind Lean.AttributeKind.global) (prio : optParam ℕ 1000) (post : optParam Bool true) (guards : optParam (Array (ℕ × SciLean.Tactic.RefinedSimp.ArgGuard)) #[]) : Lean.MetaM Unit"}
{"name":"SciLean.Tactic.RefinedSimp.ArgGuard.notConst","declaration":"/-- Argument can't be constant function -/\nctor SciLean.Tactic.RefinedSimp.ArgGuard.notConst  : SciLean.Tactic.RefinedSimp.ArgGuard"}
