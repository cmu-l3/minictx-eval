{"name":"Float.exp.arg_a0.isomorph_rule_FloatToReal","declaration":"axiom Float.exp.arg_a0.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) : (SciLean.isomorph `FloatToReal fun x => Float.exp (f x)) = fun x => Real.exp (SciLean.isomorph `FloatToReal f x)"}
{"name":"Float.acos.arg_a0.isomorph_rule_FloatToReal","declaration":"axiom Float.acos.arg_a0.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) : (SciLean.isomorph `FloatToReal fun x => Float.acos (f x)) = fun x => Real.arccos (SciLean.isomorph `FloatToReal f x)"}
{"name":"HAdd.hAdd.arg_a0a1.isomorph_rule_RealToFloat","declaration":"axiom HAdd.hAdd.arg_a0a1.isomorph_rule_RealToFloat {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → ℝ) (g : α → ℝ) : (SciLean.isomorph `RealToFloat fun x => f x + g x) = fun x =>\n  SciLean.isomorph `RealToFloat f x + SciLean.isomorph `RealToFloat g x"}
{"name":"Float.atan.arg_a0.isomorph_rule_FloatToReal","declaration":"axiom Float.atan.arg_a0.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) : (SciLean.isomorph `FloatToReal fun x => Float.atan (f x)) = fun x => Real.arctan (SciLean.isomorph `FloatToReal f x)"}
{"name":"Neg.neg.arg_a0.isomorph_rule_FloatToReal","declaration":"axiom Neg.neg.arg_a0.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) : (SciLean.isomorph `FloatToReal fun x => -f x) = fun x => -SciLean.isomorph `FloatToReal f x"}
{"name":"instInvFloat","declaration":"instance instInvFloat  : Inv Float"}
{"name":"HDiv.hDiv.arg_a0a1.isomorph_rule_RealToFloat","declaration":"axiom HDiv.hDiv.arg_a0a1.isomorph_rule_RealToFloat {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → ℝ) (g : α → ℝ) : (SciLean.isomorph `RealToFloat fun x => f x / g x) = fun x =>\n  SciLean.isomorph `RealToFloat f x / SciLean.isomorph `RealToFloat g x"}
{"name":"Float.cos.arg_a0.isomorph_rule_FloatToReal","declaration":"axiom Float.cos.arg_a0.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) : (SciLean.isomorph `FloatToReal fun x => Float.cos (f x)) = fun x => Real.cos (SciLean.isomorph `FloatToReal f x)"}
{"name":"HMul.hMul.arg_a0a1.isomorph_rule_RealToFloat","declaration":"axiom HMul.hMul.arg_a0a1.isomorph_rule_RealToFloat {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → ℝ) (g : α → ℝ) : (SciLean.isomorph `RealToFloat fun x => f x * g x) = fun x =>\n  SciLean.isomorph `RealToFloat f x * SciLean.isomorph `RealToFloat g x"}
{"name":"HDiv.hDiv.arg_a0a1.isomorph_rule_FloatToReal","declaration":"axiom HDiv.hDiv.arg_a0a1.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) (g : α → Float) : (SciLean.isomorph `FloatToReal fun x => f x / g x) = fun x =>\n  SciLean.isomorph `FloatToReal f x / SciLean.isomorph `FloatToReal g x"}
{"name":"HAdd.hAdd.arg_a0a1.isomorph_rule_FloatToReal","declaration":"axiom HAdd.hAdd.arg_a0a1.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) (g : α → Float) : (SciLean.isomorph `FloatToReal fun x => f x + g x) = fun x =>\n  SciLean.isomorph `FloatToReal f x + SciLean.isomorph `FloatToReal g x"}
{"name":"Neg.neg.arg_a0.isomorph_rule_RealToFloat","declaration":"axiom Neg.neg.arg_a0.isomorph_rule_RealToFloat {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → ℝ) : (SciLean.isomorph `RealToFloat fun x => -f x) = fun x => -SciLean.isomorph `RealToFloat f x"}
{"name":"Float.sin.arg_a0.isomorph_rule_FloatToReal","declaration":"axiom Float.sin.arg_a0.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) : (SciLean.isomorph `FloatToReal fun x => Float.sin (f x)) = fun x => Real.sin (SciLean.isomorph `FloatToReal f x)"}
{"name":"HSub.hSub.arg_a0a1.isomorph_rule_FloatToReal","declaration":"axiom HSub.hSub.arg_a0a1.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) (g : α → Float) : (SciLean.isomorph `FloatToReal fun x => f x - g x) = fun x =>\n  SciLean.isomorph `FloatToReal f x - SciLean.isomorph `FloatToReal g x"}
{"name":"HMul.hMul.arg_a0a1.isomorph_rule_FloatToReal","declaration":"axiom HMul.hMul.arg_a0a1.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) (g : α → Float) : (SciLean.isomorph `FloatToReal fun x => f x * g x) = fun x =>\n  SciLean.isomorph `FloatToReal f x * SciLean.isomorph `FloatToReal g x"}
{"name":"Zero.zero.isomorph_rule_FloatToReal","declaration":"axiom Zero.zero.isomorph_rule_FloatToReal  : SciLean.floatToReal 0 = 0"}
{"name":"Real.sqrt.arg_x.isomorph_rule_RealToFloat","declaration":"axiom Real.sqrt.arg_x.isomorph_rule_RealToFloat {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → ℝ) : (SciLean.isomorph `RealToFloat fun x => √(f x)) = fun x => Float.sqrt (SciLean.isomorph `RealToFloat f x)"}
{"name":"Prod.snd.arg_self.isomorph_rule","declaration":"theorem Prod.snd.arg_self.isomorph_rule {α : Type u_1} {α' : Type u_2} {β₁ : Type u_3} {β₂ : Type u_4} {β₁' : Type u_5} {β₂' : Type u_6} [SciLean.IsomorphicType `RealToFloat α α'] [SciLean.IsomorphicType `RealToFloat β₁ β₁'] [SciLean.IsomorphicType `RealToFloat β₂ β₂'] (f : α → β₁ × β₂) : (SciLean.isomorph `RealToFloat fun x => (f x).2) = fun x => (SciLean.isomorph `RealToFloat f x).2"}
{"name":"Real.exp.arg_x.isomorph_rule","declaration":"axiom Real.exp.arg_x.isomorph_rule {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → ℝ) : (SciLean.isomorph `RealToFloat fun x => Real.exp (f x)) = fun x => Float.exp (SciLean.isomorph `RealToFloat f x)"}
{"name":"Inv.inv.arg_a0.isomorph_rule_FloatToReal","declaration":"axiom Inv.inv.arg_a0.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) : (SciLean.isomorph `FloatToReal fun x => (f x)⁻¹) = fun x => (SciLean.isomorph `FloatToReal f x)⁻¹"}
{"name":"Float.asin.arg_a0.isomorph_rule_FloatToReal","declaration":"axiom Float.asin.arg_a0.isomorph_rule_FloatToReal {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `FloatToReal α α'] (f : α → Float) : (SciLean.isomorph `FloatToReal fun x => Float.asin (f x)) = fun x => Real.arcsin (SciLean.isomorph `FloatToReal f x)"}
{"name":"HSub.hSub.arg_a0a1.isomorph_rule_RealToFloat","declaration":"axiom HSub.hSub.arg_a0a1.isomorph_rule_RealToFloat {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → ℝ) (g : α → ℝ) : (SciLean.isomorph `RealToFloat fun x => f x - g x) = fun x =>\n  SciLean.isomorph `RealToFloat f x - SciLean.isomorph `RealToFloat g x"}
{"name":"One.one.isomorph_rule_FloatToReal","declaration":"axiom One.one.isomorph_rule_FloatToReal  : SciLean.floatToReal 1 = 1"}
{"name":"Prod.fst.arg_self.isomorph_rule","declaration":"theorem Prod.fst.arg_self.isomorph_rule {α : Type u_1} {α' : Type u_2} {β₁ : Type u_3} {β₂ : Type u_4} {β₁' : Type u_5} {β₂' : Type u_6} [SciLean.IsomorphicType `RealToFloat α α'] [SciLean.IsomorphicType `RealToFloat β₁ β₁'] [SciLean.IsomorphicType `RealToFloat β₂ β₂'] (f : α → β₁ × β₂) : (SciLean.isomorph `RealToFloat fun x => (f x).1) = fun x => (SciLean.isomorph `RealToFloat f x).1"}
{"name":"And.arg_ab.isomorph_rule","declaration":"axiom And.arg_ab.isomorph_rule {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → Prop) (g : α → Prop) : (SciLean.isomorph `RealToFloat fun x => f x ∧ g x) = fun x =>\n  SciLean.isomorph `RealToFloat f x ∧ SciLean.isomorph `RealToFloat g x"}
{"name":"LE.le.arg_a0a1.isomorph_rule","declaration":"axiom LE.le.arg_a0a1.isomorph_rule {α : Type u_1} {α' : Type u_2} [SciLean.IsomorphicType `RealToFloat α α'] (f : α → ℝ) (g : α → ℝ) : (SciLean.isomorph `RealToFloat fun x => f x ≤ g x) = fun x =>\n  SciLean.isomorph `RealToFloat f x ≤ SciLean.isomorph `RealToFloat g x"}
