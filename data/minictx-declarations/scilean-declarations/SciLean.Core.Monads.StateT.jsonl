{"name":"MonadState.get.arg.fwdDerivValM_rule","declaration":"theorem MonadState.get.arg.fwdDerivValM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] : SciLean.fwdDerivValM K get = get"}
{"name":"modify.arg_f.HasAdjDiffM_rule","declaration":"theorem modify.arg_f.HasAdjDiffM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.SemiInnerProductSpace K S] {X : Type} [SciLean.SemiInnerProductSpace K X] (f : X → S → S) (ha0 : SciLean.HasAdjDiff K fun xs => f xs.1 xs.2) : SciLean.HasAdjDiffM K fun x => modify (f x)"}
{"name":"getThe.arg.revDerivValM_rule","declaration":"theorem getThe.arg.revDerivValM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.SemiInnerProductSpace K S] : SciLean.revDerivValM K (getThe S) = do\n  let __do_lift ← getThe S\n  pure (__do_lift, fun ds => modifyThe S fun ds' => ds + ds')"}
{"name":"getThe.arg.CDifferentiableValM_rule","declaration":"theorem getThe.arg.CDifferentiableValM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] : SciLean.CDifferentiableValM K (getThe S)"}
{"name":"MonadStateOf.set.arg_a0.revDerivM_rule","declaration":"theorem MonadStateOf.set.arg_a0.revDerivM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.SemiInnerProductSpace K S] {X : Type} [SciLean.SemiInnerProductSpace K X] (s : X → S) (ha0 : SciLean.HasAdjDiff K s) : (SciLean.revDerivM K fun x => set (s x)) = fun x =>\n  let sds := SciLean.revDeriv K s x;\n  do\n  let __do_lift ← set sds.1\n  pure\n      (__do_lift, fun x => do\n        let __do_lift ← get\n        let dx : X := sds.2 __do_lift\n        set 0\n        pure dx)"}
{"name":"MonadStateOf.set.arg_a0.CDifferentiableM_rule","declaration":"theorem MonadStateOf.set.arg_a0.CDifferentiableM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] {X : Type} [SciLean.Vec K X] (s : X → S) (ha0 : SciLean.CDifferentiable K s) : SciLean.CDifferentiableM K fun x => set (s x)"}
{"name":"MonadState.get.arg.revDerivValM_rule","declaration":"theorem MonadState.get.arg.revDerivValM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.SemiInnerProductSpace K S] : SciLean.revDerivValM K get = do\n  let __do_lift ← get\n  pure (__do_lift, fun ds => modify fun ds' => ds + ds')"}
{"name":"MonadStateOf.set.arg_a0.HasAdjDiffM_rule","declaration":"theorem MonadStateOf.set.arg_a0.HasAdjDiffM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.SemiInnerProductSpace K S] {X : Type} [SciLean.SemiInnerProductSpace K X] (s : X → S) (ha0 : SciLean.HasAdjDiff K s) : SciLean.HasAdjDiffM K fun x => set (s x)"}
{"name":"getThe.arg.HasAdjDiffValM_rule","declaration":"theorem getThe.arg.HasAdjDiffValM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.SemiInnerProductSpace K S] : SciLean.HasAdjDiffValM K (getThe S)"}
{"name":"MonadState.get.arg.HasAdjDiffValM_rule","declaration":"theorem MonadState.get.arg.HasAdjDiffValM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.SemiInnerProductSpace K S] : SciLean.HasAdjDiffValM K get"}
{"name":"modify.arg_f.revDerivM_rule","declaration":"theorem modify.arg_f.revDerivM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.SemiInnerProductSpace K S] {X : Type} [SciLean.SemiInnerProductSpace K X] (f : X → S → S) (ha0 : SciLean.HasAdjDiff K fun xs => f xs.1 xs.2) : (SciLean.revDerivM K fun x => modify (f x)) = fun x => do\n  let __do_lift ← get\n  let sdf : S × (S → X × S) := SciLean.revDeriv K (fun xs => f xs.1 xs.2) (x, __do_lift)\n  set sdf.1\n  pure\n      ((), fun x => do\n        let __do_lift ← get\n        let dxs : X × S := sdf.2 __do_lift\n        set dxs.2\n        pure dxs.1)"}
{"name":"MonadState.get.arg.CDifferentiableValM_rule","declaration":"theorem MonadState.get.arg.CDifferentiableValM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] : SciLean.CDifferentiableValM K get"}
{"name":"MonadStateOf.set.arg_a0.fwdDerivM_rule","declaration":"theorem MonadStateOf.set.arg_a0.fwdDerivM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] {X : Type} [SciLean.Vec K X] (s : X → S) (ha0 : SciLean.CDifferentiable K s) : (SciLean.fwdDerivM K fun x => set (s x)) = fun x dx =>\n  let sds := SciLean.fwdDeriv K s x dx;\n  do\n  set sds\n  pure ((), ())"}
{"name":"getThe.arg.fwdDerivValM_rule","declaration":"theorem getThe.arg.fwdDerivValM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] : SciLean.fwdDerivValM K (getThe S) = getThe (S × S)"}
{"name":"SciLean.instFwdDerivMonadStateTProdInstMonadStateT","declaration":"instance SciLean.instFwdDerivMonadStateTProdInstMonadStateT {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] (S : Type) [SciLean.Vec K S] : SciLean.FwdDerivMonad K (StateT S m) (StateT (S × S) m')"}
{"name":"SciLean.instRevDerivMonadStateTInstMonadStateT","declaration":"instance SciLean.instRevDerivMonadStateTInstMonadStateT {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.RevDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] (S : Type) [SciLean.SemiInnerProductSpace K S] : SciLean.RevDerivMonad K (StateT S m) (StateT S m')"}
{"name":"modifyThe.arg_f.CDifferentiableM_rule","declaration":"theorem modifyThe.arg_f.CDifferentiableM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] {X : Type} [SciLean.Vec K X] (f : X → S → S) (ha0 : SciLean.CDifferentiable K fun xs => f xs.1 xs.2) : SciLean.CDifferentiableM K fun x => modifyThe S (f x)"}
{"name":"modify.arg_f.fwdDerivM_rule","declaration":"theorem modify.arg_f.fwdDerivM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] {X : Type} [SciLean.Vec K X] (f : X → S → S) (ha0 : SciLean.CDifferentiable K fun xs => f xs.1 xs.2) : (SciLean.fwdDerivM K fun x => modify (f x)) = fun x dx => do\n  modify fun sds =>\n      let sds := SciLean.fwdDeriv K (fun xs => f xs.1 xs.2) (x, sds.1) (dx, sds.2);\n      sds\n  pure ((), ())"}
{"name":"modify.arg_f.CDifferentiableM_rule","declaration":"theorem modify.arg_f.CDifferentiableM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] {X : Type} [SciLean.Vec K X] (f : X → S → S) (ha0 : SciLean.CDifferentiable K fun xs => f xs.1 xs.2) : SciLean.CDifferentiableM K fun x => modify (f x)"}
{"name":"modifyThe.arg_f.fwdDerivM_rule","declaration":"theorem modifyThe.arg_f.fwdDerivM_rule {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {S : Type} [SciLean.Vec K S] {X : Type} [SciLean.Vec K X] (f : X → S → S) (ha0 : SciLean.CDifferentiable K fun xs => f xs.1 xs.2) : (SciLean.fwdDerivM K fun x => modifyThe S (f x)) = fun x dx => do\n  modifyThe (S × S) fun sds =>\n      let sds := SciLean.fwdDeriv K (fun xs => f xs.1 xs.2) (x, sds.1) (dx, sds.2);\n      sds\n  pure ((), ())"}
