{"name":"SciLean.SciLean.norm₂.arg_x.HasAdjDiff_rule","declaration":"theorem SciLean.SciLean.norm₂.arg_x.HasAdjDiff_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (hf : SciLean.HasAdjDiff R f) (hfz : ∀ (x : X), f x ≠ 0) : SciLean.HasAdjDiff R fun x => ‖f x‖₂[R]"}
{"name":"SciLean.HasAdjDiffAt.comp_rule","declaration":"theorem SciLean.HasAdjDiffAt.comp_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_3} [SciLean.SemiInnerProductSpace K Z] (f : Y → Z) (g : X → Y) (x : X) (hf : SciLean.HasAdjDiffAt K f (g x)) (hg : SciLean.HasAdjDiffAt K g x) : SciLean.HasAdjDiffAt K (fun x => f (g x)) x"}
{"name":"SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiff_rule","declaration":"theorem SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {W : Type u_4} [SciLean.SemiInnerProductSpace K W] (f : X → Y) (a0 : W → Y) (hf : SciLean.CDifferentiable K f) (ha0 : SciLean.HasAdjDiff K a0) : SciLean.HasAdjDiff K fun w => SciLean.semiAdjoint K f (a0 w)"}
{"name":"SciLean.Prod.fst.arg_self.HasAdjDiffAt_rule","declaration":"theorem SciLean.Prod.fst.arg_self.HasAdjDiffAt_rule (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_2} [SciLean.SemiInnerProductSpace K Z] (x : X) (f : X → Y × Z) (hf : SciLean.HasAdjDiffAt K f x) : SciLean.HasAdjDiffAt K (fun x => (f x).1) x"}
{"name":"SciLean.HasSemiAdjoint.hasAdjDiff","declaration":"theorem SciLean.HasSemiAdjoint.hasAdjDiff (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasSemiAdjoint K f) : SciLean.HasAdjDiff K f"}
{"name":"SciLean.HasAdjDiffAt.apply_rule","declaration":"theorem SciLean.HasAdjDiffAt.apply_rule (K : Type u_1) [RCLike K] {ι : Type u_2} [SciLean.IndexType ι] [DecidableEq ι] {E : ι → Type u_3} [(i : ι) → SciLean.SemiInnerProductSpace K (E i)] (x : (i : ι) → E i) (i : ι) : SciLean.HasAdjDiffAt K (fun x => x i) x"}
{"name":"SciLean.IndexType.sum.arg_f.HasAdjDiffAt_rule","declaration":"theorem SciLean.IndexType.sum.arg_f.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {ι : Type u_4} [SciLean.IndexType ι] (x : X) (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.HasAdjDiffAt K (fun x => f x i) x) : SciLean.HasAdjDiffAt K (fun x =>  ∑ i, f x i) x"}
{"name":"SciLean.HDiv.hDiv.arg_a0a1.HasAdjDiff_rule","declaration":"def SciLean.HDiv.hDiv.arg_a0a1.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (f : X → K) (g : X → K) (hf : SciLean.HasAdjDiff K f) (hg : SciLean.HasAdjDiff K g) (hx : ∀ (x : X), g x ≠ 0) : SciLean.HasAdjDiff K fun x => f x / g x"}
{"name":"SciLean.Inner.inner.arg_a0a1.HasAdjDiff_rule","declaration":"theorem SciLean.Inner.inner.arg_a0a1.HasAdjDiff_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (g : X → Y) (hf : SciLean.HasAdjDiff R f) (hg : SciLean.HasAdjDiff R g) : SciLean.HasAdjDiff R fun x => ⟪f x, g x⟫_R"}
{"name":"SciLean.HasAdjDiff.cdifferentiable","declaration":"theorem SciLean.HasAdjDiff.cdifferentiable (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasAdjDiff K f) : SciLean.CDifferentiable K f"}
{"name":"SciLean.HSMul.hSMul.arg_a1.HasAdjDiffAt_rule","declaration":"theorem SciLean.HSMul.hSMul.arg_a1.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (c : K) (g : X → Y) (x : X) (hg : SciLean.HasAdjDiffAt K g x) : SciLean.HasAdjDiffAt K (fun x => c • g x) x"}
{"name":"SciLean.HasAdjDiff.apply_rule","declaration":"theorem SciLean.HasAdjDiff.apply_rule (K : Type u_1) [RCLike K] {ι : Type u_2} [SciLean.IndexType ι] [DecidableEq ι] {E : ι → Type u_3} [(i : ι) → SciLean.SemiInnerProductSpace K (E i)] (i : ι) : SciLean.HasAdjDiff K fun x => x i"}
{"name":"SciLean.HasAjdDiff.const_rule","declaration":"theorem SciLean.HasAjdDiff.const_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (y : Y) : SciLean.HasAdjDiff K fun x => y"}
{"name":"SciLean.SciLean.semiAdjoint.arg_y.CDifferentiable_rule","declaration":"theorem SciLean.SciLean.semiAdjoint.arg_y.CDifferentiable_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_4} [SciLean.SemiInnerProductSpace K Y] {W : Type u_1} [SciLean.Vec K W] (f : X → Y) (a0 : W → Y) (hf : SciLean.CDifferentiable K f) (ha0 : SciLean.CDifferentiable K a0) : SciLean.CDifferentiable K fun w => SciLean.semiAdjoint K f (a0 w)"}
{"name":"SciLean.HasAdjDiff.pi_rule","declaration":"theorem SciLean.HasAdjDiff.pi_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {ι : Type u_4} [SciLean.IndexType ι] {E : ι → Type u_3} [(i : ι) → SciLean.SemiInnerProductSpace K (E i)] (f : X → (i : ι) → E i) (hf : ∀ (i : ι), SciLean.HasAdjDiff K fun x => f x i) : SciLean.HasAdjDiff K fun x i => f x i"}
{"name":"SciLean.HasAdjDiff.hasAdjDiffAt","declaration":"theorem SciLean.HasAdjDiff.hasAdjDiffAt (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (x : X) (hf : SciLean.HasAdjDiff K f) : SciLean.HasAdjDiffAt K f x"}
{"name":"SciLean.SciLean.norm₂.arg_x.HasAdjDiffAt_rule","declaration":"theorem SciLean.SciLean.norm₂.arg_x.HasAdjDiffAt_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (x : X) (f : X → Y) (hf : SciLean.HasAdjDiffAt R f x) (hfz : f x ≠ 0) : SciLean.HasAdjDiffAt R (fun x => ‖f x‖₂[R]) x"}
{"name":"SciLean.Prod.mk.arg_fstsnd.HasAdjDiffAt_rule","declaration":"theorem SciLean.Prod.mk.arg_fstsnd.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_4} [SciLean.SemiInnerProductSpace K Z] (x : X) (g : X → Y) (hg : SciLean.HasAdjDiffAt K g x) (f : X → Z) (hf : SciLean.HasAdjDiffAt K f x) : SciLean.HasAdjDiffAt K (fun x => (g x, f x)) x"}
{"name":"SciLean.ite.arg_te.HasAdjDiff_rule","declaration":"theorem SciLean.ite.arg_te.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) (ht : SciLean.HasAdjDiff K t) (he : SciLean.HasAdjDiff K e) : SciLean.HasAdjDiff K fun x => if c then t x else e x"}
{"name":"SciLean.HasAdjDiffAt.pi_rule","declaration":"theorem SciLean.HasAdjDiffAt.pi_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {ι : Type u_4} [SciLean.IndexType ι] {E : ι → Type u_3} [(i : ι) → SciLean.SemiInnerProductSpace K (E i)] (f : X → (i : ι) → E i) (x : X) (hf : ∀ (i : ι), SciLean.HasAdjDiffAt K (fun x => f x i) x) : SciLean.HasAdjDiffAt K (fun x i => f x i) x"}
{"name":"SciLean.HMul.hMul.arg_a0a1.HasAdjDiff_rule","declaration":"def SciLean.HMul.hMul.arg_a0a1.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (f : X → K) (g : X → K) (hf : SciLean.HasAdjDiff K f) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiff K fun x => f x * g x"}
{"name":"SciLean.SciLean.semiAdjoint.arg_y.CDifferentiableAt_rule","declaration":"theorem SciLean.SciLean.semiAdjoint.arg_y.CDifferentiableAt_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_4} [SciLean.SemiInnerProductSpace K Y] {W : Type u_1} [SciLean.Vec K W] (w : W) (f : X → Y) (a0 : W → Y) (hf : SciLean.CDifferentiable K f) (ha0 : SciLean.CDifferentiableAt K a0 w) : SciLean.CDifferentiableAt K (fun w => SciLean.semiAdjoint K f (a0 w)) w"}
{"name":"SciLean.Prod.snd.arg_self.HasAdjDiffAt_rule","declaration":"theorem SciLean.Prod.snd.arg_self.HasAdjDiffAt_rule (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_2} [SciLean.SemiInnerProductSpace K Z] (x : X) (f : X → Y × Z) (hf : SciLean.HasAdjDiffAt K f x) : SciLean.HasAdjDiffAt K (fun x => (f x).2) x"}
{"name":"SciLean.cderiv.arg_dx.hasSemiAdjointAt","declaration":"theorem SciLean.cderiv.arg_dx.hasSemiAdjointAt (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (x : X) (hf : SciLean.HasAdjDiffAt K f x) : SciLean.HasSemiAdjoint K (SciLean.cderiv K f x)"}
{"name":"SciLean.cderiv.arg_dx.hasSemiAdjoint","declaration":"theorem SciLean.cderiv.arg_dx.hasSemiAdjoint (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (x : X) (hf : SciLean.HasAdjDiff K f) : SciLean.HasSemiAdjoint K (SciLean.cderiv K f x)"}
{"name":"SciLean.HasAdjDiffAt.const_rule","declaration":"theorem SciLean.HasAdjDiffAt.const_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (x : X) (y : Y) : SciLean.HasAdjDiffAt K (fun x => y) x"}
{"name":"SciLean.dite.arg_te.HasAdjDiffAt_rule","declaration":"theorem SciLean.dite.arg_te.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (x : X) (c : Prop) [dec : Decidable c] (t : c → X → Y) (e : ¬c → X → Y) (ht : ∀ (h : c), SciLean.HasAdjDiffAt K (t h) x) (he : ∀ (h : ¬c), SciLean.HasAdjDiffAt K (e h) x) : SciLean.HasAdjDiffAt K (fun x => if x_1 : c then t x_1 x else e x_1 x) x"}
{"name":"SciLean.HasAdjDiffAt.cdifferentiableAt","declaration":"theorem SciLean.HasAdjDiffAt.cdifferentiableAt (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (x : X) (hf : SciLean.HasAdjDiffAt K f x) : SciLean.CDifferentiableAt K f x"}
{"name":"SciLean.HasAdjDiff.let_rule","declaration":"theorem SciLean.HasAdjDiff.let_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_4} [SciLean.SemiInnerProductSpace K Z] (f : X → Y → Z) (g : X → Y) (hf : SciLean.HasAdjDiff K ↿f) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiff K fun x =>\n  let y := g x;\n  f x y"}
{"name":"SciLean.HMul.hMul.arg_a0a1.HasAdjDiffAt_rule","declaration":"def SciLean.HMul.hMul.arg_a0a1.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (x : X) (f : X → K) (g : X → K) (hf : SciLean.HasAdjDiffAt K f x) (hg : SciLean.HasAdjDiffAt K g x) : SciLean.HasAdjDiffAt K (fun x => f x * g x) x"}
{"name":"SciLean.HSMul.hSMul.arg_a1.HasAdjDiff_rule","declaration":"theorem SciLean.HSMul.hSMul.arg_a1.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (c : K) (g : X → Y) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiff K fun x => c • g x"}
{"name":"SciLean.ite.arg_te.HasAdjDiffAt_rule","declaration":"theorem SciLean.ite.arg_te.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (x : X) (c : Prop) [dec : Decidable c] (t : X → Y) (e : X → Y) (ht : SciLean.HasAdjDiffAt K t x) (he : SciLean.HasAdjDiffAt K e x) : SciLean.HasAdjDiffAt K (fun x => if c then t x else e x) x"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.HasAdjDiffAt_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.HasAdjDiffAt K f x) (hg : SciLean.HasAdjDiffAt K g x) : SciLean.HasAdjDiffAt K (fun x => f x + g x) x"}
{"name":"SciLean.dite.arg_te.HasAdjDiff_rule","declaration":"theorem SciLean.dite.arg_te.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (c : Prop) [dec : Decidable c] (t : c → X → Y) (e : ¬c → X → Y) (ht : ∀ (h : c), SciLean.HasAdjDiff K (t h)) (he : ∀ (h : ¬c), SciLean.HasAdjDiff K (e h)) : SciLean.HasAdjDiff K fun x => if x_1 : c then t x_1 x else e x_1 x"}
{"name":"SciLean.IndexType.sum.arg_f.HasAdjDiff_rule","declaration":"theorem SciLean.IndexType.sum.arg_f.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {ι : Type u_4} [SciLean.IndexType ι] (f : X → ι → Y) (hf : ∀ (i : ι), SciLean.HasAdjDiff K fun x => f x i) : SciLean.HasAdjDiff K fun x =>  ∑ i, f x i"}
{"name":"SciLean.Prod.fst.arg_self.HasAdjDiff_rule","declaration":"theorem SciLean.Prod.fst.arg_self.HasAdjDiff_rule (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_2} [SciLean.SemiInnerProductSpace K Z] (f : X → Y × Z) (hf : SciLean.HasAdjDiff K f) : SciLean.HasAdjDiff K fun x => (f x).1"}
{"name":"SciLean.Prod.mk.arg_fstsnd.HasAdjDiff_rule","declaration":"theorem SciLean.Prod.mk.arg_fstsnd.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_4} [SciLean.SemiInnerProductSpace K Z] (g : X → Y) (hg : SciLean.HasAdjDiff K g) (f : X → Z) (hf : SciLean.HasAdjDiff K f) : SciLean.HasAdjDiff K fun x => (g x, f x)"}
{"name":"SciLean.HasAdjDiffAt","declaration":"def SciLean.HasAdjDiffAt (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (x : X) : Prop"}
{"name":"SciLean.HasAdjDiffAt.id_rule","declaration":"theorem SciLean.HasAdjDiffAt.id_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (x : X) : SciLean.HasAdjDiffAt K (fun x => x) x"}
{"name":"SciLean.HSub.hSub.arg_a0a1.HasAdjDiffAt_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.HasAdjDiffAt K f x) (hg : SciLean.HasAdjDiffAt K g x) : SciLean.HasAdjDiffAt K (fun x => f x - g x) x"}
{"name":"SciLean.SciLean.Norm2.norm2.arg_a0.HasAdjDiffAt_rule","declaration":"theorem SciLean.SciLean.Norm2.norm2.arg_a0.HasAdjDiffAt_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (x : X) (f : X → Y) (hf : SciLean.HasAdjDiffAt R f x) : SciLean.HasAdjDiffAt R (fun x => ‖f x‖₂²) x"}
{"name":"SciLean.HasAdjDiffAt.let_rule","declaration":"theorem SciLean.HasAdjDiffAt.let_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_4} [SciLean.SemiInnerProductSpace K Z] (f : X → Y → Z) (g : X → Y) (x : X) (hf : SciLean.HasAdjDiffAt K (↿f) (x, g x)) (hg : SciLean.HasAdjDiffAt K g x) : SciLean.HasAdjDiffAt K\n  (fun x =>\n    let y := g x;\n    f x y)\n  x"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.HasAdjDiffAt_rule","declaration":"theorem SciLean.HSMul.hSMul.arg_a0a1.HasAdjDiffAt_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] (x : X) {Y : Type u_1} [SciLean.SemiHilbert K Y] (f : X → K) (g : X → Y) (hf : SciLean.HasAdjDiffAt K f x) (hg : SciLean.HasAdjDiffAt K g x) : SciLean.HasAdjDiffAt K (fun x => f x • g x) x"}
{"name":"SciLean.SciLean.Norm2.norm2.arg_a0.HasAdjDiff_rule","declaration":"theorem SciLean.SciLean.Norm2.norm2.arg_a0.HasAdjDiff_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (f : X → Y) (hf : SciLean.HasAdjDiff R f) : SciLean.HasAdjDiff R fun x => ‖f x‖₂²"}
{"name":"SciLean.HasAdjDiff.id_rule","declaration":"theorem SciLean.HasAdjDiff.id_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] : SciLean.HasAdjDiff K fun x => x"}
{"name":"SciLean.HPow.hPow.arg_a0.HasAdjDiffAt_rule","declaration":"def SciLean.HPow.hPow.arg_a0.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (x : X) (n : ℕ) (f : X → K) (hf : SciLean.HasAdjDiffAt K f x) : SciLean.HasAdjDiffAt K (fun x => f x ^ n) x"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.HasAdjDiff_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (g : X → Y) (hf : SciLean.HasAdjDiff K f) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiff K fun x => f x + g x"}
{"name":"SciLean.Prod.snd.arg_self.HasAdjDiff_rule","declaration":"theorem SciLean.Prod.snd.arg_self.HasAdjDiff_rule (K : Type u_3) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_2} [SciLean.SemiInnerProductSpace K Z] (f : X → Y × Z) (hf : SciLean.HasAdjDiff K f) : SciLean.HasAdjDiff K fun x => (f x).2"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.HasAdjDiff_rule","declaration":"theorem SciLean.HSMul.hSMul.arg_a0a1.HasAdjDiff_rule (K : Type u_2) [RCLike K] {X : Type u_3} [SciLean.SemiInnerProductSpace K X] {Y : Type u_1} [SciLean.SemiHilbert K Y] (f : X → K) (g : X → Y) (hf : SciLean.HasAdjDiff K f) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiff K fun x => f x • g x"}
{"name":"SciLean.Neg.neg.arg_a0.HasAdjDiff_rule","declaration":"theorem SciLean.Neg.neg.arg_a0.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (hf : SciLean.HasAdjDiff K f) : SciLean.HasAdjDiff K fun x => -f x"}
{"name":"SciLean.HasAdjDiff","declaration":"def SciLean.HasAdjDiff (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) : Prop"}
{"name":"SciLean.SciLean.cderiv.arg_dx.HasSemiAdjoint_rule","declaration":"theorem SciLean.SciLean.cderiv.arg_dx.HasSemiAdjoint_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_3} [SciLean.SemiInnerProductSpace K Z] (f : Y → Z) (g : X → Y) (y : Y) (hf : SciLean.HasAdjDiff K f) (hg : SciLean.HasSemiAdjoint K g) : SciLean.HasSemiAdjoint K fun dx => SciLean.cderiv K f y (g dx)"}
{"name":"SciLean.HDiv.hDiv.arg_a0a1.HasAdjDiffAt_rule","declaration":"def SciLean.HDiv.hDiv.arg_a0a1.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (x : X) (f : X → K) (g : X → K) (hf : SciLean.HasAdjDiffAt K f x) (hg : SciLean.HasAdjDiffAt K g x) (hx : g x ≠ 0) : SciLean.HasAdjDiffAt K (fun x => f x / g x) x"}
{"name":"SciLean.Neg.neg.arg_a0.HasAdjDiffAt_rule","declaration":"theorem SciLean.Neg.neg.arg_a0.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (x : X) (f : X → Y) (hf : SciLean.HasAdjDiffAt K f x) : SciLean.HasAdjDiffAt K (fun x => -f x) x"}
{"name":"SciLean.HasAdjDiff.comp_rule","declaration":"theorem SciLean.HasAdjDiff.comp_rule (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_3} [SciLean.SemiInnerProductSpace K Z] (f : Y → Z) (g : X → Y) (hf : SciLean.HasAdjDiff K f) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiff K fun x => f (g x)"}
{"name":"SciLean.HPow.hPow.arg_a0.HasAdjDiff_rule","declaration":"def SciLean.HPow.hPow.arg_a0.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] (n : ℕ) (f : X → K) (hf : SciLean.HasAdjDiff K f) : SciLean.HasAdjDiff K fun x => f x ^ n"}
{"name":"SciLean.SciLean.cderiv.arg_dx.HasSemiAdjoint_rule_at","declaration":"theorem SciLean.SciLean.cderiv.arg_dx.HasSemiAdjoint_rule_at (K : Type u_1) [RCLike K] {X : Type u_4} [SciLean.SemiInnerProductSpace K X] {Y : Type u_2} [SciLean.SemiInnerProductSpace K Y] {Z : Type u_3} [SciLean.SemiInnerProductSpace K Z] (f : Y → Z) (g : X → Y) (y : Y) (hf : SciLean.HasAdjDiffAt K f y) (hg : SciLean.HasSemiAdjoint K g) : SciLean.HasSemiAdjoint K fun dx => SciLean.cderiv K f y (g dx)"}
{"name":"SciLean.HSub.hSub.arg_a0a1.HasAdjDiff_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.HasAdjDiff_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] (f : X → Y) (g : X → Y) (hf : SciLean.HasAdjDiff K f) (hg : SciLean.HasAdjDiff K g) : SciLean.HasAdjDiff K fun x => f x - g x"}
{"name":"SciLean.Inner.inner.arg_a0a1.HasAdjDiffAt_rule","declaration":"theorem SciLean.Inner.inner.arg_a0a1.HasAdjDiffAt_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.SemiInnerProductSpace R X] {Y : Type u_3} [SciLean.SemiHilbert R Y] (x : X) (f : X → Y) (g : X → Y) (hf : SciLean.HasAdjDiffAt R f x) (hg : SciLean.HasAdjDiffAt R g x) : SciLean.HasAdjDiffAt R (fun x => ⟪f x, g x⟫_R) x"}
{"name":"SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule","declaration":"theorem SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] {Y : Type u_3} [SciLean.SemiInnerProductSpace K Y] {W : Type u_4} [SciLean.SemiInnerProductSpace K W] (w : W) (f : X → Y) (a0 : W → Y) (hf : SciLean.CDifferentiable K f) (ha0 : SciLean.HasAdjDiffAt K a0 w) : SciLean.HasAdjDiffAt K (fun w => SciLean.semiAdjoint K f (a0 w)) w"}
