{"name":"SciLean.cintegral.arg_f.fwdDeriv_rule","declaration":"theorem SciLean.cintegral.arg_f.fwdDeriv_rule {β : Type u_1} [MeasurableSpace β] {R : Type u_2} [RCLike R] {X : Type u_3} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] [Module ℝ Z] (f : X → β → Z) (μ : MeasureTheory.Measure β) (hf : ∀ (x : β), SciLean.CDifferentiable R fun x_1 => f x_1 x) : (SciLean.fwdDeriv R fun x => ∫' y, f x y ∂μ) = fun x dx => ∫' y, SciLean.fwdDeriv R (fun x => f x y) x dx ∂μ"}
{"name":"SciLean.cintegral.arg_f.IsSmoothLinearMap_rule","declaration":"theorem SciLean.cintegral.arg_f.IsSmoothLinearMap_rule {β : Type u_1} [MeasurableSpace β] {R : Type u_2} [RCLike R] {X : Type u_3} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] [Module ℝ Z] (f : X → β → Z) (μ : MeasureTheory.Measure β) (hf : ∀ (y : β), SciLean.IsSmoothLinearMap R fun x => f x y) : SciLean.IsSmoothLinearMap R fun x => ∫' y, f x y ∂μ"}
{"name":"SciLean.cintegral.arg_f.IsLinearMap_rule","declaration":"theorem SciLean.cintegral.arg_f.IsLinearMap_rule {β : Type u_1} [MeasurableSpace β] {R : Type u_2} [RCLike R] {X : Type u_3} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] [Module ℝ Z] (f : X → β → Z) (μ : MeasureTheory.Measure β) (hf : ∀ (y : β), IsLinearMap R fun x => f x y) : IsLinearMap R fun x => ∫' y, f x y ∂μ"}
{"name":"SciLean.cintegral_prod_mk'","declaration":"theorem SciLean.cintegral_prod_mk' {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] {Y : Type u_3} [AddCommGroup Y] [Module ℝ Y] {f : α → X} {g : α → Y} {μ : MeasureTheory.Measure α} : (∫' x, f x ∂μ, ∫' x, g x ∂μ) = ∫' x, (f x, g x) ∂μ"}
{"name":"SciLean.«term∫'_In_,_∂_»","declaration":"def SciLean.«term∫'_In_,_∂_»  : Lean.ParserDescr"}
{"name":"SciLean.cintegral.arg_f.cderiv_rule","declaration":"theorem SciLean.cintegral.arg_f.cderiv_rule {β : Type u_1} [MeasurableSpace β] {R : Type u_2} [RCLike R] {X : Type u_3} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] [Module ℝ Z] (f : X → β → Z) (μ : MeasureTheory.Measure β) (hf : ∀ (y : β), SciLean.CDifferentiable R fun x => f x y) : (SciLean.cderiv R fun x => ∫' y, f x y ∂μ) = fun x dx => ∫' y, SciLean.cderiv R (fun x => f x y) x dx ∂μ"}
{"name":"SciLean.cintegral_unit","declaration":"theorem SciLean.cintegral_unit {X : Type u_1} [AddCommGroup X] [Module ℝ X] {f : Unit → X} : ∫' x, f x ∂MeasureTheory.volume = f ()"}
{"name":"SciLean.cintegral_smul","declaration":"theorem SciLean.cintegral_smul {α : Type u_1} [MeasurableSpace α] {X : Type u_3} [AddCommGroup X] [Module ℝ X] {μ : MeasureTheory.Measure α} {R : Type u_2} [Semiring R] [Module R X] {f : α → X} (r : R) : ∫' x, r • f x ∂μ = r • ∫' x, f x ∂μ"}
{"name":"SciLean.cintegral_measure_map","declaration":"theorem SciLean.cintegral_measure_map {α : Type u_1} [MeasurableSpace α] {β : Type u_3} [MeasurableSpace β] {X : Type u_2} [AddCommGroup X] [Module ℝ X] (g : β → X) (f : α → β) (μ : MeasureTheory.Measure α) : ∫' y, g y ∂MeasureTheory.Measure.map f μ = ∫' x, g (f x) ∂μ"}
{"name":"SciLean.cintegral","declaration":"/-- Convenient integral - the integral I need :)\nIt should be Bochner integral but it should integrate function valued function point wise i.e.\n```\n∫ x, fun y => f x y = fun y => ∫ x, f x y\n```\nwhere rhs can be understoods as Bochenr integral and lhs defined thie `cintegral`. -/\nopaque SciLean.cintegral {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] (f : α → X) (μ : MeasureTheory.Measure α) : X"}
{"name":"SciLean.split_integral_over_set_of_ite","declaration":"theorem SciLean.split_integral_over_set_of_ite {R : Type u_3} [SciLean.RealScalar R] [DecidableRel fun x x_1 => x ≤ x_1] {X : Type u_1} [MeasureTheory.MeasureSpace X] {Y : Type u_2} [AddCommGroup Y] [Module ℝ Y] (φ : X → R) (ψ : X → R) (f : X → Y) (g : X → Y) (A : Set X) : ∫' x, if ψ x ≤ φ x then f x else g x ∂MeasureTheory.volume.restrict A =\n  ∫' x, f x ∂MeasureTheory.volume.restrict ({x' | 0 ≤ φ x' - ψ x'} ∩ A) +\n    ∫' x, g x ∂MeasureTheory.volume.restrict ({x' | 0 ≤ ψ x' - φ x'} ∩ A)"}
{"name":"SciLean.cintegral_add'","declaration":"theorem SciLean.cintegral_add' {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] {f : α → X} {g : α → X} {μ : MeasureTheory.Measure α} (hf : SciLean.CIntegrable f μ) (hg : SciLean.CIntegrable g μ) : ∫' x, f x ∂μ + ∫' x, g x ∂μ = ∫' x, f x + g x ∂μ"}
{"name":"SciLean.cintegral_zero","declaration":"theorem SciLean.cintegral_zero {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] (μ : MeasureTheory.Measure α) : ∫' x, 0 ∂μ = 0"}
{"name":"SciLean.unexpandCIntegral","declaration":"def SciLean.unexpandCIntegral  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.cintegral_smul'","declaration":"theorem SciLean.cintegral_smul' {α : Type u_1} [MeasurableSpace α] {X : Type u_3} [AddCommGroup X] [Module ℝ X] {μ : MeasureTheory.Measure α} {R : Type u_2} [Semiring R] [Module R X] {f : α → X} (r : R) : r • ∫' x, f x ∂μ = ∫' x, r • f x ∂μ"}
{"name":"SciLean.integral_in_set_simp","declaration":"theorem SciLean.integral_in_set_simp {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] (f : α → X) (g : α → X) (A : Set α) (h : ∀ x ∈ A, f x = g x) (μ : MeasureTheory.Measure α) : ∫' x, f x ∂μ.restrict A = ∫' x, g x ∂μ.restrict A"}
{"name":"SciLean.cintegral_add","declaration":"theorem SciLean.cintegral_add {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] {f : α → X} {g : α → X} {μ : MeasureTheory.Measure α} (hf : SciLean.CIntegrable f μ) (hg : SciLean.CIntegrable g μ) : ∫' x, f x + g x ∂μ = ∫' x, f x ∂μ + ∫' x, g x ∂μ"}
{"name":"SciLean.cintegral.arg_f.push_lambda","declaration":"theorem SciLean.cintegral.arg_f.push_lambda {β : Type u_2} [MeasurableSpace β] {X : Type u_3} [AddCommGroup X] [Module ℝ X] {α : Type u_1} (f : α → β → X) (μ : MeasureTheory.Measure β) : (fun x => ∫' y, f x y ∂μ) = ∫' y, (fun x => f x y) ∂μ"}
{"name":"SciLean.split_integral_of_ite","declaration":"theorem SciLean.split_integral_of_ite {R : Type u_3} [SciLean.RealScalar R] [DecidableRel fun x x_1 => x ≤ x_1] {X : Type u_2} [MeasureTheory.MeasureSpace X] {Y : Type u_1} [AddCommGroup Y] [Module ℝ Y] (φ : X → R) (ψ : X → R) (f : X → Y) (g : X → Y) : ∫' x, if ψ x ≤ φ x then f x else g x ∂MeasureTheory.volume =\n  ∫' x, f x ∂MeasureTheory.volume.restrict {x' | ψ x' ≤ φ x'} +\n    ∫' x, g x ∂MeasureTheory.volume.restrict {x' | φ x' < ψ x'}"}
{"name":"SciLean.integral_simproc","declaration":"def SciLean.integral_simproc  : Lean.Meta.Simp.Simproc"}
{"name":"SciLean.cintegral_prod_mk","declaration":"theorem SciLean.cintegral_prod_mk {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] {Y : Type u_3} [AddCommGroup Y] [Module ℝ Y] {f : α → X} {g : α → Y} {μ : MeasureTheory.Measure α} : ∫' x, (f x, g x) ∂μ = (∫' x, f x ∂μ, ∫' x, g x ∂μ)"}
{"name":"SciLean.CIntegrable","declaration":"opaque SciLean.CIntegrable {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] (f : α → X) (μ : MeasureTheory.Measure α) : Prop"}
{"name":"SciLean.cintegral_lambda","declaration":"theorem SciLean.cintegral_lambda {β : Type u_2} [MeasurableSpace β] {X : Type u_3} [AddCommGroup X] [Module ℝ X] {α : Type u_1} (f : α → β → X) (μ : MeasureTheory.Measure β) : (fun x => ∫' y, f x y ∂μ) = ∫' y, (fun x => f x y) ∂μ"}
{"name":"SciLean.cintegral.arg_f.CDifferentiable_rule","declaration":"theorem SciLean.cintegral.arg_f.CDifferentiable_rule {β : Type u_1} [MeasurableSpace β] {R : Type u_2} [RCLike R] {X : Type u_3} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] [Module ℝ Z] (f : X → β → Z) (μ : MeasureTheory.Measure β) (hf : ∀ (x : β), SciLean.CDifferentiable R fun x_1 => f x_1 x) : SciLean.CDifferentiable R fun x => ∫' y, f x y ∂μ"}
{"name":"SciLean.cintegral_add_measures","declaration":"theorem SciLean.cintegral_add_measures {α : Type u_1} [MeasurableSpace α] {X : Type u_2} [AddCommGroup X] [Module ℝ X] {f : α → X} {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure α} (hμ : SciLean.CIntegrable f μ) (hν : SciLean.CIntegrable f ν) : ∫' x, f x ∂(μ + ν) = ∫' x, f x ∂μ + ∫' x, f x ∂ν"}
{"name":"SciLean.cintegral_dirac","declaration":"theorem SciLean.cintegral_dirac {α : Type u_2} [MeasurableSpace α] {X : Type u_1} [AddCommGroup X] [Module ℝ X] {f : α → X} (p : α) : ∫' x, f x ∂MeasureTheory.Measure.dirac p = f p"}
