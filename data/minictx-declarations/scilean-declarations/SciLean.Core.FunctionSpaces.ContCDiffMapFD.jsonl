{"name":"SciLean.ContCDiffMapFD.dir_independence","declaration":"def SciLean.ContCDiffMapFD.dir_independence {K : Type u_1} [RCLike K] {n : ℕ∞} {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (self : X ⟿FD[K,n] Y) (x : X) (dx : X) : self.toFun x dx = self.toFun x 0"}
{"name":"SciLean.ContCDiffMapFD_apply_linearSmoothMap","declaration":"theorem SciLean.ContCDiffMapFD_apply_linearSmoothMap {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] {n : ℕ∞} (f : W → X ⟿FD[K,n] Y) (hf : SciLean.IsSmoothLinearMap K f) (x : X) : SciLean.IsSmoothLinearMap K fun w => (f w) x"}
{"name":"SciLean.ContCDiffMapFD_fwdDeriv_rule","declaration":"theorem SciLean.ContCDiffMapFD_fwdDeriv_rule {K : Type u_4} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] {W : Type u_5} [SciLean.Vec K W] (f : W → (X ⟿FD[K,⊤] Y) × Z) (g : W → X) : (SciLean.fwdDeriv K fun w => (f w).1 (g w)) = fun w dw =>\n  let fdfz := SciLean.fwdDeriv K f w dw;\n  let xdx := SciLean.fwdDeriv K g w dw;\n  let fw := fdfz.1.1;\n  let df := fdfz.2.1;\n  let zdz := fw.FD xdx.1 xdx.2;\n  (zdz.1, df xdx.1 + zdz.2)"}
{"name":"SciLean.ContCDiffMapFD.is_cont_cdiff_map","declaration":"def SciLean.ContCDiffMapFD.is_cont_cdiff_map {K : Type u_1} [RCLike K] {n : ℕ∞} {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (self : X ⟿FD[K,n] Y) : SciLean.ContCDiff K n fun x => (self.toFun x 0).1"}
{"name":"SciLean.«termFun_⟿FD[_]_»","declaration":"def SciLean.«termFun_⟿FD[_]_»  : Lean.ParserDescr"}
{"name":"SciLean.instSubContCDiffMapFD","declaration":"instance SciLean.instSubContCDiffMapFD {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} : Sub (X ⟿FD[K,n] Y)"}
{"name":"SciLean.ContCDiffMapFD_eval_fwdDeriv","declaration":"theorem SciLean.ContCDiffMapFD_eval_fwdDeriv {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) : (SciLean.fwdDeriv K fun x => f x) = f.FD"}
{"name":"SciLean.ContCDiffMapFD.sub_apply","declaration":"theorem SciLean.ContCDiffMapFD.sub_apply {K : Type u_3} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) (g : X ⟿FD[K,n] Y) (x : X) : (f - g) x = f x - g x"}
{"name":"SciLean.ContCDiffMapFD_apply_right","declaration":"theorem SciLean.ContCDiffMapFD_apply_right (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) (f : X ⟿FD[K,n] Y) : SciLean.ContCDiff K n fun x => f x"}
{"name":"SciLean.ContCDiffMapFD.mk.arg_f.ContCDiff_rule","declaration":"theorem SciLean.ContCDiffMapFD.mk.arg_f.ContCDiff_rule {K : Type u_2} [RCLike K] {X : Type u_3} [SciLean.Vec K X] {Y : Type u_4} [SciLean.Vec K Y] {Z : Type u_1} [SciLean.Vec K Z] (f : X → Y → Z) (f' : X → Y → Y → Z × Z) (hf : SciLean.ContCDiff K ⊤ fun xy => f xy.1 xy.2) (h : ∀ (x : X), (SciLean.fwdDeriv K fun y => f x y) = f' x) (h' : ∀ (x : X), SciLean.ContCDiff K ⊤ (f x)) : SciLean.ContCDiff K ⊤ fun x => fun y ⟿FD[K,⊤] f x y"}
{"name":"SciLean.«term_⟿FD[_]_»","declaration":"def SciLean.«term_⟿FD[_]_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.«term_⟿FD_»","declaration":"def SciLean.«term_⟿FD_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.ContCDiffMapFD_apply_CDifferentiableAt","declaration":"theorem SciLean.ContCDiffMapFD_apply_CDifferentiableAt {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : W → X ⟿FD[K,⊤] Y) (g : W → X) (w : W) (hf : SciLean.CDifferentiableAt K f w) (hg : SciLean.CDifferentiableAt K g w) : SciLean.CDifferentiableAt K (fun w => (f w) (g w)) w"}
{"name":"SciLean.ContCDiffMapFD_eval_cdifferentiable'","declaration":"theorem SciLean.ContCDiffMapFD_eval_cdifferentiable' {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (f : X ⟿FD[K,⊤] Y) : SciLean.CDifferentiable K fun x => f x"}
{"name":"SciLean.instUniformSpaceContCDiffMapFD","declaration":"instance SciLean.instUniformSpaceContCDiffMapFD {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} : UniformSpace (X ⟿FD[K,n] Y)"}
{"name":"SciLean.ContCDiffMapFD.neg_apply","declaration":"theorem SciLean.ContCDiffMapFD.neg_apply {K : Type u_3} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) (x : X) : (-f) x = -f x"}
{"name":"SciLean.ContCDiffMapFD_eval_CDifferentiable","declaration":"theorem SciLean.ContCDiffMapFD_eval_CDifferentiable {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} (h : 0 < n) : SciLean.CDifferentiable K fun fx => fx.1 fx.2"}
{"name":"SciLean.ContCDiffMapFD.FD_fst","declaration":"theorem SciLean.ContCDiffMapFD.FD_fst {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) (x : X) (dx : X) : (f.FD x dx).1 = f x"}
{"name":"SciLean.instZeroContCDiffMapFD","declaration":"instance SciLean.instZeroContCDiffMapFD {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} : Zero (X ⟿FD[K,n] Y)"}
{"name":"SciLean.ContCDiffMapFD.mk.arg_f.ContCDiff_rule_partial","declaration":"theorem SciLean.ContCDiffMapFD.mk.arg_f.ContCDiff_rule_partial {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {Z : Type u_4} [SciLean.Vec K Z] (n : ℕ) (l : ℕ) (k : ℕ) (f : X → Y → Z) (hf : SciLean.ContCDiff K ↑n fun xy => f xy.1 xy.2) (h : l + k ≤ n) : SciLean.ContCDiff K ↑k fun x => fun y ⟿FD[K,↑l] f x y"}
{"name":"SciLean.ContCDiffMapFD_partial","declaration":"theorem SciLean.ContCDiffMapFD_partial {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (n : ℕ) (f : W → X ⟿FD[K,↑n] Y) (g : W → X) (hf : SciLean.ContCDiff K (↑n) f) (hg : SciLean.ContCDiff K (↑n) g) : SciLean.ContCDiff K ↑n fun w => (f w) (g w)"}
{"name":"SciLean.ContCDiffMapFD.mk","declaration":"ctor SciLean.ContCDiffMapFD.mk {K : Type u_1} [RCLike K] {n : ℕ∞} {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (toFun : X → X → Y × Y) (is_cont_cdiff_map : SciLean.ContCDiff K n fun x => (toFun x 0).1) (cderiv_snd : ∂ x, (toFun x 0).1 = fun x dx => (toFun x dx).2) (dir_independence : ∀ (x dx : X), toFun x dx = toFun x 0) : X ⟿FD[K,n] Y"}
{"name":"SciLean.ContCDiffMapFD_cderiv_rule","declaration":"theorem SciLean.ContCDiffMapFD_cderiv_rule {K : Type u_4} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {Z : Type u_3} [SciLean.Vec K Z] {W : Type u_5} [SciLean.Vec K W] (f : W → (X ⟿FD[K,⊤] Y) × Z) (g : W → X) : ∂ w, (f w).1 (g w) = fun w dw =>\n  let dfz := ∂ f w dw;\n  let fwz := f w;\n  let x := g w;\n  let dx := ∂ g w dw;\n  dfz.1 x + (fwz.1.FD x dx).2"}
{"name":"SciLean.instNegContCDiffMapFD","declaration":"instance SciLean.instNegContCDiffMapFD {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} : Neg (X ⟿FD[K,n] Y)"}
{"name":"SciLean.ContCDiffMapFD_apply","declaration":"theorem SciLean.ContCDiffMapFD_apply {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : W → X ⟿FD[K,⊤] Y) (g : W → X) (hf : SciLean.ContCDiff K ⊤ f) (hg : SciLean.ContCDiff K ⊤ g) : SciLean.ContCDiff K ⊤ fun w => (f w) (g w)"}
{"name":"SciLean.instSMulContCDiffMapFD","declaration":"instance SciLean.instSMulContCDiffMapFD {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} : SMul K (X ⟿FD[K,n] Y)"}
{"name":"SciLean.ContCDiffMapFD.add_apply","declaration":"theorem SciLean.ContCDiffMapFD.add_apply {K : Type u_3} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) (g : X ⟿FD[K,n] Y) (x : X) : (f + g) x = f x + g x"}
{"name":"SciLean.instFunLikeContCDiffMapFD","declaration":"instance SciLean.instFunLikeContCDiffMapFD (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) : FunLike (X ⟿FD[K,n] Y) X Y"}
{"name":"SciLean.ContCDiffMapFD.toFun","declaration":"def SciLean.ContCDiffMapFD.toFun {K : Type u_1} [RCLike K] {n : ℕ∞} {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (self : X ⟿FD[K,n] Y) : X → X → Y × Y"}
{"name":"SciLean.«termFun_⟿FD[_,_]_»","declaration":"def SciLean.«termFun_⟿FD[_,_]_»  : Lean.ParserDescr"}
{"name":"SciLean.ContCDiffMapFD_eval_cdifferentiable","declaration":"theorem SciLean.ContCDiffMapFD_eval_cdifferentiable {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) (h : 0 < n) : SciLean.CDifferentiable K fun x => f x"}
{"name":"SciLean.ContCDiffMapFD.mk'","declaration":"def SciLean.ContCDiffMapFD.mk' (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] (n : ℕ∞) (f : X → Y) (f' : X → X → Y × Y) (h : SciLean.fwdDeriv K f = f') (hf : SciLean.ContCDiff K n f) : X ⟿FD[K,n] Y"}
{"name":"SciLean.unexpandContCDiffMapFDMk","declaration":"def SciLean.unexpandContCDiffMapFDMk  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.instVecContCDiffMapFD","declaration":"instance SciLean.instVecContCDiffMapFD {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} : SciLean.Vec K (X ⟿FD[K,n] Y)"}
{"name":"SciLean.ContCDiffMapFD","declaration":"structure SciLean.ContCDiffMapFD (K : Type u_1) [RCLike K] (n : ℕ∞) (X : Type u_2) (Y : Type u_3) [SciLean.Vec K X] [SciLean.Vec K Y] : Type (max u_2 u_3)"}
{"name":"SciLean.ContCDiffMapFD.smul_apply","declaration":"theorem SciLean.ContCDiffMapFD.smul_apply {K : Type u_3} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) (x : X) (r : K) : (r • f) x = r • f x"}
{"name":"SciLean.ContCDiffMapFD_eta","declaration":"theorem SciLean.ContCDiffMapFD_eta {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) : (fun x ⟿FD[K,n] f x) = f"}
{"name":"SciLean.ContCDiffMapFD.zero_apply","declaration":"theorem SciLean.ContCDiffMapFD.zero_apply {K : Type u_3} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {n : ℕ∞} (x : X) : 0 x = 0"}
{"name":"SciLean.unexpandContCDiffMapFD","declaration":"def SciLean.unexpandContCDiffMapFD  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.«term_⟿FD[_,_]_»","declaration":"def SciLean.«term_⟿FD[_,_]_»  : Lean.TrailingParserDescr"}
{"name":"SciLean.ContCDiffMapFD_apply_CDifferentiable","declaration":"theorem SciLean.ContCDiffMapFD_apply_CDifferentiable {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] (f : W → X ⟿FD[K,⊤] Y) (g : W → X) (hf : SciLean.CDifferentiable K f) (hg : SciLean.CDifferentiable K g) : SciLean.CDifferentiable K fun w => (f w) (g w)"}
{"name":"SciLean.ContCDiffMapFD.FD","declaration":"def SciLean.ContCDiffMapFD.FD {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} (f : X ⟿FD[K,n] Y) (x : X) (dx : X) : Y × Y"}
{"name":"SciLean.«termFun_⟿FD_»","declaration":"def SciLean.«termFun_⟿FD_»  : Lean.ParserDescr"}
{"name":"SciLean.instAddContCDiffMapFD","declaration":"instance SciLean.instAddContCDiffMapFD {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] {n : ℕ∞} : Add (X ⟿FD[K,n] Y)"}
{"name":"SciLean.ContCDiffMapFD_eval_CDifferentiable'","declaration":"theorem SciLean.ContCDiffMapFD_eval_CDifferentiable' {K : Type u_1} [RCLike K] {X : Type u_2} [SciLean.Vec K X] {Y : Type u_3} [SciLean.Vec K Y] : SciLean.CDifferentiable K fun fx => fx.1 fx.2"}
{"name":"SciLean.ContCDiffMapFD.cderiv_snd","declaration":"def SciLean.ContCDiffMapFD.cderiv_snd {K : Type u_1} [RCLike K] {n : ℕ∞} {X : Type u_2} {Y : Type u_3} [SciLean.Vec K X] [SciLean.Vec K Y] (self : X ⟿FD[K,n] Y) : ∂ x, (self.toFun x 0).1 = fun x dx => (self.toFun x dx).2"}
{"name":"SciLean.ContCDiffMapFD.mk.arg_f.IsSmoothLinearMap_rule","declaration":"theorem SciLean.ContCDiffMapFD.mk.arg_f.IsSmoothLinearMap_rule {K : Type u_2} [RCLike K] {X : Type u_3} [SciLean.Vec K X] {Y : Type u_1} [SciLean.Vec K Y] {W : Type u_4} [SciLean.Vec K W] {n : ℕ∞} (f : W → X → Y) (f' : W → X → X → Y × Y) (hf₁ : SciLean.CDifferentiable K fun x =>\n  match x with\n  | (w, x) => f w x) (hf₂ : IsLinearMap K f) (hf₃ : ∀ (w : W), SciLean.ContCDiff K n (f w)) (h : ∀ (w : W), (SciLean.fwdDeriv K fun x => f w x) = f' w) (h' : ∀ (w : W), SciLean.ContCDiff K n (f w)) : SciLean.IsSmoothLinearMap K fun w => fun x ⟿FD[K,n] f w x"}
