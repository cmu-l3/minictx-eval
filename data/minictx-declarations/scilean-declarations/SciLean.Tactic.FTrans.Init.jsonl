{"name":"SciLean.FTrans.PiLInvData.f","declaration":"def SciLean.FTrans.PiLInvData.f (self : SciLean.FTrans.PiLInvData) : Q(unknown_1 → unknown_2 → unknown_3)"}
{"name":"SciLean.FTrans.PiLInvData.I","declaration":"def SciLean.FTrans.PiLInvData.I (self : SciLean.FTrans.PiLInvData) : Q(Type)"}
{"name":"SciLean.FTrans.getFTransExt?","declaration":"/-- Returns function transformation info if `e` is function tranformation expression.\n-/\ndef SciLean.FTrans.getFTransExt? (e : Lean.Expr) : Lean.CoreM (Option SciLean.FTrans.FTransExt)"}
{"name":"SciLean.FTrans.FTransExt.projRule","declaration":"/-- Custom rule for transforming `fun (x : (i' : ι) → X i') => x i` -/\ndef SciLean.FTrans.FTransExt.projRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (X : Lean.Expr) (i : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.PiInvData.h","declaration":"def SciLean.FTrans.PiInvData.h (self : SciLean.FTrans.PiInvData) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.FTrans.FTransExt.piCompRule","declaration":"/-- Custom rule for transforming `fun x i => f (g x i) i` -/\ndef SciLean.FTrans.FTransExt.piCompRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (g : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.PiLInvData.is_inverse","declaration":"def SciLean.FTrans.PiLInvData.is_inverse (self : SciLean.FTrans.PiLInvData) : Q(∀ (i₁ : unknown_1), Function.Inverse (unknown_4 i₁) fun i₂ => unknown_6 (unknown_7 i₁ i₂))"}
{"name":"SciLean.FTrans.FTransExt.piProdRule","declaration":"/-- Custom rule for transforming `fun x i => (f x i, g x i)` -/\ndef SciLean.FTrans.FTransExt.piProdRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (g : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.FTransExt.ftransName","declaration":"/-- Function transformation name -/\ndef SciLean.FTrans.FTransExt.ftransName (self : SciLean.FTrans.FTransExt) : Lean.Name"}
{"name":"SciLean.FTrans.PiInvData.X","declaration":"def SciLean.FTrans.PiInvData.X (self : SciLean.FTrans.PiInvData) : Q(Type udummy._uniq.192)"}
{"name":"SciLean.FTrans.PiLInvData.I₂","declaration":"def SciLean.FTrans.PiLInvData.I₂ (self : SciLean.FTrans.PiLInvData) : Q(Type)"}
{"name":"SciLean.FTrans.FTransRule.ruleName","declaration":"def SciLean.FTrans.FTransRule.ruleName (self : SciLean.FTrans.FTransRule) : Lean.Name"}
{"name":"SciLean.FTrans.FTransRule.mainIds","declaration":"/-- Set of main argument indices in this rule\nFor example:\n - rule `∂ (fun x => @HAdd.hAdd _ _ _ _ (f x) (g x)) = ...` has `mainIds = #[4,5]`\n - rule `∂ (fun x => @HAdd.hAdd _ _ _ _ (f x) y) = ...` has `mainIds = #[4]` -/\ndef SciLean.FTrans.FTransRule.mainIds (self : SciLean.FTrans.FTransRule) : SciLean.ArraySet ℕ"}
{"name":"SciLean.FTrans.FTransExt","declaration":"structure SciLean.FTrans.FTransExt  : Type"}
{"name":"SciLean.FTrans.FTransExt.piRule","declaration":"/-- Custom rule for transforming `fun x y => f x y` -/\ndef SciLean.FTrans.FTransExt.piRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.getFTransPiRules","declaration":"def SciLean.FTrans.getFTransPiRules (funName : Lean.Name) (ftransName : Lean.Name) : Lean.CoreM (Array Lean.Meta.SimpTheorem)"}
{"name":"SciLean.FTrans.FTransExt.replaceFTransFun","declaration":"/-- Replace function being transformed in function transformation expression -/\ndef SciLean.FTrans.FTransExt.replaceFTransFun (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (newFun : Lean.Expr) : Lean.Expr"}
{"name":"SciLean.FTrans.FTransExt.compRule","declaration":"/-- Custom rule for transforming `fun x => f (g x)` or `fun x => let y := g x; f y` -/\ndef SciLean.FTrans.FTransExt.compRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (g : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.PiLInvData.h","declaration":"def SciLean.FTrans.PiLInvData.h (self : SciLean.FTrans.PiLInvData) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.FTrans.FTransExt.prodSnd","declaration":"def SciLean.FTrans.FTransExt.prodSnd (self : SciLean.FTrans.FTransExt) : Lean.Name"}
{"name":"SciLean.FTrans.PiLInvData","declaration":"/-- Data for `fun x i => f x (h i)` case when `h` admits left inverse/is surjective\n\nThe domain of `h` is decomposed into `I₁×I₂` and inverse `h'` between `I₂` and `J` is provided\n-/\nstructure SciLean.FTrans.PiLInvData  : Type"}
{"name":"SciLean.FTrans.PiLInvData.q","declaration":"def SciLean.FTrans.PiLInvData.q (self : SciLean.FTrans.PiLInvData) : Q(unknown_1 → unknown_2 → unknown_3)"}
{"name":"SciLean.FTrans.PiInvData.w","declaration":"def SciLean.FTrans.PiInvData.w (self : SciLean.FTrans.PiInvData) : Lean.Level"}
{"name":"SciLean.FTrans.Parser.Attr.ftrans_simp_proc","declaration":"/-- Simplification procedure -/\ndef SciLean.FTrans.Parser.Attr.ftrans_simp_proc  : Lean.ParserDescr"}
{"name":"SciLean.FTrans.PiLInvData.p₁","declaration":"def SciLean.FTrans.PiLInvData.p₁ (self : SciLean.FTrans.PiLInvData) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.FTrans.mkFTransExt","declaration":"def SciLean.FTrans.mkFTransExt (n : Lean.Name) : Lean.ImportM SciLean.FTrans.FTransExt"}
{"name":"SciLean.FTrans.PiLInvData.I₁","declaration":"def SciLean.FTrans.PiLInvData.I₁ (self : SciLean.FTrans.PiLInvData) : Q(Type)"}
{"name":"SciLean.FTrans.FTransExt.constRule","declaration":"/-- Custom rule for transforming `fun (x : X)  => y` -/\ndef SciLean.FTrans.FTransExt.constRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (X : Lean.Expr) (y : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.FTransExt.discharger","declaration":"/-- Custom discharger for this function transformation -/\ndef SciLean.FTrans.FTransExt.discharger (self : SciLean.FTrans.FTransExt) : Lean.Expr → Lean.Meta.SimpM (Option Lean.Expr)"}
{"name":"SciLean.FTrans.ftransExt","declaration":"opaque SciLean.FTrans.ftransExt  : Lean.PersistentEnvExtension (Lean.Name × Lean.Name) (Lean.Name × SciLean.FTrans.FTransExt)\n  (Std.RBMap Lean.Name SciLean.FTrans.FTransExt Lean.Name.quickCmp)"}
{"name":"SciLean.FTrans.FTransExt.name","declaration":"/-- Name of this extension, keep the default value! -/\ndef SciLean.FTrans.FTransExt.name (self : SciLean.FTrans.FTransExt) : Lean.Name"}
{"name":"SciLean.FTrans.FTransExt.letRule","declaration":"/-- Custom rule for transforming `fun x => let y := g x; f x y` -/\ndef SciLean.FTrans.FTransExt.letRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (g : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.funTransRuleAttr","declaration":"opaque SciLean.FTrans.funTransRuleAttr  : Lean.TagAttribute"}
{"name":"SciLean.FTrans.PiInvData.mk","declaration":"ctor SciLean.FTrans.PiInvData.mk {u : Lean.Level} {v : Lean.Level} {w : Lean.Level} {w' : Lean.Level} {X : Q(Type u)} {Y : Q(Type v)} {I : Q(Type w)} {J : Q(Type w')} (f : Q(«$X» → «$J» → «$Y»)) (h : Q(«$I» → «$J»)) (h' : Q(«$J» → «$I»)) (is_inverse : Q(Function.Inverse «$h'» «$h»)) : SciLean.FTrans.PiInvData"}
{"name":"SciLean.FTrans.FTransExt.piRInvRule","declaration":"/-- Custom rule for transforming `fun x i => f x (h i)` when `h` has left inverse  -/\ndef SciLean.FTrans.FTransExt.piRInvRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (rinv : SciLean.Meta.RightInverse) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.FTransRule.priority","declaration":"def SciLean.FTrans.FTransRule.priority (self : SciLean.FTrans.FTransRule) : ℕ"}
{"name":"SciLean.FTrans.FTransExt.mk","declaration":"ctor SciLean.FTrans.FTransExt.mk (ftransName : Lean.Name) (getFTransFun? : Lean.Expr → Option Lean.Expr) (replaceFTransFun : Lean.Expr → Lean.Expr → Lean.Expr) (idRule : Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (constRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (projRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (compRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (letRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piRule : Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (useRefinedPiRules : Bool) (piIdRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piConstRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piUncurryRule : Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piCurryNRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Expr → ℕ → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piProdRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piCompRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piElemWiseCompRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piLetRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piSimpleCompRule : Lean.Expr → Lean.Expr → Lean.Expr → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piInvRule : Lean.Expr → Lean.Expr → SciLean.Meta.FullInverse → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (piRInvRule : Lean.Expr → Lean.Expr → SciLean.Meta.RightInverse → Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)) (discharger : Lean.Expr → Lean.Meta.SimpM (Option Lean.Expr)) (prodMk : Lean.Name) (prodFst : Lean.Name) (prodSnd : Lean.Name) (name : autoParam Lean.Name _auto✝) : SciLean.FTrans.FTransExt"}
{"name":"SciLean.FTrans.PiLInvData.h'","declaration":"def SciLean.FTrans.PiLInvData.h' (self : SciLean.FTrans.PiLInvData) : Q(unknown_1 → unknown_2 → unknown_3)"}
{"name":"SciLean.FTrans.PiInvData.h'","declaration":"def SciLean.FTrans.PiInvData.h' (self : SciLean.FTrans.PiInvData) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.FTrans.FTransExt.piIdRule","declaration":"/-- Custom rule for transforming `fun (x : I → X) (i : I) => x i` -/\ndef SciLean.FTrans.FTransExt.piIdRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (X : Lean.Expr) (I : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.PiInvData.J","declaration":"def SciLean.FTrans.PiInvData.J (self : SciLean.FTrans.PiInvData) : Q(Type udummy._uniq.291)"}
{"name":"SciLean.FTrans.getFTrans?","declaration":"/-- Returns function transformation name and function being tranformed if `e` is function tranformation expression.\n-/\ndef SciLean.FTrans.getFTrans? (e : Lean.Expr) : Lean.CoreM (Option (Lean.Name × SciLean.FTrans.FTransExt × Lean.Expr))"}
{"name":"SciLean.FTrans.FTransExt.piElemWiseCompRule","declaration":"/-- Custom rule for transforming `fun x i => f (g x i) i` -/\ndef SciLean.FTrans.FTransExt.piElemWiseCompRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (g : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.FTransRule.cmp","declaration":"def SciLean.FTrans.FTransRule.cmp (a : SciLean.FTrans.FTransRule) (b : SciLean.FTrans.FTransRule) : Ordering"}
{"name":"SciLean.FTrans.FTransExt.piSimpleCompRule","declaration":"/-- Custom rule for transforming `fun x i => f (g x i)` -/\ndef SciLean.FTrans.FTransExt.piSimpleCompRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (g : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.FTransExt.prodFst","declaration":"def SciLean.FTrans.FTransExt.prodFst (self : SciLean.FTrans.FTransExt) : Lean.Name"}
{"name":"SciLean.FTrans.FTransRule.trailingIds","declaration":"/-- Set of trailing argument indices in this rule\nFor example:\n- rule `∂ (fun x i => @getElem _ _ _ _ _ (f x) i dom ` has `piArgs = #[6]`\n- rule `∂ (fun f x => @Function.invFun _ _ _ f x` has `piArgs = #[4]`\n- rule `∂ (fun x => (f x) + (g x)` has `piArgs = #[]`\n-/\ndef SciLean.FTrans.FTransRule.trailingIds (self : SciLean.FTrans.FTransRule) : SciLean.ArraySet ℕ"}
{"name":"SciLean.FTrans.FTransExt.piUncurryRule","declaration":"/-- Custom rule for transforming `fun x i j => f x i j` -/\ndef SciLean.FTrans.FTransExt.piUncurryRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.getFTransFun?","declaration":"/-- Returns function transformation info if `e` is function btranformation expression.\n-/\ndef SciLean.FTrans.getFTransFun? (e : Lean.Expr) : Lean.CoreM (Option Lean.Expr)"}
{"name":"SciLean.FTrans.FTransExt.piInvRule","declaration":"/-- Custom rule for transforming `fun x i => f x (h i)` when `h` has inverse -/\ndef SciLean.FTrans.FTransExt.piInvRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (inv : SciLean.Meta.FullInverse) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.PiInvData.is_inverse","declaration":"def SciLean.FTrans.PiInvData.is_inverse (self : SciLean.FTrans.PiInvData) : Q(Function.Inverse unknown_3 unknown_4)"}
{"name":"SciLean.FTrans.PiInvData.I","declaration":"def SciLean.FTrans.PiInvData.I (self : SciLean.FTrans.PiInvData) : Q(Type udummy._uniq.278)"}
{"name":"SciLean.FTrans.PiInvData.v","declaration":"def SciLean.FTrans.PiInvData.v (self : SciLean.FTrans.PiInvData) : Lean.Level"}
{"name":"SciLean.FTrans.PiLInvData.X","declaration":"def SciLean.FTrans.PiLInvData.X (self : SciLean.FTrans.PiLInvData) : Q(Type)"}
{"name":"SciLean.FTrans.FTransExt.idRule","declaration":"/-- Custom rule for transforming `fun (x : X) => x` -/\ndef SciLean.FTrans.FTransExt.idRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (X : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.PiLInvData.Y","declaration":"def SciLean.FTrans.PiLInvData.Y (self : SciLean.FTrans.PiLInvData) : Q(Type)"}
{"name":"SciLean.FTrans.FTransRules.instInhabitedFTransRules","declaration":"instance SciLean.FTrans.FTransRules.instInhabitedFTransRules  : Inhabited SciLean.FTrans.FTransRules"}
{"name":"SciLean.FTrans.FTransRule.mk","declaration":"ctor SciLean.FTrans.FTransRule.mk (ruleName : Lean.Name) (priority : ℕ) (mainIds : SciLean.ArraySet ℕ) (trailingIds : SciLean.ArraySet ℕ) : SciLean.FTrans.FTransRule"}
{"name":"SciLean.FTrans.FTransExt.getFTransFun?","declaration":"/-- Get function being transformed from function transformation expression -/\ndef SciLean.FTrans.FTransExt.getFTransFun? (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) : Option Lean.Expr"}
{"name":"SciLean.FTrans.FTransExt.piCurryNRule","declaration":"/-- Custom rule for transforming `fun x (is : Is) => uncurryN n (f x) is` where `uncurryN n (f x)` has type `Is → Y` -/\ndef SciLean.FTrans.FTransExt.piCurryNRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (Is : Lean.Expr) (Y : Lean.Expr) (n : ℕ) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.FTransRules.empty","declaration":"def SciLean.FTrans.FTransRules.empty  : SciLean.FTrans.FTransRules"}
{"name":"SciLean.FTrans.PiInvData","declaration":"/-- Data for `fun x i => f x (h i)` case when `h` is invertible\n-/\nstructure SciLean.FTrans.PiInvData  : Type"}
{"name":"SciLean.FTrans.PiInvData.w'","declaration":"def SciLean.FTrans.PiInvData.w' (self : SciLean.FTrans.PiInvData) : Lean.Level"}
{"name":"SciLean.FTrans.FTransExt.prodMk","declaration":"def SciLean.FTrans.FTransExt.prodMk (self : SciLean.FTrans.FTransExt) : Lean.Name"}
{"name":"SciLean.FTrans.instInhabitedFTransExt","declaration":"instance SciLean.FTrans.instInhabitedFTransExt  : Inhabited SciLean.FTrans.FTransExt"}
{"name":"SciLean.FTrans.PiInvData.Y","declaration":"def SciLean.FTrans.PiInvData.Y (self : SciLean.FTrans.PiInvData) : Q(Type udummy._uniq.166)"}
{"name":"SciLean.FTrans.FTransRule","declaration":"structure SciLean.FTrans.FTransRule  : Type"}
{"name":"SciLean.FTrans.FTransExt.piConstRule","declaration":"/-- Custom rule for transforming `fun x (i : I) => f x` -/\ndef SciLean.FTrans.FTransExt.piConstRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (I : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.FTransRulesExt","declaration":"opaque SciLean.FTrans.FTransRulesExt  : Lean.MergeMapDeclarationExtension SciLean.FTrans.FTransRules"}
{"name":"SciLean.FTrans.PiLInvData.mk","declaration":"ctor SciLean.FTrans.PiLInvData.mk {X : Q(Type)} {Y : Q(Type)} {I : Q(Type)} {I₁ : Q(Type)} {I₂ : Q(Type)} {J : Q(Type)} (f : Q(«$X» → «$J» → «$Y»)) (h : Q(«$I» → «$J»)) (h' : Q(«$I₁» → «$J» → «$I₂»)) (p₁ : Q(«$I» → «$I₁»)) (p₂ : Q(«$I» → «$I₂»)) (q : Q(«$I₁» → «$I₂» → «$I»)) (is_dec : Q(SciLean.Meta.IsDecomposition «$p₁» «$p₂» «$q»)) (is_inverse : Q(∀ (i₁ : «$I₁»), Function.Inverse («$h'» i₁) fun i₂ => «$h» («$q» i₁ i₂))) : SciLean.FTrans.PiLInvData"}
{"name":"SciLean.FTrans.getFTransRules","declaration":"def SciLean.FTrans.getFTransRules (funName : Lean.Name) (ftransName : Lean.Name) : Lean.CoreM (Array Lean.Meta.SimpTheorem)"}
{"name":"SciLean.FTrans.FTransExt.useRefinedPiRules","declaration":"def SciLean.FTrans.FTransExt.useRefinedPiRules (self : SciLean.FTrans.FTransExt) : Bool"}
{"name":"SciLean.FTrans.FTransRules.insert","declaration":"def SciLean.FTrans.FTransRules.insert (fp : SciLean.FTrans.FTransRules) (ftransName : Lean.Name) (rule : SciLean.FTrans.FTransRule) : SciLean.FTrans.FTransRules"}
{"name":"SciLean.FTrans.PiLInvData.p₂","declaration":"def SciLean.FTrans.PiLInvData.p₂ (self : SciLean.FTrans.PiLInvData) : Q(unknown_1 → unknown_2)"}
{"name":"SciLean.FTrans.Parser.Attr.ftrans_simp","declaration":"def SciLean.FTrans.Parser.Attr.ftrans_simp  : Lean.ParserDescr"}
{"name":"SciLean.FTrans.FTransRules","declaration":"/-- This holds a collection of function transformation rules for a fixed constant\n-/\ndef SciLean.FTrans.FTransRules  : Type"}
{"name":"SciLean.FTrans.instOrdName","declaration":"def SciLean.FTrans.instOrdName  : Ord Lean.Name"}
{"name":"SciLean.FTrans.PiLInvData.J","declaration":"def SciLean.FTrans.PiLInvData.J (self : SciLean.FTrans.PiLInvData) : Q(Type)"}
{"name":"SciLean.FTrans.PiInvData.u","declaration":"def SciLean.FTrans.PiInvData.u (self : SciLean.FTrans.PiInvData) : Lean.Level"}
{"name":"SciLean.FTrans.FTransExt.piLetRule","declaration":"/-- Custom rule for transforming `fun x i => let y := g x i; f x y i` -/\ndef SciLean.FTrans.FTransExt.piLetRule (self : SciLean.FTrans.FTransExt) (expr : Lean.Expr) (f : Lean.Expr) (g : Lean.Expr) : Lean.Meta.SimpM (Option Lean.Meta.Simp.Step)"}
{"name":"SciLean.FTrans.PiLInvData.is_dec","declaration":"def SciLean.FTrans.PiLInvData.is_dec (self : SciLean.FTrans.PiLInvData) : Q(SciLean.Meta.IsDecomposition unknown_4 unknown_5 unknown_6)"}
{"name":"SciLean.FTrans.PiInvData.f","declaration":"def SciLean.FTrans.PiInvData.f (self : SciLean.FTrans.PiInvData) : Q(unknown_1 → unknown_2 → unknown_3)"}
