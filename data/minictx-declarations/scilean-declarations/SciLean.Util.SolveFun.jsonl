{"name":"SciLean.decompose_has_unique_solution","declaration":"theorem SciLean.decompose_has_unique_solution {Xs : Type u_1} {Ys : Type u_2} {Zs : Type u_3} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs] (f : Ys → Zs → Xs) (hf : Function.Bijective (SciLean.uncurryN 2 f)) (P : Xs → Prop) (Q₁ : Ys → Zs → Prop) (Q₂ : Ys → Zs → Prop) (equiv : ∀ (ys : Ys) (zs : Zs), Q₁ ys zs ∧ Q₂ ys zs ↔ P (f ys zs)) (unique : ∀ (ys : Ys), SciLean.HasUniqueSolution (Q₁ ys)) : SciLean.HasUniqueSolution P ↔ SciLean.HasUniqueSolution fun ys => Q₂ ys (solve zs, Q₁ ys zs)"}
{"name":"SciLean.HasUniqueSolution","declaration":"structure SciLean.HasUniqueSolution {F : Sort u_1} {Xs : Sort u_2} [SciLean.UncurryAll F Xs Prop] (P : F) : Prop"}
{"name":"SciLean.SolveFun.solveForTactic","declaration":"def SciLean.SolveFun.solveForTactic  : Lean.Elab.Tactic.Tactic"}
{"name":"SciLean.SolveFun.solve_for_core_tactic","declaration":"/-- Tactic `solve_for y w from 0 1 := uniq` will decompose `solve x y z w, ...` problem\nby first solving for `y` and `w` from `0`th and `2`th equations and then solving the rest.\nYou have to provide proof `uniq` that the decomposed problem has unique solution.\n\n---\n\nFor example, calling `solve_for y w from 0 1 := by ...` on:\n\n```\n  solve x y z w, P ∧ Q ∧ R ∧ T\n```\n\nproduces\n\n```\n  let yw' := fun x z => solve y w, P ∧ Q\n\n  fun (x,z) := solve x z, R ∧ T\n\n  let (y,w) := yw' x z\n\n  (x,y,z,w)\n```\n\nWarring: this tactic currently uses `sorry`!-/\ndef SciLean.SolveFun.solve_for_core_tactic  : Lean.ParserDescr"}
{"name":"SciLean.SolveFun.splitAnd?","declaration":"/-- Take and expresion of the form `P₁ ∧ ... ∧ Pₙ` and return array `#[P₁, ..., Pₙ]`\n\nIt ignores bracketing, so both `(P₁ ∧ P₂) ∧ P₃` and `P₁ ∧ (P₂ ∧ P₃)` produce `#[P₁, P₂, P₃]`-/\ndef SciLean.SolveFun.splitAnd? (e : Lean.Expr) : Lean.MetaM (Array Lean.Expr)"}
{"name":"SciLean.HasSolution.mk","declaration":"ctor SciLean.HasSolution.mk {F : Sort u_1} {Xs : Sort u_2} [SciLean.UncurryAll F Xs Prop] {P : F} (ex : ∃ xs, SciLean.uncurryAll P xs) : SciLean.HasSolution P"}
{"name":"SciLean.SolveFun.solve_for_tacitc","declaration":"/-- Tactic `solve_for y w from 0 1 := uniq` will decompose `solve x y z w, ...` problem\nby first solving for `y` and `w` from `0`th and `2`th equations and then solving the rest.\nYou have to provide proof `uniq` that the decomposed problem has unique solution.\n\n---\n\nFor example, calling `solve_for y w from 0 1 := by ...` on:\n\n```\n  solve x y z w, P ∧ Q ∧ R ∧ T\n```\n\nproduces\n\n```\n  let yw' := fun x z => solve y w, P ∧ Q\n\n  fun (x,z) := solve x z, R ∧ T\n\n  let (y,w) := yw' x z\n\n  (x,y,z,w)\n```\n\nWarring: this tactic currently uses `sorry`!-/\ndef SciLean.SolveFun.solve_for_tacitc  : Lean.ParserDescr"}
{"name":"SciLean.HasUniqueSolution.uniq","declaration":"def SciLean.HasUniqueSolution.uniq {F : Sort u_1} {Xs : Sort u_2} [SciLean.UncurryAll F Xs Prop] {P : F} (self : SciLean.HasUniqueSolution P) (xs : Xs) (xs' : Xs) : SciLean.uncurryAll P xs → SciLean.uncurryAll P xs' → xs = xs'"}
{"name":"SciLean.decomposeSolution","declaration":"/-- This theorem allows us to decompose one problem `P` into two succesives problems `Q₁` and `Q₂`.\n-/\ntheorem SciLean.decomposeSolution {Xs : Type u_1} {Ys : Type u_2} {Zs : Type u_3} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs] (f : Ys → Zs → Xs) (hf : Function.Bijective (SciLean.uncurryN 2 f)) (P : Xs → Prop) (Q₁ : Ys → Zs → Prop) (Q₂ : Ys → Zs → Prop) (equiv : ∀ (ys : Ys) (zs : Zs), Q₁ ys zs ∧ Q₂ ys zs ↔ P (f ys zs)) (unique : ∀ (ys : Ys), SciLean.HasUniqueSolution (Q₁ ys)) : (solve xs, P xs) =\n  let zs' := fun ys => solve zs, Q₁ ys zs;\n  let ys := solve ys, Q₂ ys (zs' ys);\n  let zs := zs' ys;\n  f ys zs"}
{"name":"SciLean.SolveFun.convSolve_as_inv","declaration":"def SciLean.SolveFun.convSolve_as_inv  : Lean.ParserDescr"}
{"name":"SciLean.«termSolve_,_»","declaration":"/-- Expresses the unique solution of a system of equations if it exists\n\nFor example\n\n```\nsolve x y, x + y = a ∧ x - y = b\n```\nreturns a pair `(x,y)` that solve the above system\n\nThe returned value is not specified if the system does not have an unique solution.\n-/\ndef SciLean.«termSolve_,_»  : Lean.ParserDescr"}
{"name":"SciLean.unexpandSolveFun","declaration":"def SciLean.unexpandSolveFun  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.SolveFun.solve_as_invFun_lhs","declaration":"theorem SciLean.SolveFun.solve_as_invFun_lhs {α : Type u_1} {β : Type u_2} [Nonempty α] (f : α → β) (b : β) [AddGroup β] : (solve x, f x = b) = Function.invFun f b"}
{"name":"SciLean.solveFun","declaration":"/-- Finds unique `(x₁, ..., xₙ)` such that `P x₁ ... xₙ` holds.\n\nTODO: Can we return a solution if it exists and it not necessarily unique? I'm not sure if we would be able to prove `decomposeSolution` then.\n\nTODO: This is related to mathlib's `Classical.epsilon` i.e. the Hilbert epsilon function. Maybe redefine this function using it.\n-/\ndef SciLean.solveFun {F : Sort u_1} {Xs : outParam (Type u_2)} [SciLean.UncurryAll F Xs Prop] [Nonempty Xs] (f : F) : Xs"}
{"name":"SciLean.HasUniqueSolution.mk","declaration":"ctor SciLean.HasUniqueSolution.mk {F : Sort u_1} {Xs : Sort u_2} [SciLean.UncurryAll F Xs Prop] {P : F} (toHasSolution : SciLean.HasSolution P) (uniq : ∀ (xs xs' : Xs), SciLean.uncurryAll P xs → SciLean.uncurryAll P xs' → xs = xs') : SciLean.HasUniqueSolution P"}
{"name":"SciLean.SolveFun.solve_as_invFun_rhs","declaration":"theorem SciLean.SolveFun.solve_as_invFun_rhs {α : Type u_1} {β : Type u_2} [Nonempty α] (f : α → β) (b : β) [AddGroup β] : (solve x, b = f x) = Function.invFun f b"}
{"name":"SciLean.SolveFun.solveForNameFrom","declaration":"def SciLean.SolveFun.solveForNameFrom (e : Lean.Expr) (names : Array Lean.Name) (js : Array ℕ) : Lean.MetaM (Lean.Expr × Lean.Expr × Lean.MVarId)"}
{"name":"SciLean.SolveFun.solveForFrom","declaration":"/-- Decompose `solve` problem into two `solve` problems. First, solve specified equations with indices `js` w.r.t to unknowns with indices `is`. Afterward, solve remaining equations w.r.t. remaining unknowns.\n\nReturns:\n\n1. the decomposed problem\n\n2. proof that it is equivalent to the original problem\n\n3. proof obligation that the decomposed problem has unique solution\n\n---\n\nFor example calling `solveForFrom · #[1,3] #[0,1]` on\n\n```\n  solve x y z w, P ∧ Q ∧ R ∧ T\n```\n\nwill return\n\n```\n  let yw' := fun x z => solve y w, P ∧ Q\n\n  fun (x,z) := solve x z, R ∧ T\n\n  let (y,w) := yw' x z\n\n  (x,y,z,w)\n```\n\nTODO: This should produce proof that those two terms are equal\n-/\ndef SciLean.SolveFun.solveForFrom (e : Lean.Expr) (is : Array ℕ) (js : Array ℕ) : Lean.MetaM (Lean.Expr × Lean.Expr × Lean.MVarId)"}
{"name":"SciLean.SolveFun.solve_as_invFun","declaration":"/-- Rewrite `solve` as `invFun`\n\nTODO: There might be slight inconsistency as `invFun` always tries to give you some kind of answer even if it is not uniquely determined but `solve` gives up if the answer is not unique.\n\nThe issue is that I'm not sure if\n`Classical.choose (∃ x, f x - g x = 0)` might not be the same as `Classical.choose (∃ x, f x = g x)` or is that\n-/\ntheorem SciLean.SolveFun.solve_as_invFun {α : Type u_1} {β : Type u_2} [Nonempty α] (f : α → β) (g : α → β) [AddGroup β] : (solve x, f x = g x) = Function.invFun (fun x => f x - g x) 0"}
{"name":"SciLean.HasSolution","declaration":"structure SciLean.HasSolution {F : Sort u_1} {Xs : Sort u_2} [SciLean.UncurryAll F Xs Prop] (P : F) : Prop"}
{"name":"SciLean.HasSolution.ex","declaration":"def SciLean.HasSolution.ex {F : Sort u_1} {Xs : Sort u_2} [SciLean.UncurryAll F Xs Prop] {P : F} (self : SciLean.HasSolution P) : ∃ xs, SciLean.uncurryAll P xs"}
