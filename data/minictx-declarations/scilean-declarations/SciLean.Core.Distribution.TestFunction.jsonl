{"name":"SciLean.instTCOr","declaration":"instance SciLean.instTCOr {A : Sort u_1} {B : Sort u_2} [inst : A] : SciLean.TCOr A B"}
{"name":"SciLean.TCOr.val","declaration":"def SciLean.TCOr.val {A : Sort u_1} {B : Sort u_2} [self : SciLean.TCOr A B] : A ‚äï' B"}
{"name":"SciLean.TestFunctionSpace.mk","declaration":"ctor SciLean.TestFunctionSpace.mk {R : Type u} [SciLean.RealScalar R] {X : Type v} [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] (toFun : X ‚Üí R) (is_test_fun : SciLean.IsTestFunction toFun) : ùíü X"}
{"name":"SciLean.TestFunctionSpace.eval_IsLinearMap","declaration":"theorem SciLean.TestFunctionSpace.eval_IsLinearMap {X : Type u_2} {R : Type u_1} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] (x : X) : IsLinearMap R fun œÜ => œÜ x"}
{"name":"SciLean.instAddTestFunctionSpace","declaration":"instance SciLean.instAddTestFunctionSpace {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : Add (ùíü X)"}
{"name":"SciLean.TestFunctionSpace.eval_CDifferentiable_rule'","declaration":"theorem SciLean.TestFunctionSpace.eval_CDifferentiable_rule' {R : Type u_1} [SciLean.RealScalar R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] (œÜ : W ‚Üí ùíü X) (x : W ‚Üí X) (hœÜ : SciLean.CDifferentiable R œÜ) (hx : SciLean.CDifferentiable R x) : SciLean.CDifferentiable R fun w => (œÜ w) (x w)"}
{"name":"SciLean.instFunLikeTestFunctionSpace","declaration":"instance SciLean.instFunLikeTestFunctionSpace {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : FunLike (ùíü X) X R"}
{"name":"SciLean.unexpandTestFunctionSpace","declaration":"def SciLean.unexpandTestFunctionSpace  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.instTCOr_1","declaration":"instance SciLean.instTCOr_1 {A : Sort u_1} {B : Sort u_2} [inst : B] : SciLean.TCOr A B"}
{"name":"SciLean.instUniformSpaceTestFunctionSpace","declaration":"instance SciLean.instUniformSpaceTestFunctionSpace {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : UniformSpace (ùíü X)"}
{"name":"SciLean.termùíü_","declaration":"def SciLean.termùíü_  : Lean.ParserDescr"}
{"name":"SciLean.TCOr","declaration":"class SciLean.TCOr (A : Sort u_1) (B : Sort u_2) : Sort (max (max 1 u_1) u_2)"}
{"name":"SciLean.TestFunctionSpace.eval_CDifferentiable","declaration":"theorem SciLean.TestFunctionSpace.eval_CDifferentiable {X : Type u_2} {R : Type u_1} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] (x : X) : SciLean.CDifferentiable R fun œÜ => œÜ x"}
{"name":"SciLean.TestFunctionSpace.is_test_fun","declaration":"def SciLean.TestFunctionSpace.is_test_fun {R : Type u} [SciLean.RealScalar R] {X : Type v} [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] (self : ùíü X) : SciLean.IsTestFunction self.toFun"}
{"name":"SciLean.testFunApprox","declaration":"/-- Restrict function `f` by a ball of radius `n` and do smooth by convolution with radius `1/n`.\n\nIf `X` is discrete space then we do not need to do smoothing. -/\nopaque SciLean.testFunApprox {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] (n : ‚Ñï) (f : X ‚Üí R) : ùíü X"}
{"name":"SciLean.TestFunctionSpace","declaration":"structure SciLean.TestFunctionSpace (R : Type u) [SciLean.RealScalar R] (X : Type v) [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : Type (max u v)"}
{"name":"SciLean.IsTestFunction.has_compact_support","declaration":"def SciLean.IsTestFunction.has_compact_support {R : Type u} [SciLean.RealScalar R] {X : Type v} [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] {f : X ‚Üí R} (self : SciLean.IsTestFunction f) : HasCompactSupport f"}
{"name":"SciLean.IsTestFunction.is_smooth","declaration":"def SciLean.IsTestFunction.is_smooth {R : Type u} [SciLean.RealScalar R] {X : Type v} [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] {f : X ‚Üí R} (self : SciLean.IsTestFunction f) : match SciLean.TCOr.val with\n| PSum.inl val => SciLean.ContCDiff R ‚ä§ f\n| PSum.inr val => True"}
{"name":"SciLean.instVecToRCLikeToScalarTestFunctionSpace","declaration":"instance SciLean.instVecToRCLikeToScalarTestFunctionSpace {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : SciLean.Vec R (ùíü X)"}
{"name":"SciLean.TestFunctionSpace.toFun","declaration":"def SciLean.TestFunctionSpace.toFun {R : Type u} [SciLean.RealScalar R] {X : Type v} [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] (self : ùíü X) : X ‚Üí R"}
{"name":"SciLean.instSubTestFunctionSpace","declaration":"instance SciLean.instSubTestFunctionSpace {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : Sub (ùíü X)"}
{"name":"SciLean.TestFunctionSpace.eval_IsSmoothLinearMap","declaration":"theorem SciLean.TestFunctionSpace.eval_IsSmoothLinearMap {X : Type u_2} {R : Type u_1} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] (x : X) : SciLean.IsSmoothLinearMap R fun œÜ => œÜ x"}
{"name":"SciLean.TestFunctionSpace.eval_CDifferentiableAt_rule","declaration":"theorem SciLean.TestFunctionSpace.eval_CDifferentiableAt_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] (w : W) (œÜ : W ‚Üí ùíü X) (x : W ‚Üí X) (hœÜ : SciLean.CDifferentiableAt R œÜ w) (hx : SciLean.CDifferentiableAt R x w) : SciLean.CDifferentiableAt R (fun w => (œÜ w) (x w)) w"}
{"name":"SciLean.instNegTestFunctionSpace","declaration":"instance SciLean.instNegTestFunctionSpace {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : Neg (ùíü X)"}
{"name":"SciLean.IsTestFunction","declaration":"structure SciLean.IsTestFunction {R : Type u} [SciLean.RealScalar R] {X : Type v} [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] (f : X ‚Üí R) : Prop"}
{"name":"SciLean.instSMulTestFunctionSpace","declaration":"instance SciLean.instSMulTestFunctionSpace {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : SMul R (ùíü X)"}
{"name":"SciLean.TCOr.mk","declaration":"ctor SciLean.TCOr.mk {A : Sort u_1} {B : Sort u_2} (val : A ‚äï' B) : SciLean.TCOr A B"}
{"name":"SciLean.IsTestFunction.mk","declaration":"ctor SciLean.IsTestFunction.mk {R : Type u} [SciLean.RealScalar R] {X : Type v} [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] {f : X ‚Üí R} (is_smooth : match SciLean.TCOr.val with\n| PSum.inl val => SciLean.ContCDiff R ‚ä§ f\n| PSum.inr val => True) (has_compact_support : HasCompactSupport f) : SciLean.IsTestFunction f"}
{"name":"SciLean.instZeroTestFunctionSpace","declaration":"instance SciLean.instZeroTestFunctionSpace {X : Type u_1} {R : Type u_2} [SciLean.RealScalar R] [TopologicalSpace X] [space : SciLean.TCOr (SciLean.Vec R X) (DiscreteTopology X)] : Zero (ùíü X)"}
