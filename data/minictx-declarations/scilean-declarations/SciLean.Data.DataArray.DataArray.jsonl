{"name":"SciLean.DataArrayN.toList","declaration":"def SciLean.DataArrayN.toList {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (xs : SciLean.DataArrayN α ι) : List α"}
{"name":"SciLean.DataArrayN.set","declaration":"def SciLean.DataArrayN.set {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (xs : SciLean.DataArrayN α ι) (i : ι) (xi : α) : SciLean.DataArrayN α ι"}
{"name":"SciLean.instSizeDataArrayN","declaration":"instance SciLean.instSizeDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.Size (SciLean.DataArrayN α ι)"}
{"name":"SciLean.instArrayTypeNotationDataArrayN","declaration":"instance SciLean.instArrayTypeNotationDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : SciLean.ArrayTypeNotation (SciLean.DataArrayN α ι) ι α"}
{"name":"SciLean.DataArrayN","declaration":"structure SciLean.DataArrayN (α : Type) [pd : SciLean.PlainDataType α] (ι : Type) [SciLean.IndexType ι] : Type"}
{"name":"SciLean.DataArray.set","declaration":"def SciLean.DataArray.set {α : Type} [pd : SciLean.PlainDataType α] (arr : SciLean.DataArray α) (i : Fin arr.size) (val : α) : SciLean.DataArray α"}
{"name":"SciLean.instToMultisetWithIdxDataArrayNProd","declaration":"instance SciLean.instToMultisetWithIdxDataArrayNProd {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.ToMultiset (LeanColls.Indexed.WithIdx (SciLean.DataArrayN α ι)) (ι × α)"}
{"name":"SciLean.instReadOnlyWithIdxDataArrayNProd","declaration":"instance SciLean.instReadOnlyWithIdxDataArrayNProd {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.MultiBag.ReadOnly (LeanColls.Indexed.WithIdx (SciLean.DataArrayN α ι)) (ι × α)"}
{"name":"SciLean.DataArrayN.modify","declaration":"def SciLean.DataArrayN.modify {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (xs : SciLean.DataArrayN α ι) (i : ι) (f : α → α) : SciLean.DataArrayN α ι"}
{"name":"SciLean.DataArray","declaration":"structure SciLean.DataArray (α : Type) [pd : SciLean.PlainDataType α] : Type"}
{"name":"SciLean.DataArray.byteData","declaration":"def SciLean.DataArray.byteData {α : Type} [pd : SciLean.PlainDataType α] (self : SciLean.DataArray α) : ByteArray"}
{"name":"SciLean.DataArray.swap","declaration":"def SciLean.DataArray.swap {α : Type} [pd : SciLean.PlainDataType α] (arr : SciLean.DataArray α) (i : Fin arr.size) (j : Fin arr.size) : SciLean.DataArray α"}
{"name":"SciLean.instFoldDataArrayN","declaration":"instance SciLean.instFoldDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.Fold (SciLean.DataArrayN α ι) α"}
{"name":"SciLean.DataArrayN.reshape","declaration":"def SciLean.DataArrayN.reshape {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (x : SciLean.DataArrayN α ι) (κ : Type) [SciLean.IndexType κ] (hs : SciLean.IndexType.card κ = SciLean.IndexType.card ι) : SciLean.DataArrayN α κ"}
{"name":"SciLean.DataArray.h_size","declaration":"def SciLean.DataArray.h_size {α : Type} [pd : SciLean.PlainDataType α] (self : SciLean.DataArray α) : SciLean.PlainDataType.bytes pd self.size ≤ ByteArray.size self.byteData"}
{"name":"SciLean.DataArray.get","declaration":"def SciLean.DataArray.get {α : Type} [pd : SciLean.PlainDataType α] (arr : SciLean.DataArray α) (i : Fin arr.size) : α"}
{"name":"SciLean.DataArray.capacity","declaration":"/-- Capacity of an array. The return type is `Squash Nat` as the capacity is is just an implementation detail and should not affect semantics of the program. -/\ndef SciLean.DataArray.capacity {α : Type} [pd : SciLean.PlainDataType α] (arr : SciLean.DataArray α) : Squash ℕ"}
{"name":"SciLean.DataArray.reserve","declaration":"/-- Makes sure that `arr` fits at least `n` elements of `α` -/\ndef SciLean.DataArray.reserve {α : Type} [pd : SciLean.PlainDataType α] (arr : SciLean.DataArray α) (capacity : ℕ) : SciLean.DataArray α"}
{"name":"SciLean.instMembershipProdWithIdxDataArrayN","declaration":"instance SciLean.instMembershipProdWithIdxDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : Membership (ι × α) (LeanColls.Indexed.WithIdx (SciLean.DataArrayN α ι))"}
{"name":"SciLean.instLawfulIndexedDataArrayNInstIndexedDataArrayN","declaration":"instance SciLean.instLawfulIndexedDataArrayNInstIndexedDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.LawfulIndexed (SciLean.DataArrayN α ι) ι α"}
{"name":"ByteArray.mkArray","declaration":"def ByteArray.mkArray (n : ℕ) (v : UInt8) : ByteArray"}
{"name":"SciLean.DataArray.mkEmpty","declaration":"def SciLean.DataArray.mkEmpty {α : Type} [pd : SciLean.PlainDataType α] (capacity : ℕ) : SciLean.DataArray α"}
{"name":"SciLean.DataArrayN.toListIdx","declaration":"def SciLean.DataArrayN.toListIdx {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (xs : SciLean.DataArrayN α ι) : List (ι × α)"}
{"name":"SciLean.instPlainDataType","declaration":"instance SciLean.instPlainDataType {Cont : Type} {ι : Type} {α : Type} [SciLean.ArrayType Cont ι α] [SciLean.IndexType ι] [Inhabited α] [pd : SciLean.PlainDataType α] : SciLean.PlainDataType Cont"}
{"name":"SciLean.instSizeWithIdxDataArrayN","declaration":"instance SciLean.instSizeWithIdxDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.Size (LeanColls.Indexed.WithIdx (SciLean.DataArrayN α ι))"}
{"name":"SciLean.DataArray.drop","declaration":"def SciLean.DataArray.drop {α : Type} [pd : SciLean.PlainDataType α] (arr : SciLean.DataArray α) (k : ℕ) : SciLean.DataArray α"}
{"name":"SciLean.DataArrayN.h_size","declaration":"def SciLean.DataArrayN.h_size {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (self : SciLean.DataArrayN α ι) : SciLean.IndexType.card ι = self.data.size"}
{"name":"SciLean.instReadOnlyDataArrayN","declaration":"instance SciLean.instReadOnlyDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.MultiBag.ReadOnly (SciLean.DataArrayN α ι) α"}
{"name":"SciLean.DataArrayN.mk","declaration":"ctor SciLean.DataArrayN.mk {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (data : SciLean.DataArray α) (h_size : SciLean.IndexType.card ι = data.size) : SciLean.DataArrayN α ι"}
{"name":"SciLean.DataArray.mk","declaration":"ctor SciLean.DataArray.mk {α : Type} [pd : SciLean.PlainDataType α] (byteData : ByteArray) (size : ℕ) (h_size : SciLean.PlainDataType.bytes pd size ≤ ByteArray.size byteData) : SciLean.DataArray α"}
{"name":"SciLean.DataArray.ext","declaration":"/-- Extensionality of DataArray\n\nCurrently this is inconsistent, we need to turn DataArray into quotient!\n-/\ntheorem SciLean.DataArray.ext {α : Type} [pd : SciLean.PlainDataType α] (d : SciLean.DataArray α) (d' : SciLean.DataArray α) (h : d.size = d'.size) : (∀ (i : Fin d.size), SciLean.DataArray.get d i = SciLean.DataArray.get d' (h ▸ i)) → d = d'"}
{"name":"SciLean.DataArray.reverse","declaration":"def SciLean.DataArray.reverse {α : Type} [pd : SciLean.PlainDataType α] (arr : SciLean.DataArray α) : SciLean.DataArray α"}
{"name":"SciLean.DataArrayN.curry","declaration":"def SciLean.DataArrayN.curry {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] {κ : Type} [SciLean.IndexType κ] [Inhabited α] (x : SciLean.DataArrayN α (ι × κ)) : SciLean.DataArrayN (SciLean.DataArrayN α κ) ι"}
{"name":"SciLean.instMembershipDataArrayN","declaration":"instance SciLean.instMembershipDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : Membership α (SciLean.DataArrayN α ι)"}
{"name":"SciLean.instIndexedDataArrayN","declaration":"instance SciLean.instIndexedDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.Indexed (SciLean.DataArrayN α ι) ι α"}
{"name":"SciLean.instArrayTypeDataArrayN","declaration":"instance SciLean.instArrayTypeDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : SciLean.ArrayType (SciLean.DataArrayN α ι) ι α"}
{"name":"SciLean.instToStringDataArray","declaration":"instance SciLean.instToStringDataArray {α : Type} [pd : SciLean.PlainDataType α] [ToString α] : ToString (SciLean.DataArray α)"}
{"name":"SciLean.DataArrayN.data","declaration":"def SciLean.DataArrayN.data {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (self : SciLean.DataArrayN α ι) : SciLean.DataArray α"}
{"name":"SciLean.instFoldWithIdxDataArrayNProd","declaration":"instance SciLean.instFoldWithIdxDataArrayNProd {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.Fold (LeanColls.Indexed.WithIdx (SciLean.DataArrayN α ι)) (ι × α)"}
{"name":"SciLean.instToMultisetDataArrayN","declaration":"instance SciLean.instToMultisetDataArrayN {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] : LeanColls.ToMultiset (SciLean.DataArrayN α ι) α"}
{"name":"SciLean.DataArray.size","declaration":"def SciLean.DataArray.size {α : Type} [pd : SciLean.PlainDataType α] (self : SciLean.DataArray α) : ℕ"}
{"name":"SciLean.instGetElemDataArrayNatLtInstLTNatSize","declaration":"instance SciLean.instGetElemDataArrayNatLtInstLTNatSize {α : Type} [pd : SciLean.PlainDataType α] : GetElem (SciLean.DataArray α) ℕ α fun a i => i < a.size"}
{"name":"SciLean.DataArray.push","declaration":"def SciLean.DataArray.push {α : Type} [pd : SciLean.PlainDataType α] (arr : SciLean.DataArray α) (val : α) (k : optParam ℕ 1) : SciLean.DataArray α"}
{"name":"SciLean.DataArray.intro","declaration":"def SciLean.DataArray.intro {α : Type} [pd : SciLean.PlainDataType α] {ι : Type u_1} [SciLean.IndexType ι] (f : ι → α) : SciLean.DataArray α"}
{"name":"SciLean.DataArrayN.get","declaration":"def SciLean.DataArrayN.get {α : Type} [pd : SciLean.PlainDataType α] {ι : Type} [SciLean.IndexType ι] (xs : SciLean.DataArrayN α ι) (i : ι) : α"}
