{"name":"SciLean.Rand.walkOnSpheres","declaration":"def SciLean.Rand.walkOnSpheres {Y : Type} [SciLean.SemiHilbert Float Y] (φ : SciLean.Vec3 → Float) (g : SciLean.Vec3 → Y) (n : ℕ) (x : SciLean.Vec3) : SciLean.Rand Y"}
{"name":"SciLean.Rand.harmonicRec'_CDifferentiable","declaration":"theorem SciLean.Rand.harmonicRec'_CDifferentiable {Y : Type} [SciLean.SemiHilbert Float Y] [Module ℝ Y] (n : ℕ) : SciLean.CDifferentiable Float fun w => SciLean.Rand.harmonicRec' n w.1 w.2.1 w.2.2"}
{"name":"SciLean.Rand.harmonicRec'_fwdDeriv_rand","declaration":"def SciLean.Rand.harmonicRec'_fwdDeriv_rand {Y : Type} [SciLean.SemiHilbert Float Y] (n : ℕ) (φ : SciLean.Vec3 ⟿FD[Float,⊤] Float) (dφ : SciLean.Vec3 ⟿FD[Float,⊤] Float) (g : SciLean.Vec3 ⟿FD[Float,⊤] Y) (dg : SciLean.Vec3 ⟿FD[Float,⊤] Y) (x : SciLean.Vec3) (dx : SciLean.Vec3) : SciLean.Rand (Y × Y)"}
{"name":"SciLean.Rand.pi'","declaration":"def SciLean.Rand.pi'  : Float"}
{"name":"SciLean.Rand.harmonicRec","declaration":"def SciLean.Rand.harmonicRec {Y : Type} [SciLean.SemiHilbert Float Y] [Module ℝ Y] (n : ℕ) (φ : SciLean.Vec3 → Float) (g : SciLean.Vec3 → Y) (x : SciLean.Vec3) : Y"}
{"name":"SciLean.Rand.harmonicRec.arg_x.CDifferentiable_rule","declaration":"theorem SciLean.Rand.harmonicRec.arg_x.CDifferentiable_rule {Y : Type} [SciLean.SemiHilbert Float Y] [Module ℝ Y] (n : ℕ) (φ : SciLean.Vec3 → Float) (g : SciLean.Vec3 → Y) (hφ : SciLean.CDifferentiable Float φ) (hg : SciLean.CDifferentiable Float g) : SciLean.CDifferentiable Float fun x => SciLean.Rand.harmonicRec n φ g x"}
{"name":"SciLean.Rand.harmonicRec.arg_x.fwdDeriv_randApprox","declaration":"def SciLean.Rand.harmonicRec.arg_x.fwdDeriv_randApprox {Y : Type} [SciLean.SemiHilbert Float Y] (n : ℕ) (φ : SciLean.Vec3 → Float) (φ' : SciLean.Vec3 → SciLean.Vec3 → Float × Float) (g : SciLean.Vec3 → Y) (g' : SciLean.Vec3 → SciLean.Vec3 → Y × Y) (x : SciLean.Vec3) (dx : SciLean.Vec3) : SciLean.Rand (Y × Y)"}
{"name":"SciLean.Rand.harmonicRec_fwdDeriv","declaration":"def SciLean.Rand.harmonicRec_fwdDeriv {Y : Type} [SciLean.SemiHilbert Float Y] [Module ℝ Y] (n : ℕ) (φ : SciLean.Vec3 → Float) (φ' : SciLean.Vec3 → SciLean.Vec3 → Float × Float) (g : SciLean.Vec3 → Y) (g' : SciLean.Vec3 → SciLean.Vec3 → Y × Y) : SciLean.Vec3 → SciLean.Vec3 → Y × Y"}
{"name":"SciLean.Rand.harmonicRec'","declaration":"def SciLean.Rand.harmonicRec' {Y : Type} [SciLean.SemiHilbert Float Y] [Module ℝ Y] (n : ℕ) (φ : SciLean.Vec3 ⟿FD[Float,⊤] Float) (g : SciLean.Vec3 ⟿FD[Float,⊤] Y) (x : SciLean.Vec3) : Y"}
{"name":"SciLean.Rand.harmonicRec'_fwdDeriv","declaration":"def SciLean.Rand.harmonicRec'_fwdDeriv {Y : Type} [SciLean.SemiHilbert Float Y] [Module ℝ Y] (n : ℕ) (x : (SciLean.Vec3 ⟿FD[Float,⊤] Float) × (SciLean.Vec3 ⟿FD[Float,⊤] Y) × SciLean.Vec3) (dx : (SciLean.Vec3 ⟿FD[Float,⊤] Float) × (SciLean.Vec3 ⟿FD[Float,⊤] Y) × SciLean.Vec3) : Y × Y"}
