{"name":"SciLean.StructType.structProj","declaration":"def SciLean.StructType.structProj {X : Sort u_1} {I : Sort u_2} {XI : outParam (I → Sort u_3)} [self : SciLean.StructType X I XI] (x : X) (i : I) : XI i"}
{"name":"SciLean.StructType.right_inv","declaration":"def SciLean.StructType.right_inv {X : Sort u_1} {I : Sort u_2} {XI : outParam (I → Sort u_3)} [self : SciLean.StructType X I XI] : Function.RightInverse SciLean.structProj SciLean.structMake"}
{"name":"SciLean.StructType.mk","declaration":"ctor SciLean.StructType.mk {X : Sort u_1} {I : Sort u_2} {XI : outParam (I → Sort u_3)} (structProj : X → (i : I) → XI i) (structMake : ((i : I) → XI i) → X) (structModify : (i : I) → (XI i → XI i) → X → X) (left_inv : Function.LeftInverse structProj structMake) (right_inv : Function.RightInverse structProj structMake) (structProj_structModify : ∀ (i : I) (f : XI i → XI i) (x : X), structProj (structModify i f x) i = f (structProj x i)) (structProj_structModify' : ∀ (i j : I) (f : XI i → XI i) (x : X), i ≠ j → structProj (structModify i f x) j = structProj x j) : SciLean.StructType X I XI"}
{"name":"SciLean.StructType.structMake_structProj","declaration":"theorem SciLean.StructType.structMake_structProj {X : Sort u_1} {I : Sort u_2} {XI : I → Sort u_3} [SciLean.StructType X I XI] (x : X) : (SciLean.structMake fun i => SciLean.structProj x i) = x"}
{"name":"SciLean.oneHot","declaration":"def SciLean.oneHot {X : Sort u_1} {I : Sort u_2} {XI : I → Type u_3} [SciLean.StructType X I XI] [DecidableEq I] [(i : I) → Zero (XI i)] (i : I) (xi : XI i) : X"}
{"name":"SciLean.StructType.structProj_structModify","declaration":"def SciLean.StructType.structProj_structModify {X : Sort u_1} {I : Sort u_2} {XI : outParam (I → Sort u_3)} [self : SciLean.StructType X I XI] (i : I) (f : XI i → XI i) (x : X) : SciLean.structProj (SciLean.structModify i f x) i = f (SciLean.structProj x i)"}
{"name":"SciLean.StructType.structModify","declaration":"def SciLean.StructType.structModify {X : Sort u_1} {I : Sort u_2} {XI : outParam (I → Sort u_3)} [self : SciLean.StructType X I XI] (i : I) (f : XI i → XI i) (x : X) : X"}
{"name":"SciLean.StructType.instStrucTypeArrow","declaration":"instance SciLean.StructType.instStrucTypeArrow (E : Type u_1) (I : Type u_2) (J : Type u_3) (EI : I → Type u_4) [SciLean.StructType E I EI] [DecidableEq J] : SciLean.StructType (J → E) (J × I) fun ji => EI ji.2"}
{"name":"SciLean.StructType.structProj_structMake","declaration":"theorem SciLean.StructType.structProj_structMake {X : Sort u_2} {I : Sort u_3} {XI : I → Sort u_1} [SciLean.StructType X I XI] (f : (i : I) → XI i) (i : I) : SciLean.structProj (SciLean.structMake f) i = f i"}
{"name":"SciLean.StructType.structProj_structModify'","declaration":"def SciLean.StructType.structProj_structModify' {X : Sort u_1} {I : Sort u_2} {XI : outParam (I → Sort u_3)} [self : SciLean.StructType X I XI] (i : I) (j : I) (f : XI i → XI i) (x : X) : i ≠ j → SciLean.structProj (SciLean.structModify i f x) j = SciLean.structProj x j"}
{"name":"SciLean.structExt","declaration":"theorem SciLean.structExt {X : Sort u_2} {I : Sort u_3} {XI : I → Sort u_1} [SciLean.StructType X I XI] (x : X) (x' : X) : (∀ (i : I), SciLean.structProj x i = SciLean.structProj x' i) → x = x'"}
{"name":"SciLean.StructType.structMake","declaration":"def SciLean.StructType.structMake {X : Sort u_1} {I : Sort u_2} {XI : outParam (I → Sort u_3)} [self : SciLean.StructType X I XI] (f : (i : I) → XI i) : X"}
{"name":"SciLean.StructType.instStrucTypeProd","declaration":"instance SciLean.StructType.instStrucTypeProd {I : Type u_1} {E : Type u_2} {EI : I → Sort u_3} {F : Type u_4} {J : Type u_5} {FJ : J → Sort u_3} [SciLean.StructType E I EI] [SciLean.StructType F J FJ] : SciLean.StructType (E × F) (I ⊕ J) fun t => Sum.rec EI FJ t"}
{"name":"SciLean.StructType.instStructTypeDefault","declaration":"/-- Every type is `StructType` with `Unit` as index set.\n\nThe motivation behind this instance is that type like `X×(Y×Z)` should have `StructType`\ninstance that the type has three components. Such instance is defines inductively\nand this is the base case of this induction, the inductive step is `instStrucTypeProd`.\n-/\ninstance SciLean.StructType.instStructTypeDefault {α : Sort u_1} : SciLean.StructType α Unit fun x => α"}
{"name":"SciLean.StructType.instStrucTypeArrowSimple","declaration":"instance SciLean.StructType.instStrucTypeArrowSimple (E : Type u_1) (J : Type u_2) [DecidableEq J] : SciLean.StructType (J → E) J fun x => E"}
{"name":"SciLean.StructType","declaration":"class SciLean.StructType (X : Sort u_1) (I : Sort u_2) (XI : outParam (I → Sort u_3)) : Sort (max (max (max 1 u_1) u_2) u_3)"}
{"name":"SciLean.StructType.oneHot_unit","declaration":"theorem SciLean.StructType.oneHot_unit {X : Type u_1} [Zero X] (x : X) : SciLean.oneHot () x = x"}
{"name":"SciLean.StructType.structProj_oneHot","declaration":"theorem SciLean.StructType.structProj_oneHot {X : Sort u_3} {I : Sort u_1} {XI : I → Type u_2} [SciLean.StructType X I XI] {i : I} [DecidableEq I] [(i : I) → Zero (XI i)] (xi : XI i) : SciLean.structProj (SciLean.oneHot i xi) i = xi"}
{"name":"SciLean.StructType.structProj_oneHot'","declaration":"theorem SciLean.StructType.structProj_oneHot' {X : Sort u_3} {I : Sort u_1} {XI : I → Type u_2} [SciLean.StructType X I XI] [DecidableEq I] [(i : I) → Zero (XI i)] (i : I) (j : I) (xi : XI i) (h : i ≠ j) : SciLean.structProj (SciLean.oneHot i xi) j = 0"}
{"name":"SciLean.StructType.instStrucTypePiSimple","declaration":"instance SciLean.StructType.instStrucTypePiSimple (I : Type u_1) (E : I → Type u_2) [DecidableEq I] : SciLean.StructType ((i : I) → E i) I E"}
{"name":"SciLean.StructType.left_inv","declaration":"def SciLean.StructType.left_inv {X : Sort u_1} {I : Sort u_2} {XI : outParam (I → Sort u_3)} [self : SciLean.StructType X I XI] : Function.LeftInverse SciLean.structProj SciLean.structMake"}
{"name":"SciLean.StructType.instStrucTypePi","declaration":"instance SciLean.StructType.instStrucTypePi (I : Type u_1) (E : I → Type u_2) (J : I → Type u_3) (EJ : (i : I) → J i → Type u_4) [(i : I) → SciLean.StructType (E i) (J i) (EJ i)] [DecidableEq I] : SciLean.StructType ((i : I) → E i) ((i : I) × J i) fun ij => EJ ij.fst ij.snd"}
