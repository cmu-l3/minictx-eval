{"name":"SciLean.sub_restrict'","declaration":"theorem SciLean.sub_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (S : ùíü'(X, Y)) (A : Set X) : T.restrict A - S.restrict A = (T - S).restrict A"}
{"name":"SciLean.Distribution.toMeasure","declaration":"def SciLean.Distribution.toMeasure {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasurableSpace X] (f' : ùíü'(X, R)) : MeasureTheory.Measure X"}
{"name":"SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule","declaration":"theorem SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_5} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] (T : W ‚Üí ùíü'(X, Y)) (f : Y ‚ä∏[R] Z) (hT : SciLean.IsSmoothLinearMap R T) : SciLean.IsSmoothLinearMap R fun w => SciLean.Distribution.postComp (T w) f"}
{"name":"SciLean.Distribution.smul_extAction","declaration":"theorem SciLean.Distribution.smul_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (r : R) (T : ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : (r ‚Ä¢ T).extAction œÜ L = r ‚Ä¢ T.extAction œÜ L"}
{"name":"SciLean.Function.toDistribution_extAction","declaration":"theorem SciLean.Function.toDistribution_extAction {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_1} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (f : X ‚Üí Y) (œÜ : X ‚Üí R) : (‚Üëf).extAction œÜ (fun y ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ y) = ‚à´' x, œÜ x ‚Ä¢ f x ‚àÇMeasureTheory.volume"}
{"name":"SciLean.Distribution.restrict","declaration":"def SciLean.Distribution.restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (A : Set X) : ùíü'(X, Y)"}
{"name":"SciLean.¬´termùíü'(_,_)¬ª","declaration":"def SciLean.¬´termùíü'(_,_)¬ª  : Lean.ParserDescr"}
{"name":"SciLean.restrict_univ","declaration":"theorem SciLean.restrict_univ {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) : T.restrict Set.univ = T"}
{"name":"SciLean.Distribution.extAction_iteD'","declaration":"theorem SciLean.Distribution.extAction_iteD' {R : Type u_2} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_1} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (A : Set X) (B : Set X) (t : ùíü'(X, U)) (e : ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : ((ifD A then\n            t\n          else\n            e).restrict\n        B).extAction\n    œÜ L =\n  (t.restrict B).extAction (fun x => if x ‚àà A then œÜ x else 0) L +\n    (e.restrict B).extAction (fun x => if x ‚àâ A then œÜ x else 0) L"}
{"name":"SciLean.Distribution.prod'_extAction","declaration":"theorem SciLean.Distribution.prod'_extAction {R : Type u_1} [SciLean.RealScalar R] {X : Type u_7} [SciLean.Vec R X] {Z : Type u_6} [SciLean.Vec R Z] {X‚ÇÅ : Type u_2} [SciLean.Vec R X‚ÇÅ] {X‚ÇÇ : Type u_4} [SciLean.Vec R X‚ÇÇ] {Y‚ÇÅ : Type u_3} [SciLean.Vec R Y‚ÇÅ] {Y‚ÇÇ : Type u_5} [SciLean.Vec R Y‚ÇÇ] (p : X‚ÇÅ ‚Üí X‚ÇÇ ‚Üí X) (T : ùíü'(X‚ÇÅ, Y‚ÇÅ)) (S : X‚ÇÅ ‚Üí ùíü'(X‚ÇÇ, Y‚ÇÇ)) (L : Y‚ÇÅ ‚ä∏[R] Y‚ÇÇ ‚ä∏[R] Z) (K : Z ‚ä∏[R] R ‚ä∏[R] Z) (œÜ : X ‚Üí R) : (SciLean.Distribution.prod p T S L).extAction œÜ K =\n  T.extAction (fun x‚ÇÅ => (S x‚ÇÅ).extAction (fun x‚ÇÇ => œÜ (p x‚ÇÅ x‚ÇÇ)) (fun y‚ÇÇ ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ y‚ÇÇ))\n    (fun y‚ÇÅ ‚ä∏[R] fun y‚ÇÇ ‚ä∏[R] (K ((L y‚ÇÅ) y‚ÇÇ)) 1)"}
{"name":"SciLean.Distribution.ext","declaration":"theorem SciLean.Distribution.ext {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (x : ùíü'(X, Y)) (y : ùíü'(X, Y)) : (‚àÄ (œÜ : ùíü X), x œÜ = y œÜ) ‚Üí x = y"}
{"name":"Function.toDistribution","declaration":"def Function.toDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (f : X ‚Üí Y) : ùíü'(X, Y)"}
{"name":"SciLean.Distribution.extAction.arg_œÜ.IsSmoothLinearMap","declaration":"theorem SciLean.Distribution.extAction.arg_œÜ.IsSmoothLinearMap {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : ùíü'(X, U)) (œÜ : W ‚Üí X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] Z) (hœÜ : SciLean.IsSmoothLinearMap R œÜ) : SciLean.IsSmoothLinearMap R fun w => T.extAction (œÜ w) L"}
{"name":"SciLean.postComp_id","declaration":"theorem SciLean.postComp_id {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (u : ùíü'(X, Y)) : SciLean.Distribution.postComp u (fun y ‚ä∏[R] y) = u"}
{"name":"SciLean.instInnerDistribution","declaration":"instance SciLean.instInnerDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [MeasureTheory.MeasureSpace X] [SciLean.SemiInnerProductSpace R Y] [Module ‚Ñù Y] : Inner R (ùíü'(X, Y))"}
{"name":"SciLean.HSub.hSub.arg_a0a1.toDistribution_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (f : X ‚Üí Y) (g : X ‚Üí Y) : (‚Üëfun x => f x - g x) = ‚Üëf - ‚Üëg"}
{"name":"SciLean.iteD.arg_te.IsSmoothLinearMap_rule","declaration":"theorem SciLean.iteD.arg_te.IsSmoothLinearMap_rule {R : Type u_2} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) (t : W ‚Üí ùíü'(X, Y)) (e : W ‚Üí ùíü'(X, Y)) (ht : SciLean.IsSmoothLinearMap R t) (he : SciLean.IsSmoothLinearMap R e) : SciLean.IsSmoothLinearMap R fun w =>\n  ifD A then\n    t w\n  else\n    e w"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.toDistribution_rule'","declaration":"theorem SciLean.HSMul.hSMul.arg_a0a1.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (r : R) (f : X ‚Üí Y) : r ‚Ä¢ ‚Üëf = ‚Üëfun x => r ‚Ä¢ f x"}
{"name":"SciLean.Distribution.add_extAction","declaration":"theorem SciLean.Distribution.add_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : ùíü'(X, U)) (T' : ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : (T + T').extAction œÜ L = T.extAction œÜ L + T'.extAction œÜ L"}
{"name":"SciLean.unexpandIteD","declaration":"def SciLean.unexpandIteD  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.Function.toDistribution_action","declaration":"theorem SciLean.Function.toDistribution_action {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (f : X ‚Üí Y) (œÜ : ùíü X) : ‚Üëf œÜ = ‚à´' x, œÜ x ‚Ä¢ f x ‚àÇMeasureTheory.volume"}
{"name":"SciLean.Distribution.mk_extAction","declaration":"theorem SciLean.Distribution.mk_extAction {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : (X ‚Üí R) ‚Üí Y) (hT : SciLean.IsSmoothLinearMap R fun œÜ => T ‚áëœÜ) (œÜ : X ‚Üí R) : (fun œÜ ‚ä∏[R] T ‚áëœÜ).extAction œÜ (fun y ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ y) = T œÜ"}
{"name":"SciLean.Distribution.neg_extAction","declaration":"theorem SciLean.Distribution.neg_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : (-T).extAction œÜ L = -T.extAction œÜ L"}
{"name":"SciLean.Distribution","declaration":"def SciLean.Distribution (R : Type u_1) [SciLean.RealScalar R] (X : Type u_2) [SciLean.Vec R X] (Y : Type u_3) [SciLean.Vec R Y] : Type (max (max u_2 u_1) u_3)"}
{"name":"SciLean.TestFunction.apply_IsSmoothLinearMap","declaration":"theorem SciLean.TestFunction.apply_IsSmoothLinearMap {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] : SciLean.IsSmoothLinearMap R fun œÜ => ‚áëœÜ"}
{"name":"SciLean.unexpandDistribution","declaration":"def SciLean.unexpandDistribution  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.instModuleRealDistributionSemiringToAddCommMonoidToAddCommGroupToRCLikeToScalarInstVecSmoothLinearMapTestFunctionSpaceToTopologicalSpaceToUniformSpaceInstTCOrVecDiscreteTopologyInstVecToRCLikeToScalarTestFunctionSpace","declaration":"instance SciLean.instModuleRealDistributionSemiringToAddCommMonoidToAddCommGroupToRCLikeToScalarInstVecSmoothLinearMapTestFunctionSpaceToTopologicalSpaceToUniformSpaceInstTCOrVecDiscreteTopologyInstVecToRCLikeToScalarTestFunctionSpace {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] : Module ‚Ñù (ùíü'(X, Y))"}
{"name":"SciLean.postComp_comp","declaration":"theorem SciLean.postComp_comp {R : Type u_1} [SciLean.RealScalar R] {W : Type u_5} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_4} [SciLean.Vec R V] (x : ùíü'(X, U)) (g : U ‚ä∏[R] V) (f : V ‚ä∏[R] W) : SciLean.Distribution.postComp (SciLean.Distribution.postComp x g) f =\n  SciLean.Distribution.postComp x (fun u ‚ä∏[R] f (g u))"}
{"name":"SciLean.postComp_restrict_extAction","declaration":"theorem SciLean.postComp_restrict_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Z : Type u_5} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] {V : Type u_4} [SciLean.Vec R V] (x : ùíü'(X, U)) (f : U ‚ä∏[R] V) (A : Set X) (œÜ : X ‚Üí W) (L : V ‚ä∏[R] W ‚ä∏[R] Z) : ((SciLean.Distribution.postComp x f).restrict A).extAction œÜ L =\n  (x.restrict A).extAction œÜ (fun u ‚ä∏[R] fun w ‚ä∏[R] (L (f u)) w)"}
{"name":"SciLean.Distribution.extAction'","declaration":"def SciLean.Distribution.extAction' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (œÜ : X ‚Üí R) : Y"}
{"name":"SciLean.indextype_sum_restrict'","declaration":"theorem SciLean.indextype_sum_restrict' {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {I : Type u_1} [SciLean.IndexType I] (T : I ‚Üí ùíü'(X, R)) (A : Set X) :  ‚àë i, (T i).restrict A = ( ‚àë i, T i).restrict A"}
{"name":"SciLean.instSemiInnerProductSpaceToRCLikeToScalarDistribution","declaration":"instance SciLean.instSemiInnerProductSpaceToRCLikeToScalarDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [MeasureTheory.MeasureSpace X] [SciLean.SemiInnerProductSpace R Y] [Module ‚Ñù Y] : SciLean.SemiInnerProductSpace R (ùíü'(X, Y))"}
{"name":"SciLean.Distribution.IsFunction","declaration":"def SciLean.Distribution.IsFunction {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (T : ùíü'(X, Y)) : Prop"}
{"name":"SciLean.Distribution.extAction","declaration":"def SciLean.Distribution.extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {Z : Type u_5} [SciLean.Vec R Z] (T : ùíü'(X, Y)) (œÜ : X ‚Üí Z) (L : Y ‚ä∏[R] Z ‚ä∏[R] W) : W"}
{"name":"SciLean.add_restrict'","declaration":"theorem SciLean.add_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (S : ùíü'(X, Y)) (A : Set X) : T.restrict A + S.restrict A = (T + S).restrict A"}
{"name":"SciLean.instTestFunctionsDistribution","declaration":"instance SciLean.instTestFunctionsDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [MeasureTheory.MeasureSpace X] [SciLean.SemiInnerProductSpace R Y] [Module ‚Ñù Y] : SciLean.TestFunctions (ùíü'(X, Y))"}
{"name":"SciLean.Distribution.postComp","declaration":"def SciLean.Distribution.postComp {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] (T : ùíü'(X, Y)) (f : Y ‚ä∏[R] Z) : ùíü'(X, Z)"}
{"name":"SciLean.postComp_assoc","declaration":"theorem SciLean.postComp_assoc {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_5} [SciLean.Vec R Y] {U : Type u_3} [SciLean.Vec R U] {V : Type u_4} [SciLean.Vec R V] (x : ùíü'(X, U)) (y : U ‚ä∏[R] ùíü'(Y, V)) (f : V ‚ä∏[R] W) (œÜ : Y ‚Üí R) : SciLean.Distribution.postComp (SciLean.Distribution.postComp x y) (fun T ‚ä∏[R] SciLean.Distribution.postComp T f) =\n  SciLean.Distribution.postComp x (fun u ‚ä∏[R] SciLean.Distribution.postComp (y u) f)"}
{"name":"SciLean.finset_sum_restrict","declaration":"theorem SciLean.finset_sum_restrict {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {I : Type u_1} [Fintype I] (T : I ‚Üí ùíü'(X, Y)) (A : Set X) : (Finset.sum Finset.univ fun i => T i).restrict A = Finset.sum Finset.univ fun i => (T i).restrict A"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.toDistribution_rule'","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (f : X ‚Üí Y) (g : X ‚Üí Y) : ‚Üëf + ‚Üëg = ‚Üëfun x => f x + g x"}
{"name":"SciLean.Distribution.zero_extAction","declaration":"theorem SciLean.Distribution.zero_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_5} [SciLean.Vec R X] {U : Type u_2} [SciLean.Vec R U] {V : Type u_4} [SciLean.Vec R V] (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : 0.extAction œÜ L = 0"}
{"name":"SciLean.action_dirac","declaration":"theorem SciLean.action_dirac {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] (x : X) (œÜ : ùíü X) : (SciLean.dirac x) œÜ = œÜ x"}
{"name":"SciLean.Function.toDistribution_zero","declaration":"theorem SciLean.Function.toDistribution_zero {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] : (‚Üëfun x => 0) = 0"}
{"name":"SciLean.termùíü'_","declaration":"def SciLean.termùíü'_  : Lean.ParserDescr"}
{"name":"SciLean.Distribution.prod_restrict","declaration":"theorem SciLean.Distribution.prod_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_7} [SciLean.Vec R X] {Z : Type u_6} [SciLean.Vec R Z] {X‚ÇÅ : Type u_2} [SciLean.Vec R X‚ÇÅ] {X‚ÇÇ : Type u_4} [SciLean.Vec R X‚ÇÇ] {Y‚ÇÅ : Type u_3} [SciLean.Vec R Y‚ÇÅ] {Y‚ÇÇ : Type u_5} [SciLean.Vec R Y‚ÇÇ] (p : X‚ÇÅ ‚Üí X‚ÇÇ ‚Üí X) (T : ùíü'(X‚ÇÅ, Y‚ÇÅ)) (S : X‚ÇÅ ‚Üí ùíü'(X‚ÇÇ, Y‚ÇÇ)) (L : Y‚ÇÅ ‚ä∏[R] Y‚ÇÇ ‚ä∏[R] Z) (A : Set X) : (SciLean.Distribution.prod p T S L).restrict A =\n  SciLean.Distribution.prod p (T.restrict (Set.preimage1 p A)) (fun x‚ÇÅ => (S x‚ÇÅ).restrict (p x‚ÇÅ ‚Åª¬π' A)) L"}
{"name":"SciLean.Distribution.IsMeasure","declaration":"def SciLean.Distribution.IsMeasure {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasurableSpace X] (f : ùíü'(X, R)) : Prop"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.toDistribution_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (f : X ‚Üí Y) (g : X ‚Üí Y) : (‚Üëfun x => f x + g x) = ‚Üëf + ‚Üëg"}
{"name":"SciLean.HSub.hSub.arg_a0a1.toDistribution_rule'","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (f : X ‚Üí Y) (g : X ‚Üí Y) : ‚Üëf - ‚Üëg = ‚Üëfun x => f x - g x"}
{"name":"SciLean.termIfD_Then_____Else____","declaration":"def SciLean.termIfD_Then_____Else____  : Lean.ParserDescr"}
{"name":"SciLean.finset_sum_restrict'","declaration":"theorem SciLean.finset_sum_restrict' {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {I : Type u_1} [Fintype I] (T : I ‚Üí ùíü'(X, Y)) (A : Set X) : (Finset.sum Finset.univ fun i => (T i).restrict A) = (Finset.sum Finset.univ fun i => T i).restrict A"}
{"name":"SciLean.HMul.hMul.arg_a0.toDistribution_rule","declaration":"theorem SciLean.HMul.hMul.arg_a0.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (r : R) (f : X ‚Üí R) : (‚Üëfun x => f x * r) = r ‚Ä¢ ‚Üëf"}
{"name":"SciLean.Distribution.toFunction","declaration":"def SciLean.Distribution.toFunction {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (T : ùíü'(X, Y)) : X ‚Üí Y"}
{"name":"SciLean.Distribution.extAction.arg_T.IsSmoothLinearMap","declaration":"theorem SciLean.Distribution.extAction.arg_T.IsSmoothLinearMap {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : W ‚Üí ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] Z) (hT : SciLean.IsSmoothLinearMap R T) : SciLean.IsSmoothLinearMap R fun w => (T w).extAction œÜ L"}
{"name":"SciLean.iteD_restrict","declaration":"theorem SciLean.iteD_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (A : Set X) : (ifD A then\n    T\n  else\n    0) =\n  T.restrict A"}
{"name":"MeasureTheory.Measure.toDistribution","declaration":"def MeasureTheory.Measure.toDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasurableSpace X] (Œº : MeasureTheory.Measure X) : ùíü'(X, R)"}
{"name":"SciLean.Distribution.iteD_same","declaration":"theorem SciLean.Distribution.iteD_same {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) (u : ùíü'(X, Y)) : (ifD A then\n    u\n  else\n    u) =\n  u"}
{"name":"SciLean.HMul.hMul.arg_a1.toDistribution_rule'","declaration":"theorem SciLean.HMul.hMul.arg_a1.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (r : R) (f : X ‚Üí R) : r ‚Ä¢ ‚Üëf = ‚Üëfun x => r ‚Ä¢ f x"}
{"name":"SciLean.neg_restrict","declaration":"theorem SciLean.neg_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (A : Set X) : (-T).restrict A = -T.restrict A"}
{"name":"SciLean.iteD_restrict'","declaration":"theorem SciLean.iteD_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (A : Set X) : (ifD A then\n    0\n  else\n    T) =\n  T.restrict A·∂ú"}
{"name":"SciLean.sub_restrict","declaration":"theorem SciLean.sub_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (S : ùíü'(X, Y)) (A : Set X) : (T - S).restrict A = T.restrict A - S.restrict A"}
{"name":"SciLean.smul_restrict","declaration":"theorem SciLean.smul_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (r : R) (T : ùíü'(X, Y)) (A : Set X) : (r ‚Ä¢ T).restrict A = r ‚Ä¢ T.restrict A"}
{"name":"SciLean.smul_restrict'","declaration":"theorem SciLean.smul_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (r : R) (T : ùíü'(X, Y)) (A : Set X) : r ‚Ä¢ T.restrict A = (r ‚Ä¢ T).restrict A"}
{"name":"SciLean.Distribution.indextype_sum_extAction","declaration":"theorem SciLean.Distribution.indextype_sum_extAction {R : Type u_2} [SciLean.RealScalar R] {W : Type (max (max u_2 u_3) u_4)} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {U : Type u_4} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] {I : Type u_1} [SciLean.IndexType I] (T : I ‚Üí ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : ( ‚àë i, T i).extAction œÜ L = ‚àë i, (T i).extAction œÜ L"}
{"name":"SciLean.HMul.hMul.arg_a0.toDistribution_rule'","declaration":"theorem SciLean.HMul.hMul.arg_a0.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (r : R) (f : X ‚Üí R) : r ‚Ä¢ ‚Üëf = ‚Üëfun x => f x * r"}
{"name":"SciLean.zero_restrict","declaration":"theorem SciLean.zero_restrict {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) : 0.restrict A = 0"}
{"name":"SciLean.Distribution.prod","declaration":"def SciLean.Distribution.prod {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Z : Type u_3} [SciLean.Vec R Z] {X‚ÇÅ : Type u_4} [SciLean.Vec R X‚ÇÅ] {X‚ÇÇ : Type u_5} [SciLean.Vec R X‚ÇÇ] {Y‚ÇÅ : Type u_6} [SciLean.Vec R Y‚ÇÅ] {Y‚ÇÇ : Type u_7} [SciLean.Vec R Y‚ÇÇ] (p : X‚ÇÅ ‚Üí X‚ÇÇ ‚Üí X) (T : ùíü'(X‚ÇÅ, Y‚ÇÅ)) (S : X‚ÇÅ ‚Üí ùíü'(X‚ÇÇ, Y‚ÇÇ)) (L : Y‚ÇÅ ‚ä∏[R] Y‚ÇÇ ‚ä∏[R] Z) : ùíü'(X, Z)"}
{"name":"SciLean.Distribution.¬´term‚ü™_,_‚ü´[_]¬ª","declaration":"def SciLean.Distribution.¬´term‚ü™_,_‚ü´[_]¬ª  : Lean.ParserDescr"}
{"name":"SciLean.Distribution.extAction_iteD","declaration":"theorem SciLean.Distribution.extAction_iteD {R : Type u_2} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_1} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (A : Set X) (t : ùíü'(X, U)) (e : ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : (ifD A then\n        t\n      else\n        e).extAction\n    œÜ L =\n  t.extAction (fun x => if x ‚àà A then œÜ x else 0) L + e.extAction (fun x => if x ‚àâ A then œÜ x else 0) L"}
{"name":"SciLean.add_restrict","declaration":"theorem SciLean.add_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (S : ùíü'(X, Y)) (A : Set X) : (T + S).restrict A = T.restrict A + S.restrict A"}
{"name":"SciLean.postComp_extAction","declaration":"theorem SciLean.postComp_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_4} [SciLean.Vec R X] {Z : Type u_5} [SciLean.Vec R Z] {U : Type u_2} [SciLean.Vec R U] {V : Type u_3} [SciLean.Vec R V] {y : U ‚ä∏[R] V} (x : ùíü'(X, U)) (f : U ‚ä∏[R] V) (œÜ : X ‚Üí W) (L : V ‚ä∏[R] W ‚ä∏[R] Z) : (SciLean.Distribution.postComp x y).extAction œÜ L = x.extAction œÜ (fun u ‚ä∏[R] fun w ‚ä∏[R] (L (f u)) w)"}
{"name":"SciLean.iteD.arg_cte.toDistribution_rule","declaration":"theorem SciLean.iteD.arg_cte.toDistribution_rule {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (s : Set X) (t : X ‚Üí Y) (e : X ‚Üí Y) : (ifD s then\n    ‚Üët\n  else\n    ‚Üëe) =\n  ‚Üëfun x => if x ‚àà s then t x else e x"}
{"name":"SciLean.instSMulRealDistribution","declaration":"instance SciLean.instSMulRealDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] : SMul ‚Ñù (ùíü'(X, Y))"}
{"name":"SciLean.dirac","declaration":"def SciLean.dirac {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] (x : X) : ùíü'(X, R)"}
{"name":"SciLean.indextype_sum_restrict","declaration":"theorem SciLean.indextype_sum_restrict {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {I : Type u_1} [SciLean.IndexType I] (T : I ‚Üí ùíü'(X, R)) (A : Set X) : ( ‚àë i, T i).restrict A = ‚àë i, (T i).restrict A"}
{"name":"SciLean.Distribution.bind","declaration":"def SciLean.Distribution.bind {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {U : Type u_5} [SciLean.Vec R U] {V : Type u_6} [SciLean.Vec R V] (x' : ùíü'(X, U)) (f : X ‚Üí ùíü'(Y, V)) (L : U ‚ä∏[R] V ‚ä∏[R] W) : ùíü'(Y, W)"}
{"name":"SciLean.Distribution.integrate","declaration":"def SciLean.Distribution.integrate {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) : Y"}
{"name":"SciLean.instCoeMeasureDistributionToVecToRCLikeToScalarInstSemiInnerProductSpace","declaration":"instance SciLean.instCoeMeasureDistributionToVecToRCLikeToScalarInstSemiInnerProductSpace {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasurableSpace X] : Coe (MeasureTheory.Measure X) (ùíü'(X, R))"}
{"name":"SciLean.action_bind","declaration":"theorem SciLean.action_bind {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (x : ùíü'(X, U)) (f : X ‚Üí ùíü'(Y, V)) (L : U ‚ä∏[R] V ‚ä∏[R] W) (œÜ : ùíü Y) : (SciLean.Distribution.bind x f L) œÜ = x.extAction (fun x' => SciLean.Distribution.extAction' (f x') ‚áëœÜ) L"}
{"name":"SciLean.iteD","declaration":"def SciLean.iteD {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) (t : ùíü'(X, Y)) (e : ùíü'(X, Y)) : ùíü'(X, Y)"}
{"name":"SciLean.Distribution.fintype_sum_extAction","declaration":"theorem SciLean.Distribution.fintype_sum_extAction {R : Type u_2} [SciLean.RealScalar R] {W : Type u_5} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {U : Type u_4} [SciLean.Vec R U] {V : Type u_6} [SciLean.Vec R V] {I : Type u_1} [Fintype I] (T : I ‚Üí ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : (Finset.sum Finset.univ fun i => T i).extAction œÜ L = Finset.sum Finset.univ fun i => (T i).extAction œÜ L"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.toDistribution_rule","declaration":"theorem SciLean.HSMul.hSMul.arg_a0a1.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module ‚Ñù Y] [MeasureTheory.MeasureSpace X] (r : R) (f : X ‚Üí Y) : (‚Üëfun x => r ‚Ä¢ f x) = r ‚Ä¢ ‚Üëf"}
{"name":"SciLean.Distribution.sub_extAction","declaration":"theorem SciLean.Distribution.sub_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : ùíü'(X, U)) (T' : ùíü'(X, U)) (œÜ : X ‚Üí V) (L : U ‚ä∏[R] V ‚ä∏[R] W) : (T - T').extAction œÜ L = T.extAction œÜ L - T'.extAction œÜ L"}
{"name":"SciLean.Distribution.action_iteD","declaration":"theorem SciLean.Distribution.action_iteD {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) (t : ùíü'(X, Y)) (e : ùíü'(X, Y)) (œÜ : ùíü X) : (ifD A then\n      t\n    else\n      e)\n    œÜ =\n  t.extAction (fun x => if x ‚àà A then œÜ x else 0) (fun y ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ y) +\n    e.extAction (fun x => if x ‚àâ A then œÜ x else 0) (fun y ‚ä∏[R] fun r ‚ä∏[R] r ‚Ä¢ y)"}
{"name":"SciLean.HMul.hMul.arg_a1.toDistribution_rule","declaration":"theorem SciLean.HMul.hMul.arg_a1.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (r : R) (f : X ‚Üí R) : (‚Üëfun x => r ‚Ä¢ f x) = r ‚Ä¢ ‚Üëf"}
{"name":"SciLean.neg_restrict'","declaration":"theorem SciLean.neg_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ùíü'(X, Y)) (A : Set X) : -T.restrict A = (-T).restrict A"}
