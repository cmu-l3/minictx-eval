{"name":"SciLean.sub_restrict'","declaration":"theorem SciLean.sub_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (S : ğ’Ÿ'(X, Y)) (A : Set X) : T.restrict A - S.restrict A = (T - S).restrict A"}
{"name":"SciLean.Distribution.toMeasure","declaration":"def SciLean.Distribution.toMeasure {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasurableSpace X] (f' : ğ’Ÿ'(X, R)) : MeasureTheory.Measure X"}
{"name":"SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule","declaration":"theorem SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule {R : Type u_1} [SciLean.RealScalar R] {W : Type u_5} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] (T : W â†’ ğ’Ÿ'(X, Y)) (f : Y âŠ¸[R] Z) (hT : SciLean.IsSmoothLinearMap R T) : SciLean.IsSmoothLinearMap R fun w => SciLean.Distribution.postComp (T w) f"}
{"name":"SciLean.Distribution.smul_extAction","declaration":"theorem SciLean.Distribution.smul_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (r : R) (T : ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : (r â€¢ T).extAction Ï† L = r â€¢ T.extAction Ï† L"}
{"name":"SciLean.Function.toDistribution_extAction","declaration":"theorem SciLean.Function.toDistribution_extAction {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_1} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (f : X â†’ Y) (Ï† : X â†’ R) : (â†‘f).extAction Ï† (fun y âŠ¸[R] fun r âŠ¸[R] r â€¢ y) = âˆ«' x, Ï† x â€¢ f x âˆ‚MeasureTheory.volume"}
{"name":"SciLean.Distribution.restrict","declaration":"def SciLean.Distribution.restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (A : Set X) : ğ’Ÿ'(X, Y)"}
{"name":"SciLean.Â«termğ’Ÿ'(_,_)Â»","declaration":"def SciLean.Â«termğ’Ÿ'(_,_)Â»  : Lean.ParserDescr"}
{"name":"SciLean.restrict_univ","declaration":"theorem SciLean.restrict_univ {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) : T.restrict Set.univ = T"}
{"name":"SciLean.Distribution.extAction_iteD'","declaration":"theorem SciLean.Distribution.extAction_iteD' {R : Type u_2} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_1} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (A : Set X) (B : Set X) (t : ğ’Ÿ'(X, U)) (e : ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : ((ifD A then\n            t\n          else\n            e).restrict\n        B).extAction\n    Ï† L =\n  (t.restrict B).extAction (fun x => if x âˆˆ A then Ï† x else 0) L +\n    (e.restrict B).extAction (fun x => if x âˆ‰ A then Ï† x else 0) L"}
{"name":"SciLean.Distribution.prod'_extAction","declaration":"theorem SciLean.Distribution.prod'_extAction {R : Type u_1} [SciLean.RealScalar R] {X : Type u_7} [SciLean.Vec R X] {Z : Type u_6} [SciLean.Vec R Z] {Xâ‚ : Type u_2} [SciLean.Vec R Xâ‚] {Xâ‚‚ : Type u_4} [SciLean.Vec R Xâ‚‚] {Yâ‚ : Type u_3} [SciLean.Vec R Yâ‚] {Yâ‚‚ : Type u_5} [SciLean.Vec R Yâ‚‚] (p : Xâ‚ â†’ Xâ‚‚ â†’ X) (T : ğ’Ÿ'(Xâ‚, Yâ‚)) (S : Xâ‚ â†’ ğ’Ÿ'(Xâ‚‚, Yâ‚‚)) (L : Yâ‚ âŠ¸[R] Yâ‚‚ âŠ¸[R] Z) (K : Z âŠ¸[R] R âŠ¸[R] Z) (Ï† : X â†’ R) : (SciLean.Distribution.prod p T S L).extAction Ï† K =\n  T.extAction (fun xâ‚ => (S xâ‚).extAction (fun xâ‚‚ => Ï† (p xâ‚ xâ‚‚)) (fun yâ‚‚ âŠ¸[R] fun r âŠ¸[R] r â€¢ yâ‚‚))\n    (fun yâ‚ âŠ¸[R] fun yâ‚‚ âŠ¸[R] (K ((L yâ‚) yâ‚‚)) 1)"}
{"name":"SciLean.Distribution.ext","declaration":"theorem SciLean.Distribution.ext {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (x : ğ’Ÿ'(X, Y)) (y : ğ’Ÿ'(X, Y)) : (âˆ€ (Ï† : ğ’Ÿ X), x Ï† = y Ï†) â†’ x = y"}
{"name":"Function.toDistribution","declaration":"def Function.toDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (f : X â†’ Y) : ğ’Ÿ'(X, Y)"}
{"name":"SciLean.Distribution.extAction.arg_Ï†.IsSmoothLinearMap","declaration":"theorem SciLean.Distribution.extAction.arg_Ï†.IsSmoothLinearMap {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : ğ’Ÿ'(X, U)) (Ï† : W â†’ X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] Z) (hÏ† : SciLean.IsSmoothLinearMap R Ï†) : SciLean.IsSmoothLinearMap R fun w => T.extAction (Ï† w) L"}
{"name":"SciLean.postComp_id","declaration":"theorem SciLean.postComp_id {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (u : ğ’Ÿ'(X, Y)) : SciLean.Distribution.postComp u (fun y âŠ¸[R] y) = u"}
{"name":"SciLean.instInnerDistribution","declaration":"instance SciLean.instInnerDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [MeasureTheory.MeasureSpace X] [SciLean.SemiInnerProductSpace R Y] [Module â„ Y] : Inner R (ğ’Ÿ'(X, Y))"}
{"name":"SciLean.HSub.hSub.arg_a0a1.toDistribution_rule","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (f : X â†’ Y) (g : X â†’ Y) : (â†‘fun x => f x - g x) = â†‘f - â†‘g"}
{"name":"SciLean.iteD.arg_te.IsSmoothLinearMap_rule","declaration":"theorem SciLean.iteD.arg_te.IsSmoothLinearMap_rule {R : Type u_2} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) (t : W â†’ ğ’Ÿ'(X, Y)) (e : W â†’ ğ’Ÿ'(X, Y)) (ht : SciLean.IsSmoothLinearMap R t) (he : SciLean.IsSmoothLinearMap R e) : SciLean.IsSmoothLinearMap R fun w =>\n  ifD A then\n    t w\n  else\n    e w"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.toDistribution_rule'","declaration":"theorem SciLean.HSMul.hSMul.arg_a0a1.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (r : R) (f : X â†’ Y) : r â€¢ â†‘f = â†‘fun x => r â€¢ f x"}
{"name":"SciLean.Distribution.add_extAction","declaration":"theorem SciLean.Distribution.add_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : ğ’Ÿ'(X, U)) (T' : ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : (T + T').extAction Ï† L = T.extAction Ï† L + T'.extAction Ï† L"}
{"name":"SciLean.unexpandIteD","declaration":"def SciLean.unexpandIteD  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.Function.toDistribution_action","declaration":"theorem SciLean.Function.toDistribution_action {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (f : X â†’ Y) (Ï† : ğ’Ÿ X) : â†‘f Ï† = âˆ«' x, Ï† x â€¢ f x âˆ‚MeasureTheory.volume"}
{"name":"SciLean.Distribution.mk_extAction","declaration":"theorem SciLean.Distribution.mk_extAction {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : (X â†’ R) â†’ Y) (hT : SciLean.IsSmoothLinearMap R fun Ï† => T â‡‘Ï†) (Ï† : X â†’ R) : (fun Ï† âŠ¸[R] T â‡‘Ï†).extAction Ï† (fun y âŠ¸[R] fun r âŠ¸[R] r â€¢ y) = T Ï†"}
{"name":"SciLean.Distribution.neg_extAction","declaration":"theorem SciLean.Distribution.neg_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : (-T).extAction Ï† L = -T.extAction Ï† L"}
{"name":"SciLean.Distribution","declaration":"def SciLean.Distribution (R : Type u_1) [SciLean.RealScalar R] (X : Type u_2) [SciLean.Vec R X] (Y : Type u_3) [SciLean.Vec R Y] : Type (max (max u_2 u_1) u_3)"}
{"name":"SciLean.TestFunction.apply_IsSmoothLinearMap","declaration":"theorem SciLean.TestFunction.apply_IsSmoothLinearMap {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] : SciLean.IsSmoothLinearMap R fun Ï† => â‡‘Ï†"}
{"name":"SciLean.unexpandDistribution","declaration":"def SciLean.unexpandDistribution  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.instModuleRealDistributionSemiringToAddCommMonoidToAddCommGroupToRCLikeToScalarInstVecSmoothLinearMapTestFunctionSpaceToTopologicalSpaceToUniformSpaceInstTCOrVecDiscreteTopologyInstVecToRCLikeToScalarTestFunctionSpace","declaration":"instance SciLean.instModuleRealDistributionSemiringToAddCommMonoidToAddCommGroupToRCLikeToScalarInstVecSmoothLinearMapTestFunctionSpaceToTopologicalSpaceToUniformSpaceInstTCOrVecDiscreteTopologyInstVecToRCLikeToScalarTestFunctionSpace {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] : Module â„ (ğ’Ÿ'(X, Y))"}
{"name":"SciLean.postComp_comp","declaration":"theorem SciLean.postComp_comp {R : Type u_1} [SciLean.RealScalar R] {W : Type u_5} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_4} [SciLean.Vec R V] (x : ğ’Ÿ'(X, U)) (g : U âŠ¸[R] V) (f : V âŠ¸[R] W) : SciLean.Distribution.postComp (SciLean.Distribution.postComp x g) f =\n  SciLean.Distribution.postComp x (fun u âŠ¸[R] f (g u))"}
{"name":"SciLean.postComp_restrict_extAction","declaration":"theorem SciLean.postComp_restrict_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Z : Type u_5} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] {V : Type u_4} [SciLean.Vec R V] (x : ğ’Ÿ'(X, U)) (f : U âŠ¸[R] V) (A : Set X) (Ï† : X â†’ W) (L : V âŠ¸[R] W âŠ¸[R] Z) : ((SciLean.Distribution.postComp x f).restrict A).extAction Ï† L =\n  (x.restrict A).extAction Ï† (fun u âŠ¸[R] fun w âŠ¸[R] (L (f u)) w)"}
{"name":"SciLean.Distribution.extAction'","declaration":"def SciLean.Distribution.extAction' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (Ï† : X â†’ R) : Y"}
{"name":"SciLean.indextype_sum_restrict'","declaration":"theorem SciLean.indextype_sum_restrict' {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {I : Type u_1} [SciLean.IndexType I] (T : I â†’ ğ’Ÿ'(X, R)) (A : Set X) :  âˆ‘ i, (T i).restrict A = ( âˆ‘ i, T i).restrict A"}
{"name":"SciLean.instSemiInnerProductSpaceToRCLikeToScalarDistribution","declaration":"instance SciLean.instSemiInnerProductSpaceToRCLikeToScalarDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [MeasureTheory.MeasureSpace X] [SciLean.SemiInnerProductSpace R Y] [Module â„ Y] : SciLean.SemiInnerProductSpace R (ğ’Ÿ'(X, Y))"}
{"name":"SciLean.Distribution.IsFunction","declaration":"def SciLean.Distribution.IsFunction {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (T : ğ’Ÿ'(X, Y)) : Prop"}
{"name":"SciLean.Distribution.extAction","declaration":"def SciLean.Distribution.extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {Z : Type u_5} [SciLean.Vec R Z] (T : ğ’Ÿ'(X, Y)) (Ï† : X â†’ Z) (L : Y âŠ¸[R] Z âŠ¸[R] W) : W"}
{"name":"SciLean.add_restrict'","declaration":"theorem SciLean.add_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (S : ğ’Ÿ'(X, Y)) (A : Set X) : T.restrict A + S.restrict A = (T + S).restrict A"}
{"name":"SciLean.instTestFunctionsDistribution","declaration":"instance SciLean.instTestFunctionsDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [MeasureTheory.MeasureSpace X] [SciLean.SemiInnerProductSpace R Y] [Module â„ Y] : SciLean.TestFunctions (ğ’Ÿ'(X, Y))"}
{"name":"SciLean.Distribution.postComp","declaration":"def SciLean.Distribution.postComp {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] {Z : Type u_4} [SciLean.Vec R Z] (T : ğ’Ÿ'(X, Y)) (f : Y âŠ¸[R] Z) : ğ’Ÿ'(X, Z)"}
{"name":"SciLean.postComp_assoc","declaration":"theorem SciLean.postComp_assoc {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_5} [SciLean.Vec R Y] {U : Type u_3} [SciLean.Vec R U] {V : Type u_4} [SciLean.Vec R V] (x : ğ’Ÿ'(X, U)) (y : U âŠ¸[R] ğ’Ÿ'(Y, V)) (f : V âŠ¸[R] W) (Ï† : Y â†’ R) : SciLean.Distribution.postComp (SciLean.Distribution.postComp x y) (fun T âŠ¸[R] SciLean.Distribution.postComp T f) =\n  SciLean.Distribution.postComp x (fun u âŠ¸[R] SciLean.Distribution.postComp (y u) f)"}
{"name":"SciLean.finset_sum_restrict","declaration":"theorem SciLean.finset_sum_restrict {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {I : Type u_1} [Fintype I] (T : I â†’ ğ’Ÿ'(X, Y)) (A : Set X) : (Finset.sum Finset.univ fun i => T i).restrict A = Finset.sum Finset.univ fun i => (T i).restrict A"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.toDistribution_rule'","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (f : X â†’ Y) (g : X â†’ Y) : â†‘f + â†‘g = â†‘fun x => f x + g x"}
{"name":"SciLean.Distribution.zero_extAction","declaration":"theorem SciLean.Distribution.zero_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_3} [SciLean.Vec R W] {X : Type u_5} [SciLean.Vec R X] {U : Type u_2} [SciLean.Vec R U] {V : Type u_4} [SciLean.Vec R V] (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : 0.extAction Ï† L = 0"}
{"name":"SciLean.action_dirac","declaration":"theorem SciLean.action_dirac {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] (x : X) (Ï† : ğ’Ÿ X) : (SciLean.dirac x) Ï† = Ï† x"}
{"name":"SciLean.Function.toDistribution_zero","declaration":"theorem SciLean.Function.toDistribution_zero {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] : (â†‘fun x => 0) = 0"}
{"name":"SciLean.termğ’Ÿ'_","declaration":"def SciLean.termğ’Ÿ'_  : Lean.ParserDescr"}
{"name":"SciLean.Distribution.prod_restrict","declaration":"theorem SciLean.Distribution.prod_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_7} [SciLean.Vec R X] {Z : Type u_6} [SciLean.Vec R Z] {Xâ‚ : Type u_2} [SciLean.Vec R Xâ‚] {Xâ‚‚ : Type u_4} [SciLean.Vec R Xâ‚‚] {Yâ‚ : Type u_3} [SciLean.Vec R Yâ‚] {Yâ‚‚ : Type u_5} [SciLean.Vec R Yâ‚‚] (p : Xâ‚ â†’ Xâ‚‚ â†’ X) (T : ğ’Ÿ'(Xâ‚, Yâ‚)) (S : Xâ‚ â†’ ğ’Ÿ'(Xâ‚‚, Yâ‚‚)) (L : Yâ‚ âŠ¸[R] Yâ‚‚ âŠ¸[R] Z) (A : Set X) : (SciLean.Distribution.prod p T S L).restrict A =\n  SciLean.Distribution.prod p (T.restrict (Set.preimage1 p A)) (fun xâ‚ => (S xâ‚).restrict (p xâ‚ â»Â¹' A)) L"}
{"name":"SciLean.Distribution.IsMeasure","declaration":"def SciLean.Distribution.IsMeasure {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasurableSpace X] (f : ğ’Ÿ'(X, R)) : Prop"}
{"name":"SciLean.HAdd.hAdd.arg_a0a1.toDistribution_rule","declaration":"theorem SciLean.HAdd.hAdd.arg_a0a1.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (f : X â†’ Y) (g : X â†’ Y) : (â†‘fun x => f x + g x) = â†‘f + â†‘g"}
{"name":"SciLean.HSub.hSub.arg_a0a1.toDistribution_rule'","declaration":"theorem SciLean.HSub.hSub.arg_a0a1.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (f : X â†’ Y) (g : X â†’ Y) : â†‘f - â†‘g = â†‘fun x => f x - g x"}
{"name":"SciLean.termIfD_Then_____Else____","declaration":"def SciLean.termIfD_Then_____Else____  : Lean.ParserDescr"}
{"name":"SciLean.finset_sum_restrict'","declaration":"theorem SciLean.finset_sum_restrict' {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {I : Type u_1} [Fintype I] (T : I â†’ ğ’Ÿ'(X, Y)) (A : Set X) : (Finset.sum Finset.univ fun i => (T i).restrict A) = (Finset.sum Finset.univ fun i => T i).restrict A"}
{"name":"SciLean.HMul.hMul.arg_a0.toDistribution_rule","declaration":"theorem SciLean.HMul.hMul.arg_a0.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (r : R) (f : X â†’ R) : (â†‘fun x => f x * r) = r â€¢ â†‘f"}
{"name":"SciLean.Distribution.toFunction","declaration":"def SciLean.Distribution.toFunction {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (T : ğ’Ÿ'(X, Y)) : X â†’ Y"}
{"name":"SciLean.Distribution.extAction.arg_T.IsSmoothLinearMap","declaration":"theorem SciLean.Distribution.extAction.arg_T.IsSmoothLinearMap {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Z : Type u_4} [SciLean.Vec R Z] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : W â†’ ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] Z) (hT : SciLean.IsSmoothLinearMap R T) : SciLean.IsSmoothLinearMap R fun w => (T w).extAction Ï† L"}
{"name":"SciLean.iteD_restrict","declaration":"theorem SciLean.iteD_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (A : Set X) : (ifD A then\n    T\n  else\n    0) =\n  T.restrict A"}
{"name":"MeasureTheory.Measure.toDistribution","declaration":"def MeasureTheory.Measure.toDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasurableSpace X] (Î¼ : MeasureTheory.Measure X) : ğ’Ÿ'(X, R)"}
{"name":"SciLean.Distribution.iteD_same","declaration":"theorem SciLean.Distribution.iteD_same {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) (u : ğ’Ÿ'(X, Y)) : (ifD A then\n    u\n  else\n    u) =\n  u"}
{"name":"SciLean.HMul.hMul.arg_a1.toDistribution_rule'","declaration":"theorem SciLean.HMul.hMul.arg_a1.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (r : R) (f : X â†’ R) : r â€¢ â†‘f = â†‘fun x => r â€¢ f x"}
{"name":"SciLean.neg_restrict","declaration":"theorem SciLean.neg_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (A : Set X) : (-T).restrict A = -T.restrict A"}
{"name":"SciLean.iteD_restrict'","declaration":"theorem SciLean.iteD_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (A : Set X) : (ifD A then\n    0\n  else\n    T) =\n  T.restrict Aá¶œ"}
{"name":"SciLean.sub_restrict","declaration":"theorem SciLean.sub_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (S : ğ’Ÿ'(X, Y)) (A : Set X) : (T - S).restrict A = T.restrict A - S.restrict A"}
{"name":"SciLean.smul_restrict","declaration":"theorem SciLean.smul_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (r : R) (T : ğ’Ÿ'(X, Y)) (A : Set X) : (r â€¢ T).restrict A = r â€¢ T.restrict A"}
{"name":"SciLean.smul_restrict'","declaration":"theorem SciLean.smul_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (r : R) (T : ğ’Ÿ'(X, Y)) (A : Set X) : r â€¢ T.restrict A = (r â€¢ T).restrict A"}
{"name":"SciLean.Distribution.indextype_sum_extAction","declaration":"theorem SciLean.Distribution.indextype_sum_extAction {R : Type u_2} [SciLean.RealScalar R] {W : Type (max (max u_2 u_3) u_4)} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {U : Type u_4} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] {I : Type u_1} [SciLean.IndexType I] (T : I â†’ ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : ( âˆ‘ i, T i).extAction Ï† L = âˆ‘ i, (T i).extAction Ï† L"}
{"name":"SciLean.HMul.hMul.arg_a0.toDistribution_rule'","declaration":"theorem SciLean.HMul.hMul.arg_a0.toDistribution_rule' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (r : R) (f : X â†’ R) : r â€¢ â†‘f = â†‘fun x => f x * r"}
{"name":"SciLean.zero_restrict","declaration":"theorem SciLean.zero_restrict {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) : 0.restrict A = 0"}
{"name":"SciLean.Distribution.prod","declaration":"def SciLean.Distribution.prod {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Z : Type u_3} [SciLean.Vec R Z] {Xâ‚ : Type u_4} [SciLean.Vec R Xâ‚] {Xâ‚‚ : Type u_5} [SciLean.Vec R Xâ‚‚] {Yâ‚ : Type u_6} [SciLean.Vec R Yâ‚] {Yâ‚‚ : Type u_7} [SciLean.Vec R Yâ‚‚] (p : Xâ‚ â†’ Xâ‚‚ â†’ X) (T : ğ’Ÿ'(Xâ‚, Yâ‚)) (S : Xâ‚ â†’ ğ’Ÿ'(Xâ‚‚, Yâ‚‚)) (L : Yâ‚ âŠ¸[R] Yâ‚‚ âŠ¸[R] Z) : ğ’Ÿ'(X, Z)"}
{"name":"SciLean.Distribution.Â«termâŸª_,_âŸ«[_]Â»","declaration":"def SciLean.Distribution.Â«termâŸª_,_âŸ«[_]Â»  : Lean.ParserDescr"}
{"name":"SciLean.Distribution.extAction_iteD","declaration":"theorem SciLean.Distribution.extAction_iteD {R : Type u_2} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_1} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (A : Set X) (t : ğ’Ÿ'(X, U)) (e : ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : (ifD A then\n        t\n      else\n        e).extAction\n    Ï† L =\n  t.extAction (fun x => if x âˆˆ A then Ï† x else 0) L + e.extAction (fun x => if x âˆ‰ A then Ï† x else 0) L"}
{"name":"SciLean.add_restrict","declaration":"theorem SciLean.add_restrict {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (S : ğ’Ÿ'(X, Y)) (A : Set X) : (T + S).restrict A = T.restrict A + S.restrict A"}
{"name":"SciLean.postComp_extAction","declaration":"theorem SciLean.postComp_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_4} [SciLean.Vec R X] {Z : Type u_5} [SciLean.Vec R Z] {U : Type u_2} [SciLean.Vec R U] {V : Type u_3} [SciLean.Vec R V] {y : U âŠ¸[R] V} (x : ğ’Ÿ'(X, U)) (f : U âŠ¸[R] V) (Ï† : X â†’ W) (L : V âŠ¸[R] W âŠ¸[R] Z) : (SciLean.Distribution.postComp x y).extAction Ï† L = x.extAction Ï† (fun u âŠ¸[R] fun w âŠ¸[R] (L (f u)) w)"}
{"name":"SciLean.iteD.arg_cte.toDistribution_rule","declaration":"theorem SciLean.iteD.arg_cte.toDistribution_rule {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (s : Set X) (t : X â†’ Y) (e : X â†’ Y) : (ifD s then\n    â†‘t\n  else\n    â†‘e) =\n  â†‘fun x => if x âˆˆ s then t x else e x"}
{"name":"SciLean.instSMulRealDistribution","declaration":"instance SciLean.instSMulRealDistribution {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] : SMul â„ (ğ’Ÿ'(X, Y))"}
{"name":"SciLean.dirac","declaration":"def SciLean.dirac {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] (x : X) : ğ’Ÿ'(X, R)"}
{"name":"SciLean.indextype_sum_restrict","declaration":"theorem SciLean.indextype_sum_restrict {R : Type u_2} [SciLean.RealScalar R] {X : Type u_3} [SciLean.Vec R X] {I : Type u_1} [SciLean.IndexType I] (T : I â†’ ğ’Ÿ'(X, R)) (A : Set X) : ( âˆ‘ i, T i).restrict A = âˆ‘ i, (T i).restrict A"}
{"name":"SciLean.Distribution.bind","declaration":"def SciLean.Distribution.bind {R : Type u_1} [SciLean.RealScalar R] {W : Type u_2} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {U : Type u_5} [SciLean.Vec R U] {V : Type u_6} [SciLean.Vec R V] (x' : ğ’Ÿ'(X, U)) (f : X â†’ ğ’Ÿ'(Y, V)) (L : U âŠ¸[R] V âŠ¸[R] W) : ğ’Ÿ'(Y, W)"}
{"name":"SciLean.Distribution.integrate","declaration":"def SciLean.Distribution.integrate {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) : Y"}
{"name":"SciLean.instCoeMeasureDistributionToVecToRCLikeToScalarInstSemiInnerProductSpace","declaration":"instance SciLean.instCoeMeasureDistributionToVecToRCLikeToScalarInstSemiInnerProductSpace {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasurableSpace X] : Coe (MeasureTheory.Measure X) (ğ’Ÿ'(X, R))"}
{"name":"SciLean.action_bind","declaration":"theorem SciLean.action_bind {R : Type u_1} [SciLean.RealScalar R] {W : Type u_6} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_4} [SciLean.Vec R Y] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (x : ğ’Ÿ'(X, U)) (f : X â†’ ğ’Ÿ'(Y, V)) (L : U âŠ¸[R] V âŠ¸[R] W) (Ï† : ğ’Ÿ Y) : (SciLean.Distribution.bind x f L) Ï† = x.extAction (fun x' => SciLean.Distribution.extAction' (f x') â‡‘Ï†) L"}
{"name":"SciLean.iteD","declaration":"def SciLean.iteD {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) (t : ğ’Ÿ'(X, Y)) (e : ğ’Ÿ'(X, Y)) : ğ’Ÿ'(X, Y)"}
{"name":"SciLean.Distribution.fintype_sum_extAction","declaration":"theorem SciLean.Distribution.fintype_sum_extAction {R : Type u_2} [SciLean.RealScalar R] {W : Type u_5} [SciLean.Vec R W] {X : Type u_3} [SciLean.Vec R X] {U : Type u_4} [SciLean.Vec R U] {V : Type u_6} [SciLean.Vec R V] {I : Type u_1} [Fintype I] (T : I â†’ ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : (Finset.sum Finset.univ fun i => T i).extAction Ï† L = Finset.sum Finset.univ fun i => (T i).extAction Ï† L"}
{"name":"SciLean.HSMul.hSMul.arg_a0a1.toDistribution_rule","declaration":"theorem SciLean.HSMul.hSMul.arg_a0a1.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] [Module â„ Y] [MeasureTheory.MeasureSpace X] (r : R) (f : X â†’ Y) : (â†‘fun x => r â€¢ f x) = r â€¢ â†‘f"}
{"name":"SciLean.Distribution.sub_extAction","declaration":"theorem SciLean.Distribution.sub_extAction {R : Type u_1} [SciLean.RealScalar R] {W : Type u_4} [SciLean.Vec R W] {X : Type u_2} [SciLean.Vec R X] {U : Type u_3} [SciLean.Vec R U] {V : Type u_5} [SciLean.Vec R V] (T : ğ’Ÿ'(X, U)) (T' : ğ’Ÿ'(X, U)) (Ï† : X â†’ V) (L : U âŠ¸[R] V âŠ¸[R] W) : (T - T').extAction Ï† L = T.extAction Ï† L - T'.extAction Ï† L"}
{"name":"SciLean.Distribution.action_iteD","declaration":"theorem SciLean.Distribution.action_iteD {R : Type u_2} [SciLean.RealScalar R] {X : Type u_1} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (A : Set X) (t : ğ’Ÿ'(X, Y)) (e : ğ’Ÿ'(X, Y)) (Ï† : ğ’Ÿ X) : (ifD A then\n      t\n    else\n      e)\n    Ï† =\n  t.extAction (fun x => if x âˆˆ A then Ï† x else 0) (fun y âŠ¸[R] fun r âŠ¸[R] r â€¢ y) +\n    e.extAction (fun x => if x âˆ‰ A then Ï† x else 0) (fun y âŠ¸[R] fun r âŠ¸[R] r â€¢ y)"}
{"name":"SciLean.HMul.hMul.arg_a1.toDistribution_rule","declaration":"theorem SciLean.HMul.hMul.arg_a1.toDistribution_rule {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] [MeasureTheory.MeasureSpace X] (r : R) (f : X â†’ R) : (â†‘fun x => r â€¢ f x) = r â€¢ â†‘f"}
{"name":"SciLean.neg_restrict'","declaration":"theorem SciLean.neg_restrict' {R : Type u_1} [SciLean.RealScalar R] {X : Type u_2} [SciLean.Vec R X] {Y : Type u_3} [SciLean.Vec R Y] (T : ğ’Ÿ'(X, Y)) (A : Set X) : -T.restrict A = (-T).restrict A"}
