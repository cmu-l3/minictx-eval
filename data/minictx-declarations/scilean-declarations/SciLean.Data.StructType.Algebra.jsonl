{"name":"SciLean.instTestFunctionsRecSumType","declaration":"instance SciLean.instTestFunctionsRecSumType {I : Type u_1} {EI : I → Type u_2} {J : Type u_3} {FJ : J → Type u_2} [(i : I) → SciLean.TestFunctions (EI i)] [(j : J) → SciLean.TestFunctions (FJ j)] (i : I ⊕ J) : SciLean.TestFunctions (Sum.rec EI FJ i)"}
{"name":"SciLean.instVecStructDefault","declaration":"instance SciLean.instVecStructDefault (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.Vec K X] : SciLean.VecStruct K X Unit fun x => X"}
{"name":"SciLean.oneHot_inl","declaration":"theorem SciLean.oneHot_inl {E : Type u_1} {I : Type u_4} {EI : I → Type u_5} [SciLean.StructType E I EI] {F : Type u_2} {J : Type u_3} {FJ : J → Type u_5} [SciLean.StructType F J FJ] [(i : I) → Zero (EI i)] [Zero F] [(j : J) → Zero (FJ j)] [SciLean.ZeroStruct F J FJ] [DecidableEq I] [DecidableEq J] (i : I) (xi : EI i) : SciLean.oneHot (Sum.inl i) xi = (SciLean.oneHot i xi, 0)"}
{"name":"SciLean.SMulStruct","declaration":"class SciLean.SMulStruct (K : Type u_1) (X : Type u_2) (I : Sort u_3) (XI : I → Type u_4) [SciLean.StructType X I XI] [SMul K X] [(i : I) → SMul K (XI i)] : Prop"}
{"name":"SciLean.ZeroStruct.mk","declaration":"ctor SciLean.ZeroStruct.mk {X : Type u_1} {I : Sort u_2} {XI : I → Type u_3} [SciLean.StructType X I XI] [Zero X] [(i : I) → Zero (XI i)] (structProj_zero : ∀ (i : I), SciLean.structProj 0 i = 0) : SciLean.ZeroStruct X I XI"}
{"name":"SciLean.instVecRecSumType","declaration":"instance SciLean.instVecRecSumType (K : Type u_1) [RCLike K] {I : Type u_2} {EI : I → Type u_3} {J : Type u_4} {FJ : J → Type u_3} [(i : I) → SciLean.Vec K (EI i)] [(j : J) → SciLean.Vec K (FJ j)] (i : I ⊕ J) : SciLean.Vec K (Sum.rec EI FJ i)"}
{"name":"SciLean.SMulStruct.mk","declaration":"ctor SciLean.SMulStruct.mk {K : Type u_1} {X : Type u_2} {I : Sort u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [SMul K X] [(i : I) → SMul K (XI i)] (structProj_smul : ∀ (i : I) (k : K) (x : X), SciLean.structProj (k • x) i = k • SciLean.structProj x i) : SciLean.SMulStruct K X I XI"}
{"name":"SciLean.StructType.structMake.arg_f.IsLinearMap_rule","declaration":"theorem SciLean.StructType.structMake.arg_f.IsLinearMap_rule (K : Type u_1) [RCLike K] {I : Type u_3} {X : Type u_5} {XI : I → Type u_4} [SciLean.StructType X I XI] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] {W : Type u_2} [SciLean.Vec K W] (f : W → (i : I) → XI i) (hf : IsLinearMap K f) : IsLinearMap K fun w => SciLean.structMake (f w)"}
{"name":"SciLean.instInnerRecSumType","declaration":"instance SciLean.instInnerRecSumType (K : Type u_1) {I : Type u_2} {EI : I → Type u_3} {J : Type u_4} {FJ : J → Type u_3} [(i : I) → Inner K (EI i)] [(j : J) → Inner K (FJ j)] (i : I ⊕ J) : Inner K (Sum.rec EI FJ i)"}
{"name":"SciLean.SemiInnerProductSpaceStruct.testFun_structProj","declaration":"def SciLean.SemiInnerProductSpaceStruct.testFun_structProj {K : Type u_1} {X : Type u_2} {I : Type u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [RCLike K] [SciLean.IndexType I] [SciLean.LawfulIndexType I] [SciLean.SemiInnerProductSpace K X] [(i : I) → SciLean.SemiInnerProductSpace K (XI i)] [self : SciLean.SemiInnerProductSpaceStruct K X I XI] (x : X) : SciLean.TestFunction x ↔ ∀ (i : I), SciLean.TestFunction (SciLean.structProj x i)"}
{"name":"SciLean.AddStruct.mk","declaration":"ctor SciLean.AddStruct.mk {X : Type u_1} {I : Sort u_2} {XI : I → Type u_3} [SciLean.StructType X I XI] [Add X] [(i : I) → Add (XI i)] (structProj_add : ∀ (i : I) (x x' : X), SciLean.structProj (x + x') i = SciLean.structProj x i + SciLean.structProj x' i) : SciLean.AddStruct X I XI"}
{"name":"SciLean.inner_oneHot_eq_inner_structProj","declaration":"theorem SciLean.inner_oneHot_eq_inner_structProj (K : Type u_4) [RCLike K] {I : Type u_3} {X : Type u_1} {XI : I → Type u_2} [SciLean.StructType X I XI] [SciLean.IndexType I] [SciLean.LawfulIndexType I] [DecidableEq I] [(i : I) → SciLean.SemiInnerProductSpace K (XI i)] [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpaceStruct K X I XI] (i : I) (xi : XI i) (x : X) : ⟪x, SciLean.oneHot i xi⟫_K = ⟪SciLean.structProj x i, xi⟫_K"}
{"name":"SciLean.VecStruct.structProj_continuous","declaration":"def SciLean.VecStruct.structProj_continuous {K : Type u_1} {X : Type u_2} {I : Type u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [RCLike K] [SciLean.Vec K X] [(i : I) → SciLean.Vec K (XI i)] [self : SciLean.VecStruct K X I XI] : Continuous fun x i => SciLean.structProj x i"}
{"name":"SciLean.ZeroStruct","declaration":"class SciLean.ZeroStruct (X : Type u_1) (I : Sort u_2) (XI : I → Type u_3) [SciLean.StructType X I XI] [Zero X] [(i : I) → Zero (XI i)] : Prop"}
{"name":"SciLean.StructType.structMake_zero","declaration":"theorem SciLean.StructType.structMake_zero (K : Type u_4) [RCLike K] {I : Type u_2} {X : Type u_1} {XI : I → Type u_3} [SciLean.StructType X I XI] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] : (SciLean.structMake fun x => 0) = 0"}
{"name":"SciLean.instSemiInnerProductSpaceRecSumType","declaration":"instance SciLean.instSemiInnerProductSpaceRecSumType (K : Type u_1) [RCLike K] {I : Type u_2} {EI : I → Type u_3} {J : Type u_4} {FJ : J → Type u_3} [(i : I) → SciLean.SemiInnerProductSpace K (EI i)] [(j : J) → SciLean.SemiInnerProductSpace K (FJ j)] (i : I ⊕ J) : SciLean.SemiInnerProductSpace K (Sum.rec EI FJ i)"}
{"name":"SciLean.instSemiInnerProductSpaceStructProdSumRecTypeInstStrucTypeProdInstIndexTypeSumInstLawfulIndexTypeSumInstIndexTypeSumInstSemiInnerProductSpaceProdInstSemiInnerProductSpaceRecSumType","declaration":"instance SciLean.instSemiInnerProductSpaceStructProdSumRecTypeInstStrucTypeProdInstIndexTypeSumInstLawfulIndexTypeSumInstIndexTypeSumInstSemiInnerProductSpaceProdInstSemiInnerProductSpaceRecSumType (K : Type u_1) [RCLike K] {E : Type u_2} {I : Type u_3} {EI : I → Type u_4} [SciLean.StructType E I EI] {F : Type u_5} {J : Type u_6} {FJ : J → Type u_4} [SciLean.StructType F J FJ] [SciLean.SemiInnerProductSpace K E] [SciLean.SemiInnerProductSpace K F] [(i : I) → SciLean.SemiInnerProductSpace K (EI i)] [(j : J) → SciLean.SemiInnerProductSpace K (FJ j)] [SciLean.IndexType I] [SciLean.LawfulIndexType I] [SciLean.IndexType J] [SciLean.LawfulIndexType J] [SciLean.SemiInnerProductSpaceStruct K E I EI] [SciLean.SemiInnerProductSpaceStruct K F J FJ] : SciLean.SemiInnerProductSpaceStruct K (E × F) (I ⊕ J) fun t => Sum.rec EI FJ t"}
{"name":"SciLean.instSubRecSumType","declaration":"instance SciLean.instSubRecSumType {I : Type u_1} {EI : I → Type u_2} {J : Type u_3} {FJ : J → Type u_2} [(i : I) → Sub (EI i)] [(j : J) → Sub (FJ j)] (i : I ⊕ J) : Sub (Sum.rec EI FJ i)"}
{"name":"SciLean.instAddStructDefault","declaration":"instance SciLean.instAddStructDefault {X : Type u_1} [Add X] : SciLean.AddStruct X Unit fun x => X"}
{"name":"SciLean.SemiInnerProductSpaceStruct.inner_structProj","declaration":"def SciLean.SemiInnerProductSpaceStruct.inner_structProj {K : Type u_1} {X : Type u_2} {I : Type u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [RCLike K] [SciLean.IndexType I] [SciLean.LawfulIndexType I] [SciLean.SemiInnerProductSpace K X] [(i : I) → SciLean.SemiInnerProductSpace K (XI i)] [self : SciLean.SemiInnerProductSpaceStruct K X I XI] (x : X) (x' : X) : ⟪x, x'⟫_K = ∑ i, ⟪SciLean.structProj x i, SciLean.structProj x' i⟫_K"}
{"name":"SciLean.StructType.structProj.arg_x.CDifferentiable_rule","declaration":"theorem SciLean.StructType.structProj.arg_x.CDifferentiable_rule (K : Type u_1) [RCLike K] {I : Type u_5} {X : Type u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] {W : Type u_2} [SciLean.Vec K W] (x : W → X) (i : I) (hx : SciLean.CDifferentiable K x) : SciLean.CDifferentiable K fun w => SciLean.structProj (x w) i"}
{"name":"SciLean.instSMulRecSumType","declaration":"instance SciLean.instSMulRecSumType (K : Type u_1) {I : Type u_2} {EI : I → Type u_3} {J : Type u_4} {FJ : J → Type u_3} [(i : I) → SMul K (EI i)] [(j : J) → SMul K (FJ j)] (i : I ⊕ J) : SMul K (Sum.rec EI FJ i)"}
{"name":"SciLean.VecStruct","declaration":"class SciLean.VecStruct (K : Type u_1) (X : Type u_2) (I : Type u_3) (XI : I → Type u_4) [SciLean.StructType X I XI] [RCLike K] [SciLean.Vec K X] [(i : I) → SciLean.Vec K (XI i)] : Prop"}
{"name":"SciLean.instSemiInnerProductSpaceStructUnitInstStructTypeDefaultInstIndexTypeUnitInstLawfulIndexTypeUnitInstIndexTypeUnit","declaration":"instance SciLean.instSemiInnerProductSpaceStructUnitInstStructTypeDefaultInstIndexTypeUnitInstLawfulIndexTypeUnitInstIndexTypeUnit (K : Type u_1) [RCLike K] {X : Type u_2} [SciLean.SemiInnerProductSpace K X] : SciLean.SemiInnerProductSpaceStruct K X Unit fun x => X"}
{"name":"SciLean.instTopologicalSpaceRecSumType","declaration":"instance SciLean.instTopologicalSpaceRecSumType {I : Type u_1} {EI : I → Type u_2} {J : Type u_3} {FJ : J → Type u_2} [(i : I) → TopologicalSpace (EI i)] [(j : J) → TopologicalSpace (FJ j)] (i : I ⊕ J) : TopologicalSpace (Sum.rec EI FJ i)"}
{"name":"SciLean.SMulStruct.structProj_smul","declaration":"def SciLean.SMulStruct.structProj_smul {K : Type u_1} {X : Type u_2} {I : Sort u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [SMul K X] [(i : I) → SMul K (XI i)] [self : SciLean.SMulStruct K X I XI] (i : I) (k : K) (x : X) : SciLean.structProj (k • x) i = k • SciLean.structProj x i"}
{"name":"SciLean.instUniformSpaceRecSumType","declaration":"instance SciLean.instUniformSpaceRecSumType {I : Type u_1} {EI : I → Type u_2} {J : Type u_3} {FJ : J → Type u_2} [(i : I) → UniformSpace (EI i)] [(j : J) → UniformSpace (FJ j)] (i : I ⊕ J) : UniformSpace (Sum.rec EI FJ i)"}
{"name":"SciLean.VecStruct.structMake_continuous","declaration":"def SciLean.VecStruct.structMake_continuous {K : Type u_1} {X : Type u_2} {I : Type u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [RCLike K] [SciLean.Vec K X] [(i : I) → SciLean.Vec K (XI i)] [self : SciLean.VecStruct K X I XI] : Continuous fun f => SciLean.structMake f"}
{"name":"SciLean.StructType.structMake.arg_f.CDifferentiable_rule","declaration":"theorem SciLean.StructType.structMake.arg_f.CDifferentiable_rule (K : Type u_1) [RCLike K] {I : Type u_3} {X : Type u_5} {XI : I → Type u_4} [SciLean.StructType X I XI] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] {W : Type u_2} [SciLean.Vec K W] (f : W → (i : I) → XI i) (hf : SciLean.CDifferentiable K f) : SciLean.CDifferentiable K fun w => SciLean.structMake (f w)"}
{"name":"SciLean.AddStruct.structProj_add","declaration":"def SciLean.AddStruct.structProj_add {X : Type u_1} {I : Sort u_2} {XI : I → Type u_3} [SciLean.StructType X I XI] [Add X] [(i : I) → Add (XI i)] [self : SciLean.AddStruct X I XI] (i : I) (x : X) (x' : X) : SciLean.structProj (x + x') i = SciLean.structProj x i + SciLean.structProj x' i"}
{"name":"SciLean.oneHot_inr","declaration":"theorem SciLean.oneHot_inr {E : Type u_1} {I : Type u_4} {EI : I → Type u_5} [SciLean.StructType E I EI] {F : Type u_2} {J : Type u_3} {FJ : J → Type u_5} [SciLean.StructType F J FJ] [Zero E] [(i : I) → Zero (EI i)] [SciLean.ZeroStruct E I EI] [(j : J) → Zero (FJ j)] [DecidableEq I] [DecidableEq J] (j : J) (xj : FJ j) : SciLean.oneHot (Sum.inr j) xj = (0, SciLean.oneHot j xj)"}
{"name":"SciLean.add_oneHot_eq_structModify","declaration":"theorem SciLean.add_oneHot_eq_structModify (K : Type u_2) [RCLike K] {I : Type u_3} {X : Type u_1} {XI : I → Type u_4} [SciLean.StructType X I XI] [DecidableEq I] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] (i : I) (xi : XI i) (x : X) : x + SciLean.oneHot i xi = SciLean.structModify i (fun xi' => xi' + xi) x"}
{"name":"SciLean.instSMulStructDefault","declaration":"instance SciLean.instSMulStructDefault (K : Type u_1) [RCLike K] {X : Type u_2} [SMul K X] : SciLean.SMulStruct K X Unit fun x => X"}
{"name":"SciLean.oneHot.arg_xi.IsLinearMap_rule_simple","declaration":"theorem SciLean.oneHot.arg_xi.IsLinearMap_rule_simple (K : Type u_1) [RCLike K] {I : Type u_4} {X : Type u_3} {XI : I → Type u_2} [SciLean.StructType X I XI] [DecidableEq I] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] (i : I) : IsLinearMap K fun xi => SciLean.oneHot i xi"}
{"name":"SciLean.inner_oneHot_eq_inner_proj'","declaration":"theorem SciLean.inner_oneHot_eq_inner_proj' (K : Type u_4) [RCLike K] {I : Type u_3} {X : Type u_1} {XI : I → Type u_2} [SciLean.StructType X I XI] [SciLean.IndexType I] [SciLean.LawfulIndexType I] [DecidableEq I] [(i : I) → SciLean.SemiInnerProductSpace K (XI i)] [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpaceStruct K X I XI] (i : I) (xi : XI i) (x : X) : ⟪SciLean.oneHot i xi, x⟫_K = ⟪xi, SciLean.structProj x i⟫_K"}
{"name":"SciLean.SemiInnerProductSpaceStruct","declaration":"class SciLean.SemiInnerProductSpaceStruct (K : Type u_1) (X : Type u_2) (I : Type u_3) (XI : I → Type u_4) [SciLean.StructType X I XI] [RCLike K] [SciLean.IndexType I] [SciLean.LawfulIndexType I] [SciLean.SemiInnerProductSpace K X] [(i : I) → SciLean.SemiInnerProductSpace K (XI i)] : Prop"}
{"name":"SciLean.VecStruct.mk","declaration":"ctor SciLean.VecStruct.mk {K : Type u_1} {X : Type u_2} {I : Type u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [RCLike K] [SciLean.Vec K X] [(i : I) → SciLean.Vec K (XI i)] [toZeroStruct : SciLean.ZeroStruct X I XI] [toAddStruct : SciLean.AddStruct X I XI] [toSMulStruct : SciLean.SMulStruct K X I XI] (structProj_continuous : Continuous fun x i => SciLean.structProj x i) (structMake_continuous : Continuous fun f => SciLean.structMake f) : SciLean.VecStruct K X I XI"}
{"name":"SciLean.instVecStructProd","declaration":"instance SciLean.instVecStructProd (K : Type u_1) [RCLike K] {E : Type u_2} {I : Type u_3} {EI : I → Type u_4} [SciLean.StructType E I EI] {F : Type u_5} {J : Type u_6} {FJ : J → Type u_4} [SciLean.StructType F J FJ] [SciLean.Vec K E] [SciLean.Vec K F] [(i : I) → SciLean.Vec K (EI i)] [(j : J) → SciLean.Vec K (FJ j)] [SciLean.VecStruct K E I EI] [SciLean.VecStruct K F J FJ] : SciLean.VecStruct K (E × F) (I ⊕ J) fun t => Sum.rec EI FJ t"}
{"name":"SciLean.instZeroRecSumType","declaration":"instance SciLean.instZeroRecSumType {I : Type u_1} {EI : I → Type u_2} {J : Type u_3} {FJ : J → Type u_2} [(i : I) → Zero (EI i)] [(j : J) → Zero (FJ j)] (i : I ⊕ J) : Zero (Sum.rec EI FJ i)"}
{"name":"SciLean.instAddStructProd","declaration":"instance SciLean.instAddStructProd {E : Type u_1} {I : Type u_2} {EI : I → Type u_3} [SciLean.StructType E I EI] {F : Type u_4} {J : Type u_5} {FJ : J → Type u_3} [SciLean.StructType F J FJ] [Add E] [Add F] [(i : I) → Add (EI i)] [(j : J) → Add (FJ j)] [SciLean.AddStruct E I EI] [SciLean.AddStruct F J FJ] : SciLean.AddStruct (E × F) (I ⊕ J) fun t => Sum.rec EI FJ t"}
{"name":"SciLean.SemiInnerProductSpaceStruct.mk","declaration":"ctor SciLean.SemiInnerProductSpaceStruct.mk {K : Type u_1} {X : Type u_2} {I : Type u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [RCLike K] [SciLean.IndexType I] [SciLean.LawfulIndexType I] [SciLean.SemiInnerProductSpace K X] [(i : I) → SciLean.SemiInnerProductSpace K (XI i)] [toVecStruct : SciLean.VecStruct K X I XI] (inner_structProj : ∀ (x x' : X), ⟪x, x'⟫_K = ∑ i, ⟪SciLean.structProj x i, SciLean.structProj x' i⟫_K) (testFun_structProj : ∀ (x : X), SciLean.TestFunction x ↔ ∀ (i : I), SciLean.TestFunction (SciLean.structProj x i)) : SciLean.SemiInnerProductSpaceStruct K X I XI"}
{"name":"SciLean.StructType.structProj.arg_x.IsLinearMap_rule","declaration":"theorem SciLean.StructType.structProj.arg_x.IsLinearMap_rule (K : Type u_1) [RCLike K] {I : Type u_5} {X : Type u_3} {XI : I → Type u_4} [SciLean.StructType X I XI] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] {W : Type u_2} [SciLean.Vec K W] (x : W → X) (i : I) (hx : IsLinearMap K x) : IsLinearMap K fun w => SciLean.structProj (x w) i"}
{"name":"SciLean.ZeroStruct.structProj_zero","declaration":"def SciLean.ZeroStruct.structProj_zero {X : Type u_1} {I : Sort u_2} {XI : I → Type u_3} [SciLean.StructType X I XI] [Zero X] [(i : I) → Zero (XI i)] [self : SciLean.ZeroStruct X I XI] (i : I) : SciLean.structProj 0 i = 0"}
{"name":"SciLean.add_oneHot_eq_structModify'","declaration":"theorem SciLean.add_oneHot_eq_structModify' (K : Type u_2) [RCLike K] {I : Type u_3} {X : Type u_1} {XI : I → Type u_4} [SciLean.StructType X I XI] [DecidableEq I] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] (i : I) (xi : XI i) (x : X) : SciLean.oneHot i xi + x = SciLean.structModify i (fun xi' => xi + xi') x"}
{"name":"SciLean.instSemiHilbertRecSumType","declaration":"instance SciLean.instSemiHilbertRecSumType (K : Type u_1) [RCLike K] {I : Type u_2} {EI : I → Type u_3} {J : Type u_4} {FJ : J → Type u_3} [(i : I) → SciLean.SemiHilbert K (EI i)] [(j : J) → SciLean.SemiHilbert K (FJ j)] (i : I ⊕ J) : SciLean.SemiHilbert K (Sum.rec EI FJ i)"}
{"name":"SciLean.instAddRecSumType","declaration":"instance SciLean.instAddRecSumType {I : Type u_1} {EI : I → Type u_2} {J : Type u_3} {FJ : J → Type u_2} [(i : I) → Add (EI i)] [(j : J) → Add (FJ j)] (i : I ⊕ J) : Add (Sum.rec EI FJ i)"}
{"name":"SciLean.AddStruct","declaration":"class SciLean.AddStruct (X : Type u_1) (I : Sort u_2) (XI : I → Type u_3) [SciLean.StructType X I XI] [Add X] [(i : I) → Add (XI i)] : Prop"}
{"name":"SciLean.StructType.structMake.arg_f.IsLinearMap_rule_simple","declaration":"theorem SciLean.StructType.structMake.arg_f.IsLinearMap_rule_simple (K : Type u_1) [RCLike K] {I : Type u_2} {X : Type u_4} {XI : I → Type u_3} [SciLean.StructType X I XI] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] : IsLinearMap K fun f => SciLean.structMake f"}
{"name":"SciLean.instSMulStructProd","declaration":"instance SciLean.instSMulStructProd (K : Type u_1) [RCLike K] {E : Type u_2} {I : Type u_3} {EI : I → Type u_4} [SciLean.StructType E I EI] {F : Type u_5} {J : Type u_6} {FJ : J → Type u_4} [SciLean.StructType F J FJ] [SMul K E] [SMul K F] [(i : I) → SMul K (EI i)] [(j : J) → SMul K (FJ j)] [SciLean.SMulStruct K E I EI] [SciLean.SMulStruct K F J FJ] : SciLean.SMulStruct K (E × F) (I ⊕ J) fun t => Sum.rec EI FJ t"}
{"name":"SciLean.oneHot.arg_xi.IsLinearMap_rule","declaration":"theorem SciLean.oneHot.arg_xi.IsLinearMap_rule (K : Type u_1) [RCLike K] {I : Type u_5} {X : Type u_4} {XI : I → Type u_3} [SciLean.StructType X I XI] [DecidableEq I] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] {W : Type u_2} [SciLean.Vec K W] (i : I) (xi : W → XI i) (hxi : IsLinearMap K xi) : IsLinearMap K fun w => SciLean.oneHot i (xi w)"}
{"name":"SciLean.oneHot.arg_xi.CDifferentiable_rule","declaration":"theorem SciLean.oneHot.arg_xi.CDifferentiable_rule (K : Type u_1) [RCLike K] {I : Type u_5} {X : Type u_4} {XI : I → Type u_3} [SciLean.StructType X I XI] [DecidableEq I] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] {W : Type u_2} [SciLean.Vec K W] (i : I) (xi : W → XI i) (hxi : SciLean.CDifferentiable K xi) : SciLean.CDifferentiable K fun w => SciLean.oneHot i (xi w)"}
{"name":"SciLean.instZeroStructProd","declaration":"instance SciLean.instZeroStructProd {E : Type u_1} {I : Type u_2} {EI : I → Type u_3} [SciLean.StructType E I EI] {F : Type u_4} {J : Type u_5} {FJ : J → Type u_3} [SciLean.StructType F J FJ] [Zero E] [Zero F] [(i : I) → Zero (EI i)] [(j : J) → Zero (FJ j)] [SciLean.ZeroStruct E I EI] [SciLean.ZeroStruct F J FJ] : SciLean.ZeroStruct (E × F) (I ⊕ J) fun t => Sum.rec EI FJ t"}
{"name":"SciLean.StructType.structProj.arg_x.IsLinearMap_rule_simple","declaration":"theorem SciLean.StructType.structProj.arg_x.IsLinearMap_rule_simple (K : Type u_1) [RCLike K] {I : Type u_4} {X : Type u_2} {XI : I → Type u_3} [SciLean.StructType X I XI] [(i : I) → SciLean.Vec K (XI i)] [SciLean.Vec K X] (i : I) : IsLinearMap K fun x => SciLean.structProj x i"}
{"name":"SciLean.instNegRecSumType","declaration":"instance SciLean.instNegRecSumType {I : Type u_1} {EI : I → Type u_2} {J : Type u_3} {FJ : J → Type u_2} [(i : I) → Neg (EI i)] [(j : J) → Neg (FJ j)] (i : I ⊕ J) : Neg (Sum.rec EI FJ i)"}
{"name":"SciLean.instZeroStructDefault","declaration":"instance SciLean.instZeroStructDefault {X : Type u_1} [Zero X] : SciLean.ZeroStruct X Unit fun x => X"}
