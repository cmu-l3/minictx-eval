{"name":"SciLean.fwdDerivM.let_rule","declaration":"theorem SciLean.fwdDerivM.let_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] {Z : Type} [SciLean.Vec K Z] (f : X → Y → m Z) (g : X → Y) (hf : SciLean.CDifferentiableM K fun xy => f xy.1 xy.2) (hg : SciLean.CDifferentiable K g) : (SciLean.fwdDerivM K fun x =>\n    let y := g x;\n    f x y) =\n  fun x dx =>\n  let ydy := SciLean.fwdDeriv K g x dx;\n  SciLean.fwdDerivM K (fun xy => f xy.1 xy.2) (x, ydy.1) (dx, ydy.2)"}
{"name":"SciLean.fwdDerivM.const_rule","declaration":"theorem SciLean.fwdDerivM.const_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] (y : m Y) (hy : SciLean.CDifferentiableValM K y) : (SciLean.fwdDerivM K fun x => y) = fun x x => SciLean.fwdDerivValM K y"}
{"name":"SciLean.fwdDerivM.pure_rule","declaration":"theorem SciLean.fwdDerivM.pure_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] : (SciLean.fwdDerivM K fun x => pure x) = fun x dx => pure (x, dx)"}
{"name":"Bind.bind.arg_a0a1.CDifferentiableM_rule","declaration":"theorem Bind.bind.arg_a0a1.CDifferentiableM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] {Z : Type} [SciLean.Vec K Z] (a0 : X → m Y) (a1 : X → Y → m Z) (ha0 : SciLean.CDifferentiableM K a0) (ha1 : SciLean.CDifferentiableM K fun xy => a1 xy.1 xy.2) : SciLean.CDifferentiableM K fun x => a0 x >>= a1 x"}
{"name":"SciLean.FwdDerivMonad.fwdDerivM_pair","declaration":"def SciLean.FwdDerivMonad.fwdDerivM_pair {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.FwdDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.Vec K X] [SciLean.Vec K Y] (f : X → m Y) (hf : SciLean.CDifferentiableM K f) : (SciLean.fwdDerivM K fun x => do\n    let y ← f x\n    pure (x, y)) =\n  fun x dx => do\n  let ydy ← SciLean.fwdDerivM K f x dx\n  pure ((x, ydy.1), dx, ydy.2)"}
{"name":"SciLean.CDifferentiableM.pure_rule","declaration":"theorem SciLean.CDifferentiableM.pure_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] : SciLean.CDifferentiableM K fun x => pure x"}
{"name":"Bind.bind.arg_a0a1.fwdDerivM_rule","declaration":"theorem Bind.bind.arg_a0a1.fwdDerivM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] {Z : Type} [SciLean.Vec K Z] (a0 : X → m Y) (a1 : X → Y → m Z) (ha0 : SciLean.CDifferentiableM K a0) (ha1 : SciLean.CDifferentiableM K fun xy => a1 xy.1 xy.2) : (SciLean.fwdDerivM K fun x => a0 x >>= a1 x) = fun x dx => do\n  let ydy ← SciLean.fwdDerivM K a0 x dx\n  SciLean.fwdDerivM K (fun xy => a1 xy.1 xy.2) (x, ydy.1) (dx, ydy.2)"}
{"name":"SciLean.FwdDerivMonad.mk","declaration":"ctor SciLean.FwdDerivMonad.mk {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] (fwdDerivM : {X Y : Type} → [inst : SciLean.Vec K X] → [inst : SciLean.Vec K Y] → (X → m Y) → X → X → m' (Y × Y)) (CDifferentiableM : {X Y : Type} → [inst : SciLean.Vec K X] → [inst : SciLean.Vec K Y] → (X → m Y) → Prop) (fwdDerivM_pure : ∀ {X Y : Type} [inst : SciLean.Vec K X] [inst_1 : SciLean.Vec K Y] (f : X → Y),\n  SciLean.CDifferentiable K f → (fwdDerivM fun x => pure (f x)) = fun x dx => pure (SciLean.fwdDeriv K f x dx)) (fwdDerivM_bind : ∀ {X Y Z : Type} [inst : SciLean.Vec K X] [inst_1 : SciLean.Vec K Y] [inst_2 : SciLean.Vec K Z] (f : Y → m Z)\n  (g : X → m Y),\n  CDifferentiableM f →\n    CDifferentiableM g →\n      (fwdDerivM fun x => g x >>= f) = fun x dx => do\n        let ydy ← fwdDerivM g x dx\n        fwdDerivM f ydy.1 ydy.2) (fwdDerivM_pair : ∀ {X Y : Type} [inst : SciLean.Vec K X] [inst_1 : SciLean.Vec K Y] (f : X → m Y),\n  CDifferentiableM f →\n    (fwdDerivM fun x => do\n        let y ← f x\n        pure (x, y)) =\n      fun x dx => do\n      let ydy ← fwdDerivM f x dx\n      pure ((x, ydy.1), dx, ydy.2)) (CDifferentiableM_pure : ∀ {X Y : Type} [inst : SciLean.Vec K X] [inst_1 : SciLean.Vec K Y] (f : X → Y),\n  SciLean.CDifferentiable K f → CDifferentiableM fun x => pure (f x)) (CDifferentiableM_bind : ∀ {X Y Z : Type} [inst : SciLean.Vec K X] [inst_1 : SciLean.Vec K Y] [inst_2 : SciLean.Vec K Z] (f : Y → m Z)\n  (g : X → m Y), CDifferentiableM f → CDifferentiableM g → CDifferentiableM fun x => g x >>= f) (CDifferentiableM_pair : ∀ {X Y : Type} [inst : SciLean.Vec K X] [inst_1 : SciLean.Vec K Y] (f : X → m Y),\n  CDifferentiableM f →\n    CDifferentiableM fun x => do\n      let y ← f x\n      pure (x, y)) : SciLean.FwdDerivMonad K m m'"}
{"name":"SciLean.CDifferentiableM.const_rule","declaration":"theorem SciLean.CDifferentiableM.const_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] (y : m Y) (hy : SciLean.CDifferentiableValM K y) : SciLean.CDifferentiableM K fun x => y"}
{"name":"dite.arg_te.fwdDerivM_rule","declaration":"theorem dite.arg_te.fwdDerivM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : c → X → m Y) (e : ¬c → X → m Y) : (SciLean.fwdDerivM K fun x => if h : c then t h x else e h x) = fun y =>\n  if h : c then SciLean.fwdDerivM K (t h) y else SciLean.fwdDerivM K (e h) y"}
{"name":"SciLean.CDifferentiableValM","declaration":"def SciLean.CDifferentiableValM (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] (x : m X) : Prop"}
{"name":"SciLean.FwdDerivMonad.CDifferentiableM_bind","declaration":"def SciLean.FwdDerivMonad.CDifferentiableM_bind {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.FwdDerivMonad K m m'] {X : Type} {Y : Type} {Z : Type} [SciLean.Vec K X] [SciLean.Vec K Y] [SciLean.Vec K Z] (f : Y → m Z) (g : X → m Y) (hf : SciLean.CDifferentiableM K f) (hg : SciLean.CDifferentiableM K g) : SciLean.CDifferentiableM K fun x => g x >>= f"}
{"name":"SciLean.FwdDerivMonad","declaration":"class SciLean.FwdDerivMonad (K : Type) [RCLike K] (m : Type → Type) (m' : outParam (Type → Type)) [Monad m] [Monad m'] : Type 1"}
{"name":"SciLean.fwdDerivValM","declaration":"def SciLean.fwdDerivValM (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] (x : m X) : m' (X × X)"}
{"name":"Pure.pure.arg_a0.CDifferentiableM_rule","declaration":"theorem Pure.pure.arg_a0.CDifferentiableM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] (a0 : X → Y) (ha0 : SciLean.CDifferentiable K a0) : SciLean.CDifferentiableM K fun x => pure (a0 x)"}
{"name":"Pure.pure.arg.CDifferentiableValM_rule","declaration":"theorem Pure.pure.arg.CDifferentiableValM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] (x : X) : SciLean.CDifferentiableValM K (pure x)"}
{"name":"ite.arg_te.fwdDerivM_rule","declaration":"theorem ite.arg_te.fwdDerivM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : X → m Y) (e : X → m Y) : (SciLean.fwdDerivM K fun x => if c then t x else e x) = fun y =>\n  if c then SciLean.fwdDerivM K t y else SciLean.fwdDerivM K e y"}
{"name":"SciLean.CDifferentiableM.comp_rule","declaration":"theorem SciLean.CDifferentiableM.comp_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] {Z : Type} [SciLean.Vec K Z] (f : Y → m Z) (g : X → Y) (hf : SciLean.CDifferentiableM K f) (hg : SciLean.CDifferentiable K g) : SciLean.CDifferentiableM K fun x => f (g x)"}
{"name":"SciLean.fwdDerivM.comp_rule","declaration":"theorem SciLean.fwdDerivM.comp_rule (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] [LawfulMonad m] [LawfulMonad m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] {Z : Type} [SciLean.Vec K Z] (f : Y → m Z) (g : X → Y) (hf : SciLean.CDifferentiableM K f) (hg : SciLean.CDifferentiable K g) : (SciLean.fwdDerivM K fun x => f (g x)) = fun x dx =>\n  let ydy := SciLean.fwdDeriv K g x dx;\n  SciLean.fwdDerivM K f ydy.1 ydy.2"}
{"name":"dite.arg_te.CDifferentiableM_rule","declaration":"theorem dite.arg_te.CDifferentiableM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : c → X → m Y) (e : ¬c → X → m Y) (ht : ∀ (h : c), SciLean.CDifferentiableM K (t h)) (he : ∀ (h : ¬c), SciLean.CDifferentiableM K (e h)) : SciLean.CDifferentiableM K fun x => if h : c then t h x else e h x"}
{"name":"Pure.pure.arg.fwdDerivValM_rule","declaration":"theorem Pure.pure.arg.fwdDerivValM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] (x : X) : SciLean.fwdDerivValM K (pure x) = pure (x, 0)"}
{"name":"SciLean.FwdDerivMonad.CDifferentiableM_pure","declaration":"def SciLean.FwdDerivMonad.CDifferentiableM_pure {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.FwdDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.Vec K X] [SciLean.Vec K Y] (f : X → Y) (hf : SciLean.CDifferentiable K f) : SciLean.CDifferentiableM K fun x => pure (f x)"}
{"name":"Pure.pure.arg_a0.fwdDerivM_rule","declaration":"theorem Pure.pure.arg_a0.fwdDerivM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] (a0 : X → Y) (ha0 : SciLean.CDifferentiable K a0) : (SciLean.fwdDerivM K fun x => pure (a0 x)) = fun x dx => pure (SciLean.fwdDeriv K a0 x dx)"}
{"name":"SciLean.FwdDerivMonad.CDifferentiableM","declaration":"def SciLean.FwdDerivMonad.CDifferentiableM (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.FwdDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.Vec K X] [SciLean.Vec K Y] (f : X → m Y) : Prop"}
{"name":"SciLean.FwdDerivMonad.fwdDerivM_bind","declaration":"def SciLean.FwdDerivMonad.fwdDerivM_bind {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.FwdDerivMonad K m m'] {X : Type} {Y : Type} {Z : Type} [SciLean.Vec K X] [SciLean.Vec K Y] [SciLean.Vec K Z] (f : Y → m Z) (g : X → m Y) (hf : SciLean.CDifferentiableM K f) (hg : SciLean.CDifferentiableM K g) : (SciLean.fwdDerivM K fun x => g x >>= f) = fun x dx => do\n  let ydy ← SciLean.fwdDerivM K g x dx\n  SciLean.fwdDerivM K f ydy.1 ydy.2"}
{"name":"ite.arg_te.CDifferentiableM_rule","declaration":"theorem ite.arg_te.CDifferentiableM_rule (K : Type) [RCLike K] {m : Type → Type} {m' : Type → Type} [Monad m] [Monad m'] [SciLean.FwdDerivMonad K m m'] {X : Type} [SciLean.Vec K X] {Y : Type} [SciLean.Vec K Y] (c : Prop) [dec : Decidable c] (t : X → m Y) (e : X → m Y) (ht : SciLean.CDifferentiableM K t) (he : SciLean.CDifferentiableM K e) : SciLean.CDifferentiableM K fun x => if c then t x else e x"}
{"name":"SciLean.FwdDerivMonad.CDifferentiableM_pair","declaration":"def SciLean.FwdDerivMonad.CDifferentiableM_pair {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.FwdDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.Vec K X] [SciLean.Vec K Y] (f : X → m Y) (hf : SciLean.CDifferentiableM K f) : SciLean.CDifferentiableM K fun x => do\n  let y ← f x\n  pure (x, y)"}
{"name":"SciLean.FwdDerivMonad.fwdDerivM_pure","declaration":"def SciLean.FwdDerivMonad.fwdDerivM_pure {K : Type} [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.FwdDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.Vec K X] [SciLean.Vec K Y] (f : X → Y) (hf : SciLean.CDifferentiable K f) : (SciLean.fwdDerivM K fun x => pure (f x)) = fun x dx => pure (SciLean.fwdDeriv K f x dx)"}
{"name":"SciLean.FwdDerivMonad.fwdDerivM","declaration":"def SciLean.FwdDerivMonad.fwdDerivM (K : Type) [RCLike K] {m : Type → Type} {m' : outParam (Type → Type)} [Monad m] [Monad m'] [self : SciLean.FwdDerivMonad K m m'] {X : Type} {Y : Type} [SciLean.Vec K X] [SciLean.Vec K Y] (f : X → m Y) (x : X) (dx : X) : m' (Y × Y)"}
