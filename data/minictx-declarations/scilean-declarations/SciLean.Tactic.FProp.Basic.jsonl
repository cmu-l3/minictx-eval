{"name":"SciLean.FProp.LocalRule.mk","declaration":"ctor SciLean.FProp.LocalRule.mk (fvar : Lean.FVarId) (proof : Lean.Expr) (mainIds : SciLean.ArraySet ℕ) (trailingIds : SciLean.ArraySet ℕ) : SciLean.FProp.LocalRule"}
{"name":"SciLean.FProp.LocalRule.fvar","declaration":"def SciLean.FProp.LocalRule.fvar (self : SciLean.FProp.LocalRule) : Lean.FVarId"}
{"name":"SciLean.FProp.LocalRule.trailingIds","declaration":"def SciLean.FProp.LocalRule.trailingIds (self : SciLean.FProp.LocalRule) : SciLean.ArraySet ℕ"}
{"name":"SciLean.FProp.fprop","declaration":"opaque SciLean.FProp.fprop (e : Lean.Expr) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.unfoldFunHead?","declaration":"def SciLean.FProp.unfoldFunHead? (e : Lean.Expr) : Lean.MetaM (Option Lean.Expr)"}
{"name":"SciLean.FProp.tryTheoremCore","declaration":"def SciLean.FProp.tryTheoremCore (xs : Array Lean.Expr) (bis : Array Lean.BinderInfo) (val : Lean.Expr) (type : Lean.Expr) (e : Lean.Expr) (thm : Lean.Meta.SimpTheorem) (discharge? : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.synthesizeArgs","declaration":"def SciLean.FProp.synthesizeArgs (thmId : Lean.Meta.Origin) (xs : Array Lean.Expr) (bis : Array Lean.BinderInfo) (discharge? : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM Bool"}
{"name":"SciLean.FProp.fvarAppCase","declaration":"def SciLean.FProp.fvarAppCase (e : Lean.Expr) (fpropName : Lean.Name) (ext : SciLean.FPropExt) (f : Lean.Expr) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.tryTheorem?'","declaration":"def SciLean.FProp.tryTheorem?' (e : Lean.Expr) (thm : Lean.Meta.SimpTheorem) (discharge? : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.LocalRule","declaration":"structure SciLean.FProp.LocalRule  : Type"}
{"name":"SciLean.FProp.tacticToDischarge","declaration":"def SciLean.FProp.tacticToDischarge (tacticCode : Lean.Syntax) : Lean.Expr → Lean.MetaM (Option Lean.Expr)"}
{"name":"SciLean.FProp.getLocalRules","declaration":"def SciLean.FProp.getLocalRules (fpropName : Lean.Name) : Lean.MetaM (Array Lean.Meta.SimpTheorem)"}
{"name":"SciLean.FProp.unfoldFVar?","declaration":"/-- Does `e` contain fvar that has local definition? i.e. local hypothesis that\n`fvar id = ...`\n\nIf it contains such fvar, replace it with its definition and return modified\nexpression `e'` and proof that `e = e'`\n-/\ndef SciLean.FProp.unfoldFVar? (e : Lean.Expr) : Lean.MetaM (Option (Lean.Expr × Lean.Expr))"}
{"name":"SciLean.FProp.cache","declaration":"def SciLean.FProp.cache (e : Lean.Expr) (proof? : Option Lean.Expr) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.tryTheorem?","declaration":"def SciLean.FProp.tryTheorem? (e : Lean.Expr) (thm : Lean.Meta.SimpTheorem) (discharge? : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.LocalRule.proof","declaration":"def SciLean.FProp.LocalRule.proof (self : SciLean.FProp.LocalRule) : Lean.Expr"}
{"name":"SciLean.FProp.main","declaration":"opaque SciLean.FProp.main (e : Lean.Expr) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.toFullyAppliedForm","declaration":"def SciLean.FProp.toFullyAppliedForm (f : Lean.Expr) : Lean.MetaM Lean.Expr"}
{"name":"SciLean.FProp.constAppCase","declaration":"def SciLean.FProp.constAppCase (e : Lean.Expr) (fpropName : Lean.Name) (ext : SciLean.FPropExt) (funName : Lean.Name) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.synthesizeInstance","declaration":"def SciLean.FProp.synthesizeInstance (thmId : Lean.Meta.Origin) (x : Lean.Expr) (type : Lean.Expr) : Lean.MetaM Bool"}
{"name":"SciLean.FProp.tryLocalTheorems","declaration":"def SciLean.FProp.tryLocalTheorems (e : Lean.Expr) (fpropName : Lean.Name) (ext : SciLean.FPropExt) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.bvarAppCase","declaration":"def SciLean.FProp.bvarAppCase (e : Lean.Expr) (fpropName : Lean.Name) (ext : SciLean.FPropExt) (f : Lean.Expr) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.getLocalRulesForFVar","declaration":"def SciLean.FProp.getLocalRulesForFVar (fId : Lean.FVarId) (fpropName : Lean.Name) (ext : SciLean.FPropExt) : Lean.MetaM (Array SciLean.FProp.LocalRule)"}
{"name":"SciLean.FProp.LocalRule.mainIds","declaration":"def SciLean.FProp.LocalRule.mainIds (self : SciLean.FProp.LocalRule) : SciLean.ArraySet ℕ"}
{"name":"SciLean.FProp.letCase","declaration":"def SciLean.FProp.letCase (e : Lean.Expr) (fpropName : Lean.Name) (ext : SciLean.FPropExt) (f : Lean.Expr) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.tryAfterFVarUnfold?","declaration":"/-- If `e` contains fvar with local definition then expand it and run `fprop` again\n-/\ndef SciLean.FProp.tryAfterFVarUnfold? (e : Lean.Expr) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.tryRemoveArg","declaration":"/-- Try to prove `FProp fun x => f x i` as composition `fun f => f i` `fun x => f x`\n-/\ndef SciLean.FProp.tryRemoveArg (e : Lean.Expr) (fpropName : Lean.Name) (ext : SciLean.FPropExt) (f : Lean.Expr) (fprop : Lean.Expr → SciLean.FPropM (Option Lean.Expr)) : SciLean.FPropM (Option Lean.Expr)"}
{"name":"SciLean.FProp.evalSplit","declaration":"def SciLean.FProp.evalSplit (e : Lean.Expr) : Lean.MetaM (Option (Lean.Expr × Lean.Expr))"}
