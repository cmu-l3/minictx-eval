{"name":"Lean.MergeMapDeclarationExtension.find?","declaration":"def Lean.MergeMapDeclarationExtension.find? {m : Type → Type} [Monad m] [Lean.MonadEnv m] {α : Type} [Inhabited α] (ext : Lean.MergeMapDeclarationExtension α) (declName : Lean.Name) : m (Option α)"}
{"name":"Lean.MergeMapDeclarationExtension.Merge","declaration":"structure Lean.MergeMapDeclarationExtension.Merge (α : Sort u_1) : Sort (max 1 u_1)"}
{"name":"Lean.MergeMapDeclarationExtension.Merge.is_valid","declaration":"def Lean.MergeMapDeclarationExtension.Merge.is_valid {α : Sort u_1} (self : Lean.MergeMapDeclarationExtension.Merge α) (n : Lean.Name) (a : α) (b : α) (c : α) : self.merge n (self.merge n a b) c = self.merge n a (self.merge n b c) ∧\n  ∀ (n : Lean.Name) (a b : α), self.merge n a b = self.merge n b a"}
{"name":"Lean.mkMergeMapDeclarationExtension","declaration":"def Lean.mkMergeMapDeclarationExtension {α : Type} [Inhabited α] (merge : Lean.MergeMapDeclarationExtension.Merge α) (name : autoParam Lean.Name _auto✝) : IO (Lean.MergeMapDeclarationExtension α)"}
{"name":"Lean.MergeMapDeclarationExtension.Merge.merge","declaration":"def Lean.MergeMapDeclarationExtension.Merge.merge {α : Sort u_1} (self : Lean.MergeMapDeclarationExtension.Merge α) : Lean.Name → α → α → α"}
{"name":"Lean.MergeMapDeclarationExtension.contains","declaration":"def Lean.MergeMapDeclarationExtension.contains {m : Type → Type} [Monad m] [Lean.MonadEnv m] {α : Type} [Inhabited α] (ext : Lean.MergeMapDeclarationExtension α) (declName : Lean.Name) : m Bool"}
{"name":"Lean.MergeMapDeclarationExtension.Merge.mk","declaration":"ctor Lean.MergeMapDeclarationExtension.Merge.mk {α : Sort u_1} (merge : Lean.Name → α → α → α) (is_valid : ∀ (n : Lean.Name) (a b c : α),\n  merge n (merge n a b) c = merge n a (merge n b c) ∧ ∀ (n : Lean.Name) (a b : α), merge n a b = merge n b a) : Lean.MergeMapDeclarationExtension.Merge α"}
{"name":"Lean.MergeMapDeclarationExtension","declaration":"/-- Similar to `MapDeclarationExtension` but it allows you have insert declarations that were not declared in the same file.\nHowever, you have to provide how to merge the values and to guarantee consistency i.e. merging should be associative and commutative.\n-/\ndef Lean.MergeMapDeclarationExtension (α : Type) : Type"}
{"name":"Lean.MergeMapDeclarationExtension.instInhabitedMergeMapDeclarationExtension","declaration":"instance Lean.MergeMapDeclarationExtension.instInhabitedMergeMapDeclarationExtension {α : Type} : Inhabited (Lean.MergeMapDeclarationExtension α)"}
{"name":"Lean.MergeMapDeclarationExtension.insert","declaration":"def Lean.MergeMapDeclarationExtension.insert {m : Type → Type} [Lean.MonadEnv m] {α : Type} (ext : Lean.MergeMapDeclarationExtension α) (declName : Lean.Name) (val : α) : m Unit"}
