{"name":"SciLean.TestFunctions.TestFunction","declaration":"def SciLean.TestFunctions.TestFunction {X : Type u_1} [self : SciLean.TestFunctions X] : Set X"}
{"name":"SciLean.instSemiInnerProductSpace_1","declaration":"instance SciLean.instSemiInnerProductSpace_1 {K : Type u_1} {X : Type u_2} [RCLike K] [NormedAddCommGroup X] [InnerProductSpace K X] [CompleteSpace X] : SciLean.SemiInnerProductSpace K X"}
{"name":"SciLean.norm₂_squared_nat","declaration":"theorem SciLean.norm₂_squared_nat {R : Type u_1} {K : Type u_2} {X : Type u_3} [SciLean.Scalar R K] [SciLean.Norm2 K X] (x : X) : ‖x‖₂ ^ 2 = ‖x‖₂²"}
{"name":"SciLean.«term‖_‖₂²»","declaration":"def SciLean.«term‖_‖₂²»  : Lean.ParserDescr"}
{"name":"SciLean.norm₂_prod","declaration":"theorem SciLean.norm₂_prod {R : Type u_1} {K : Type u_2} {X : Type u_3} {Y : Type u_4} [SciLean.Scalar R K] [AddCommMonoid K] [Inner K X] [Inner K Y] (x : X) (y : Y) : ‖(x, y)‖₂ = SciLean.Scalar.sqrt (‖x‖₂² + ‖y‖₂²)"}
{"name":"SciLean.instInner","declaration":"instance SciLean.instInner {K : Type u_1} [RCLike K] : Inner K K"}
{"name":"SciLean.«term⟪_,_⟫»","declaration":"def SciLean.«term⟪_,_⟫»  : Lean.ParserDescr"}
{"name":"SciLean.SemiInnerProductSpace","declaration":"/-- SemiInnerProductSpace is almost InnerProductSpace but `⟪x,y⟫` does not make\nsense for all elements `x y : X`. For example, `C∞(ℝ, ℝ)` or `ℕ → ℝ` are almost\ninner product spaces but `∫ x : ℝ, f x * g x` or `∑ i : ℕ, a i * b i` are not\nmeaningful for all `f, g` or `a, b`. Therefore we introduce notion of test functions\nand `⟪x, φ⟫` has meaning only when `φ` is test function, `x` can be arbitrary.\n\nThe important property is that deciding if an element is zero, `x = 0`, can be\ndetermined by testing `⟪x, ϕ⟫[K] = 0` for all test functions `φ`. This is known\nas fundamental lemma of the calculus of variations.\nhttps://en.wikipedia.org/wiki/Fundamental_lemma_of_the_calculus_of_variations\n\nThis also allows a definition of adjoint between two semi-inner product spaces, see `semiAdjoint`.\n-/\nclass SciLean.SemiInnerProductSpace (K : Type u_1) [RCLike K] (X : Type u_2) : Type (max u_1 u_2)"}
{"name":"SciLean.«term‖_‖₂»","declaration":"def SciLean.«term‖_‖₂»  : Lean.ParserDescr"}
{"name":"SciLean.instSemiHilbertUnit","declaration":"instance SciLean.instSemiHilbertUnit {K : Type u_1} [RCLike K] : SciLean.SemiHilbert K Unit"}
{"name":"SciLean.SemiInnerProductSpace.add_left","declaration":"def SciLean.SemiInnerProductSpace.add_left {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiInnerProductSpace K X] (x : X) (y : X) (z : X) : SciLean.TestFunction x ∧ SciLean.TestFunction y ∨ SciLean.TestFunction z → ⟪x + y, z⟫_K = ⟪x, z⟫_K + ⟪y, z⟫_K"}
{"name":"SciLean.norm₂","declaration":"def SciLean.norm₂ (K : Type u_1) {R : Type u_2} {X : Type u_3} [SciLean.Scalar R K] [SciLean.Norm2 K X] (x : X) : K"}
{"name":"SciLean.SemiInnerProductSpace.conj_sym","declaration":"def SciLean.SemiInnerProductSpace.conj_sym {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiInnerProductSpace K X] (x : X) (y : X) : (starRingEnd K) ⟪y, x⟫_K = ⟪x, y⟫_K"}
{"name":"SciLean.SemiInnerProductSpace.inner_with_testfun_is_continuous","declaration":"def SciLean.SemiInnerProductSpace.inner_with_testfun_is_continuous {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiInnerProductSpace K X] (ϕ : X) : SciLean.TestFunction ϕ → Continuous fun x => ⟪x, ϕ⟫_K"}
{"name":"SciLean.instSemiHilbertProd","declaration":"instance SciLean.instSemiHilbertProd {K : Type u_1} [RCLike K] (X : Type u_2) (Y : Type u_3) [SciLean.SemiHilbert K X] [SciLean.SemiHilbert K Y] : SciLean.SemiHilbert K (X × Y)"}
{"name":"SciLean.instTestFunctions","declaration":"instance SciLean.instTestFunctions {K : Type u_1} [RCLike K] : SciLean.TestFunctions K"}
{"name":"SciLean.SemiHilbert","declaration":"/-- Almost Hilbert space but does not have to be complete. It is only c∞-complete.\n\nThe important property is that the norm `‖x‖₂` and inner product `⟪x,y⟫` is meaningful for any `x y : X`. For general semi-inner prodcut space the norm and inner product is well defined only for `x ∈ TestFunction`-/\nclass SciLean.SemiHilbert (K : Type u_1) [RCLike K] (X : Type u_2) : Type (max u_1 u_2)"}
{"name":"SciLean.instSemiHilbertForAll","declaration":"instance SciLean.instSemiHilbertForAll {K : Type u_1} [RCLike K] (ι : Type u_2) (X : ι → Type u_3) [(i : ι) → SciLean.SemiHilbert K (X i)] [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] : SciLean.SemiHilbert K ((i : ι) → X i)"}
{"name":"SciLean.instSemiInnerProductSpaceForAll","declaration":"instance SciLean.instSemiInnerProductSpaceForAll {K : Type u_1} [RCLike K] (ι : Type u_2) (X : ι → Type u_3) [(i : ι) → SciLean.SemiInnerProductSpace K (X i)] [SciLean.IndexType ι] : SciLean.SemiInnerProductSpace K ((i : ι) → X i)"}
{"name":"SciLean.instSemiInnerProductSpaceUnit","declaration":"instance SciLean.instSemiInnerProductSpaceUnit {K : Type u_1} [RCLike K] : SciLean.SemiInnerProductSpace K Unit"}
{"name":"SciLean.Norm2.norm2","declaration":"def SciLean.Norm2.norm2 {K : Type u_1} {X : Type u_2} [self : SciLean.Norm2 K X] : X → K"}
{"name":"SciLean.unexpandNorm₂","declaration":"def SciLean.unexpandNorm₂  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.vecNormalize","declaration":"def SciLean.vecNormalize {R : Type u_1} (C : Type u_2) [SciLean.Scalar R C] {X : Type u_3} [SciLean.SemiHilbert C X] (x : X) : X"}
{"name":"SciLean.SemiInnerProductSpace.inner_norm2","declaration":"def SciLean.SemiInnerProductSpace.inner_norm2 {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiInnerProductSpace K X] (x : X) : ⟪x, x⟫_K = ‖x‖₂²"}
{"name":"SciLean.norm₂_scalar","declaration":"theorem SciLean.norm₂_scalar {R : Type u_1} [SciLean.RealScalar R] (x : R) : ‖x‖₂[R] = SciLean.Scalar.abs x"}
{"name":"SciLean.instTestFunctionsForAll","declaration":"instance SciLean.instTestFunctionsForAll (ι : Type u_1) (X : ι → Type u_2) [(i : ι) → SciLean.TestFunctions (X i)] : SciLean.TestFunctions ((i : ι) → X i)"}
{"name":"SciLean.instSemiInnerProductSpace","declaration":"instance SciLean.instSemiInnerProductSpace {K : Type u_1} [RCLike K] : SciLean.SemiInnerProductSpace K K"}
{"name":"SciLean.«term‖_‖₂²[_]»","declaration":"def SciLean.«term‖_‖₂²[_]»  : Lean.ParserDescr"}
{"name":"SciLean.SemiInnerProductSpace.inner_pos","declaration":"def SciLean.SemiInnerProductSpace.inner_pos {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiInnerProductSpace K X] (x : X) : SciLean.TestFunction x → RCLike.re ⟪x, x⟫_K ≥ 0 ∧ RCLike.im ⟪x, x⟫_K = 0"}
{"name":"SciLean.SemiInnerProductSpace.mk","declaration":"ctor SciLean.SemiInnerProductSpace.mk {K : Type u_1} [RCLike K] {X : Type u_2} [toVec : SciLean.Vec K X] [toInner : Inner K X] [toTestFunctions : SciLean.TestFunctions X] [toNorm2 : SciLean.Norm2 K X] (add_left : ∀ (x y z : X),\n  SciLean.TestFunction x ∧ SciLean.TestFunction y ∨ SciLean.TestFunction z → ⟪x + y, z⟫_K = ⟪x, z⟫_K + ⟪y, z⟫_K) (smul_left : ∀ (x y : X) (r : K), ⟪r • x, y⟫_K = (starRingEnd K) r * ⟪x, y⟫_K) (conj_sym : ∀ (x y : X), (starRingEnd K) ⟪y, x⟫_K = ⟪x, y⟫_K) (inner_pos : ∀ (x : X), SciLean.TestFunction x → RCLike.re ⟪x, x⟫_K ≥ 0 ∧ RCLike.im ⟪x, x⟫_K = 0) (inner_ext : ∀ (x : X), x = 0 ↔ ∀ (ϕ : X), SciLean.TestFunction ϕ → ⟪x, ϕ⟫_K = 0) (is_lin_subspace : SciLean.VecProp K SciLean.TestFunction) (inner_norm2 : ∀ (x : X), ⟪x, x⟫_K = ‖x‖₂²) (inner_with_testfun_is_continuous : ∀ (ϕ : X), SciLean.TestFunction ϕ → Continuous fun x => ⟪x, ϕ⟫_K) : SciLean.SemiInnerProductSpace K X"}
{"name":"SciLean.SemiHilbert.test_functions_true","declaration":"def SciLean.SemiHilbert.test_functions_true {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiHilbert K X] (x : X) : SciLean.TestFunction x"}
{"name":"SciLean.norm2_scalar","declaration":"theorem SciLean.norm2_scalar {R : Type u_1} [SciLean.RealScalar R] (x : R) : ‖x‖₂² = x ^ 2"}
{"name":"SciLean.TestFunctions.mk","declaration":"ctor SciLean.TestFunctions.mk {X : Type u_1} (TestFunction : Set X) : SciLean.TestFunctions X"}
{"name":"SciLean.TestFunctions","declaration":"/-- TestFunctions defines a subset of well behaved elemets w.r.t. to the inner product.\nFor example:\n  1. test function on `ℕ → ℝ` are sequences with only finitely many non-zero elements\n  2. test function on `C∞(ℝ, ℝ)` are functions with compact support\n\nsee `SemiInnerProductSpace` for more information\n-/\nclass SciLean.TestFunctions (X : Type u_1) : Type u_1"}
{"name":"SciLean.Norm2.mk","declaration":"ctor SciLean.Norm2.mk {K : Type u_1} {X : Type u_2} (norm2 : X → K) : SciLean.Norm2 K X"}
{"name":"SciLean.instTestFunctionsProd","declaration":"instance SciLean.instTestFunctionsProd (X : Type u_1) (Y : Type u_2) [SciLean.TestFunctions X] [SciLean.TestFunctions Y] : SciLean.TestFunctions (X × Y)"}
{"name":"SciLean.unexpandNorm2","declaration":"def SciLean.unexpandNorm2  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.SemiInnerProductSpace.is_lin_subspace","declaration":"def SciLean.SemiInnerProductSpace.is_lin_subspace {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiInnerProductSpace K X] : SciLean.VecProp K SciLean.TestFunction"}
{"name":"SciLean.instInnerProd","declaration":"instance SciLean.instInnerProd (K : Type u_1) (X : Type u_2) (Y : Type u_3) [AddCommMonoid K] [Inner K X] [Inner K Y] : Inner K (X × Y)"}
{"name":"SciLean.instSemiInnerProductSpaceProd","declaration":"instance SciLean.instSemiInnerProductSpaceProd {K : Type u_1} [RCLike K] (X : Type u_2) (Y : Type u_3) [SciLean.SemiInnerProductSpace K X] [SciLean.SemiInnerProductSpace K Y] : SciLean.SemiInnerProductSpace K (X × Y)"}
{"name":"SciLean.SemiHilbert.mk","declaration":"ctor SciLean.SemiHilbert.mk {K : Type u_1} [RCLike K] {X : Type u_2} [toSemiInnerProductSpace : SciLean.SemiInnerProductSpace K X] (test_functions_true : ∀ (x : X), SciLean.TestFunction x) : SciLean.SemiHilbert K X"}
{"name":"SciLean.Norm2","declaration":"/-- Square of L₂ norm over the field `K` -/\nclass SciLean.Norm2 (K : Type u_1) (X : Type u_2) : Type (max u_1 u_2)"}
{"name":"SciLean.SemiInnerProductSpace.mkSorryProofs","declaration":"def SciLean.SemiInnerProductSpace.mkSorryProofs {K : Type u_1} [RCLike K] {α : Type u_2} [SciLean.Vec K α] [Inner K α] [SciLean.TestFunctions α] : SciLean.SemiInnerProductSpace K α"}
{"name":"SciLean.scalar_norm","declaration":"theorem SciLean.scalar_norm {R : Type u_1} [SciLean.RealScalar R] (r : R) : ‖r‖₂[R] = SciLean.Scalar.abs r"}
{"name":"SciLean.«term⟪_,_⟫[_]»","declaration":"def SciLean.«term⟪_,_⟫[_]»  : Lean.ParserDescr"}
{"name":"SciLean.instInnerUnit","declaration":"instance SciLean.instInnerUnit {K : Type u_1} [RCLike K] : Inner K Unit"}
{"name":"SciLean.unexpandInner","declaration":"def SciLean.unexpandInner  : Lean.PrettyPrinter.Unexpander"}
{"name":"SciLean.norm₂_squared","declaration":"theorem SciLean.norm₂_squared {R : Type u_1} {K : Type u_2} {X : Type u_3} [SciLean.Scalar R K] [SciLean.Norm2 K X] (x : X) : ‖x‖₂ ^ 2 = ‖x‖₂²"}
{"name":"SciLean.instSemiHilbert","declaration":"instance SciLean.instSemiHilbert {K : Type u_1} [RCLike K] : SciLean.SemiHilbert K K"}
{"name":"SciLean.SemiInnerProductSpace.inner_ext","declaration":"def SciLean.SemiInnerProductSpace.inner_ext {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiInnerProductSpace K X] (x : X) : x = 0 ↔ ∀ (ϕ : X), SciLean.TestFunction ϕ → ⟪x, ϕ⟫_K = 0"}
{"name":"SciLean.«term‖_‖₂[_]»","declaration":"def SciLean.«term‖_‖₂[_]»  : Lean.ParserDescr"}
{"name":"SciLean.SemiInnerProductSpace.smul_left","declaration":"def SciLean.SemiInnerProductSpace.smul_left {K : Type u_1} [RCLike K] {X : Type u_2} [self : SciLean.SemiInnerProductSpace K X] (x : X) (y : X) (r : K) : ⟪r • x, y⟫_K = (starRingEnd K) r * ⟪x, y⟫_K"}
{"name":"SciLean.instInnerForAll","declaration":"instance SciLean.instInnerForAll (K : Type u_1) (ι : Type u_2) (X : ι → Type u_3) [AddCommMonoid K] [(i : ι) → Inner K (X i)] [SciLean.IndexType ι] : Inner K ((i : ι) → X i)"}
{"name":"SciLean.instTestFunctionsUnit","declaration":"instance SciLean.instTestFunctionsUnit {K : Type u_1} [RCLike K] : SciLean.TestFunctions Unit"}
{"name":"SciLean.instNorm2","declaration":"instance SciLean.instNorm2 {K : Type u_1} {X : Type u_2} [Inner K X] : SciLean.Norm2 K X"}
