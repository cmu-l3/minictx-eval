{"name":"Function.invFun.HSMul.hSMul.arg_a1.invFun_rule_group","declaration":"def Function.invFun.HSMul.hSMul.arg_a1.invFun_rule_group {X : Type u_1} [Nonempty X] {Y : Type u_2} {G : Type u_3} [Group G] [MulAction G Y] (g : G) (f : X → Y) (hf : Function.Bijective f) : (Function.invFun fun x => g • f x) = fun y => Function.invFun f (g⁻¹ • y)"}
{"name":"Function.invFun.HSMul.hSMul.arg_a1.invFun_rule_field","declaration":"def Function.invFun.HSMul.hSMul.arg_a1.invFun_rule_field {X : Type u_1} [Nonempty X] {Y : Type u_2} {R : Type u_3} [Field R] [MulAction R Y] (r : R) (f : X → Y) (hf : Function.Bijective f) (hr : r ≠ 0) : (Function.invFun fun x => r • f x) = fun y => Function.invFun f (r⁻¹ • y)"}
{"name":"Function.invFun.HMul.hMul.arg_a0.invFun_rule_field","declaration":"def Function.invFun.HMul.hMul.arg_a0.invFun_rule_field {X : Type u_1} [Nonempty X] {Y : Type u_2} [Field Y] (f : X → Y) (y : Y) (hf : Function.Bijective f) (hy : y ≠ 0) : (Function.invFun fun x => f x * y) = fun y' => Function.invFun f (y' / y)"}
{"name":"Function.invFun.comp_rule","declaration":"theorem Function.invFun.comp_rule {X : Type u_3} [Nonempty X] {Y : Type u_1} [Nonempty Y] {Z : Type u_2} (f : Y → Z) (g : X → Y) (hf : Function.Bijective f) (hg : Function.Bijective g) : (Function.invFun fun x => f (g x)) = fun z =>\n  let y := Function.invFun f z;\n  let x := Function.invFun g y;\n  x"}
{"name":"Function.invFun.HAdd.hAdd.arg_a0.invFun_rule","declaration":"theorem Function.invFun.HAdd.hAdd.arg_a0.invFun_rule {X : Type u_2} [Nonempty X] {Y : Type u_1} [AddGroup Y] (f : X → Y) (y : Y) (hf : Function.Bijective f) : (Function.invFun fun x => f x + y) = fun y' => Function.invFun f (y' - y)"}
{"name":"Function.invFun.HSub.hSub.arg_a0.invFun_rule","declaration":"theorem Function.invFun.HSub.hSub.arg_a0.invFun_rule {X : Type u_2} [Nonempty X] {Y : Type u_1} [AddGroup Y] (f : X → Y) (y : Y) (hf : Function.Bijective f) : (Function.invFun fun x => f x - y) = fun y' => Function.invFun f (y' + y)"}
{"name":"Function.invFun.let_rule","declaration":"theorem Function.invFun.let_rule {X : Type u_5} [Nonempty X] {Y : Type u_1} [Nonempty Y] {Z : Type u_3} {X₁ : Type u_4} [Nonempty X₁] {X₂ : Type u_2} [Nonempty X₂] (f : X₂ → Y → Z) (g : X₁ → Y) (p₁ : X → X₁) (p₂ : X → X₂) (hf : Function.Bijective fun xy => f xy.1 xy.2) (hg : Function.Bijective g) (hp : Function.Bijective fun x => (p₁ x, p₂ x)) : (Function.invFun fun x =>\n    let y := g (p₁ x);\n    f (p₂ x) y) =\n  fun z =>\n  let x₂y := Function.invFun (fun xy => f xy.1 xy.2) z;\n  let x₁ := Function.invFun g x₂y.2;\n  let x := Function.invFun (fun x => (p₁ x, p₂ x)) (x₁, x₂y.1);\n  x"}
{"name":"Function.invFun.Inv.inv.arg_a0.invFun_rule_group","declaration":"theorem Function.invFun.Inv.inv.arg_a0.invFun_rule_group {X : Type u_2} [Nonempty X] {Y : Type u_1} [Group Y] (f : X → Y) (hf : Function.Bijective f) : (Function.invFun fun x => (f x)⁻¹) = fun y => Function.invFun f y⁻¹"}
{"name":"Function.invFun.HAdd.hAdd.arg_a1.invFun_rule","declaration":"theorem Function.invFun.HAdd.hAdd.arg_a1.invFun_rule {X : Type u_2} [Nonempty X] {Y : Type u_1} [AddGroup Y] (y : Y) (f : X → Y) (hf : Function.Bijective f) : (Function.invFun fun x => y + f x) = fun y' => Function.invFun f (-y + y')"}
{"name":"Function.invFun.Prod.mk.arg_fstsnd.invFun_rule","declaration":"theorem Function.invFun.Prod.mk.arg_fstsnd.invFun_rule {X₁ : Type u_1} [Nonempty X₁] {X₂ : Type u_3} [Nonempty X₂] {X : Type u_5} [Nonempty X] {Y : Type u_2} {Z : Type u_4} (f : X₁ → Y) (g : X₂ → Z) (p₁ : X → X₁) (p₂ : X → X₂) (hf : Function.Bijective f) (hg : Function.Bijective g) (hp : Function.Bijective fun x => (p₁ x, p₂ x)) : (Function.invFun fun x => (f (p₁ x), g (p₂ x))) = fun yz =>\n  let x₁ := Function.invFun f yz.1;\n  let x₂ := Function.invFun g yz.2;\n  let x := Function.invFun (fun x => (p₁ x, p₂ x)) (x₁, x₂);\n  x"}
{"name":"Function.invFun.Neg.neg.arg_a0.invFun_rule","declaration":"theorem Function.invFun.Neg.neg.arg_a0.invFun_rule {X : Type u_2} [Nonempty X] {Y : Type u_1} [AddGroup Y] (f : X → Y) (hf : Function.Bijective f) : (Function.invFun fun x => -f x) = fun y => Function.invFun f (-y)"}
{"name":"Function.invFun.Equiv.toFun.arg_a0.invFun_rule","declaration":"theorem Function.invFun.Equiv.toFun.arg_a0.invFun_rule {X : Type u_3} [Nonempty X] {Y : Type u_1} {Z : Type u_2} (f : Y ≃ Z) (g : X → Y) (hf : Function.Bijective g) : (Function.invFun fun x => f (g x)) = fun z => Function.invFun g (f.invFun z)"}
{"name":"Function.invFun.Equiv.invFun.arg_a0.invFun_rule","declaration":"theorem Function.invFun.Equiv.invFun.arg_a0.invFun_rule {X : Type u_3} [Nonempty X] {Y : Type u_1} {Z : Type u_2} (f : Y ≃ Z) (g : X → Z) (hf : Function.Bijective g) : (Function.invFun fun x => f.invFun (g x)) = fun z => Function.invFun g (f z)"}
{"name":"Function.invFun.HMul.hMul.arg_a1.invFun_rule_group","declaration":"def Function.invFun.HMul.hMul.arg_a1.invFun_rule_group {X : Type u_1} [Nonempty X] {Y : Type u_2} [Group Y] (y : Y) (f : X → Y) (hf : Function.Bijective f) : (Function.invFun fun x => y * f x) = fun y' => Function.invFun f (y⁻¹ * y')"}
{"name":"Function.invFun.HSub.hSub.arg_a1.invFun_rule","declaration":"theorem Function.invFun.HSub.hSub.arg_a1.invFun_rule {X : Type u_2} [Nonempty X] {Y : Type u_1} [AddGroup Y] (y : Y) (f : X → Y) (hf : Function.Bijective f) : (Function.invFun fun x => y - f x) = fun y' => Function.invFun f (y - y')"}
{"name":"Function.invFun.Inv.inv.arg_a0.invFun_rule_field","declaration":"theorem Function.invFun.Inv.inv.arg_a0.invFun_rule_field {X : Type u_2} [Nonempty X] {Y : Type u_1} [Field Y] (f : X → Y) (hf : Function.Bijective f) (hf' : ∀ (x : X), f x ≠ 0) : (Function.invFun fun x => (f x)⁻¹) = fun y => Function.invFun f y⁻¹"}
{"name":"Function.invFun.HMul.hMul.arg_a0.invFun_rule_group","declaration":"def Function.invFun.HMul.hMul.arg_a0.invFun_rule_group {X : Type u_1} [Nonempty X] {Y : Type u_2} [Group Y] (f : X → Y) (y : Y) (hf : Function.Bijective f) : (Function.invFun fun x => f x * y) = fun y' => Function.invFun f (y' / y)"}
{"name":"Function.invFun.HVAdd.hVAdd.arg_a1.invFun_rule_group","declaration":"def Function.invFun.HVAdd.hVAdd.arg_a1.invFun_rule_group {X : Type u_1} [Nonempty X] {Y : Type u_2} {G : Type u_3} [AddGroup G] [AddAction G Y] (g : G) (f : X → Y) (hf : Function.Bijective f) : (Function.invFun fun x => g +ᵥ f x) = fun y => Function.invFun f (-g +ᵥ y)"}
{"name":"Function.invFun.id_rule","declaration":"theorem Function.invFun.id_rule {X : Type u_1} [Nonempty X] : (Function.invFun fun x => x) = fun x => x"}
{"name":"Function.invFun.HMul.hMul.arg_a1.invFun_rule_field","declaration":"def Function.invFun.HMul.hMul.arg_a1.invFun_rule_field {X : Type u_1} [Nonempty X] {Y : Type u_2} [Field Y] (y : Y) (f : X → Y) (hf : Function.Bijective f) (hy : y ≠ 0) : (Function.invFun fun x => y * f x) = fun y' => Function.invFun f (y⁻¹ * y')"}
