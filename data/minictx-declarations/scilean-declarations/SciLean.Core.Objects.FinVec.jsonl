{"name":"SciLean.FinVec.to_dual","declaration":"def SciLean.FinVec.to_dual {ι : outParam (Type u_1)} {K : Type u_2} {X : Type u_3} [outParam (SciLean.IndexType ι)] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [self : SciLean.FinVec ι K X] {x : X} : SciLean.BasisDuality.toDual x = ∑ i, ℼ i x • ⅇ' i"}
{"name":"SciLean.instBasisDuality","declaration":"instance SciLean.instBasisDuality (K : Type u_1) [RCLike K] : SciLean.BasisDuality K"}
{"name":"SciLean.instBasisUnit","declaration":"instance SciLean.instBasisUnit (K : Type u_1) [RCLike K] : SciLean.Basis Unit K K"}
{"name":"SciLean.BasisDuality","declaration":"/-- This should somehow relate to raising and lowering indices but I forgot how.\n\nTODO: add explanation why this is useful\n-/\nclass SciLean.BasisDuality (X : Type u) : Type u"}
{"name":"SciLean.instOrthonormalBasisSumProdToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldToDenselyNormedFieldInstBasisSumProdToBasisToBasisToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToAddCommGroupToVecToSemiInnerProductSpaceToSemiHilbertToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToAddCommGroupToVecToSemiInnerProductSpaceToSemiHilbertInstInnerProdToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingToNonUnitalSeminormedCommRingToSeminormedCommRingToNormedCommRingToInnerToInner","declaration":"instance SciLean.instOrthonormalBasisSumProdToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldToDenselyNormedFieldInstBasisSumProdToBasisToBasisToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToAddCommGroupToVecToSemiInnerProductSpaceToSemiHilbertToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToAddCommGroupToVecToSemiInnerProductSpaceToSemiHilbertInstInnerProdToAddCommMonoidToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingToNonUnitalSeminormedCommRingToSeminormedCommRingToNormedCommRingToInnerToInner {ι : Type u_1} {K : Type u_2} {X : Type u_3} [RCLike K] {κ : Type u_4} {Y : Type u_5} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [SciLean.IndexType κ] [SciLean.LawfulIndexType κ] [DecidableEq κ] [SciLean.FinVec ι K X] [SciLean.OrthonormalBasis ι K X] [SciLean.FinVec κ K Y] [SciLean.OrthonormalBasis κ K Y] : SciLean.OrthonormalBasis (ι ⊕ κ) K (X × Y)"}
{"name":"SciLean.BasisDuality.mk","declaration":"ctor SciLean.BasisDuality.mk {X : Type u} (toDual : X → X) (fromDual : X → X) : SciLean.BasisDuality X"}
{"name":"SciLean.DualBasis.dualProj","declaration":"def SciLean.DualBasis.dualProj {ι : outParam (Type v)} {K : outParam (Type w)} {X : Type u} [self : SciLean.DualBasis ι K X] (i : ι) (x : X) : K"}
{"name":"SciLean.Basis.proj","declaration":"def SciLean.Basis.proj {ι : outParam (Type v)} {K : outParam (Type w)} {X : Type u} [self : SciLean.Basis ι K X] (i : ι) (x : X) : K"}
{"name":"SciLean.BasisDuality.fromDual","declaration":"def SciLean.BasisDuality.fromDual {X : Type u} [self : SciLean.BasisDuality X] (x : X) : X"}
{"name":"SciLean.instBasisDualityProd","declaration":"instance SciLean.instBasisDualityProd {X : Type u_1} {Y : Type u_2} [SciLean.BasisDuality X] [SciLean.BasisDuality Y] : SciLean.BasisDuality (X × Y)"}
{"name":"SciLean.instDualBasisSumProd","declaration":"instance SciLean.instDualBasisSumProd {X : Type u_1} {Y : Type u_2} {ι : Type u_3} {κ : Type u_4} {K : Type u_5} [SciLean.DualBasis ι K X] [SciLean.DualBasis κ K Y] [Zero X] [Zero Y] : SciLean.DualBasis (ι ⊕ κ) K (X × Y)"}
{"name":"SciLean.instGetElemTrue","declaration":"instance SciLean.instGetElemTrue {ι : Type u_1} {K : Type u_2} {X : Type u_3} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] : GetElem X ι K fun x x => True"}
{"name":"SciLean.DualBasis.mk","declaration":"ctor SciLean.DualBasis.mk {ι : outParam (Type v)} {K : outParam (Type w)} {X : Type u} (dualBasis : ι → X) (dualProj : ι → X → K) : SciLean.DualBasis ι K X"}
{"name":"SciLean.instBasisSumProd","declaration":"instance SciLean.instBasisSumProd {X : Type u_1} {Y : Type u_2} {ι : Type u_3} {κ : Type u_4} {K : Type u_5} [SciLean.Basis ι K X] [SciLean.Basis κ K Y] [Zero X] [Zero Y] : SciLean.Basis (ι ⊕ κ) K (X × Y)"}
{"name":"SciLean.inner_proj_dualProj","declaration":"theorem SciLean.inner_proj_dualProj {ι : Type u_1} {K : Type u_2} {X : Type u_2} : ∀ {x : SciLean.IndexType ι} [inst : SciLean.LawfulIndexType ι] [inst_1 : DecidableEq ι] [inst_2 : RCLike K]\n  [inst_3 : SciLean.FinVec ι K X] (x_1 y : X), ⟪x_1, y⟫_K = ∑ i, ℼ i x_1 * ℼ' i y"}
{"name":"SciLean.basis_ext","declaration":"theorem SciLean.basis_ext {ι : Type u_1} {K : Type u_2} {X : Type u_3} : ∀ {x : SciLean.IndexType ι} [inst : SciLean.LawfulIndexType ι] [inst_1 : DecidableEq ι] [inst_2 : RCLike K]\n  [inst_3 : SciLean.FinVec ι K X] (x_1 y : X), (∀ (i : ι), ⟪x_1, ⅇ i⟫_K = ⟪y, ⅇ i⟫_K) → x_1 = y"}
{"name":"SciLean.termⅇ_","declaration":"/-- `ⅇ i` is the i-th basis vector -/\ndef SciLean.termⅇ_  : Lean.ParserDescr"}
{"name":"SciLean.termℼ'_","declaration":"/-- `ℼ' i x` is projection of `x` onto i-th dual basis vector `ⅇ' i` -/\ndef SciLean.termℼ'_  : Lean.ParserDescr"}
{"name":"SciLean.FinVec.from_dual","declaration":"def SciLean.FinVec.from_dual {ι : outParam (Type u_1)} {K : Type u_2} {X : Type u_3} [outParam (SciLean.IndexType ι)] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [self : SciLean.FinVec ι K X] {x : X} : SciLean.BasisDuality.fromDual x = ∑ i, ℼ' i x • ⅇ i"}
{"name":"SciLean.instDualBasisForAll","declaration":"instance SciLean.instDualBasisForAll {ι : Type u_1} {K : Type u_2} [DecidableEq ι] [RCLike K] : SciLean.DualBasis ι K (ι → K)"}
{"name":"SciLean.instFinVecProdForAllInstIndexTypeProdInstLawfulIndexTypeProdInstIndexTypeProdInstDecidableEqProd","declaration":"instance SciLean.instFinVecProdForAllInstIndexTypeProdInstLawfulIndexTypeProdInstIndexTypeProdInstDecidableEqProd {ι : Type} {κ : Type} {K : Type u_1} {X : Type u_1} [SciLean.IndexType ι] [SciLean.IndexType κ] [SciLean.LawfulIndexType ι] [SciLean.LawfulIndexType κ] [DecidableEq ι] [DecidableEq κ] [RCLike K] [SciLean.FinVec κ K X] : SciLean.FinVec (ι × κ) K (ι → X)"}
{"name":"SciLean.dualBasis_ext","declaration":"theorem SciLean.dualBasis_ext {ι : Type u_1} {K : Type u_2} {X : Type u_3} : ∀ {x : SciLean.IndexType ι} [inst : SciLean.LawfulIndexType ι] [inst_1 : DecidableEq ι] [inst_2 : RCLike K]\n  [inst_3 : SciLean.FinVec ι K X] (x_1 y : X), (∀ (i : ι), ⟪x_1, ⅇ' i⟫_K = ⟪y, ⅇ' i⟫_K) → x_1 = y"}
{"name":"SciLean.dualProj_dualBasis","declaration":"theorem SciLean.dualProj_dualBasis {ι : Type u_2} {K : Type u_1} {X : Type u_3} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] (i : ι) (j : ι) : ℼ' i ⅇ' j = if i = j then 1 else 0"}
{"name":"SciLean.instBasisDualityForAll","declaration":"instance SciLean.instBasisDualityForAll {ι : Type u_1} {X : Type u_2} [SciLean.BasisDuality X] : SciLean.BasisDuality (ι → X)"}
{"name":"SciLean.DualBasis.dualBasis","declaration":"def SciLean.DualBasis.dualBasis {ι : outParam (Type v)} {K : outParam (Type w)} {X : Type u} [self : SciLean.DualBasis ι K X] (i : ι) : X"}
{"name":"SciLean.FinVec.mk","declaration":"ctor SciLean.FinVec.mk {ι : outParam (Type u_1)} {K : Type u_2} {X : Type u_3} [outParam (SciLean.IndexType ι)] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [toSemiHilbert : SciLean.SemiHilbert K X] [toBasis : SciLean.Basis ι K X] [toDualBasis : SciLean.DualBasis ι K X] [toBasisDuality : SciLean.BasisDuality X] (is_basis : ∀ (x : X), x = ∑ i, ℼ i x • ⅇ i) (duality : ∀ (i j : ι), ⟪ⅇ i, ⅇ' j⟫_K = if i = j then 1 else 0) (to_dual : ∀ {x : X}, SciLean.BasisDuality.toDual x = ∑ i, ℼ i x • ⅇ' i) (from_dual : ∀ {x : X}, SciLean.BasisDuality.fromDual x = ∑ i, ℼ' i x • ⅇ i) : SciLean.FinVec ι K X"}
{"name":"SciLean.OrthonormalBasis","declaration":"class SciLean.OrthonormalBasis (ι : Type u_1) (K : Type u_2) (X : Type u_3) [Semiring K] [SciLean.Basis ι K X] [Inner K X] : Prop"}
{"name":"SciLean.instFinVecUnitInstIndexTypeUnitInstLawfulIndexTypeUnitInstIndexTypeUnitInstDecidableEqPUnit","declaration":"instance SciLean.instFinVecUnitInstIndexTypeUnitInstLawfulIndexTypeUnitInstIndexTypeUnitInstDecidableEqPUnit {K : Type u_1} [RCLike K] : SciLean.FinVec Unit K K"}
{"name":"SciLean.OrthonormalBasis.mk","declaration":"ctor SciLean.OrthonormalBasis.mk {ι : Type u_1} {K : Type u_2} {X : Type u_3} [Semiring K] [SciLean.Basis ι K X] [Inner K X] (is_orthogonal : ∀ (i j : ι), i ≠ j → ⟪ⅇ i, ⅇ j⟫_K = 0) (is_orthonormal : ∀ (i : ι), ⟪ⅇ i, ⅇ i⟫_K = 1) : SciLean.OrthonormalBasis ι K X"}
{"name":"SciLean.instBasisProdForAll","declaration":"instance SciLean.instBasisProdForAll {ι : Type u_1} {κ : Type u_2} {K : Type u_3} {X : Type u_4} [DecidableEq ι] [SciLean.Basis κ K X] [Zero X] : SciLean.Basis (ι × κ) K (ι → X)"}
{"name":"SciLean.instFinVecForAll","declaration":"instance SciLean.instFinVecForAll {ι : Type} {K : Type v} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] : SciLean.FinVec ι K (ι → K)"}
{"name":"SciLean.FinVec.duality","declaration":"def SciLean.FinVec.duality {ι : outParam (Type u_1)} {K : Type u_2} {X : Type u_3} [outParam (SciLean.IndexType ι)] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [self : SciLean.FinVec ι K X] (i : ι) (j : ι) : ⟪ⅇ i, ⅇ' j⟫_K = if i = j then 1 else 0"}
{"name":"SciLean.DualBasis","declaration":"/-- Dual basis of the space `X` over the field `K` indexed by `ι`\n\nThe class `FinVec ι K X` guarantees that any element `x : X` can be writtens as:\n```\n∑ i, proj i x • basis i\n```\nand that it is dual to the normal basis\n```\n⟪basis i, dualBasis j⟫[K] = if i=j then 1 else 0\n```\n-/\nclass SciLean.DualBasis (ι : outParam (Type v)) (K : outParam (Type w)) (X : Type u) : Type (max (max u v) w)"}
{"name":"SciLean.instDualBasisProdForAll","declaration":"instance SciLean.instDualBasisProdForAll {ι : Type u_1} {κ : Type u_2} {K : Type u_3} {X : Type u_4} [DecidableEq ι] [SciLean.DualBasis κ K X] [Zero X] : SciLean.DualBasis (ι × κ) K (ι → X)"}
{"name":"SciLean.Basis","declaration":"/-- Basis of the space `X` over the field `K` indexed by `ι`\n\nThe class `FinVec ι K X` guarantees that any element `x : X` can be writtens as:\n```\n∑ i, proj i x • basis i\n```\n-/\nclass SciLean.Basis (ι : outParam (Type v)) (K : outParam (Type w)) (X : Type u) : Type (max (max u v) w)"}
{"name":"SciLean.Basis.basis","declaration":"def SciLean.Basis.basis {ι : outParam (Type v)} {K : outParam (Type w)} {X : Type u} [self : SciLean.Basis ι K X] (i : ι) : X"}
{"name":"SciLean.instBasisForAll","declaration":"instance SciLean.instBasisForAll {ι : Type u_1} {K : Type u_2} [DecidableEq ι] [RCLike K] : SciLean.Basis ι K (ι → K)"}
{"name":"SciLean.termⅇ'_","declaration":"/-- `ⅇ' i` is the i-th dual basis vector -/\ndef SciLean.termⅇ'_  : Lean.ParserDescr"}
{"name":"SciLean.inner_dualBasis_proj","declaration":"theorem SciLean.inner_dualBasis_proj {ι : Type u_3} {K : Type u_1} {X : Type u_2} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] (i : ι) (x : X) : ⟪x, ⅇ' i⟫_K = ℼ i x"}
{"name":"SciLean.Basis.mk","declaration":"ctor SciLean.Basis.mk {ι : outParam (Type v)} {K : outParam (Type w)} {X : Type u} (basis : ι → X) (proj : ι → X → K) : SciLean.Basis ι K X"}
{"name":"SciLean.«termⅇ'[_]_»","declaration":"/-- `ⅇ'[X] i` is the i-th dual basis vector of type `X` -/\ndef SciLean.«termⅇ'[_]_»  : Lean.ParserDescr"}
{"name":"SciLean.termℼ_","declaration":"/-- `ℼ i x` is projection of `x` onto i-th basis vector `ⅇ i` -/\ndef SciLean.termℼ_  : Lean.ParserDescr"}
{"name":"SciLean.«termⅇ[_]_»","declaration":"/-- `ⅇ[X] i` is the i-th basis vector of type `X` -/\ndef SciLean.«termⅇ[_]_»  : Lean.ParserDescr"}
{"name":"SciLean.FinVec.is_basis","declaration":"def SciLean.FinVec.is_basis {ι : outParam (Type u_1)} {K : Type u_2} {X : Type u_3} [outParam (SciLean.IndexType ι)] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [self : SciLean.FinVec ι K X] (x : X) : x = ∑ i, ℼ i x • ⅇ i"}
{"name":"SciLean.instDualBasisUnit","declaration":"instance SciLean.instDualBasisUnit (K : Type u_1) [RCLike K] : SciLean.DualBasis Unit K K"}
{"name":"SciLean.instOrthonormalBasisProdForAllToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldToDenselyNormedFieldInstBasisProdForAllToInnerInstSemiInnerProductSpaceForAllToSemiInnerProductSpaceToSemiHilbert","declaration":"instance SciLean.instOrthonormalBasisProdForAllToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldToDenselyNormedFieldInstBasisProdForAllToInnerInstSemiInnerProductSpaceForAllToSemiInnerProductSpaceToSemiHilbert {ι : Type u_1} {K : Type u_2} {X : Type u_3} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] {κ : Type u_4} [SciLean.IndexType ι] [SciLean.IndexType κ] [SciLean.LawfulIndexType ι] [SciLean.LawfulIndexType κ] [Zero X] [SciLean.Basis κ K X] [SciLean.OrthonormalBasis κ K X] : SciLean.OrthonormalBasis (ι × κ) K (ι → X)"}
{"name":"SciLean.instFinVecSumProdInstIndexTypeSumInstLawfulIndexTypeSumInstIndexTypeSumInstDecidableEqSum_1","declaration":"instance SciLean.instFinVecSumProdInstIndexTypeSumInstLawfulIndexTypeSumInstIndexTypeSumInstDecidableEqSum_1 {ι : Type u_1} {κ : Type u_2} {K : Type u_3} {X : Type (max u_4 u_5)} {Y : Type (max u_4 u_5)} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [SciLean.IndexType κ] [SciLean.LawfulIndexType κ] [DecidableEq κ] [RCLike K] [SciLean.FinVec ι K X] [SciLean.FinVec κ K Y] : SciLean.FinVec (ι ⊕ κ) K (X × Y)"}
{"name":"SciLean.proj_zero","declaration":"theorem SciLean.proj_zero {ι : Type u_2} {K : Type u_1} {X : Type u_3} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] (i : ι) : ℼ i 0 = 0"}
{"name":"SciLean.proj_basis","declaration":"theorem SciLean.proj_basis {ι : Type u_2} {K : Type u_1} {X : Type u_3} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] (i : ι) (j : ι) : ℼ i ⅇ j = if i = j then 1 else 0"}
{"name":"SciLean.instOrthonormalBasisUnitToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldToDenselyNormedFieldInstBasisUnitInstInner","declaration":"instance SciLean.instOrthonormalBasisUnitToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldToDenselyNormedFieldInstBasisUnitInstInner {K : Type u_1} [RCLike K] : SciLean.OrthonormalBasis Unit K K"}
{"name":"SciLean.inner_basis_dualBasis","declaration":"theorem SciLean.inner_basis_dualBasis {ι : Type u_3} {K : Type u_1} {X : Type u_2} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] (i : ι) (j : ι) : ⟪ⅇ i, ⅇ' j⟫_K = if i = j then 1 else 0"}
{"name":"SciLean.FinVec","declaration":"/-- -/\nclass SciLean.FinVec (ι : outParam (Type u_1)) (K : Type u_2) (X : Type u_3) [outParam (SciLean.IndexType ι)] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] : Type (max (max u_1 u_2) u_3)"}
{"name":"SciLean.BasisDuality.toDual","declaration":"def SciLean.BasisDuality.toDual {X : Type u} [self : SciLean.BasisDuality X] (x : X) : X"}
{"name":"SciLean.OrthonormalBasis.is_orthogonal","declaration":"def SciLean.OrthonormalBasis.is_orthogonal {ι : Type u_1} {K : Type u_2} {X : Type u_3} [Semiring K] [SciLean.Basis ι K X] [Inner K X] [self : SciLean.OrthonormalBasis ι K X] (i : ι) (j : ι) : i ≠ j → ⟪ⅇ i, ⅇ j⟫_K = 0"}
{"name":"SciLean.instGetElemNatLtInstLTNatCard","declaration":"instance SciLean.instGetElemNatLtInstLTNatCard {ι : Type u_1} {K : Type u_2} {X : Type u_3} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] : GetElem X ℕ K fun x i => i < SciLean.IndexType.card ι"}
{"name":"SciLean.OrthonormalBasis.is_orthonormal","declaration":"def SciLean.OrthonormalBasis.is_orthonormal {ι : Type u_1} {K : Type u_2} {X : Type u_3} [Semiring K] [SciLean.Basis ι K X] [Inner K X] [self : SciLean.OrthonormalBasis ι K X] (i : ι) : ⟪ⅇ i, ⅇ i⟫_K = 1"}
{"name":"SciLean.inner_dualBasis_basis","declaration":"theorem SciLean.inner_dualBasis_basis {ι : Type u_3} {K : Type u_1} {X : Type u_2} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] (i : ι) (j : ι) : ⟪ⅇ' i, ⅇ j⟫_K = if i = j then 1 else 0"}
{"name":"SciLean.inner_basis_dualProj","declaration":"theorem SciLean.inner_basis_dualProj {ι : Type u_3} {K : Type u_1} {X : Type u_2} [SciLean.IndexType ι] [SciLean.LawfulIndexType ι] [DecidableEq ι] [RCLike K] [SciLean.FinVec ι K X] (i : ι) (x : X) : ⟪x, ⅇ i⟫_K = ℼ' i x"}
