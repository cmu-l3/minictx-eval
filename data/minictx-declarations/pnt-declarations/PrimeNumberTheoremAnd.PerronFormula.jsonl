{"name":"Perron.residuePull1","declaration":"theorem Perron.residuePull1 {x : ℝ} {σ : ℝ} (x_gt_one : 1 < x) (σ_pos : 0 < σ) : VerticalIntegral' (Perron.f x) σ = 1 + VerticalIntegral' (Perron.f x) (-1 / 2)"}
{"name":"Complex.cpow_neg_eq_inv_pow_ofReal_pos","declaration":"theorem Complex.cpow_neg_eq_inv_pow_ofReal_pos {a : ℝ} (ha : 0 < a) (r : ℂ) : ↑a ^ (-r) = (↑a)⁻¹ ^ r"}
{"name":"limitOfConstantLeft","declaration":"theorem limitOfConstantLeft {a : ℝ → ℂ} {σ : ℝ} (σlt : σ ≤ -3 / 2) (ha : ∀ (σ' σ'' : ℝ), σ' ≤ -3 / 2 → σ'' ≤ -3 / 2 → a σ' = a σ'') (ha' : Filter.Tendsto a Filter.atBot (nhds 0)) : a σ = 0"}
{"name":"Perron.formulaLtOne","declaration":"theorem Perron.formulaLtOne {x : ℝ} {σ : ℝ} (xpos : 0 < x) (x_lt_one : x < 1) (σ_pos : 0 < σ) : VerticalIntegral (Perron.f x) σ = 0"}
{"name":"Perron.sPlusOneNeZero","declaration":"theorem Perron.sPlusOneNeZero {s : ℂ} (s_ne_neg_one : s ≠ -1) : s + 1 ≠ 0"}
{"name":"Perron.diffBddAtZero","declaration":"theorem Perron.diffBddAtZero {x : ℝ} (xpos : 0 < x) : ∀ᶠ (c : ℝ) in nhdsWithin 0 (Set.Ioi 0),\n  BddAbove ((norm ∘ fun s => ↑x ^ s / (s * (s + 1)) - 1 / s) '' (Square 0 c \\ {0}))"}
{"name":"Perron.vertIntBoundLeft","declaration":"theorem Perron.vertIntBoundLeft {x : ℝ} (xpos : 0 < x) : ∃ C, ∀ σ < -3 / 2, ‖VerticalIntegral' (Perron.f x) σ‖ ≤ C * x ^ σ"}
{"name":"Perron.tendsto_zero_Upper","declaration":"theorem Perron.tendsto_zero_Upper {x : ℝ} (xpos : 0 < x) (σ' : ℝ) (σ'' : ℝ) : Filter.Tendsto (fun t => ∫ (σ : ℝ) in σ'..σ'', Perron.f x (↑σ + ↑t * Complex.I)) Filter.atTop (nhds 0)"}
{"name":"Perron.horizontal_integral_isBigO","declaration":"theorem Perron.horizontal_integral_isBigO {x : ℝ} (xpos : 0 < x) (σ' : ℝ) (σ'' : ℝ) (μ : MeasureTheory.Measure ℝ) [MeasureTheory.IsLocallyFiniteMeasure μ] : (fun y => ∫ (σ : ℝ) in σ'..σ'', Perron.f x (↑σ + ↑y * Complex.I) ∂μ) =O[Filter.atBot ⊔ Filter.atTop] fun y => 1 / y ^ 2"}
{"name":"Perron.integralPosAux'_of_le","declaration":"theorem Perron.integralPosAux'_of_le (c₁ : ℝ) (c₂ : ℝ) (c₁_pos : 0 < c₁) (hle : c₁ ≤ c₂) : 0 < ∫ (t : ℝ), 1 / (Real.sqrt (c₁ + t ^ 2) * Real.sqrt (c₂ + t ^ 2))"}
{"name":"Perron.HolomorphicOn.lowerUIntegral_eq_zero","declaration":"theorem Perron.HolomorphicOn.lowerUIntegral_eq_zero {f : ℂ → ℂ} {σ : ℝ} {σ' : ℝ} {T : ℝ} (hσ : σ ≤ σ') (hf : HolomorphicOn f {z | σ ≤ z.re ∧ z.re ≤ σ' ∧ z.im ≤ -T}) (hbot : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atBot (nhds 0)) (hleft : MeasureTheory.Integrable (fun y => f (↑σ + ↑y * Complex.I)) MeasureTheory.volume) (hright : MeasureTheory.Integrable (fun y => f (↑σ' + ↑y * Complex.I)) MeasureTheory.volume) : LowerUIntegral f σ σ' T = 0"}
{"name":"RectangleIntegral_tendsTo_UpperU","declaration":"theorem RectangleIntegral_tendsTo_UpperU {σ : ℝ} {σ' : ℝ} {T : ℝ} {f : ℂ → ℂ} (htop : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atTop (nhds 0)) (hleft : MeasureTheory.Integrable (fun y => f (↑σ + ↑y * Complex.I)) MeasureTheory.volume) (hright : MeasureTheory.Integrable (fun y => f (↑σ' + ↑y * Complex.I)) MeasureTheory.volume) : Filter.Tendsto (fun U => RectangleIntegral f (↑σ + Complex.I * ↑T) (↑σ' + Complex.I * ↑U)) Filter.atTop\n  (nhds (UpperUIntegral f σ σ' T))"}
{"name":"Perron.bddAbove_square_of_tendsto","declaration":"theorem Perron.bddAbove_square_of_tendsto {β : Type u_2} [LinearOrder β] [NoMaxOrder β] [TopologicalSpace β] [ClosedIciTopology β] {y : β} {f : ℂ → β} {x : ℂ} (hf : Filter.Tendsto f (nhdsWithin x {x}ᶜ) (nhds y)) : ∀ᶠ (c : ℝ) in nhdsWithin 0 (Set.Ioi 0), BddAbove (f '' (Square x c \\ {x}))"}
{"name":"Perron.f_mul_eq_f","declaration":"theorem Perron.f_mul_eq_f {x : ℝ} {t : ℝ} (tpos : 0 < t) (xpos : 0 < x) (s : ℂ) : Perron.f t s * ↑x ^ (-s) = Perron.f (t / x) s"}
{"name":"Perron.contourPull","declaration":"theorem Perron.contourPull {x : ℝ} {σ' : ℝ} {σ'' : ℝ} (xpos : 0 < x) (hσ0 : 0 ∉ Set.uIcc σ' σ'') (hσ1 : -1 ∉ Set.uIcc σ' σ'') : VerticalIntegral (Perron.f x) σ' = VerticalIntegral (Perron.f x) σ''"}
{"name":"Perron.residueAtNegOne","declaration":"theorem Perron.residueAtNegOne {x : ℝ} (xpos : 0 < x) : ∀ᶠ (c : ℝ) in nhdsWithin 0 (Set.Ioi 0),\n  RectangleIntegral' (Perron.f x) (-↑c - ↑c * Complex.I - 1) (↑c + ↑c * Complex.I - 1) = -↑x⁻¹"}
{"name":"RectangleIntegral_tendsTo_LowerU","declaration":"theorem RectangleIntegral_tendsTo_LowerU {σ : ℝ} {σ' : ℝ} {T : ℝ} {f : ℂ → ℂ} (hbot : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atBot (nhds 0)) (hleft : MeasureTheory.Integrable (fun y => f (↑σ + ↑y * Complex.I)) MeasureTheory.volume) (hright : MeasureTheory.Integrable (fun y => f (↑σ' + ↑y * Complex.I)) MeasureTheory.volume) : Filter.Tendsto (fun U => RectangleIntegral f (↑σ - Complex.I * ↑U) (↑σ' - Complex.I * ↑T)) Filter.atTop\n  (nhds (-LowerUIntegral f σ σ' T))"}
{"name":"Perron.integralPosAux'","declaration":"theorem Perron.integralPosAux' (c₁ : ℝ) (c₂ : ℝ) (c₁_pos : 0 < c₁) (c₂_pos : 0 < c₂) : 0 < ∫ (t : ℝ), 1 / (Real.sqrt (c₁ + t ^ 2) * Real.sqrt (c₂ + t ^ 2))"}
{"name":"RectangleIntegral_tendsTo_VerticalIntegral","declaration":"theorem RectangleIntegral_tendsTo_VerticalIntegral {σ : ℝ} {σ' : ℝ} {f : ℂ → ℂ} (hbot : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atBot (nhds 0)) (htop : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atTop (nhds 0)) (hleft : MeasureTheory.Integrable (fun y => f (↑σ + ↑y * Complex.I)) MeasureTheory.volume) (hright : MeasureTheory.Integrable (fun y => f (↑σ' + ↑y * Complex.I)) MeasureTheory.volume) : Filter.Tendsto (fun T => RectangleIntegral f (↑σ - Complex.I * ↑T) (↑σ' + Complex.I * ↑T)) Filter.atTop\n  (nhds (VerticalIntegral f σ' - VerticalIntegral f σ))"}
{"name":"Perron.Integrable.one_div_const_add_sq","declaration":"theorem Perron.Integrable.one_div_const_add_sq (c : ℝ) (hc : 0 < c) : MeasureTheory.Integrable (fun t => 1 / (c + t ^ 2)) MeasureTheory.volume"}
{"name":"Perron.map_conj","declaration":"theorem Perron.map_conj {x : ℝ} (hx : 0 ≤ x) (s : ℂ) : Perron.f x ((starRingEnd ℂ) s) = (starRingEnd ℂ) (Perron.f x s)"}
{"name":"verticalIntegral_sub_verticalIntegral_eq_squareIntegral","declaration":"theorem verticalIntegral_sub_verticalIntegral_eq_squareIntegral {σ : ℝ} {σ' : ℝ} {f : ℂ → ℂ} {p : ℂ} (hσ : σ < p.re ∧ p.re < σ') (hf : HolomorphicOn f (Set.Icc σ σ' ×ℂ Set.univ \\ {p})) (hbot : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atBot (nhds 0)) (htop : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atTop (nhds 0)) (hleft : MeasureTheory.Integrable (fun y => f (↑σ + ↑y * Complex.I)) MeasureTheory.volume) (hright : MeasureTheory.Integrable (fun y => f (↑σ' + ↑y * Complex.I)) MeasureTheory.volume) : ∀ᶠ (c : ℝ) in nhdsWithin 0 (Set.Ioi 0),\n  VerticalIntegral f σ' - VerticalIntegral f σ =\n    RectangleIntegral f (-↑c - ↑c * Complex.I + p) (↑c + ↑c * Complex.I + p)"}
{"name":"Perron.integral_one_div_const_add_sq_pos","declaration":"theorem Perron.integral_one_div_const_add_sq_pos (c : ℝ) (hc : 0 < c) : 0 < ∫ (t : ℝ), 1 / (c + t ^ 2)"}
{"name":"zeroTendstoDiff","declaration":"theorem zeroTendstoDiff (L₁ : ℂ) (L₂ : ℂ) (f : ℝ → ℂ) (h : ∀ᶠ (T : ℝ) in Filter.atTop, f T = 0) (h' : Filter.Tendsto f Filter.atTop (nhds (L₂ - L₁))) : L₁ = L₂"}
{"name":"instMeasurableDiv₂RealMeasurableSpaceToDivInstLinearOrderedField","declaration":"instance instMeasurableDiv₂RealMeasurableSpaceToDivInstLinearOrderedField  : MeasurableDiv₂ ℝ"}
{"name":"limitOfConstant","declaration":"theorem limitOfConstant {a : ℝ → ℂ} {σ : ℝ} (σpos : 0 < σ) (ha : ∀ (σ' σ'' : ℝ), 0 < σ' → 0 < σ'' → a σ' = a σ'') (ha' : Filter.Tendsto a Filter.atTop (nhds 0)) : a σ = 0"}
{"name":"Perron.formulaGtOne","declaration":"theorem Perron.formulaGtOne {x : ℝ} {σ : ℝ} (x_gt_one : 1 < x) (σ_pos : 0 < σ) : VerticalIntegral' (fun s => ↑x ^ s / (s * (s + 1))) σ = 1 - 1 / ↑x"}
{"name":"Perron.isTheta_uniformlyOn_uIoc","declaration":"theorem Perron.isTheta_uniformlyOn_uIoc {x : ℝ} (xpos : 0 < x) (σ' : ℝ) (σ'' : ℝ) : (fun x_1 =>\n    match x_1 with\n    | (σ, y) => Perron.f x (↑σ + ↑y * Complex.I)) =Θ[Filter.principal (Ι σ' σ'') ×ˢ (Filter.atBot ⊔ Filter.atTop)]\n  fun x =>\n  match x with\n  | (σ, y) => 1 / y ^ 2"}
{"name":"Perron.diffBddAtNegOne","declaration":"theorem Perron.diffBddAtNegOne {x : ℝ} (xpos : 0 < x) : ∀ᶠ (c : ℝ) in nhdsWithin 0 (Set.Ioi 0),\n  BddAbove ((norm ∘ fun s => ↑x ^ s / (s * (s + 1)) - -↑x⁻¹ / (s + 1)) '' (Square (-1) c \\ {-1}))"}
{"name":"tendsto_rpow_atTop_nhds_zero_of_norm_gt_one","declaration":"theorem tendsto_rpow_atTop_nhds_zero_of_norm_gt_one {x : ℝ} (x_gt_one : 1 < x) (C : ℝ) : Filter.Tendsto (fun σ => x ^ σ * C) Filter.atBot (nhds 0)"}
{"name":"Perron.isTheta_uniformlyOn_uIcc","declaration":"theorem Perron.isTheta_uniformlyOn_uIcc {x : ℝ} (xpos : 0 < x) (σ' : ℝ) (σ'' : ℝ) : (fun x_1 =>\n    match x_1 with\n    | (σ, y) =>\n      Perron.f x (↑σ + ↑y * Complex.I)) =Θ[Filter.principal (Set.uIcc σ' σ'') ×ˢ (Filter.atBot ⊔ Filter.atTop)]\n  ((fun y => 1 / y ^ 2) ∘ Prod.snd)"}
{"name":"Perron.integralPosAux","declaration":"theorem Perron.integralPosAux  : 0 < ∫ (t : ℝ), 1 / (Real.sqrt (1 + t ^ 2) * Real.sqrt (2 + t ^ 2))"}
{"name":"verticalIntegral_eq_verticalIntegral","declaration":"theorem verticalIntegral_eq_verticalIntegral {σ : ℝ} {σ' : ℝ} {f : ℂ → ℂ} (hf : HolomorphicOn f (Set.uIcc σ σ' ×ℂ Set.univ)) (hbot : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atBot (nhds 0)) (htop : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atTop (nhds 0)) (hleft : MeasureTheory.Integrable (fun y => f (↑σ + ↑y * Complex.I)) MeasureTheory.volume) (hright : MeasureTheory.Integrable (fun y => f (↑σ' + ↑y * Complex.I)) MeasureTheory.volume) : VerticalIntegral f σ = VerticalIntegral f σ'"}
{"name":"tendsto_rpow_atTop_nhds_zero_of_norm_lt_one","declaration":"theorem tendsto_rpow_atTop_nhds_zero_of_norm_lt_one {x : ℝ} (xpos : 0 < x) (x_lt_one : x < 1) (C : ℝ) : Filter.Tendsto (fun σ => x ^ σ * C) Filter.atTop (nhds 0)"}
{"name":"Complex.cpow_inv_ofReal_pos","declaration":"theorem Complex.cpow_inv_ofReal_pos {a : ℝ} (ha : 0 ≤ a) (r : ℂ) : (↑a ^ r)⁻¹ = (↑a)⁻¹ ^ r"}
{"name":"Perron.keyIdentity","declaration":"theorem Perron.keyIdentity (x : ℝ) {s : ℂ} (s_ne_zero : s ≠ 0) (s_ne_neg_one : s ≠ -1) : ↑x ^ s / (s * (s + 1)) = ↑x ^ s / s - ↑x ^ s / (s + 1)"}
{"name":"Complex.cpow_eq_exp_log_ofReal","declaration":"theorem Complex.cpow_eq_exp_log_ofReal (x : ℝ) (hx : 0 < x) (y : ℂ) : ↑x ^ y = Complex.exp (↑(Real.log x) * y)"}
{"name":"Perron.isHolomorphicOn","declaration":"theorem Perron.isHolomorphicOn {x : ℝ} (xpos : 0 < x) : HolomorphicOn (Perron.f x) {0, -1}ᶜ"}
{"name":"Perron.f","declaration":"def Perron.f (x : ℝ) (s : ℂ) : ℂ"}
{"name":"Perron.HolomorphicOn.upperUIntegral_eq_zero","declaration":"theorem Perron.HolomorphicOn.upperUIntegral_eq_zero {f : ℂ → ℂ} {σ : ℝ} {σ' : ℝ} {T : ℝ} (hσ : σ ≤ σ') (hf : HolomorphicOn f {z | σ ≤ z.re ∧ z.re ≤ σ' ∧ T ≤ z.im}) (htop : Filter.Tendsto (fun y => ∫ (x : ℝ) in σ..σ', f (↑x + ↑y * Complex.I)) Filter.atTop (nhds 0)) (hleft : MeasureTheory.Integrable (fun y => f (↑σ + ↑y * Complex.I)) MeasureTheory.volume) (hright : MeasureTheory.Integrable (fun y => f (↑σ' + ↑y * Complex.I)) MeasureTheory.volume) : UpperUIntegral f σ σ' T = 0"}
{"name":"Perron.residuePull2","declaration":"theorem Perron.residuePull2 {x : ℝ} (x_gt_one : 1 < x) : VerticalIntegral' (fun s => ↑x ^ s / (s * (s + 1))) (-1 / 2) =\n  -1 / ↑x + VerticalIntegral' (fun s => ↑x ^ s / (s * (s + 1))) (-3 / 2)"}
{"name":"Perron.vertIntBound","declaration":"theorem Perron.vertIntBound {x : ℝ} {σ : ℝ} (xpos : 0 < x) (σ_gt_one : 1 < σ) : ‖VerticalIntegral (Perron.f x) σ‖ ≤ x ^ σ * ∫ (t : ℝ), 1 / (Real.sqrt (1 + t ^ 2) * Real.sqrt (2 + t ^ 2))"}
{"name":"Filter.Tendsto.eventually_bddAbove","declaration":"theorem Filter.Tendsto.eventually_bddAbove {α : Type u_1} {β : Type u_2} [LinearOrder β] [NoMaxOrder β] [TopologicalSpace β] [ClosedIciTopology β] {y : β} {l : Filter α} {f : α → β} (hf : Filter.Tendsto f l (nhds y)) : ∀ᶠ (s : Set α) in Filter.smallSets l, BddAbove (f '' s)"}
{"name":"Perron.residueAtZero","declaration":"theorem Perron.residueAtZero {x : ℝ} (xpos : 0 < x) : ∀ᶠ (c : ℝ) in nhdsWithin 0 (Set.Ioi 0), RectangleIntegral' (Perron.f x) (-↑c - ↑c * Complex.I) (↑c + ↑c * Complex.I) = 1"}
{"name":"Perron.tendsto_zero_Lower","declaration":"theorem Perron.tendsto_zero_Lower {x : ℝ} (xpos : 0 < x) (σ' : ℝ) (σ'' : ℝ) : Filter.Tendsto (fun t => ∫ (σ : ℝ) in σ'..σ'', Perron.f x (↑σ + ↑t * Complex.I)) Filter.atBot (nhds 0)"}
{"name":"Perron.contourPull3","declaration":"theorem Perron.contourPull3 {x : ℝ} {σ' : ℝ} {σ'' : ℝ} (x_gt_one : 1 < x) (σ'le : σ' ≤ -3 / 2) (σ''le : σ'' ≤ -3 / 2) : VerticalIntegral' (fun s => ↑x ^ s / (s * (s + 1))) σ' = VerticalIntegral' (fun s => ↑x ^ s / (s * (s + 1))) σ''"}
{"name":"Perron.isTheta","declaration":"theorem Perron.isTheta {x : ℝ} {σ : ℝ} (xpos : 0 < x) : ((fun y => Perron.f x (↑σ + ↑y * Complex.I)) =Θ[Filter.atBot] fun y => 1 / y ^ 2) ∧\n  (fun y => Perron.f x (↑σ + ↑y * Complex.I)) =Θ[Filter.atTop] fun y => 1 / y ^ 2"}
{"name":"Perron.isIntegrable","declaration":"theorem Perron.isIntegrable {x : ℝ} {σ : ℝ} (xpos : 0 < x) (σ_ne_zero : σ ≠ 0) (σ_ne_neg_one : σ ≠ -1) : MeasureTheory.Integrable (fun t => Perron.f x (↑σ + ↑t * Complex.I)) MeasureTheory.volume"}
