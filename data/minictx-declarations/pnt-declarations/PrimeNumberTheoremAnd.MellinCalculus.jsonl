{"name":"Filter.TendstoAtZero_of_support_in_Icc","declaration":"theorem Filter.TendstoAtZero_of_support_in_Icc {ğ•‚ : Type u_1} [RCLike ğ•‚] {a : â„} {b : â„} (f : â„ â†’ ğ•‚) (ha : 0 < a) (fSupp : Function.support f âŠ† Set.Icc a b) : Filter.Tendsto f (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)"}
{"name":"MellinOfPsi_aux","declaration":"theorem MellinOfPsi_aux {Î¨ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Î¨) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) {s : â„‚} (hs : s â‰  0) : âˆ« (x : â„) in Set.Ioi 0, â†‘(Î¨ x) * â†‘x ^ (s - 1) = -(1 / s) * âˆ« (x : â„) in Set.Ioi 0, â†‘(deriv Î¨ x) * â†‘x ^ s"}
{"name":"MellinInversion_aux1","declaration":"theorem MellinInversion_aux1 {f : â„ â†’ â„‚} {s : â„‚} (s_ne_zero : s â‰  0) (fDiff : DifferentiableOn â„ f (Set.Ioi 0)) (hfs : Filter.Tendsto (fun x => f x * â†‘x ^ s) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)) (hfinf : Filter.Tendsto (fun x => f x * â†‘x ^ s) Filter.atTop (nhds 0)) : âˆ« (x : â„) in Set.Ioi 0, f x * â†‘x ^ s / â†‘x = -âˆ« (x : â„) in Set.Ioi 0, deriv f x * â†‘x ^ s / s"}
{"name":"MellinConvolutionTransform","declaration":"theorem MellinConvolutionTransform (f : â„ â†’ â„‚) (g : â„ â†’ â„‚) (s : â„‚) (hf : MeasureTheory.IntegrableOn (Function.uncurry fun x y => f y * g (x / y) / â†‘y * â†‘x ^ (s - 1)) (Set.Ioi 0 Ã—Ë¢ Set.Ioi 0)\n  MeasureTheory.volume) : MellinTransform (MellinConvolution f g) s = MellinTransform f s * MellinTransform g s"}
{"name":"Function.support_mul_subset_of_subset","declaration":"theorem Function.support_mul_subset_of_subset {ğ•‚ : Type u_1} [RCLike ğ•‚] {s : Set â„} {f : â„ â†’ ğ•‚} {g : â„ â†’ ğ•‚} (fSupp : Function.support f âŠ† s) : Function.support (f * g) âŠ† s"}
{"name":"Complex.hasDerivAt_ofReal","declaration":"theorem Complex.hasDerivAt_ofReal (x : â„) : HasDerivAt Complex.ofReal' 1 x"}
{"name":"SetIntegral.integral_eq_integral_inter_of_support_subset_Icc","declaration":"theorem SetIntegral.integral_eq_integral_inter_of_support_subset_Icc {a : â„} {b : â„} {Î¼ : MeasureTheory.Measure â„} {E : Type u_2} [NormedAddCommGroup E] [NormedSpace â„ E] {s : Set â„} {f : â„ â†’ E} (h : Function.support f âŠ† Set.Icc a b) (hs : Set.Icc a b âŠ† s) : âˆ« (x : â„) in s, f x âˆ‚Î¼ = âˆ« (x : â„) in Set.Icc a b, f x âˆ‚Î¼"}
{"name":"MellinInverseTransform_eq","declaration":"theorem MellinInverseTransform_eq (Ïƒ : â„) (f : â„‚ â†’ â„‚) : MellinInverseTransform f Ïƒ = mellinInv Ïƒ f"}
{"name":"intervalIntegral.norm_integral_le_of_norm_le_const'","declaration":"theorem intervalIntegral.norm_integral_le_of_norm_le_const' {a : â„} {b : â„} {C : â„} {E : Type u_2} [NormedAddCommGroup E] [NormedSpace â„ E] {f : â„ â†’ E} (hab : a â‰¤ b) (h : âˆ€ x âˆˆ Set.Icc a b, â€–f xâ€– â‰¤ C) : â€–âˆ« (x : â„) in a..b, f xâ€– â‰¤ C * |b - a|"}
{"name":"MellinOf1","declaration":"theorem MellinOf1 (s : â„‚) (h : s.re > 0) : MellinTransform (fun x => if 0 < x âˆ§ x â‰¤ 1 then 1 else 0) s = 1 / s"}
{"name":"MellinOfDeltaSpikeAt1","declaration":"theorem MellinOfDeltaSpikeAt1 (Î¨ : â„ â†’ â„) {Îµ : â„} (Îµpos : Îµ > 0) : MellinTransform (fun x => â†‘(DeltaSpike Î¨ Îµ x)) 1 = MellinTransform (fun x => â†‘(Î¨ x)) â†‘Îµ"}
{"name":"MellinInversion_aux3","declaration":"theorem MellinInversion_aux3 {f : â„ â†’ â„‚} (Ïƒ : â„) (Ïƒ_ne_zero : Ïƒ â‰  0) (Ïƒ_ne_negOne : Ïƒ â‰  -1) (fInt : MeasureTheory.IntegrableOn (fun x => f x * â†‘x ^ â†‘Ïƒ) (Set.Ioi 0) MeasureTheory.volume) : MeasureTheory.IntegrableOn\n  (fun x =>\n    match x with\n    | (x, t) => f x * â†‘x ^ (â†‘Ïƒ + â†‘t * Complex.I) / ((â†‘Ïƒ + â†‘t * Complex.I) * (â†‘Ïƒ + â†‘t * Complex.I + 1)))\n  (Set.prod (Set.Ioi 0) Set.univ) MeasureTheory.volume"}
{"name":"Function.support_ofReal","declaration":"theorem Function.support_ofReal {f : â„ â†’ â„} : (Function.support fun x => â†‘(f x)) = Function.support f"}
{"name":"DeltaSpike","declaration":"def DeltaSpike (Î¨ : â„ â†’ â„) (Îµ : â„) : â„ â†’ â„"}
{"name":"Smooth1Properties_above","declaration":"theorem Smooth1Properties_above {Î¨ : â„ â†’ â„} (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) {Îµ : â„} (hÎµ : Îµ âˆˆ Set.Ioo 0 1) : âˆƒ c, 0 < c âˆ§ âˆ€ (x : â„), 1 + c * Îµ â‰¤ x â†’ Smooth1 Î¨ Îµ x = 0"}
{"name":"Smooth1Properties_above_aux2","declaration":"theorem Smooth1Properties_above_aux2 {x : â„} {y : â„} {Îµ : â„} (hÎµ : Îµ âˆˆ Set.Ioo 0 1) (hy : y âˆˆ Set.Ioc 0 1) (hx2 : 2 ^ Îµ < x) : 2 < (x / y) ^ (1 / Îµ)"}
{"name":"Smooth1LeOne","declaration":"theorem Smooth1LeOne {Î¨ : â„ â†’ â„} (Î¨nonneg : âˆ€ x > 0, 0 â‰¤ Î¨ x) (mass_one : âˆ« (x : â„) in Set.Ioi 0, Î¨ x / x = 1) {Îµ : â„} (Îµpos : 0 < Îµ) (x : â„) : 0 < x â†’ Smooth1 Î¨ Îµ x â‰¤ 1"}
{"name":"Smooth1Properties_below","declaration":"theorem Smooth1Properties_below {Î¨ : â„ â†’ â„} (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) (Îµ : â„) (Îµpos : 0 < Îµ) (mass_one : âˆ« (x : â„) in Set.Ioi 0, Î¨ x / x = 1) : âˆƒ c, 0 < c âˆ§ âˆ€ (x : â„), 0 < x â†’ x â‰¤ 1 - c * Îµ â†’ Smooth1 Î¨ Îµ x = 1"}
{"name":"DifferentiableAt.ofReal_comp_iff","declaration":"theorem DifferentiableAt.ofReal_comp_iff {z : â„} {f : â„ â†’ â„} : DifferentiableAt â„ (fun y => â†‘(f y)) z â†” DifferentiableAt â„ f z"}
{"name":"DifferentiableAt.comp_ofReal","declaration":"theorem DifferentiableAt.comp_ofReal {e : â„‚ â†’ â„‚} {z : â„} (hf : DifferentiableAt â„‚ e â†‘z) : DifferentiableAt â„ (fun x => e â†‘x) z"}
{"name":"DeltaSpikeContinuous","declaration":"theorem DeltaSpikeContinuous {Î¨ : â„ â†’ â„} {Îµ : â„} (Îµpos : 0 < Îµ) (diffÎ¨ : ContDiff â„ 1 Î¨) : Continuous fun x => DeltaSpike Î¨ Îµ x"}
{"name":"PartialIntegration_of_support_in_Icc","declaration":"theorem PartialIntegration_of_support_in_Icc {a : â„} {b : â„} (f : â„ â†’ â„‚) (g : â„ â†’ â„‚) (ha : 0 < a) (h : a â‰¤ b) (fSupp : Function.support f âŠ† Set.Icc a b) (fDiff : DifferentiableOn â„ f (Set.Ioi 0)) (gDiff : DifferentiableOn â„ g (Set.Ioi 0)) (fderivCont : ContinuousOn (deriv f) (Set.Ioi 0)) (gderivCont : ContinuousOn (deriv g) (Set.Ioi 0)) : âˆ« (x : â„) in Set.Ioi 0, f x * deriv g x = -âˆ« (x : â„) in Set.Ioi 0, deriv f x * g x"}
{"name":"Smooth1Properties_below_aux","declaration":"theorem Smooth1Properties_below_aux {x : â„} {Îµ : â„} (hx : x â‰¤ 1 - Real.log 2 * Îµ) (Îµpos : 0 < Îµ) : x < 2 ^ (-Îµ)"}
{"name":"Differentiable.ofReal_comp_iff","declaration":"theorem Differentiable.ofReal_comp_iff {f : â„ â†’ â„} : (Differentiable â„ fun y => â†‘(f y)) â†” Differentiable â„ f"}
{"name":"MeasureTheory.integral_comp_mul_right_I0i_haar_real","declaration":"theorem MeasureTheory.integral_comp_mul_right_I0i_haar_real (f : â„ â†’ â„) {a : â„} (ha : 0 < a) : âˆ« (y : â„) in Set.Ioi 0, f (y * a) / y = âˆ« (y : â„) in Set.Ioi 0, f y / y"}
{"name":"MeasureTheory.set_integral_integral_swap","declaration":"theorem MeasureTheory.set_integral_integral_swap {Î± : Type u_1} {Î² : Type u_2} {E : Type u_3} [MeasurableSpace Î±] [MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±} {Î½ : MeasureTheory.Measure Î²} [NormedAddCommGroup E] [MeasureTheory.SigmaFinite Î½] [NormedSpace â„ E] [MeasureTheory.SigmaFinite Î¼] (f : Î± â†’ Î² â†’ E) {s : Set Î±} {t : Set Î²} (hf : MeasureTheory.IntegrableOn (Function.uncurry f) (s Ã—Ë¢ t) (MeasureTheory.Measure.prod Î¼ Î½)) : âˆ« (x : Î±) in s, âˆ« (y : Î²) in t, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (y : Î²) in t, âˆ« (x : Î±) in s, f x y âˆ‚Î¼ âˆ‚Î½"}
{"name":"MeasureTheory.integral_comp_rpow_I0i_haar_real","declaration":"theorem MeasureTheory.integral_comp_rpow_I0i_haar_real (f : â„ â†’ â„) {p : â„} (hp : p â‰  0) : âˆ« (y : â„) in Set.Ioi 0, |p| * f (y ^ p) / y = âˆ« (y : â„) in Set.Ioi 0, f y / y"}
{"name":"mellintransform","declaration":"def mellintransform  : Lean.ParserDescr"}
{"name":"MellinInverseTransform","declaration":"def MellinInverseTransform (F : â„‚ â†’ â„‚) (Ïƒ : â„) (x : â„) : â„‚"}
{"name":"DeltaSpikeSupport_aux","declaration":"theorem DeltaSpikeSupport_aux {Î¨ : â„ â†’ â„} {Îµ : â„} (Îµpos : 0 < Îµ) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) : (Function.support fun x => if x < 0 then 0 else DeltaSpike Î¨ Îµ x) âŠ† Set.Icc (2 ^ (-Îµ)) (2 ^ Îµ)"}
{"name":"MellinOfDeltaSpike","declaration":"theorem MellinOfDeltaSpike (Î¨ : â„ â†’ â„) {Îµ : â„} (Îµpos : Îµ > 0) (s : â„‚) : MellinTransform (fun x => â†‘(DeltaSpike Î¨ Îµ x)) s = MellinTransform (fun x => â†‘(Î¨ x)) (â†‘Îµ * s)"}
{"name":"DifferentiableAt.ofReal_comp","declaration":"theorem DifferentiableAt.ofReal_comp {z : â„} {f : â„ â†’ â„} (hf : DifferentiableAt â„ f z) : DifferentiableAt â„ (fun y => â†‘(f y)) z"}
{"name":"MeasureTheory.integral_comp_div_I0i_haar","declaration":"theorem MeasureTheory.integral_comp_div_I0i_haar {ğ•‚ : Type u_1} [RCLike ğ•‚] (f : â„ â†’ ğ•‚) {a : â„} (ha : 0 < a) : âˆ« (y : â„) in Set.Ioi 0, f (a / y) / â†‘y = âˆ« (y : â„) in Set.Ioi 0, f y / â†‘y"}
{"name":"Filter.BigO_zero_atZero_of_support_in_Icc","declaration":"theorem Filter.BigO_zero_atZero_of_support_in_Icc {ğ•‚ : Type u_1} [RCLike ğ•‚] {a : â„} {b : â„} (f : â„ â†’ ğ•‚) (ha : 0 < a) (fSupp : Function.support f âŠ† Set.Icc a b) : f =O[nhdsWithin 0 (Set.Ioi 0)] fun x => 0"}
{"name":"MellinOfSmooth1a","declaration":"theorem MellinOfSmooth1a (Î¨ : â„ â†’ â„) (diffÎ¨ : ContDiff â„ 1 Î¨) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) {Îµ : â„} (Îµpos : 0 < Îµ) {s : â„‚} (hs : 0 < s.re) : MellinTransform (fun x => â†‘(Smooth1 Î¨ Îµ x)) s = 1 / s * MellinTransform (fun x => â†‘(Î¨ x)) (â†‘Îµ * s)"}
{"name":"Function.support_deriv_subset_Icc","declaration":"theorem Function.support_deriv_subset_Icc {ğ•‚ : Type u_1} [RCLike ğ•‚] {a : â„} {b : â„} {f : â„ â†’ ğ•‚} (fSupp : Function.support f âŠ† Set.Icc a b) : Function.support (deriv f) âŠ† Set.Icc a b"}
{"name":"MeasureTheory.integral_comp_mul_left_I0i_haar","declaration":"theorem MeasureTheory.integral_comp_mul_left_I0i_haar {ğ•‚ : Type u_1} [RCLike ğ•‚] (f : â„ â†’ ğ•‚) {a : â„} (ha : 0 < a) : âˆ« (y : â„) in Set.Ioi 0, f (a * y) / â†‘y = âˆ« (y : â„) in Set.Ioi 0, f y / â†‘y"}
{"name":"Smooth1LeOne_aux","declaration":"theorem Smooth1LeOne_aux {x : â„} {Îµ : â„} {Î¨ : â„ â†’ â„} (xpos : 0 < x) (Îµpos : 0 < Îµ) (mass_one : âˆ« (x : â„) in Set.Ioi 0, Î¨ x / x = 1) : âˆ« (y : â„) in Set.Ioi 0, Î¨ ((x / y) ^ (1 / Îµ)) / Îµ / y = 1"}
{"name":"IntervalIntegral.integral_eq_integral_of_support_subset_Icc","declaration":"theorem IntervalIntegral.integral_eq_integral_of_support_subset_Icc {a : â„} {b : â„} {Î¼ : MeasureTheory.Measure â„} [MeasureTheory.NoAtoms Î¼] {E : Type u_2} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E] {f : â„ â†’ E} (h : Function.support f âŠ† Set.Icc a b) : âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„), f x âˆ‚Î¼"}
{"name":"DeltaSpikeMass","declaration":"theorem DeltaSpikeMass {Î¨ : â„ â†’ â„} (mass_one : âˆ« (x : â„) in Set.Ioi 0, Î¨ x / x = 1) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆ« (x : â„) in Set.Ioi 0, DeltaSpike Î¨ Îµ x / x = 1"}
{"name":"MellinTransform","declaration":"def MellinTransform (f : â„ â†’ â„‚) (s : â„‚) : â„‚"}
{"name":"deriv.comp_ofReal","declaration":"theorem deriv.comp_ofReal {e : â„‚ â†’ â„‚} {z : â„} (hf : DifferentiableAt â„‚ e â†‘z) : deriv (fun x => e â†‘x) z = deriv e â†‘z"}
{"name":"MellinInversion_aux2","declaration":"theorem MellinInversion_aux2 {f : â„ â†’ â„‚} (s : â„‚) (fDiff : DifferentiableOn â„ f (Set.Ioi 0)) (fDiff2 : DifferentiableOn â„ (deriv f) (Set.Ioi 0)) (hfs : Filter.Tendsto (fun x => deriv f x * â†‘x ^ s) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)) (hfinf : Filter.Tendsto (fun x => deriv f x * â†‘x ^ s) Filter.atTop (nhds 0)) : âˆ« (x : â„) in Set.Ioi 0, deriv f x * â†‘x ^ s = -âˆ« (x : â„) in Set.Ioi 0, deriv (deriv f) x * â†‘x ^ (s + 1) / (s + 1)"}
{"name":"PerronInverseMellin_lt","declaration":"theorem PerronInverseMellin_lt {t : â„} {x : â„} (tpos : 0 < t) (t_lt_x : t < x) {Ïƒ : â„} (Ïƒpos : 0 < Ïƒ) : MellinInverseTransform (Perron.f t) Ïƒ x = 0"}
{"name":"Complex.differentiable_ofReal","declaration":"theorem Complex.differentiable_ofReal  : Differentiable â„ Complex.ofReal'"}
{"name":"Differentiable.ofReal_comp","declaration":"theorem Differentiable.ofReal_comp {f : â„ â†’ â„} (hf : Differentiable â„ f) : Differentiable â„ fun y => â†‘(f y)"}
{"name":"MellinOfSmooth1b","declaration":"theorem MellinOfSmooth1b {Î¨ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Î¨) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) {Ïƒâ‚ : â„} {Ïƒâ‚‚ : â„} (Ïƒâ‚pos : 0 < Ïƒâ‚) (Îµ : â„) (Îµpos : 0 < Îµ) : (fun s => â€–MellinTransform (fun x => â†‘(Smooth1 Î¨ Îµ x)) sâ€–) =O[Filter.principal {s | Ïƒâ‚ â‰¤ s.re âˆ§ s.re â‰¤ Ïƒâ‚‚}] fun s =>\n  1 / (Îµ * â€–sâ€– ^ 2)"}
{"name":"MellinInversion_aux4","declaration":"theorem MellinInversion_aux4 {f : â„ â†’ â„‚} (Ïƒ : â„) (Ïƒ_ne_zero : Ïƒ â‰  0) (Ïƒ_ne_negOne : Ïƒ â‰  -1) (fInt : MeasureTheory.IntegrableOn (fun x => f x * â†‘x ^ â†‘Ïƒ) (Set.Ioi 0) MeasureTheory.volume) : VerticalIntegral (fun s => âˆ« (x : â„) in Set.Ioi 0, f x * â†‘x ^ (s + 1) / (s * (s + 1))) Ïƒ =\n  âˆ« (x : â„) in Set.Ioi 0, VerticalIntegral (fun s => f x * â†‘x ^ (s + 1) / (s * (s + 1))) Ïƒ"}
{"name":"MellinOfSmooth1c","declaration":"theorem MellinOfSmooth1c {Î¨ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Î¨) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) (mass_one : âˆ« (x : â„) in Set.Ioi 0, Î¨ x / x = 1) : (fun Îµ => MellinTransform (fun x => â†‘(Smooth1 Î¨ Îµ x)) 1 - 1) =O[nhdsWithin 0 (Set.Ioi 0)] id"}
{"name":"Function.support_id","declaration":"theorem Function.support_id  : (Function.support fun x => x) = Set.Iio 0 âˆª Set.Ioi 0"}
{"name":"Smooth1","declaration":"def Smooth1 (Î¨ : â„ â†’ â„) (Îµ : â„) : â„ â†’ â„"}
{"name":"PartialIntegration","declaration":"/-- *Need differentiability, and decay at `0` and `âˆ`* -/\ntheorem PartialIntegration (f : â„ â†’ â„‚) (g : â„ â†’ â„‚) (fDiff : DifferentiableOn â„ f (Set.Ioi 0)) (gDiff : DifferentiableOn â„ g (Set.Ioi 0)) (fDerivgInt : MeasureTheory.IntegrableOn (f * deriv g) (Set.Ioi 0) MeasureTheory.volume) (gDerivfInt : MeasureTheory.IntegrableOn (deriv f * g) (Set.Ioi 0) MeasureTheory.volume) (lim_at_zero : Filter.Tendsto (f * g) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)) (lim_at_inf : Filter.Tendsto (f * g) Filter.atTop (nhds 0)) : âˆ« (x : â„) in Set.Ioi 0, f x * deriv g x = -âˆ« (x : â„) in Set.Ioi 0, deriv f x * g x"}
{"name":"MellinConvNonNeg_of_NonNeg","declaration":"theorem MellinConvNonNeg_of_NonNeg {f : â„ â†’ â„} {g : â„ â†’ â„} (f_nonneg : âˆ€ x > 0, 0 â‰¤ f x) (g_nonneg : âˆ€ x > 0, 0 â‰¤ g x) {x : â„} (xpos : 0 < x) : 0 â‰¤ MellinConvolution f g x"}
{"name":"DeltaSpikeSupport'","declaration":"theorem DeltaSpikeSupport' {Î¨ : â„ â†’ â„} {Îµ : â„} {x : â„} (Îµpos : 0 < Îµ) (xnonneg : 0 â‰¤ x) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) : DeltaSpike Î¨ Îµ x â‰  0 â†’ x âˆˆ Set.Icc (2 ^ (-Îµ)) (2 ^ Îµ)"}
{"name":"MellinConvolutionSymmetric","declaration":"theorem MellinConvolutionSymmetric {ğ•‚ : Type u_1} [RCLike ğ•‚] (f : â„ â†’ ğ•‚) (g : â„ â†’ ğ•‚) {x : â„} (xpos : 0 < x) : MellinConvolution f g x = MellinConvolution g f x"}
{"name":"deriv.ofReal_comp","declaration":"theorem deriv.ofReal_comp {z : â„} {f : â„ â†’ â„} : deriv (fun y => â†‘(f y)) z = â†‘(deriv f z)"}
{"name":"SetIntegral.integral_eq_integral_inter_of_support_subset","declaration":"theorem SetIntegral.integral_eq_integral_inter_of_support_subset {Î¼ : MeasureTheory.Measure â„} {E : Type u_2} [NormedAddCommGroup E] [NormedSpace â„ E] {s : Set â„} {t : Set â„} {f : â„ â†’ E} (h : Function.support f âŠ† t) (ht : MeasurableSet t) : âˆ« (x : â„) in s, f x âˆ‚Î¼ = âˆ« (x : â„) in s âˆ© t, f x âˆ‚Î¼"}
{"name":"Filter.TendstoAtTop_of_support_in_Icc","declaration":"theorem Filter.TendstoAtTop_of_support_in_Icc {ğ•‚ : Type u_1} [RCLike ğ•‚] {a : â„} {b : â„} (f : â„ â†’ ğ•‚) (fSupp : Function.support f âŠ† Set.Icc a b) : Filter.Tendsto f Filter.atTop (nhds 0)"}
{"name":"HasDerivAt.of_hasDerivAt_ofReal_comp","declaration":"theorem HasDerivAt.of_hasDerivAt_ofReal_comp {z : â„} {f : â„ â†’ â„} {u : â„‚} (hf : HasDerivAt (fun y => â†‘(f y)) u z) : âˆƒ u', u = â†‘u' âˆ§ HasDerivAt f u' z"}
{"name":"Filter.BigO_zero_atTop_of_support_in_Icc","declaration":"theorem Filter.BigO_zero_atTop_of_support_in_Icc {ğ•‚ : Type u_1} [RCLike ğ•‚] {a : â„} {b : â„} (f : â„ â†’ ğ•‚) (fSupp : Function.support f âŠ† Set.Icc a b) : f =O[Filter.atTop] fun x => 0"}
{"name":"Complex.differentiableAt_ofReal","declaration":"theorem Complex.differentiableAt_ofReal (x : â„) : DifferentiableAt â„ Complex.ofReal' x"}
{"name":"MellinConvolution","declaration":"def MellinConvolution {ğ•‚ : Type u_1} [RCLike ğ•‚] (f : â„ â†’ ğ•‚) (g : â„ â†’ ğ•‚) (x : â„) : ğ•‚"}
{"name":"MellinInversion","declaration":"theorem MellinInversion (Ïƒ : â„) {f : â„ â†’ â„‚} {x : â„} (hx : 0 < x) (hf : MellinConvergent f â†‘Ïƒ) (hFf : Complex.VerticalIntegrable (mellin f) Ïƒ MeasureTheory.volume) (hfx : ContinuousAt f x) : MellinInverseTransform (MellinTransform f) Ïƒ x = f x"}
{"name":"MellinOfPsi","declaration":"theorem MellinOfPsi {Î¨ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Î¨) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) {Ïƒâ‚ : â„} {Ïƒâ‚‚ : â„} (Ïƒâ‚pos : 0 < Ïƒâ‚) : (fun s => â€–MellinTransform (fun x => â†‘(Î¨ x)) sâ€–) =O[Filter.principal {s | Ïƒâ‚ â‰¤ s.re âˆ§ s.re â‰¤ Ïƒâ‚‚}] fun s => 1 / â€–sâ€–"}
{"name":"Function.support_of_along_fiber_subset_subset","declaration":"theorem Function.support_of_along_fiber_subset_subset {Î± : Type u_2} {Î² : Type u_3} {M : Type u_4} [Zero M] {f : Î± Ã— Î² â†’ M} {s : Set Î±} {t : Set Î²} (hx : âˆ€ (y : Î²), (Function.support fun x => f (x, y)) âŠ† s) (hy : âˆ€ (x : Î±), (Function.support fun y => f (x, y)) âŠ† t) : Function.support f âŠ† s Ã—Ë¢ t"}
{"name":"SmoothExistence","declaration":"theorem SmoothExistence  : âˆƒ Î¨,\n  ContDiff â„ âŠ¤ Î¨ âˆ§ (âˆ€ (x : â„), 0 â‰¤ Î¨ x) âˆ§ Function.support Î¨ âŠ† Set.Icc (1 / 2) 2 âˆ§ âˆ« (x : â„) in Set.Ici 0, Î¨ x / x = 1"}
{"name":"Smooth1Nonneg","declaration":"theorem Smooth1Nonneg {Î¨ : â„ â†’ â„} (Î¨nonneg : âˆ€ x > 0, 0 â‰¤ Î¨ x) {Îµ : â„} {x : â„} (xpos : 0 < x) (Îµpos : 0 < Îµ) : 0 â‰¤ Smooth1 Î¨ Îµ x"}
{"name":"Smooth1Properties_above_aux","declaration":"theorem Smooth1Properties_above_aux {x : â„} {Îµ : â„} (hx : 1 + 2 * Real.log 2 * Îµ â‰¤ x) (hÎµ : Îµ âˆˆ Set.Ioo 0 1) : 2 ^ Îµ < x"}
{"name":"DeltaSpikeSupport","declaration":"theorem DeltaSpikeSupport {Î¨ : â„ â†’ â„} {Îµ : â„} {x : â„} (Îµpos : 0 < Îµ) (xnonneg : 0 â‰¤ x) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) : x âˆ‰ Set.Icc (2 ^ (-Îµ)) (2 ^ Îµ) â†’ DeltaSpike Î¨ Îµ x = 0"}
{"name":"MeasureTheory.integral_comp_mul_right_I0i_haar","declaration":"theorem MeasureTheory.integral_comp_mul_right_I0i_haar {ğ•‚ : Type u_1} [RCLike ğ•‚] (f : â„ â†’ ğ•‚) {a : â„} (ha : 0 < a) : âˆ« (y : â„) in Set.Ioi 0, f (y * a) / â†‘y = âˆ« (y : â„) in Set.Ioi 0, f y / â†‘y"}
{"name":"Differentiable.comp_ofReal","declaration":"theorem Differentiable.comp_ofReal {e : â„‚ â†’ â„‚} (h : Differentiable â„‚ e) : Differentiable â„ fun x => e â†‘x"}
{"name":"Complex.deriv_ofReal","declaration":"theorem Complex.deriv_ofReal (x : â„) : deriv Complex.ofReal' x = 1"}
{"name":"Complex.ofReal_rpow","declaration":"theorem Complex.ofReal_rpow {x : â„} (h : x > 0) (y : â„) : â†‘(x ^ y) = â†‘x ^ â†‘y"}
{"name":"MellinOfDeltaSpikeAt1_asymp","declaration":"theorem MellinOfDeltaSpikeAt1_asymp {Î¨ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Î¨) (suppÎ¨ : Function.support Î¨ âŠ† Set.Icc (1 / 2) 2) (mass_one : âˆ« (x : â„) in Set.Ioi 0, Î¨ x / x = 1) : (fun Îµ => MellinTransform (fun x => â†‘(Î¨ x)) â†‘Îµ - 1) =O[nhdsWithin 0 (Set.Ioi 0)] id"}
{"name":"Smooth1Properties_estimate","declaration":"theorem Smooth1Properties_estimate {Îµ : â„} (Îµpos : 0 < Îµ) : (1 - 2 ^ (-Îµ)) / Îµ < Real.log 2"}
{"name":"deriv.ofReal_comp'","declaration":"theorem deriv.ofReal_comp' {f : â„ â†’ â„} : (deriv fun x => â†‘(f x)) = fun x => â†‘(deriv f x)"}
{"name":"MeasureTheory.integral_comp_inv_I0i_haar","declaration":"theorem MeasureTheory.integral_comp_inv_I0i_haar {ğ•‚ : Type u_1} [RCLike ğ•‚] (f : â„ â†’ ğ•‚) : âˆ« (y : â„) in Set.Ioi 0, f (1 / y) / â†‘y = âˆ« (y : â„) in Set.Ioi 0, f y / â†‘y"}
{"name":"DeltaSpikeNonNeg_of_NonNeg","declaration":"theorem DeltaSpikeNonNeg_of_NonNeg {Î¨ : â„ â†’ â„} (Î¨nonneg : âˆ€ x > 0, 0 â‰¤ Î¨ x) {x : â„} {Îµ : â„} (xpos : 0 < x) (Îµpos : 0 < Îµ) : 0 â‰¤ DeltaSpike Î¨ Îµ x"}
{"name":"PerronInverseMellin_gt","declaration":"theorem PerronInverseMellin_gt {t : â„} {x : â„} (xpos : 0 < x) (x_lt_t : x < t) {Ïƒ : â„} (Ïƒpos : 0 < Ïƒ) : MellinInverseTransform (Perron.f t) Ïƒ x = 1 - â†‘x / â†‘t"}
{"name":"mem_within_strip","declaration":"theorem mem_within_strip (Ïƒâ‚ : â„) (Ïƒâ‚‚ : â„) : {s | Ïƒâ‚ â‰¤ s.re âˆ§ s.re â‰¤ Ïƒâ‚‚} âˆˆ Filter.principal {s | Ïƒâ‚ â‰¤ s.re âˆ§ s.re â‰¤ Ïƒâ‚‚}"}
{"name":"Function.support_abs","declaration":"theorem Function.support_abs {ğ•‚ : Type u_1} [RCLike ğ•‚] {Î± : Type u_2} (f : Î± â†’ ğ•‚) : (Function.support fun x => â€–f xâ€–) = Function.support f"}
{"name":"deriv.comp_ofReal'","declaration":"theorem deriv.comp_ofReal' {e : â„‚ â†’ â„‚} (hf : Differentiable â„‚ e) : (deriv fun x => e â†‘x) = fun x => deriv e â†‘x"}
{"name":"MellinTransform_eq","declaration":"theorem MellinTransform_eq  : MellinTransform = mellin"}
{"name":"DeltaSpikeOfRealContinuous","declaration":"theorem DeltaSpikeOfRealContinuous {Î¨ : â„ â†’ â„} {Îµ : â„} (Îµpos : 0 < Îµ) (diffÎ¨ : ContDiff â„ 1 Î¨) : Continuous fun x => â†‘(DeltaSpike Î¨ Îµ x)"}
