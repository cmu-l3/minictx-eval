{"name":"Filter.TendstoAtZero_of_support_in_Icc","declaration":"theorem Filter.TendstoAtZero_of_support_in_Icc {𝕂 : Type u_1} [RCLike 𝕂] {a : ℝ} {b : ℝ} (f : ℝ → 𝕂) (ha : 0 < a) (fSupp : Function.support f ⊆ Set.Icc a b) : Filter.Tendsto f (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)"}
{"name":"MellinOfPsi_aux","declaration":"theorem MellinOfPsi_aux {Ψ : ℝ → ℝ} (diffΨ : ContDiff ℝ 1 Ψ) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) {s : ℂ} (hs : s ≠ 0) : ∫ (x : ℝ) in Set.Ioi 0, ↑(Ψ x) * ↑x ^ (s - 1) = -(1 / s) * ∫ (x : ℝ) in Set.Ioi 0, ↑(deriv Ψ x) * ↑x ^ s"}
{"name":"MellinInversion_aux1","declaration":"theorem MellinInversion_aux1 {f : ℝ → ℂ} {s : ℂ} (s_ne_zero : s ≠ 0) (fDiff : DifferentiableOn ℝ f (Set.Ioi 0)) (hfs : Filter.Tendsto (fun x => f x * ↑x ^ s) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)) (hfinf : Filter.Tendsto (fun x => f x * ↑x ^ s) Filter.atTop (nhds 0)) : ∫ (x : ℝ) in Set.Ioi 0, f x * ↑x ^ s / ↑x = -∫ (x : ℝ) in Set.Ioi 0, deriv f x * ↑x ^ s / s"}
{"name":"MellinConvolutionTransform","declaration":"theorem MellinConvolutionTransform (f : ℝ → ℂ) (g : ℝ → ℂ) (s : ℂ) (hf : MeasureTheory.IntegrableOn (Function.uncurry fun x y => f y * g (x / y) / ↑y * ↑x ^ (s - 1)) (Set.Ioi 0 ×ˢ Set.Ioi 0)\n  MeasureTheory.volume) : MellinTransform (MellinConvolution f g) s = MellinTransform f s * MellinTransform g s"}
{"name":"Function.support_mul_subset_of_subset","declaration":"theorem Function.support_mul_subset_of_subset {𝕂 : Type u_1} [RCLike 𝕂] {s : Set ℝ} {f : ℝ → 𝕂} {g : ℝ → 𝕂} (fSupp : Function.support f ⊆ s) : Function.support (f * g) ⊆ s"}
{"name":"Complex.hasDerivAt_ofReal","declaration":"theorem Complex.hasDerivAt_ofReal (x : ℝ) : HasDerivAt Complex.ofReal' 1 x"}
{"name":"SetIntegral.integral_eq_integral_inter_of_support_subset_Icc","declaration":"theorem SetIntegral.integral_eq_integral_inter_of_support_subset_Icc {a : ℝ} {b : ℝ} {μ : MeasureTheory.Measure ℝ} {E : Type u_2} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set ℝ} {f : ℝ → E} (h : Function.support f ⊆ Set.Icc a b) (hs : Set.Icc a b ⊆ s) : ∫ (x : ℝ) in s, f x ∂μ = ∫ (x : ℝ) in Set.Icc a b, f x ∂μ"}
{"name":"MellinInverseTransform_eq","declaration":"theorem MellinInverseTransform_eq (σ : ℝ) (f : ℂ → ℂ) : MellinInverseTransform f σ = mellinInv σ f"}
{"name":"intervalIntegral.norm_integral_le_of_norm_le_const'","declaration":"theorem intervalIntegral.norm_integral_le_of_norm_le_const' {a : ℝ} {b : ℝ} {C : ℝ} {E : Type u_2} [NormedAddCommGroup E] [NormedSpace ℝ E] {f : ℝ → E} (hab : a ≤ b) (h : ∀ x ∈ Set.Icc a b, ‖f x‖ ≤ C) : ‖∫ (x : ℝ) in a..b, f x‖ ≤ C * |b - a|"}
{"name":"MellinOf1","declaration":"theorem MellinOf1 (s : ℂ) (h : s.re > 0) : MellinTransform (fun x => if 0 < x ∧ x ≤ 1 then 1 else 0) s = 1 / s"}
{"name":"MellinOfDeltaSpikeAt1","declaration":"theorem MellinOfDeltaSpikeAt1 (Ψ : ℝ → ℝ) {ε : ℝ} (εpos : ε > 0) : MellinTransform (fun x => ↑(DeltaSpike Ψ ε x)) 1 = MellinTransform (fun x => ↑(Ψ x)) ↑ε"}
{"name":"MellinInversion_aux3","declaration":"theorem MellinInversion_aux3 {f : ℝ → ℂ} (σ : ℝ) (σ_ne_zero : σ ≠ 0) (σ_ne_negOne : σ ≠ -1) (fInt : MeasureTheory.IntegrableOn (fun x => f x * ↑x ^ ↑σ) (Set.Ioi 0) MeasureTheory.volume) : MeasureTheory.IntegrableOn\n  (fun x =>\n    match x with\n    | (x, t) => f x * ↑x ^ (↑σ + ↑t * Complex.I) / ((↑σ + ↑t * Complex.I) * (↑σ + ↑t * Complex.I + 1)))\n  (Set.prod (Set.Ioi 0) Set.univ) MeasureTheory.volume"}
{"name":"Function.support_ofReal","declaration":"theorem Function.support_ofReal {f : ℝ → ℝ} : (Function.support fun x => ↑(f x)) = Function.support f"}
{"name":"DeltaSpike","declaration":"def DeltaSpike (Ψ : ℝ → ℝ) (ε : ℝ) : ℝ → ℝ"}
{"name":"Smooth1Properties_above","declaration":"theorem Smooth1Properties_above {Ψ : ℝ → ℝ} (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) {ε : ℝ} (hε : ε ∈ Set.Ioo 0 1) : ∃ c, 0 < c ∧ ∀ (x : ℝ), 1 + c * ε ≤ x → Smooth1 Ψ ε x = 0"}
{"name":"Smooth1Properties_above_aux2","declaration":"theorem Smooth1Properties_above_aux2 {x : ℝ} {y : ℝ} {ε : ℝ} (hε : ε ∈ Set.Ioo 0 1) (hy : y ∈ Set.Ioc 0 1) (hx2 : 2 ^ ε < x) : 2 < (x / y) ^ (1 / ε)"}
{"name":"Smooth1LeOne","declaration":"theorem Smooth1LeOne {Ψ : ℝ → ℝ} (Ψnonneg : ∀ x > 0, 0 ≤ Ψ x) (mass_one : ∫ (x : ℝ) in Set.Ioi 0, Ψ x / x = 1) {ε : ℝ} (εpos : 0 < ε) (x : ℝ) : 0 < x → Smooth1 Ψ ε x ≤ 1"}
{"name":"Smooth1Properties_below","declaration":"theorem Smooth1Properties_below {Ψ : ℝ → ℝ} (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) (ε : ℝ) (εpos : 0 < ε) (mass_one : ∫ (x : ℝ) in Set.Ioi 0, Ψ x / x = 1) : ∃ c, 0 < c ∧ ∀ (x : ℝ), 0 < x → x ≤ 1 - c * ε → Smooth1 Ψ ε x = 1"}
{"name":"DifferentiableAt.ofReal_comp_iff","declaration":"theorem DifferentiableAt.ofReal_comp_iff {z : ℝ} {f : ℝ → ℝ} : DifferentiableAt ℝ (fun y => ↑(f y)) z ↔ DifferentiableAt ℝ f z"}
{"name":"DifferentiableAt.comp_ofReal","declaration":"theorem DifferentiableAt.comp_ofReal {e : ℂ → ℂ} {z : ℝ} (hf : DifferentiableAt ℂ e ↑z) : DifferentiableAt ℝ (fun x => e ↑x) z"}
{"name":"DeltaSpikeContinuous","declaration":"theorem DeltaSpikeContinuous {Ψ : ℝ → ℝ} {ε : ℝ} (εpos : 0 < ε) (diffΨ : ContDiff ℝ 1 Ψ) : Continuous fun x => DeltaSpike Ψ ε x"}
{"name":"PartialIntegration_of_support_in_Icc","declaration":"theorem PartialIntegration_of_support_in_Icc {a : ℝ} {b : ℝ} (f : ℝ → ℂ) (g : ℝ → ℂ) (ha : 0 < a) (h : a ≤ b) (fSupp : Function.support f ⊆ Set.Icc a b) (fDiff : DifferentiableOn ℝ f (Set.Ioi 0)) (gDiff : DifferentiableOn ℝ g (Set.Ioi 0)) (fderivCont : ContinuousOn (deriv f) (Set.Ioi 0)) (gderivCont : ContinuousOn (deriv g) (Set.Ioi 0)) : ∫ (x : ℝ) in Set.Ioi 0, f x * deriv g x = -∫ (x : ℝ) in Set.Ioi 0, deriv f x * g x"}
{"name":"Smooth1Properties_below_aux","declaration":"theorem Smooth1Properties_below_aux {x : ℝ} {ε : ℝ} (hx : x ≤ 1 - Real.log 2 * ε) (εpos : 0 < ε) : x < 2 ^ (-ε)"}
{"name":"Differentiable.ofReal_comp_iff","declaration":"theorem Differentiable.ofReal_comp_iff {f : ℝ → ℝ} : (Differentiable ℝ fun y => ↑(f y)) ↔ Differentiable ℝ f"}
{"name":"MeasureTheory.integral_comp_mul_right_I0i_haar_real","declaration":"theorem MeasureTheory.integral_comp_mul_right_I0i_haar_real (f : ℝ → ℝ) {a : ℝ} (ha : 0 < a) : ∫ (y : ℝ) in Set.Ioi 0, f (y * a) / y = ∫ (y : ℝ) in Set.Ioi 0, f y / y"}
{"name":"MeasureTheory.set_integral_integral_swap","declaration":"theorem MeasureTheory.set_integral_integral_swap {α : Type u_1} {β : Type u_2} {E : Type u_3} [MeasurableSpace α] [MeasurableSpace β] {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} [NormedAddCommGroup E] [MeasureTheory.SigmaFinite ν] [NormedSpace ℝ E] [MeasureTheory.SigmaFinite μ] (f : α → β → E) {s : Set α} {t : Set β} (hf : MeasureTheory.IntegrableOn (Function.uncurry f) (s ×ˢ t) (MeasureTheory.Measure.prod μ ν)) : ∫ (x : α) in s, ∫ (y : β) in t, f x y ∂ν ∂μ = ∫ (y : β) in t, ∫ (x : α) in s, f x y ∂μ ∂ν"}
{"name":"MeasureTheory.integral_comp_rpow_I0i_haar_real","declaration":"theorem MeasureTheory.integral_comp_rpow_I0i_haar_real (f : ℝ → ℝ) {p : ℝ} (hp : p ≠ 0) : ∫ (y : ℝ) in Set.Ioi 0, |p| * f (y ^ p) / y = ∫ (y : ℝ) in Set.Ioi 0, f y / y"}
{"name":"mellintransform","declaration":"def mellintransform  : Lean.ParserDescr"}
{"name":"MellinInverseTransform","declaration":"def MellinInverseTransform (F : ℂ → ℂ) (σ : ℝ) (x : ℝ) : ℂ"}
{"name":"DeltaSpikeSupport_aux","declaration":"theorem DeltaSpikeSupport_aux {Ψ : ℝ → ℝ} {ε : ℝ} (εpos : 0 < ε) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) : (Function.support fun x => if x < 0 then 0 else DeltaSpike Ψ ε x) ⊆ Set.Icc (2 ^ (-ε)) (2 ^ ε)"}
{"name":"MellinOfDeltaSpike","declaration":"theorem MellinOfDeltaSpike (Ψ : ℝ → ℝ) {ε : ℝ} (εpos : ε > 0) (s : ℂ) : MellinTransform (fun x => ↑(DeltaSpike Ψ ε x)) s = MellinTransform (fun x => ↑(Ψ x)) (↑ε * s)"}
{"name":"DifferentiableAt.ofReal_comp","declaration":"theorem DifferentiableAt.ofReal_comp {z : ℝ} {f : ℝ → ℝ} (hf : DifferentiableAt ℝ f z) : DifferentiableAt ℝ (fun y => ↑(f y)) z"}
{"name":"MeasureTheory.integral_comp_div_I0i_haar","declaration":"theorem MeasureTheory.integral_comp_div_I0i_haar {𝕂 : Type u_1} [RCLike 𝕂] (f : ℝ → 𝕂) {a : ℝ} (ha : 0 < a) : ∫ (y : ℝ) in Set.Ioi 0, f (a / y) / ↑y = ∫ (y : ℝ) in Set.Ioi 0, f y / ↑y"}
{"name":"Filter.BigO_zero_atZero_of_support_in_Icc","declaration":"theorem Filter.BigO_zero_atZero_of_support_in_Icc {𝕂 : Type u_1} [RCLike 𝕂] {a : ℝ} {b : ℝ} (f : ℝ → 𝕂) (ha : 0 < a) (fSupp : Function.support f ⊆ Set.Icc a b) : f =O[nhdsWithin 0 (Set.Ioi 0)] fun x => 0"}
{"name":"MellinOfSmooth1a","declaration":"theorem MellinOfSmooth1a (Ψ : ℝ → ℝ) (diffΨ : ContDiff ℝ 1 Ψ) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) {ε : ℝ} (εpos : 0 < ε) {s : ℂ} (hs : 0 < s.re) : MellinTransform (fun x => ↑(Smooth1 Ψ ε x)) s = 1 / s * MellinTransform (fun x => ↑(Ψ x)) (↑ε * s)"}
{"name":"Function.support_deriv_subset_Icc","declaration":"theorem Function.support_deriv_subset_Icc {𝕂 : Type u_1} [RCLike 𝕂] {a : ℝ} {b : ℝ} {f : ℝ → 𝕂} (fSupp : Function.support f ⊆ Set.Icc a b) : Function.support (deriv f) ⊆ Set.Icc a b"}
{"name":"MeasureTheory.integral_comp_mul_left_I0i_haar","declaration":"theorem MeasureTheory.integral_comp_mul_left_I0i_haar {𝕂 : Type u_1} [RCLike 𝕂] (f : ℝ → 𝕂) {a : ℝ} (ha : 0 < a) : ∫ (y : ℝ) in Set.Ioi 0, f (a * y) / ↑y = ∫ (y : ℝ) in Set.Ioi 0, f y / ↑y"}
{"name":"Smooth1LeOne_aux","declaration":"theorem Smooth1LeOne_aux {x : ℝ} {ε : ℝ} {Ψ : ℝ → ℝ} (xpos : 0 < x) (εpos : 0 < ε) (mass_one : ∫ (x : ℝ) in Set.Ioi 0, Ψ x / x = 1) : ∫ (y : ℝ) in Set.Ioi 0, Ψ ((x / y) ^ (1 / ε)) / ε / y = 1"}
{"name":"IntervalIntegral.integral_eq_integral_of_support_subset_Icc","declaration":"theorem IntervalIntegral.integral_eq_integral_of_support_subset_Icc {a : ℝ} {b : ℝ} {μ : MeasureTheory.Measure ℝ} [MeasureTheory.NoAtoms μ] {E : Type u_2} [NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E] {f : ℝ → E} (h : Function.support f ⊆ Set.Icc a b) : ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ), f x ∂μ"}
{"name":"DeltaSpikeMass","declaration":"theorem DeltaSpikeMass {Ψ : ℝ → ℝ} (mass_one : ∫ (x : ℝ) in Set.Ioi 0, Ψ x / x = 1) {ε : ℝ} (εpos : 0 < ε) : ∫ (x : ℝ) in Set.Ioi 0, DeltaSpike Ψ ε x / x = 1"}
{"name":"MellinTransform","declaration":"def MellinTransform (f : ℝ → ℂ) (s : ℂ) : ℂ"}
{"name":"deriv.comp_ofReal","declaration":"theorem deriv.comp_ofReal {e : ℂ → ℂ} {z : ℝ} (hf : DifferentiableAt ℂ e ↑z) : deriv (fun x => e ↑x) z = deriv e ↑z"}
{"name":"MellinInversion_aux2","declaration":"theorem MellinInversion_aux2 {f : ℝ → ℂ} (s : ℂ) (fDiff : DifferentiableOn ℝ f (Set.Ioi 0)) (fDiff2 : DifferentiableOn ℝ (deriv f) (Set.Ioi 0)) (hfs : Filter.Tendsto (fun x => deriv f x * ↑x ^ s) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)) (hfinf : Filter.Tendsto (fun x => deriv f x * ↑x ^ s) Filter.atTop (nhds 0)) : ∫ (x : ℝ) in Set.Ioi 0, deriv f x * ↑x ^ s = -∫ (x : ℝ) in Set.Ioi 0, deriv (deriv f) x * ↑x ^ (s + 1) / (s + 1)"}
{"name":"PerronInverseMellin_lt","declaration":"theorem PerronInverseMellin_lt {t : ℝ} {x : ℝ} (tpos : 0 < t) (t_lt_x : t < x) {σ : ℝ} (σpos : 0 < σ) : MellinInverseTransform (Perron.f t) σ x = 0"}
{"name":"Complex.differentiable_ofReal","declaration":"theorem Complex.differentiable_ofReal  : Differentiable ℝ Complex.ofReal'"}
{"name":"Differentiable.ofReal_comp","declaration":"theorem Differentiable.ofReal_comp {f : ℝ → ℝ} (hf : Differentiable ℝ f) : Differentiable ℝ fun y => ↑(f y)"}
{"name":"MellinOfSmooth1b","declaration":"theorem MellinOfSmooth1b {Ψ : ℝ → ℝ} (diffΨ : ContDiff ℝ 1 Ψ) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) {σ₁ : ℝ} {σ₂ : ℝ} (σ₁pos : 0 < σ₁) (ε : ℝ) (εpos : 0 < ε) : (fun s => ‖MellinTransform (fun x => ↑(Smooth1 Ψ ε x)) s‖) =O[Filter.principal {s | σ₁ ≤ s.re ∧ s.re ≤ σ₂}] fun s =>\n  1 / (ε * ‖s‖ ^ 2)"}
{"name":"MellinInversion_aux4","declaration":"theorem MellinInversion_aux4 {f : ℝ → ℂ} (σ : ℝ) (σ_ne_zero : σ ≠ 0) (σ_ne_negOne : σ ≠ -1) (fInt : MeasureTheory.IntegrableOn (fun x => f x * ↑x ^ ↑σ) (Set.Ioi 0) MeasureTheory.volume) : VerticalIntegral (fun s => ∫ (x : ℝ) in Set.Ioi 0, f x * ↑x ^ (s + 1) / (s * (s + 1))) σ =\n  ∫ (x : ℝ) in Set.Ioi 0, VerticalIntegral (fun s => f x * ↑x ^ (s + 1) / (s * (s + 1))) σ"}
{"name":"MellinOfSmooth1c","declaration":"theorem MellinOfSmooth1c {Ψ : ℝ → ℝ} (diffΨ : ContDiff ℝ 1 Ψ) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) (mass_one : ∫ (x : ℝ) in Set.Ioi 0, Ψ x / x = 1) : (fun ε => MellinTransform (fun x => ↑(Smooth1 Ψ ε x)) 1 - 1) =O[nhdsWithin 0 (Set.Ioi 0)] id"}
{"name":"Function.support_id","declaration":"theorem Function.support_id  : (Function.support fun x => x) = Set.Iio 0 ∪ Set.Ioi 0"}
{"name":"Smooth1","declaration":"def Smooth1 (Ψ : ℝ → ℝ) (ε : ℝ) : ℝ → ℝ"}
{"name":"PartialIntegration","declaration":"/-- *Need differentiability, and decay at `0` and `∞`* -/\ntheorem PartialIntegration (f : ℝ → ℂ) (g : ℝ → ℂ) (fDiff : DifferentiableOn ℝ f (Set.Ioi 0)) (gDiff : DifferentiableOn ℝ g (Set.Ioi 0)) (fDerivgInt : MeasureTheory.IntegrableOn (f * deriv g) (Set.Ioi 0) MeasureTheory.volume) (gDerivfInt : MeasureTheory.IntegrableOn (deriv f * g) (Set.Ioi 0) MeasureTheory.volume) (lim_at_zero : Filter.Tendsto (f * g) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0)) (lim_at_inf : Filter.Tendsto (f * g) Filter.atTop (nhds 0)) : ∫ (x : ℝ) in Set.Ioi 0, f x * deriv g x = -∫ (x : ℝ) in Set.Ioi 0, deriv f x * g x"}
{"name":"MellinConvNonNeg_of_NonNeg","declaration":"theorem MellinConvNonNeg_of_NonNeg {f : ℝ → ℝ} {g : ℝ → ℝ} (f_nonneg : ∀ x > 0, 0 ≤ f x) (g_nonneg : ∀ x > 0, 0 ≤ g x) {x : ℝ} (xpos : 0 < x) : 0 ≤ MellinConvolution f g x"}
{"name":"DeltaSpikeSupport'","declaration":"theorem DeltaSpikeSupport' {Ψ : ℝ → ℝ} {ε : ℝ} {x : ℝ} (εpos : 0 < ε) (xnonneg : 0 ≤ x) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) : DeltaSpike Ψ ε x ≠ 0 → x ∈ Set.Icc (2 ^ (-ε)) (2 ^ ε)"}
{"name":"MellinConvolutionSymmetric","declaration":"theorem MellinConvolutionSymmetric {𝕂 : Type u_1} [RCLike 𝕂] (f : ℝ → 𝕂) (g : ℝ → 𝕂) {x : ℝ} (xpos : 0 < x) : MellinConvolution f g x = MellinConvolution g f x"}
{"name":"deriv.ofReal_comp","declaration":"theorem deriv.ofReal_comp {z : ℝ} {f : ℝ → ℝ} : deriv (fun y => ↑(f y)) z = ↑(deriv f z)"}
{"name":"SetIntegral.integral_eq_integral_inter_of_support_subset","declaration":"theorem SetIntegral.integral_eq_integral_inter_of_support_subset {μ : MeasureTheory.Measure ℝ} {E : Type u_2} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set ℝ} {t : Set ℝ} {f : ℝ → E} (h : Function.support f ⊆ t) (ht : MeasurableSet t) : ∫ (x : ℝ) in s, f x ∂μ = ∫ (x : ℝ) in s ∩ t, f x ∂μ"}
{"name":"Filter.TendstoAtTop_of_support_in_Icc","declaration":"theorem Filter.TendstoAtTop_of_support_in_Icc {𝕂 : Type u_1} [RCLike 𝕂] {a : ℝ} {b : ℝ} (f : ℝ → 𝕂) (fSupp : Function.support f ⊆ Set.Icc a b) : Filter.Tendsto f Filter.atTop (nhds 0)"}
{"name":"HasDerivAt.of_hasDerivAt_ofReal_comp","declaration":"theorem HasDerivAt.of_hasDerivAt_ofReal_comp {z : ℝ} {f : ℝ → ℝ} {u : ℂ} (hf : HasDerivAt (fun y => ↑(f y)) u z) : ∃ u', u = ↑u' ∧ HasDerivAt f u' z"}
{"name":"Filter.BigO_zero_atTop_of_support_in_Icc","declaration":"theorem Filter.BigO_zero_atTop_of_support_in_Icc {𝕂 : Type u_1} [RCLike 𝕂] {a : ℝ} {b : ℝ} (f : ℝ → 𝕂) (fSupp : Function.support f ⊆ Set.Icc a b) : f =O[Filter.atTop] fun x => 0"}
{"name":"Complex.differentiableAt_ofReal","declaration":"theorem Complex.differentiableAt_ofReal (x : ℝ) : DifferentiableAt ℝ Complex.ofReal' x"}
{"name":"MellinConvolution","declaration":"def MellinConvolution {𝕂 : Type u_1} [RCLike 𝕂] (f : ℝ → 𝕂) (g : ℝ → 𝕂) (x : ℝ) : 𝕂"}
{"name":"MellinInversion","declaration":"theorem MellinInversion (σ : ℝ) {f : ℝ → ℂ} {x : ℝ} (hx : 0 < x) (hf : MellinConvergent f ↑σ) (hFf : Complex.VerticalIntegrable (mellin f) σ MeasureTheory.volume) (hfx : ContinuousAt f x) : MellinInverseTransform (MellinTransform f) σ x = f x"}
{"name":"MellinOfPsi","declaration":"theorem MellinOfPsi {Ψ : ℝ → ℝ} (diffΨ : ContDiff ℝ 1 Ψ) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) {σ₁ : ℝ} {σ₂ : ℝ} (σ₁pos : 0 < σ₁) : (fun s => ‖MellinTransform (fun x => ↑(Ψ x)) s‖) =O[Filter.principal {s | σ₁ ≤ s.re ∧ s.re ≤ σ₂}] fun s => 1 / ‖s‖"}
{"name":"Function.support_of_along_fiber_subset_subset","declaration":"theorem Function.support_of_along_fiber_subset_subset {α : Type u_2} {β : Type u_3} {M : Type u_4} [Zero M] {f : α × β → M} {s : Set α} {t : Set β} (hx : ∀ (y : β), (Function.support fun x => f (x, y)) ⊆ s) (hy : ∀ (x : α), (Function.support fun y => f (x, y)) ⊆ t) : Function.support f ⊆ s ×ˢ t"}
{"name":"SmoothExistence","declaration":"theorem SmoothExistence  : ∃ Ψ,\n  ContDiff ℝ ⊤ Ψ ∧ (∀ (x : ℝ), 0 ≤ Ψ x) ∧ Function.support Ψ ⊆ Set.Icc (1 / 2) 2 ∧ ∫ (x : ℝ) in Set.Ici 0, Ψ x / x = 1"}
{"name":"Smooth1Nonneg","declaration":"theorem Smooth1Nonneg {Ψ : ℝ → ℝ} (Ψnonneg : ∀ x > 0, 0 ≤ Ψ x) {ε : ℝ} {x : ℝ} (xpos : 0 < x) (εpos : 0 < ε) : 0 ≤ Smooth1 Ψ ε x"}
{"name":"Smooth1Properties_above_aux","declaration":"theorem Smooth1Properties_above_aux {x : ℝ} {ε : ℝ} (hx : 1 + 2 * Real.log 2 * ε ≤ x) (hε : ε ∈ Set.Ioo 0 1) : 2 ^ ε < x"}
{"name":"DeltaSpikeSupport","declaration":"theorem DeltaSpikeSupport {Ψ : ℝ → ℝ} {ε : ℝ} {x : ℝ} (εpos : 0 < ε) (xnonneg : 0 ≤ x) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) : x ∉ Set.Icc (2 ^ (-ε)) (2 ^ ε) → DeltaSpike Ψ ε x = 0"}
{"name":"MeasureTheory.integral_comp_mul_right_I0i_haar","declaration":"theorem MeasureTheory.integral_comp_mul_right_I0i_haar {𝕂 : Type u_1} [RCLike 𝕂] (f : ℝ → 𝕂) {a : ℝ} (ha : 0 < a) : ∫ (y : ℝ) in Set.Ioi 0, f (y * a) / ↑y = ∫ (y : ℝ) in Set.Ioi 0, f y / ↑y"}
{"name":"Differentiable.comp_ofReal","declaration":"theorem Differentiable.comp_ofReal {e : ℂ → ℂ} (h : Differentiable ℂ e) : Differentiable ℝ fun x => e ↑x"}
{"name":"Complex.deriv_ofReal","declaration":"theorem Complex.deriv_ofReal (x : ℝ) : deriv Complex.ofReal' x = 1"}
{"name":"Complex.ofReal_rpow","declaration":"theorem Complex.ofReal_rpow {x : ℝ} (h : x > 0) (y : ℝ) : ↑(x ^ y) = ↑x ^ ↑y"}
{"name":"MellinOfDeltaSpikeAt1_asymp","declaration":"theorem MellinOfDeltaSpikeAt1_asymp {Ψ : ℝ → ℝ} (diffΨ : ContDiff ℝ 1 Ψ) (suppΨ : Function.support Ψ ⊆ Set.Icc (1 / 2) 2) (mass_one : ∫ (x : ℝ) in Set.Ioi 0, Ψ x / x = 1) : (fun ε => MellinTransform (fun x => ↑(Ψ x)) ↑ε - 1) =O[nhdsWithin 0 (Set.Ioi 0)] id"}
{"name":"Smooth1Properties_estimate","declaration":"theorem Smooth1Properties_estimate {ε : ℝ} (εpos : 0 < ε) : (1 - 2 ^ (-ε)) / ε < Real.log 2"}
{"name":"deriv.ofReal_comp'","declaration":"theorem deriv.ofReal_comp' {f : ℝ → ℝ} : (deriv fun x => ↑(f x)) = fun x => ↑(deriv f x)"}
{"name":"MeasureTheory.integral_comp_inv_I0i_haar","declaration":"theorem MeasureTheory.integral_comp_inv_I0i_haar {𝕂 : Type u_1} [RCLike 𝕂] (f : ℝ → 𝕂) : ∫ (y : ℝ) in Set.Ioi 0, f (1 / y) / ↑y = ∫ (y : ℝ) in Set.Ioi 0, f y / ↑y"}
{"name":"DeltaSpikeNonNeg_of_NonNeg","declaration":"theorem DeltaSpikeNonNeg_of_NonNeg {Ψ : ℝ → ℝ} (Ψnonneg : ∀ x > 0, 0 ≤ Ψ x) {x : ℝ} {ε : ℝ} (xpos : 0 < x) (εpos : 0 < ε) : 0 ≤ DeltaSpike Ψ ε x"}
{"name":"PerronInverseMellin_gt","declaration":"theorem PerronInverseMellin_gt {t : ℝ} {x : ℝ} (xpos : 0 < x) (x_lt_t : x < t) {σ : ℝ} (σpos : 0 < σ) : MellinInverseTransform (Perron.f t) σ x = 1 - ↑x / ↑t"}
{"name":"mem_within_strip","declaration":"theorem mem_within_strip (σ₁ : ℝ) (σ₂ : ℝ) : {s | σ₁ ≤ s.re ∧ s.re ≤ σ₂} ∈ Filter.principal {s | σ₁ ≤ s.re ∧ s.re ≤ σ₂}"}
{"name":"Function.support_abs","declaration":"theorem Function.support_abs {𝕂 : Type u_1} [RCLike 𝕂] {α : Type u_2} (f : α → 𝕂) : (Function.support fun x => ‖f x‖) = Function.support f"}
{"name":"deriv.comp_ofReal'","declaration":"theorem deriv.comp_ofReal' {e : ℂ → ℂ} (hf : Differentiable ℂ e) : (deriv fun x => e ↑x) = fun x => deriv e ↑x"}
{"name":"MellinTransform_eq","declaration":"theorem MellinTransform_eq  : MellinTransform = mellin"}
{"name":"DeltaSpikeOfRealContinuous","declaration":"theorem DeltaSpikeOfRealContinuous {Ψ : ℝ → ℝ} {ε : ℝ} (εpos : 0 < ε) (diffΨ : ContDiff ℝ 1 Ψ) : Continuous fun x => ↑(DeltaSpike Ψ ε x)"}
