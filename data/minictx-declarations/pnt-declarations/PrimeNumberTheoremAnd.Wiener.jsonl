{"name":"WienerIkeharaInterval_discrete'","declaration":"theorem WienerIkeharaInterval_discrete' {A : ℝ} {a : ℝ} {b : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (hcheby : cheby fun n => ↑(f n)) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) (ha : 0 < a) (hb : a ≤ b) : Filter.Tendsto (fun N => (Finset.sum (Finset.Ico ⌈a * ↑N⌉₊ ⌈b * ↑N⌉₊) fun n => f n) / ↑N) Filter.atTop\n  (nhds (A * (b - a)))"}
{"name":"hh_antitone","declaration":"theorem hh_antitone {a : ℝ} (ha : a ∈ Set.Ioo (-1) 1) : AntitoneOn (hh a) (Set.Ioi 0)"}
{"name":"wiener_ikehara_smooth'","declaration":"theorem wiener_ikehara_smooth' {A : ℝ} {Ψ : ℝ → ℂ} {G : ℂ → ℂ} {f : ℕ → ℂ} (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - ↑A / (s - 1)) {s | 1 < s.re}) (hsmooth : ContDiff ℝ ⊤ Ψ) (hsupp : HasCompactSupport Ψ) (hplus : closure (Function.support Ψ) ⊆ Set.Ioi 0) : Filter.Tendsto (fun x => (∑' (n : ℕ), f n * Ψ (↑n / x)) / ↑x) Filter.atTop (nhds (↑A * ∫ (y : ℝ) in Set.Ioi 0, Ψ y))"}
{"name":"log_isbigo_log_div","declaration":"theorem log_isbigo_log_div {d : ℝ} (hb : 0 < d) : (fun n => Real.log n) =O[Filter.atTop] fun n => Real.log (n / d)"}
{"name":"wiener_ikehara_smooth_real","declaration":"theorem wiener_ikehara_smooth_real {A : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} {Ψ : ℝ → ℝ} (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (hcheby : cheby fun n => ↑(f n)) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) (hsmooth : ContDiff ℝ ⊤ Ψ) (hsupp : HasCompactSupport Ψ) (hplus : closure (Function.support Ψ) ⊆ Set.Ioi 0) : Filter.Tendsto (fun x => (∑' (n : ℕ), f n * Ψ (↑n / x)) / x) Filter.atTop (nhds (A * ∫ (y : ℝ) in Set.Ioi 0, Ψ y))"}
{"name":"pp'","declaration":"def pp' (a : ℝ) (x : ℝ) : ℝ"}
{"name":"one_div_sub_one","declaration":"theorem one_div_sub_one (n : ℕ) : 1 / ↑(n - 1) ≤ 2 / ↑n"}
{"name":"summation_by_parts'","declaration":"theorem summation_by_parts' {E : Type u_1} [Ring E] {a : ℕ → E} {b : ℕ → E} {n : ℕ} : cumsum (a * b) (n + 1) = cumsum a (n + 1) * b n - cumsum (shift (cumsum a) * nabla b) n"}
{"name":"cheby","declaration":"def cheby (f : ℕ → ℂ) : Prop"}
{"name":"continuous_LSeries_aux","declaration":"theorem continuous_LSeries_aux {σ' : ℝ} {f : ℕ → ℂ} (hf : Summable (nterm f σ')) : Continuous fun x => LSeries f (↑σ' + ↑x * Complex.I)"}
{"name":"limiting_cor_schwartz","declaration":"theorem limiting_cor_schwartz {A : ℝ} {G : ℂ → ℂ} {f : ℕ → ℂ} (ψ : SchwartzMap ℝ ℂ) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - ↑A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto\n  (fun x =>\n    ∑' (n : ℕ), f n / ↑n * Real.fourierIntegral (⇑ψ) (1 / (2 * Real.pi) * Real.log (↑n / x)) -\n      ↑A * ∫ (u : ℝ) in Set.Ici (-Real.log x), Real.fourierIntegral (⇑ψ) (u / (2 * Real.pi)))\n  Filter.atTop (nhds 0)"}
{"name":"comp_exp_support2","declaration":"theorem comp_exp_support2 {Ψ : ℝ → ℂ} (hsupp : HasCompactSupport Ψ) : ∀ᶠ (x : ℝ) in Filter.atTop, (Ψ ∘ Real.exp) x = 0"}
{"name":"hf_coe1","declaration":"theorem hf_coe1 {σ' : ℝ} {f : ℕ → ℂ} (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (hσ : 1 < σ') : ∑' (i : ℕ), ↑‖LSeries.term f (↑σ') i‖₊ ≠ ⊤"}
{"name":"gg_of_hh","declaration":"theorem gg_of_hh {x : ℝ} (hx : x ≠ 0) (i : ℝ) : gg x i = x⁻¹ * hh (1 / (2 * Real.pi)) (i / x)"}
{"name":"mem_Icc_iff_div","declaration":"theorem mem_Icc_iff_div {n : ℕ} {a : ℝ} {b : ℝ} {x : ℝ} (hb : 0 ≤ b) (hx : 0 < x) : n ∈ Finset.Icc ⌈a * x⌉₊ ⌊b * x⌋₊ ↔ ↑n / x ∈ Set.Icc a b"}
{"name":"decay_bounds","declaration":"theorem decay_bounds {A : ℝ} {u : ℝ} (ψ : CS 2 ℂ) (hA : ∀ (t : ℝ), ‖ψ.toFun t‖ ≤ A / (1 + t ^ 2)) (hA' : ∀ (t : ℝ), ‖deriv^[2] ψ.toFun t‖ ≤ A / (1 + t ^ 2)) : ‖Real.fourierIntegral ψ.toFun u‖ ≤ (Real.pi + 1 / (4 * Real.pi)) * A / (1 + u ^ 2)"}
{"name":"nnabla_bound_aux","declaration":"theorem nnabla_bound_aux {x : ℝ} (hx : 0 < x) : (nnabla fun n => 1 / (n * ((2 * Real.pi) ^ 2 + Real.log (n / x) ^ 2))) =O[Filter.atTop] fun n =>\n  1 / (Real.log n ^ 2 * n ^ 2)"}
{"name":"Asymptotics.IsBigO.sq","declaration":"theorem Asymptotics.IsBigO.sq {α : Type u_1} [Preorder α] {f : α → ℝ} {g : α → ℝ} (h : f =O[Filter.atTop] g) : (fun n => f n ^ 2) =O[Filter.atTop] fun n => g n ^ 2"}
{"name":"second_fourier_integrable_aux2","declaration":"theorem second_fourier_integrable_aux2 {x : ℝ} {t : ℝ} {σ' : ℝ} (hσ : 1 < σ') : MeasureTheory.IntegrableOn (fun u => Complex.exp ((1 - ↑σ' - ↑t * Complex.I) * ↑u)) (Set.Ioi (-Real.log x))\n  MeasureTheory.volume"}
{"name":"cancel_main'","declaration":"theorem cancel_main' {C : ℝ} {f : ℕ → ℝ} {g : ℕ → ℝ} (hf : 0 ≤ f) (hf0 : f 0 = 0) (hg : 0 ≤ g) (hf' : ∀ (n : ℕ), cumsum f n ≤ C * ↑n) (hg' : Antitone g) (n : ℕ) : cumsum (f * g) n ≤ C * cumsum g n"}
{"name":"hh_integral","declaration":"theorem hh_integral {a : ℝ} {b : ℝ} {c : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : ∫ (t : ℝ) in Set.Ioi 0, a * hh b (t / c) = a * c / b * Real.pi"}
{"name":"second_fourier_integrable_aux1a","declaration":"theorem second_fourier_integrable_aux1a {x : ℝ} {σ' : ℝ} (hσ : 1 < σ') : MeasureTheory.IntegrableOn (fun x => Complex.exp (-(↑x * (↑σ' - 1)))) (Set.Ici (-Real.log x)) MeasureTheory.volume"}
{"name":"pp_deriv_eq","declaration":"theorem pp_deriv_eq (a : ℝ) : deriv (pp a) = pp' a"}
{"name":"summable_iff_bounded'","declaration":"theorem summable_iff_bounded' {u : ℕ → ℝ} (hu : ∀ᶠ (n : ℕ) in Filter.atTop, 0 ≤ u n) : Summable u ↔ Filter.BoundedAtFilter Filter.atTop (cumsum u)"}
{"name":"comp_exp_support1","declaration":"theorem comp_exp_support1 {Ψ : ℝ → ℂ} (hplus : closure (Function.support Ψ) ⊆ Set.Ioi 0) : ∀ᶠ (x : ℝ) in Filter.atBot, Ψ (Real.exp x) = 0"}
{"name":"limiting_cor_W21","declaration":"theorem limiting_cor_W21 {A : ℝ} {G : ℂ → ℂ} {f : ℕ → ℂ} (ψ : W21) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - ↑A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto\n  (fun x =>\n    ∑' (n : ℕ), f n / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x)) -\n      ↑A * ∫ (u : ℝ) in Set.Ici (-Real.log x), Real.fourierIntegral ψ.toFun (u / (2 * Real.pi)))\n  Filter.atTop (nhds 0)"}
{"name":"WI_sum_Iab_le'","declaration":"theorem WI_sum_Iab_le' {a : ℝ} {b : ℝ} {f : ℕ → ℝ} (hpos : 0 ≤ f) {C : ℝ} (hcheby : chebyWith C fun n => ↑(f n)) (hb : 0 < b) : ∀ᶠ (x : ℝ) in Filter.atTop, (∑' (n : ℕ), f n * Set.indicator (Set.Ico a b) 1 (↑n / x)) / x ≤ C * 2 * b"}
{"name":"summation_by_parts","declaration":"theorem summation_by_parts {E : Type u_1} [Ring E] {a : ℕ → E} {A : ℕ → E} {b : ℕ → E} (ha : a = nabla A) {n : ℕ} : cumsum (a * b) (n + 1) = A (n + 1) * b n - A 0 * b 0 - cumsum (shift A * fun i => b (i + 1) - b i) n"}
{"name":"auto_cheby","declaration":"theorem auto_cheby {A : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) : cheby fun n => ↑(f n)"}
{"name":"ge_of_eventually_nhdsWithin","declaration":"theorem ge_of_eventually_nhdsWithin {a : ℝ} {b : ℝ} (h : ∀ᶠ (c : ℝ) in nhdsWithin b (Set.Iio b), c ≤ a) : b ≤ a"}
{"name":"nterm_eq_norm_term","declaration":"theorem nterm_eq_norm_term {n : ℕ} {σ' : ℝ} {f : ℕ → ℂ} : nterm f σ' n = ‖LSeries.term f (↑σ') n‖"}
{"name":"decay_bounds_cor_aux","declaration":"theorem decay_bounds_cor_aux (ψ : CS 2 ℂ) : ∃ C, ∀ (u : ℝ), ‖ψ.toFun u‖ ≤ C / (1 + u ^ 2)"}
{"name":"second_fourier","declaration":"theorem second_fourier {ψ : ℝ → ℂ} (hcont : Continuous ψ) (hsupp : MeasureTheory.Integrable ψ MeasureTheory.volume) {x : ℝ} {σ' : ℝ} (hx : 0 < x) (hσ : 1 < σ') : ∫ (u : ℝ) in Set.Ici (-Real.log x), ↑(Real.exp (-u * (σ' - 1))) * Real.fourierIntegral ψ (u / (2 * Real.pi)) =\n  ↑(x ^ (σ' - 1)) * ∫ (t : ℝ), 1 / (↑σ' + ↑t * Complex.I - 1) * ψ t * ↑x ^ (↑t * Complex.I)"}
{"name":"limiting_fourier_lim2","declaration":"theorem limiting_fourier_lim2 {x : ℝ} (A : ℝ) (ψ : W21) (hx : 1 ≤ x) : Filter.Tendsto\n  (fun σ' =>\n    ↑A * ↑(x ^ (1 - σ')) *\n      ∫ (u : ℝ) in Set.Ici (-Real.log x),\n        ↑(Real.exp (-u * (σ' - 1))) * Real.fourierIntegral ψ.toFun (u / (2 * Real.pi)))\n  (nhdsWithin 1 (Set.Ioi 1))\n  (nhds (↑A * ∫ (u : ℝ) in Set.Ici (-Real.log x), Real.fourierIntegral ψ.toFun (u / (2 * Real.pi))))"}
{"name":"pp_pos","declaration":"theorem pp_pos {a : ℝ} (ha : a ∈ Set.Ioo (-1) 1) (x : ℝ) : 0 < pp a x"}
{"name":"first_fourier_aux2","declaration":"theorem first_fourier_aux2 {x : ℝ} {y : ℝ} {σ' : ℝ} {ψ : ℝ → ℂ} {f : ℕ → ℂ} (hx : 0 < x) (n : ℕ) : LSeries.term f (↑σ') n * Real.fourierChar (-(y * (1 / (2 * Real.pi) * Real.log (↑n / x)))) • ψ y =\n  LSeries.term f (↑σ' + ↑y * Complex.I) n • (ψ y * ↑x ^ (↑y * Complex.I))"}
{"name":"limiting_cor","declaration":"theorem limiting_cor {A : ℝ} {G : ℂ → ℂ} {f : ℕ → ℂ} (ψ : CS 2 ℂ) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - ↑A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto\n  (fun x =>\n    ∑' (n : ℕ), f n / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x)) -\n      ↑A * ∫ (u : ℝ) in Set.Ici (-Real.log x), Real.fourierIntegral ψ.toFun (u / (2 * Real.pi)))\n  Filter.atTop (nhds 0)"}
{"name":"bound_I2","declaration":"theorem bound_I2 (x : ℝ) (ψ : W21) : ‖∫ (u : ℝ) in Set.Ici (-Real.log x), Real.fourierIntegral ψ.toFun (u / (2 * Real.pi))‖ ≤\n  W21.norm ψ.toFun * (2 * Real.pi ^ 2)"}
{"name":"summable_fourier","declaration":"theorem summable_fourier {f : ℕ → ℂ} (x : ℝ) (hx : 0 < x) (ψ : W21) (hcheby : cheby f) : Summable fun i => ‖f i / ↑i * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑i / x))‖"}
{"name":"decay_bounds_aux","declaration":"theorem decay_bounds_aux {A : ℝ} {f : ℝ → ℂ} (hf : MeasureTheory.AEStronglyMeasurable f MeasureTheory.volume) (h : ∀ (t : ℝ), ‖f t‖ ≤ A * (1 + t ^ 2)⁻¹) : ∫ (t : ℝ), ‖f t‖ ≤ Real.pi * A"}
{"name":"hh_le","declaration":"theorem hh_le (a : ℝ) (t : ℝ) (ht : 0 ≤ t) : |hh a t| ≤ t⁻¹"}
{"name":"WienerIkeharaTheorem''","declaration":"theorem WienerIkeharaTheorem'' {A : ℝ} {F : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (hG : ContinuousOn F {s | 1 ≤ s.re}) (hG' : Set.EqOn F (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto (fun N => cumsum f N / ↑N) Filter.atTop (nhds A)"}
{"name":"smooth_urysohn_support_Ioo","declaration":"theorem smooth_urysohn_support_Ioo {a : ℝ} {b : ℝ} {c : ℝ} {d : ℝ} (h1 : a < b) (h3 : c < d) : ∃ Ψ,\n  ContDiff ℝ ⊤ Ψ ∧\n    HasCompactSupport Ψ ∧\n      Set.indicator (Set.Icc b c) 1 ≤ Ψ ∧ Ψ ≤ Set.indicator (Set.Ioo a d) 1 ∧ Function.support Ψ = Set.Ioo a d"}
{"name":"summable_inv_mul_log_sq","declaration":"theorem summable_inv_mul_log_sq  : Summable fun n => (↑n * Real.log ↑n ^ 2)⁻¹"}
{"name":"hh_integrable","declaration":"theorem hh_integrable {a : ℝ} {b : ℝ} {c : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : MeasureTheory.IntegrableOn (fun t => a * hh b (t / c)) (Set.Ici 0) MeasureTheory.volume"}
{"name":"dirichlet_test'","declaration":"theorem dirichlet_test' {a : ℕ → ℝ} {b : ℕ → ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b) (hAb : Filter.BoundedAtFilter Filter.atTop (shift (cumsum a) * b)) (hbb : ∀ᶠ (n : ℕ) in Filter.atTop, b (n + 1) ≤ b n) (h : Summable (shift (cumsum a) * nnabla b)) : Summable (a * b)"}
{"name":"Finset.sum_shift_back","declaration":"theorem Finset.sum_shift_back {E : Type u_1} [Ring E] {u : ℕ → E} {n : ℕ} : cumsum u (n + 1) = cumsum u n + u n"}
{"name":"log_mul_add_isBigO_log","declaration":"theorem log_mul_add_isBigO_log {a : ℝ} (ha : 0 < a) (b : ℝ) : (fun x => Real.log (a * x + b)) =O[Filter.atTop] Real.log"}
{"name":"toSchwartz_apply","declaration":"theorem toSchwartz_apply (f : ℝ → ℂ) {h1 : ContDiff ℝ ⊤ f} {h2 : ∀ (k n : ℕ), ∃ C, ∀ (x : ℝ), ‖x‖ ^ k * ‖iteratedFDeriv ℝ n f x‖ ≤ C} {x : ℝ} : { toFun := f, smooth' := h1, decay' := h2 } x = f x"}
{"name":"nnabla","declaration":"def nnabla {α : Type u_1} {E : Type u_2} [OfNat α 1] [Add α] [Sub E] (u : α → E) (n : α) : E"}
{"name":"Finset.sum_shift_back'","declaration":"theorem Finset.sum_shift_back' {E : Type u_1} [Ring E] {u : ℕ → E} : shift (cumsum u) = cumsum u + u"}
{"name":"exists_antitone_of_eventually","declaration":"theorem exists_antitone_of_eventually {u : ℕ → ℝ} (hu : ∀ᶠ (n : ℕ) in Filter.atTop, u (n + 1) ≤ u n) : ∃ v, Set.range v ⊆ Set.range u ∧ Antitone v ∧ v =ᶠ[Filter.atTop] u"}
{"name":"nnabla_bound_aux2","declaration":"theorem nnabla_bound_aux2 (a : ℝ) {b : ℝ} (hb : 0 < b) : ∀ᶠ (x : ℝ) in Filter.atTop, 0 < x * (a + Real.log (x / b) ^ 2)"}
{"name":"cheby.bigO","declaration":"theorem cheby.bigO {f : ℕ → ℂ} (h : cheby f) : (cumsum fun x => ‖f x‖) =O[Filter.atTop] Nat.cast"}
{"name":"WI_tendsto_aux'","declaration":"theorem WI_tendsto_aux' (a : ℝ) (b : ℝ) {A : ℝ} (hA : 0 < A) : Filter.Tendsto (fun c => b - a - c / A) (nhdsWithin (A * (b - a)) (Set.Iio (A * (b - a)))) (nhdsWithin 0 (Set.Ioi 0))"}
{"name":"one_div_two_pi_mem_Ioo","declaration":"theorem one_div_two_pi_mem_Ioo  : 1 / (2 * Real.pi) ∈ Set.Ioo (-1) 1"}
{"name":"isLittleO_const_of_tendsto_atTop","declaration":"theorem isLittleO_const_of_tendsto_atTop {α : Type u_1} [Preorder α] (a : ℝ) {f : α → ℝ} (hf : Filter.Tendsto f Filter.atTop Filter.atTop) : (fun x => a) =o[Filter.atTop] f"}
{"name":"WienerIkeharaTheorem'","declaration":"theorem WienerIkeharaTheorem' {A : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (hcheby : cheby fun n => ↑(f n)) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto (fun N => cumsum f N / ↑N) Filter.atTop (nhds A)"}
{"name":"summation_by_parts''","declaration":"theorem summation_by_parts'' {E : Type u_1} [Ring E] {a : ℕ → E} {b : ℕ → E} : shift (cumsum (a * b)) = shift (cumsum a) * b - cumsum (shift (cumsum a) * nabla b)"}
{"name":"second_fourier_aux","declaration":"theorem second_fourier_aux {x : ℝ} {t : ℝ} {σ' : ℝ} (hx : 0 < x) : -(Complex.exp (-((1 - ↑σ' - ↑t * Complex.I) * ↑(Real.log x))) / (1 - ↑σ' - ↑t * Complex.I)) =\n  ↑(x ^ (σ' - 1)) * (↑σ' + ↑t * Complex.I - 1)⁻¹ * ↑x ^ (↑t * Complex.I)"}
{"name":"tendsto_S_S_zero","declaration":"theorem tendsto_S_S_zero {f : ℕ → ℝ} (hpos : 0 ≤ f) (hcheby : cheby fun n => ↑(f n)) : TendstoUniformlyOnFilter (S f) (S f 0) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop"}
{"name":"bound_I1","declaration":"theorem bound_I1 {f : ℕ → ℂ} (x : ℝ) (hx : 0 < x) (ψ : W21) (hcheby : cheby f) : ‖∑' (n : ℕ), f n / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x))‖ ≤\n  W21.norm ψ.toFun • ∑' (i : ℕ), ‖f i‖ / ↑i * (1 + (1 / (2 * Real.pi) * Real.log (↑i / x)) ^ 2)⁻¹"}
{"name":"instCoeForAllRealForAllComplex_1","declaration":"def instCoeForAllRealForAllComplex_1 {E : Type u_1} : Coe (E → ℝ) (E → ℂ)"}
{"name":"tendsto_mul_add_atTop","declaration":"theorem tendsto_mul_add_atTop {a : ℝ} (ha : 0 < a) (b : ℝ) : Filter.Tendsto (fun x => a * x + b) Filter.atTop Filter.atTop"}
{"name":"bound_main","declaration":"theorem bound_main {f : ℕ → ℂ} {C : ℝ} (A : ℂ) (x : ℝ) (hx : 1 ≤ x) (ψ : W21) (hcheby : chebyWith C f) : ‖∑' (n : ℕ), f n / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x)) -\n      A * ∫ (u : ℝ) in Set.Ici (-Real.log x), Real.fourierIntegral ψ.toFun (u / (2 * Real.pi))‖ ≤\n  W21.norm ψ.toFun * (C * (1 + 2 * Real.pi ^ 2) + ‖A‖ * (2 * Real.pi ^ 2))"}
{"name":"S","declaration":"def S {𝕜 : Type} [RCLike 𝕜] (f : ℕ → 𝕜) (ε : ℝ) (N : ℕ) : 𝕜"}
{"name":"second_fourier_integrable_aux1","declaration":"theorem second_fourier_integrable_aux1 {x : ℝ} {σ' : ℝ} {ψ : ℝ → ℂ} (hcont : Continuous ψ) (hsupp : MeasureTheory.Integrable ψ MeasureTheory.volume) (hσ : 1 < σ') : let ν := MeasureTheory.Measure.prod (MeasureTheory.volume.restrict (Set.Ici (-Real.log x))) MeasureTheory.volume;\nMeasureTheory.Integrable\n  (Function.uncurry fun u a =>\n    ↑(Real.exp (-u * (σ' - 1))) • ↑(Real.fourierChar (Multiplicative.ofAdd (-(a * (u / (2 * Real.pi)))))) • ψ a)\n  ν"}
{"name":"pp","declaration":"def pp (a : ℝ) (x : ℝ) : ℝ"}
{"name":"pp_deriv","declaration":"theorem pp_deriv (a : ℝ) (x : ℝ) : HasDerivAt (pp a) (pp' a x) x"}
{"name":"nabla","declaration":"def nabla {α : Type u_1} {E : Type u_2} [OfNat α 1] [Add α] [Sub E] (u : α → E) (n : α) : E"}
{"name":"cumsum_succ","declaration":"theorem cumsum_succ {E : Type u_2} [AddCommMonoid E] {u : ℕ → E} (n : ℕ) : cumsum u (n + 1) = cumsum u n + u n"}
{"name":"log_add_one_sub_log_le","declaration":"theorem log_add_one_sub_log_le {x : ℝ} (hx : 0 < x) : nabla Real.log x ≤ x⁻¹"}
{"name":"residue_nonneg","declaration":"theorem residue_nonneg {A : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (hcheby : cheby fun n => ↑(f n)) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) : 0 ≤ A"}
{"name":"hh","declaration":"def hh (a : ℝ) (t : ℝ) : ℝ"}
{"name":"limiting_fourier_lim2_aux","declaration":"theorem limiting_fourier_lim2_aux (x : ℝ) (C : ℝ) : MeasureTheory.Integrable (fun t => |x| * (C / (1 + (t / (2 * Real.pi)) ^ 2)))\n  (MeasureTheory.volume.restrict (Set.Ici (-Real.log x)))"}
{"name":"Finset.sum_shift_front'","declaration":"theorem Finset.sum_shift_front' {E : Type u_1} [Ring E] {u : ℕ → E} : shift (cumsum u) = (fun x => u 0) + cumsum (shift u)"}
{"name":"first_fourier_aux2a","declaration":"theorem first_fourier_aux2a {n : ℕ} {x : ℝ} {y : ℝ} : 2 * ↑Real.pi * -(↑y * (1 / (2 * ↑Real.pi) * ↑(Real.log (↑n / x)))) = -(↑y * ↑(Real.log (↑n / x)))"}
{"name":"mem_Ico_iff_div","declaration":"theorem mem_Ico_iff_div {n : ℕ} {a : ℝ} {b : ℝ} {x : ℝ} (hx : 0 < x) : n ∈ Finset.Ico ⌈a * x⌉₊ ⌈b * x⌉₊ ↔ ↑n / x ∈ Set.Ico a b"}
{"name":"Filter.EventuallyEq.summable","declaration":"theorem Filter.EventuallyEq.summable {u : ℕ → ℝ} {v : ℕ → ℝ} (h : u =ᶠ[Filter.atTop] v) (hu : Summable v) : Summable u"}
{"name":"cumsum_nonneg","declaration":"theorem cumsum_nonneg {u : ℕ → ℝ} (hu : 0 ≤ u) : 0 ≤ cumsum u"}
{"name":"nnabla_mul","declaration":"theorem nnabla_mul {α : Type u_1} {E : Type u_2} [OfNat α 1] [Add α] [Ring E] {u : α → E} {c : E} : (nnabla fun n => c * u n) = c • nnabla u"}
{"name":"vonMangoldt_cheby","declaration":"theorem vonMangoldt_cheby  : cheby fun n => ↑(ArithmeticFunction.vonMangoldt n)"}
{"name":"cancel_aux'","declaration":"theorem cancel_aux' {C : ℝ} {f : ℕ → ℝ} {g : ℕ → ℝ} (hf : 0 ≤ f) (hg : 0 ≤ g) (hf' : ∀ (n : ℕ), cumsum f n ≤ C * ↑n) (hg' : Antitone g) (n : ℕ) : (Finset.sum (Finset.range n) fun i => f i * g i) ≤\n  C * ↑n * g (n - 1) + C * cumsum g (n - 1 - 1 + 1) - C * (↑(n - 1 - 1) + 1) * g (n - 1)"}
{"name":"decay_bounds_key","declaration":"theorem decay_bounds_key (f : W21) (u : ℝ) : ‖Real.fourierIntegral f.toFun u‖ ≤ ‖f‖ * (1 + u ^ 2)⁻¹"}
{"name":"continuous_FourierIntegral","declaration":"theorem continuous_FourierIntegral (ψ : W21) : Continuous (Real.fourierIntegral ψ.toFun)"}
{"name":"BoundedAtFilter.comp_add","declaration":"theorem BoundedAtFilter.comp_add {u : ℕ → ℝ} {N : ℕ} : (Filter.BoundedAtFilter Filter.atTop fun n => u (n + N)) ↔ Filter.BoundedAtFilter Filter.atTop u"}
{"name":"le_of_eventually_nhdsWithin","declaration":"theorem le_of_eventually_nhdsWithin {a : ℝ} {b : ℝ} (h : ∀ᶠ (c : ℝ) in nhdsWithin b (Set.Ioi b), a ≤ c) : a ≤ b"}
{"name":"nabla_cumsum","declaration":"theorem nabla_cumsum {E : Type u_2} [AddCommGroup E] {u : ℕ → E} : nabla (cumsum u) = u"}
{"name":"first_fourier","declaration":"theorem first_fourier {x : ℝ} {σ' : ℝ} {ψ : ℝ → ℂ} {f : ℕ → ℂ} (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (hcont : Continuous ψ) (hsupp : MeasureTheory.Integrable ψ MeasureTheory.volume) (hx : 0 < x) (hσ : 1 < σ') : ∑' (n : ℕ), LSeries.term f (↑σ') n * Real.fourierIntegral ψ (1 / (2 * Real.pi) * Real.log (↑n / x)) =\n  ∫ (t : ℝ), LSeries f (↑σ' + ↑t * Complex.I) * ψ t * ↑x ^ (↑t * Complex.I)"}
{"name":"one_add_sq_pos","declaration":"theorem one_add_sq_pos (u : ℝ) : 0 < 1 + u ^ 2"}
{"name":"wiener_ikehara_smooth","declaration":"theorem wiener_ikehara_smooth {A : ℝ} {Ψ : ℝ → ℂ} {G : ℂ → ℂ} {f : ℕ → ℂ} (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - ↑A / (s - 1)) {s | 1 < s.re}) (hsmooth : ContDiff ℝ ⊤ Ψ) (hsupp : HasCompactSupport Ψ) (hplus : closure (Function.support Ψ) ⊆ Set.Ioi 0) : Filter.Tendsto (fun x => (∑' (n : ℕ), f n * Ψ (↑n / x)) / ↑x - ↑A * ∫ (y : ℝ) in Set.Ioi 0, Ψ y) Filter.atTop (nhds 0)"}
{"name":"W21.integrable_fourier","declaration":"theorem W21.integrable_fourier {c : ℝ} (ψ : W21) (hc : c ≠ 0) : MeasureTheory.Integrable (fun u => Real.fourierIntegral ψ.toFun (u / c)) MeasureTheory.volume"}
{"name":"pp'_deriv","declaration":"theorem pp'_deriv (a : ℝ) (x : ℝ) : HasDerivAt (pp' a) (a ^ 2 * 2) x"}
{"name":"decay_bounds_W21","declaration":"theorem decay_bounds_W21 {A : ℝ} (f : W21) (hA : ∀ (t : ℝ), ‖f.toFun t‖ ≤ A / (1 + t ^ 2)) (hA' : ∀ (t : ℝ), ‖deriv (deriv f.toFun) t‖ ≤ A / (1 + t ^ 2)) (u : ℝ) : ‖Real.fourierIntegral f.toFun u‖ ≤ (Real.pi + 1 / (4 * Real.pi)) * A / (1 + u ^ 2)"}
{"name":"bound_sum_log'","declaration":"theorem bound_sum_log' {f : ℕ → ℂ} {C : ℝ} (hf : chebyWith C f) {x : ℝ} (hx : 1 ≤ x) : ∑' (i : ℕ), ‖f i‖ / ↑i * (1 + (1 / (2 * Real.pi) * Real.log (↑i / x)) ^ 2)⁻¹ ≤ C * (1 + 2 * Real.pi ^ 2)"}
{"name":"WienerIkeharaInterval","declaration":"theorem WienerIkeharaInterval {A : ℝ} {a : ℝ} {b : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (hcheby : cheby fun n => ↑(f n)) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) (ha : 0 < a) (hb : a ≤ b) : Filter.Tendsto (fun x => (∑' (n : ℕ), f n * Set.indicator (Set.Ico a b) 1 (↑n / x)) / x) Filter.atTop\n  (nhds (A * (b - a)))"}
{"name":"comp_exp_support","declaration":"theorem comp_exp_support {Ψ : ℝ → ℂ} (hsupp : HasCompactSupport Ψ) (hplus : closure (Function.support Ψ) ⊆ Set.Ioi 0) : HasCompactSupport (Ψ ∘ Real.exp)"}
{"name":"limiting_fourier_lim1_aux","declaration":"theorem limiting_fourier_lim1_aux {x : ℝ} {f : ℕ → ℂ} (hcheby : cheby f) (hx : 0 < x) (C : ℝ) (hC : 0 ≤ C) : Summable fun n => ‖f n‖ / ↑n * (C / (1 + (1 / (2 * Real.pi) * Real.log (↑n / x)) ^ 2))"}
{"name":"toSchwartz","declaration":"def toSchwartz (f : ℝ → ℂ) (h1 : ContDiff ℝ ⊤ f) (h2 : HasCompactSupport f) : SchwartzMap ℝ ℂ"}
{"name":"smooth_urysohn","declaration":"theorem smooth_urysohn (a : ℝ) (b : ℝ) (c : ℝ) (d : ℝ) (h1 : a < b) (h3 : c < d) : ∃ Ψ, ContDiff ℝ ⊤ Ψ ∧ HasCompactSupport Ψ ∧ Set.indicator (Set.Icc b c) 1 ≤ Ψ ∧ Ψ ≤ Set.indicator (Set.Ioo a d) 1"}
{"name":"quadratic_pos","declaration":"theorem quadratic_pos (a : ℝ) (b : ℝ) (c : ℝ) (x : ℝ) (ha : 0 < a) (hΔ : discrim a b c < 0) : 0 < a * x ^ 2 + b * x + c"}
{"name":"hh'","declaration":"def hh' (a : ℝ) (t : ℝ) : ℝ"}
{"name":"summable_congr_ae","declaration":"theorem summable_congr_ae {u : ℕ → ℝ} {v : ℕ → ℝ} (huv : u =ᶠ[Filter.atTop] v) : Summable u ↔ Summable v"}
{"name":"tendsto_mul_ceil_div","declaration":"/-- A version of the *Wiener-Ikehara Tauberian Theorem*: If `f` is a nonnegative arithmetic\nfunction whose L-series has a simple pole at `s = 1` with residue `A` and otherwise extends\ncontinuously to the closed half-plane `re s ≥ 1`, then `∑ n < N, f n` is asymptotic to `A*N`. -/\ntheorem tendsto_mul_ceil_div  : Filter.Tendsto (fun p => ↑⌈p.1 * ↑p.2⌉₊ / ↑p.2) (nhdsWithin 0 (Set.Ioi 0) ×ˢ Filter.atTop) (nhds 0)"}
{"name":"set_integral_ofReal","declaration":"theorem set_integral_ofReal {f : ℝ → ℝ} {s : Set ℝ} : ∫ (x : ℝ) in s, ↑(f x) = ↑(∫ (x : ℝ) in s, f x)"}
{"name":"le_floor_mul_iff","declaration":"theorem le_floor_mul_iff {n : ℕ} {b : ℝ} {x : ℝ} (hb : 0 ≤ b) (hx : 0 < x) : n ≤ ⌊b * x⌋₊ ↔ ↑n / x ≤ b"}
{"name":"hh_integrable_aux","declaration":"theorem hh_integrable_aux {a : ℝ} {b : ℝ} {c : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : MeasureTheory.IntegrableOn (fun t => a * hh b (t / c)) (Set.Ici 0) MeasureTheory.volume ∧\n  ∫ (t : ℝ) in Set.Ioi 0, a * hh b (t / c) = a * c / b * Real.pi"}
{"name":"gg","declaration":"def gg (x : ℝ) (i : ℝ) : ℝ"}
{"name":"exists_trunc","declaration":"def exists_trunc  : trunc"}
{"name":"comp_exp_support0","declaration":"theorem comp_exp_support0 {Ψ : ℝ → ℂ} (hplus : closure (Function.support Ψ) ⊆ Set.Ioi 0) : ∀ᶠ (x : ℝ) in nhds 0, Ψ x = 0"}
{"name":"limiting_fourier_aux","declaration":"theorem limiting_fourier_aux {A : ℝ} {x : ℝ} {G : ℂ → ℂ} {f : ℕ → ℂ} (hG' : Set.EqOn G (fun s => LSeries f s - ↑A / (s - 1)) {s | 1 < s.re}) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (ψ : CS 2 ℂ) (hx : 1 ≤ x) (σ' : ℝ) (hσ' : 1 < σ') : ∑' (n : ℕ), LSeries.term f (↑σ') n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x)) -\n    ↑A * ↑(x ^ (1 - σ')) *\n      ∫ (u : ℝ) in Set.Ici (-Real.log x),\n        ↑(Real.exp (-u * (σ' - 1))) * Real.fourierIntegral ψ.toFun (u / (2 * Real.pi)) =\n  ∫ (t : ℝ), G (↑σ' + ↑t * Complex.I) * ψ.toFun t * ↑x ^ (↑t * Complex.I)"}
{"name":"isLittleO_mul_add_sq","declaration":"theorem isLittleO_mul_add_sq (a : ℝ) (b : ℝ) : (fun x => a * x + b) =o[Filter.atTop] fun x => x ^ 2"}
{"name":"isBigO_log_mul_add","declaration":"theorem isBigO_log_mul_add {a : ℝ} (ha : 0 < a) (b : ℝ) : Real.log =O[Filter.atTop] fun x => Real.log (a * x + b)"}
{"name":"hh_continuous","declaration":"theorem hh_continuous (a : ℝ) : ContinuousOn (hh a) (Set.Ioi 0)"}
{"name":"nabla_log","declaration":"theorem nabla_log {b : ℝ} (hb : 0 < b) : (nabla fun x => Real.log (x / b)) =O[Filter.atTop] fun x => 1 / x"}
{"name":"cancel_aux","declaration":"theorem cancel_aux {C : ℝ} {f : ℕ → ℝ} {g : ℕ → ℝ} (hf : 0 ≤ f) (hg : 0 ≤ g) (hf' : ∀ (n : ℕ), cumsum f n ≤ C * ↑n) (hg' : Antitone g) (n : ℕ) : (Finset.sum (Finset.range n) fun i => f i * g i) ≤\n  g (n - 1) * (C * ↑n) +\n    (C * (↑(n - 1 - 1) + 1) * g 0 - C * (↑(n - 1 - 1) + 1) * g (n - 1) -\n      ((n - 1 - 1) • (C * g 0) - Finset.sum (Finset.range (n - 1 - 1)) fun x => C * g (x + 1)))"}
{"name":"S_sub_S","declaration":"theorem S_sub_S {𝕜 : Type} [RCLike 𝕜] {f : ℕ → 𝕜} {ε : ℝ} {N : ℕ} (hε : ε ≤ 1) : S f 0 N - S f ε N = cumsum f ⌈ε * ↑N⌉₊ / ↑N"}
{"name":"WI_sum_Iab_le","declaration":"theorem WI_sum_Iab_le {a : ℝ} {b : ℝ} {x : ℝ} {f : ℕ → ℝ} (hpos : 0 ≤ f) {C : ℝ} (hcheby : chebyWith C fun n => ↑(f n)) (hb : 0 < b) (hxb : 2 / b < x) : (∑' (n : ℕ), f n * Set.indicator (Set.Ico a b) 1 (↑n / x)) / x ≤ C * 2 * b"}
{"name":"hh_deriv","declaration":"theorem hh_deriv (a : ℝ) {t : ℝ} (ht : t ≠ 0) : HasDerivAt (hh a) (hh' a t) t"}
{"name":"bound_sum_log","declaration":"theorem bound_sum_log {f : ℕ → ℂ} {C : ℝ} (hf0 : f 0 = 0) (hf : chebyWith C f) {x : ℝ} (hx : 1 ≤ x) : ∑' (i : ℕ), ‖f i‖ / ↑i * (1 + (1 / (2 * Real.pi) * Real.log (↑i / x)) ^ 2)⁻¹ ≤\n  C * (1 + ∫ (t : ℝ) in Set.Ioi 0, hh (1 / (2 * Real.pi)) t)"}
{"name":"bound_I1'","declaration":"theorem bound_I1' {f : ℕ → ℂ} {C : ℝ} (x : ℝ) (hx : 1 ≤ x) (ψ : W21) (hcheby : chebyWith C f) : ‖∑' (n : ℕ), f n / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x))‖ ≤\n  W21.norm ψ.toFun * C * (1 + 2 * Real.pi ^ 2)"}
{"name":"log_add_div_isBigO_log","declaration":"theorem log_add_div_isBigO_log (a : ℝ) {b : ℝ} (hb : 0 < b) : (fun x => Real.log ((x + a) / b)) =O[Filter.atTop] fun x => Real.log x"}
{"name":"wiener_ikehara_smooth_aux","declaration":"theorem wiener_ikehara_smooth_aux {Ψ : ℝ → ℂ} (l0 : Continuous Ψ) (hsupp : HasCompactSupport Ψ) (hplus : closure (Function.support Ψ) ⊆ Set.Ioi 0) (x : ℝ) (hx : 0 < x) : ∫ (u : ℝ) in Set.Ioi (-Real.log x), ↑(Real.exp u) * Ψ (Real.exp u) = ∫ (y : ℝ) in Set.Ioi (1 / x), Ψ y"}
{"name":"crude_upper_bound","declaration":"theorem crude_upper_bound {A : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (ψ : CS 2 ℂ) (hψpos : ∀ (y : ℝ), 0 ≤ (Real.fourierIntegral ψ.toFun y).re ∧ (Real.fourierIntegral ψ.toFun y).im = 0) : ∃ B,\n  ∀ (x : ℝ),\n    0 < x → ‖∑' (n : ℕ), ↑(f n) / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x))‖ ≤ B"}
{"name":"Asymptotics.IsBigO.add_isLittleO_right","declaration":"theorem Asymptotics.IsBigO.add_isLittleO_right {f : ℝ → ℝ} {g : ℝ → ℝ} (h : g =o[Filter.atTop] f) : f =O[Filter.atTop] (f + g)"}
{"name":"sum_le_integral","declaration":"theorem sum_le_integral {x₀ : ℝ} {f : ℝ → ℝ} {n : ℕ} (hf : AntitoneOn f (Set.Ioc x₀ (x₀ + ↑n))) (hfi : MeasureTheory.IntegrableOn f (Set.Icc x₀ (x₀ + ↑n)) MeasureTheory.volume) : (Finset.sum (Finset.range n) fun i => f (x₀ + ↑(i + 1))) ≤ ∫ (x : ℝ) in x₀..x₀ + ↑n, f x"}
{"name":"summable_iff_bounded","declaration":"theorem summable_iff_bounded {u : ℕ → ℝ} (hu : 0 ≤ u) : Summable u ↔ Filter.BoundedAtFilter Filter.atTop (cumsum u)"}
{"name":"BoundedAtFilter.add_const","declaration":"theorem BoundedAtFilter.add_const {u : ℕ → ℝ} {c : ℝ} : (Filter.BoundedAtFilter Filter.atTop fun n => u n + c) ↔ Filter.BoundedAtFilter Filter.atTop u"}
{"name":"hh'_nonpos","declaration":"theorem hh'_nonpos {a : ℝ} {x : ℝ} (ha : a ∈ Set.Ioo (-1) 1) : hh' a x ≤ 0"}
{"name":"nnabla_bound","declaration":"theorem nnabla_bound (C : ℝ) {x : ℝ} (hx : 0 < x) : (nnabla fun n => C / (1 + (Real.log (n / x) / (2 * Real.pi)) ^ 2) / n) =O[Filter.atTop] fun n =>\n  (n ^ 2 * Real.log n ^ 2)⁻¹"}
{"name":"gg_l1","declaration":"theorem gg_l1 {x : ℝ} (hx : 0 < x) (n : ℕ) : |gg x ↑n| ≤ 1 / ↑n"}
{"name":"interval_approx_inf","declaration":"theorem interval_approx_inf {a : ℝ} {b : ℝ} (ha : 0 < a) (hab : a < b) : ∀ᶠ (ε : ℝ) in nhdsWithin 0 (Set.Ioi 0),\n  ∃ ψ,\n    ContDiff ℝ ⊤ ψ ∧\n      HasCompactSupport ψ ∧\n        closure (Function.support ψ) ⊆ Set.Ioi 0 ∧\n          ψ ≤ Set.indicator (Set.Ico a b) 1 ∧ b - a - ε ≤ ∫ (y : ℝ) in Set.Ioi 0, ψ y"}
{"name":"WI_sum_le","declaration":"theorem WI_sum_le {x : ℝ} {f : ℕ → ℝ} {g₁ : ℝ → ℝ} {g₂ : ℝ → ℝ} (hf : 0 ≤ f) (hg : g₁ ≤ g₂) (hx : 0 < x) (hg₁ : HasCompactSupport g₁) (hg₂ : HasCompactSupport g₂) : (∑' (n : ℕ), f n * g₁ (↑n / x)) / x ≤ (∑' (n : ℕ), f n * g₂ (↑n / x)) / x"}
{"name":"lt_ceil_mul_iff","declaration":"theorem lt_ceil_mul_iff {n : ℕ} {b : ℝ} {x : ℝ} (hx : 0 < x) : n < ⌈b * x⌉₊ ↔ ↑n / x < b"}
{"name":"nabla_log_main","declaration":"theorem nabla_log_main  : nabla Real.log =O[Filter.atTop] fun x => 1 / x"}
{"name":"ceil_mul_le_iff","declaration":"theorem ceil_mul_le_iff {n : ℕ} {a : ℝ} {x : ℝ} (hx : 0 < x) : ⌈a * x⌉₊ ≤ n ↔ a ≤ ↑n / x"}
{"name":"nnabla_mul_log_sq","declaration":"theorem nnabla_mul_log_sq (a : ℝ) {b : ℝ} (hb : 0 < b) : (nabla fun x => x * (a + Real.log (x / b) ^ 2)) =O[Filter.atTop] fun x => Real.log x ^ 2"}
{"name":"isBigO_pow_pow_of_le","declaration":"theorem isBigO_pow_pow_of_le {m : ℕ} {n : ℕ} (h : m ≤ n) : (fun x => x ^ m) =O[Filter.atTop] fun x => x ^ n"}
{"name":"limiting_fourier_lim1","declaration":"theorem limiting_fourier_lim1 {x : ℝ} {f : ℕ → ℂ} (hcheby : cheby f) (ψ : W21) (hx : 0 < x) : Filter.Tendsto\n  (fun σ' => ∑' (n : ℕ), LSeries.term f (↑σ') n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x)))\n  (nhdsWithin 1 (Set.Ioi 1))\n  (nhds (∑' (n : ℕ), f n / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x))))"}
{"name":"chebyWith","declaration":"def chebyWith (C : ℝ) (f : ℕ → ℂ) : Prop"}
{"name":"nnabla_cast","declaration":"theorem nnabla_cast {E : Type u_2} (u : ℝ → E) [Sub E] : nnabla u ∘ Nat.cast = nnabla (u ∘ Nat.cast)"}
{"name":"WI_tendsto_aux","declaration":"theorem WI_tendsto_aux (a : ℝ) (b : ℝ) {A : ℝ} (hA : 0 < A) : Filter.Tendsto (fun c => c / A - (b - a)) (nhdsWithin (A * (b - a)) (Set.Ioi (A * (b - a)))) (nhdsWithin 0 (Set.Ioi 0))"}
{"name":"first_fourier_aux1","declaration":"theorem first_fourier_aux1 {ψ : ℝ → ℂ} (hψ : Continuous ψ) {x : ℝ} (n : ℕ) : Measurable fun u => ↑‖Real.fourierChar (-(u * (1 / (2 * Real.pi) * Real.log (↑n / x)))) • ψ u‖₊"}
{"name":"cumsum_zero","declaration":"theorem cumsum_zero {E : Type u_2} [AddCommMonoid E] {u : ℕ → E} : cumsum u 0 = 0"}
{"name":"nnabla_bound_aux1","declaration":"theorem nnabla_bound_aux1 (a : ℝ) {b : ℝ} (hb : 0 < b) : Filter.Tendsto (fun x => x * (a + Real.log (x / b) ^ 2)) Filter.atTop Filter.atTop"}
{"name":"neg_cumsum","declaration":"theorem neg_cumsum {E : Type u_2} [AddCommGroup E] {u : ℕ → E} : -cumsum u = cumsum (-u)"}
{"name":"neg_nabla","declaration":"theorem neg_nabla {α : Type u_1} {E : Type u_2} [OfNat α 1] [Add α] [Ring E] {u : α → E} : -nabla u = nnabla u"}
{"name":"cumsum","declaration":"def cumsum {E : Type u_2} [AddCommMonoid E] (u : ℕ → E) (n : ℕ) : E"}
{"name":"sum_telescopic","declaration":"theorem sum_telescopic (a : ℕ → ℝ) (n : ℕ) : (Finset.sum (Finset.range n) fun i => a (i + 1) - a i) = a n - a 0"}
{"name":"limiting_fourier_variant","declaration":"theorem limiting_fourier_variant {A : ℝ} {x : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (ψ : CS 2 ℂ) (hψpos : ∀ (y : ℝ), 0 ≤ (Real.fourierIntegral ψ.toFun y).re ∧ (Real.fourierIntegral ψ.toFun y).im = 0) (hx : 1 ≤ x) : ∑' (n : ℕ), ↑(f n) / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x)) -\n    ↑A * ∫ (u : ℝ) in Set.Ici (-Real.log x), Real.fourierIntegral ψ.toFun (u / (2 * Real.pi)) =\n  ∫ (t : ℝ), G (1 + ↑t * Complex.I) * ψ.toFun t * ↑x ^ (↑t * Complex.I)"}
{"name":"WeakPNT","declaration":"theorem WeakPNT  : Filter.Tendsto (fun N => cumsum (⇑ArithmeticFunction.vonMangoldt) N / ↑N) Filter.atTop (nhds 1)"}
{"name":"interval_approx_sup","declaration":"theorem interval_approx_sup {a : ℝ} {b : ℝ} (ha : 0 < a) (hab : a < b) : ∀ᶠ (ε : ℝ) in nhdsWithin 0 (Set.Ioi 0),\n  ∃ ψ,\n    ContDiff ℝ ⊤ ψ ∧\n      HasCompactSupport ψ ∧\n        closure (Function.support ψ) ⊆ Set.Ioi 0 ∧\n          Set.indicator (Set.Ico a b) 1 ≤ ψ ∧ ∫ (y : ℝ) in Set.Ioi 0, ψ y ≤ b - a + ε"}
{"name":"gg_le_one","declaration":"theorem gg_le_one {x : ℝ} (i : ℕ) : gg x ↑i ≤ 1"}
{"name":"hh_nonneg","declaration":"theorem hh_nonneg (a : ℝ) {t : ℝ} (ht : 0 ≤ t) : 0 ≤ hh a t"}
{"name":"bound_sum_log0","declaration":"theorem bound_sum_log0 {f : ℕ → ℂ} {C : ℝ} (hf : chebyWith C f) {x : ℝ} (hx : 1 ≤ x) : ∑' (i : ℕ), ‖f i‖ / ↑i * (1 + (1 / (2 * Real.pi) * Real.log (↑i / x)) ^ 2)⁻¹ ≤\n  C * (1 + ∫ (t : ℝ) in Set.Ioi 0, hh (1 / (2 * Real.pi)) t)"}
{"name":"pp'_deriv_eq","declaration":"theorem pp'_deriv_eq (a : ℝ) : deriv (pp' a) = fun x => a ^ 2 * 2"}
{"name":"WienerIkeharaInterval_discrete","declaration":"theorem WienerIkeharaInterval_discrete {A : ℝ} {a : ℝ} {b : ℝ} {G : ℂ → ℂ} {f : ℕ → ℝ} (hpos : 0 ≤ f) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm (fun n => ↑(f n)) σ')) (hcheby : cheby fun n => ↑(f n)) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => ↑(f n)) s - ↑A / (s - 1)) {s | 1 < s.re}) (ha : 0 < a) (hb : a ≤ b) : Filter.Tendsto (fun x => (Finset.sum (Finset.Ico ⌈a * x⌉₊ ⌈b * x⌉₊) fun n => f n) / x) Filter.atTop (nhds (A * (b - a)))"}
{"name":"limiting_fourier","declaration":"theorem limiting_fourier {A : ℝ} {x : ℝ} {G : ℂ → ℂ} {f : ℕ → ℂ} (hcheby : cheby f) (hG : ContinuousOn G {s | 1 ≤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - ↑A / (s - 1)) {s | 1 < s.re}) (hf : ∀ (σ' : ℝ), 1 < σ' → Summable (nterm f σ')) (ψ : CS 2 ℂ) (hx : 1 ≤ x) : ∑' (n : ℕ), f n / ↑n * Real.fourierIntegral ψ.toFun (1 / (2 * Real.pi) * Real.log (↑n / x)) -\n    ↑A * ∫ (u : ℝ) in Set.Ici (-Real.log x), Real.fourierIntegral ψ.toFun (u / (2 * Real.pi)) =\n  ∫ (t : ℝ), G (1 + ↑t * Complex.I) * ψ.toFun t * ↑x ^ (↑t * Complex.I)"}
{"name":"limiting_cor_aux","declaration":"theorem limiting_cor_aux {f : ℝ → ℂ} : Filter.Tendsto (fun x => ∫ (t : ℝ), f t * ↑x ^ (↑t * Complex.I)) Filter.atTop (nhds 0)"}
{"name":"nterm","declaration":"def nterm (f : ℕ → ℂ) (σ' : ℝ) (n : ℕ) : ℝ"}
{"name":"WI_summable","declaration":"theorem WI_summable {x : ℝ} {f : ℕ → ℝ} {g : ℝ → ℝ} (hg : HasCompactSupport g) (hx : 0 < x) : Summable fun n => f n * g (↑n / x)"}
{"name":"nabla_mul","declaration":"theorem nabla_mul {α : Type u_1} {E : Type u_2} [OfNat α 1] [Add α] [Ring E] {u : α → E} {c : E} : (nabla fun n => c * u n) = c • nabla u"}
{"name":"continuous_multiplicative_ofAdd","declaration":"theorem continuous_multiplicative_ofAdd  : Continuous ⇑Multiplicative.ofAdd"}
{"name":"log_sq_isbigo_mul","declaration":"theorem log_sq_isbigo_mul {a : ℝ} {b : ℝ} (hb : 0 < b) : (fun x => Real.log x ^ 2) =O[Filter.atTop] fun x => a + Real.log (x / b) ^ 2"}
{"name":"Finset.sum_shift_front","declaration":"theorem Finset.sum_shift_front {E : Type u_1} [Ring E] {u : ℕ → E} {n : ℕ} : cumsum u (n + 1) = u 0 + cumsum (shift u) n"}
{"name":"bounded_of_shift","declaration":"theorem bounded_of_shift {u : ℕ → ℝ} (h : Filter.BoundedAtFilter Filter.atTop (shift u)) : Filter.BoundedAtFilter Filter.atTop u"}
{"name":"shift","declaration":"def shift {α : Type u_1} {E : Type u_2} [OfNat α 1] [Add α] (u : α → E) (n : α) : E"}
{"name":"fourier_surjection_on_schwartz","declaration":"theorem fourier_surjection_on_schwartz (f : SchwartzMap ℝ ℂ) : ∃ g, Real.fourierIntegral ⇑g = ⇑f"}
{"name":"hh_integral'","declaration":"theorem hh_integral'  : ∫ (t : ℝ) in Set.Ioi 0, hh (1 / (2 * Real.pi)) t = 2 * Real.pi ^ 2"}
{"name":"wiener_ikehara_smooth_sub","declaration":"theorem wiener_ikehara_smooth_sub {A : ℝ} {Ψ : ℝ → ℂ} (h1 : MeasureTheory.Integrable Ψ MeasureTheory.volume) (hplus : closure (Function.support Ψ) ⊆ Set.Ioi 0) : Filter.Tendsto (fun x => (↑A * ∫ (y : ℝ) in Set.Ioi x⁻¹, Ψ y) - ↑A * ∫ (y : ℝ) in Set.Ioi 0, Ψ y) Filter.atTop (nhds 0)"}
{"name":"cancel_main","declaration":"theorem cancel_main {C : ℝ} {f : ℕ → ℝ} {g : ℕ → ℝ} (hf : 0 ≤ f) (hg : 0 ≤ g) (hf' : ∀ (n : ℕ), cumsum f n ≤ C * ↑n) (hg' : Antitone g) (n : ℕ) (hn : 2 ≤ n) : cumsum (f * g) n ≤ C * cumsum g n"}
{"name":"tsum_indicator","declaration":"theorem tsum_indicator {a : ℝ} {b : ℝ} {x : ℝ} {f : ℕ → ℝ} (hx : 0 < x) : ∑' (n : ℕ), f n * Set.indicator (Set.Ico a b) 1 (↑n / x) = Finset.sum (Finset.Ico ⌈a * x⌉₊ ⌈b * x⌉₊) fun n => f n"}
{"name":"sum_range_succ","declaration":"theorem sum_range_succ (a : ℕ → ℝ) (n : ℕ) : (Finset.sum (Finset.range n) fun i => a (i + 1)) = (Finset.sum (Finset.range (n + 1)) fun i => a i) - a 0"}
{"name":"decay_bounds_cor","declaration":"theorem decay_bounds_cor (ψ : W21) : ∃ C, ∀ (u : ℝ), ‖Real.fourierIntegral ψ.toFun u‖ ≤ C / (1 + u ^ 2)"}
{"name":"limiting_fourier_lim3","declaration":"theorem limiting_fourier_lim3 {x : ℝ} {G : ℂ → ℂ} (hG : ContinuousOn G {s | 1 ≤ s.re}) (ψ : CS 2 ℂ) (hx : 1 ≤ x) : Filter.Tendsto (fun σ' => ∫ (t : ℝ), G (↑σ' + ↑t * Complex.I) * ψ.toFun t * ↑x ^ (↑t * Complex.I))\n  (nhdsWithin 1 (Set.Ioi 1)) (nhds (∫ (t : ℝ), G (1 + ↑t * Complex.I) * ψ.toFun t * ↑x ^ (↑t * Complex.I)))"}
