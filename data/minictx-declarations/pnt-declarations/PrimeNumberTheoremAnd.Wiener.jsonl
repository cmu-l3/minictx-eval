{"name":"WienerIkeharaInterval_discrete'","declaration":"theorem WienerIkeharaInterval_discrete' {A : â„} {a : â„} {b : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (hcheby : cheby fun n => â†‘(f n)) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) (ha : 0 < a) (hb : a â‰¤ b) : Filter.Tendsto (fun N => (Finset.sum (Finset.Ico âŒˆa * â†‘NâŒ‰â‚Š âŒˆb * â†‘NâŒ‰â‚Š) fun n => f n) / â†‘N) Filter.atTop\n  (nhds (A * (b - a)))"}
{"name":"hh_antitone","declaration":"theorem hh_antitone {a : â„} (ha : a âˆˆ Set.Ioo (-1) 1) : AntitoneOn (hh a) (Set.Ioi 0)"}
{"name":"wiener_ikehara_smooth'","declaration":"theorem wiener_ikehara_smooth' {A : â„} {Î¨ : â„ â†’ â„‚} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„‚} (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - â†‘A / (s - 1)) {s | 1 < s.re}) (hsmooth : ContDiff â„ âŠ¤ Î¨) (hsupp : HasCompactSupport Î¨) (hplus : closure (Function.support Î¨) âŠ† Set.Ioi 0) : Filter.Tendsto (fun x => (âˆ‘' (n : â„•), f n * Î¨ (â†‘n / x)) / â†‘x) Filter.atTop (nhds (â†‘A * âˆ« (y : â„) in Set.Ioi 0, Î¨ y))"}
{"name":"log_isbigo_log_div","declaration":"theorem log_isbigo_log_div {d : â„} (hb : 0 < d) : (fun n => Real.log n) =O[Filter.atTop] fun n => Real.log (n / d)"}
{"name":"wiener_ikehara_smooth_real","declaration":"theorem wiener_ikehara_smooth_real {A : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} {Î¨ : â„ â†’ â„} (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (hcheby : cheby fun n => â†‘(f n)) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) (hsmooth : ContDiff â„ âŠ¤ Î¨) (hsupp : HasCompactSupport Î¨) (hplus : closure (Function.support Î¨) âŠ† Set.Ioi 0) : Filter.Tendsto (fun x => (âˆ‘' (n : â„•), f n * Î¨ (â†‘n / x)) / x) Filter.atTop (nhds (A * âˆ« (y : â„) in Set.Ioi 0, Î¨ y))"}
{"name":"pp'","declaration":"def pp' (a : â„) (x : â„) : â„"}
{"name":"one_div_sub_one","declaration":"theorem one_div_sub_one (n : â„•) : 1 / â†‘(n - 1) â‰¤ 2 / â†‘n"}
{"name":"summation_by_parts'","declaration":"theorem summation_by_parts' {E : Type u_1} [Ring E] {a : â„• â†’ E} {b : â„• â†’ E} {n : â„•} : cumsum (a * b) (n + 1) = cumsum a (n + 1) * b n - cumsum (shift (cumsum a) * nabla b) n"}
{"name":"cheby","declaration":"def cheby (f : â„• â†’ â„‚) : Prop"}
{"name":"continuous_LSeries_aux","declaration":"theorem continuous_LSeries_aux {Ïƒ' : â„} {f : â„• â†’ â„‚} (hf : Summable (nterm f Ïƒ')) : Continuous fun x => LSeries f (â†‘Ïƒ' + â†‘x * Complex.I)"}
{"name":"limiting_cor_schwartz","declaration":"theorem limiting_cor_schwartz {A : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„‚} (Ïˆ : SchwartzMap â„ â„‚) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - â†‘A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto\n  (fun x =>\n    âˆ‘' (n : â„•), f n / â†‘n * Real.fourierIntegral (â‡‘Ïˆ) (1 / (2 * Real.pi) * Real.log (â†‘n / x)) -\n      â†‘A * âˆ« (u : â„) in Set.Ici (-Real.log x), Real.fourierIntegral (â‡‘Ïˆ) (u / (2 * Real.pi)))\n  Filter.atTop (nhds 0)"}
{"name":"comp_exp_support2","declaration":"theorem comp_exp_support2 {Î¨ : â„ â†’ â„‚} (hsupp : HasCompactSupport Î¨) : âˆ€á¶  (x : â„) in Filter.atTop, (Î¨ âˆ˜ Real.exp) x = 0"}
{"name":"hf_coe1","declaration":"theorem hf_coe1 {Ïƒ' : â„} {f : â„• â†’ â„‚} (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (hÏƒ : 1 < Ïƒ') : âˆ‘' (i : â„•), â†‘â€–LSeries.term f (â†‘Ïƒ') iâ€–â‚Š â‰  âŠ¤"}
{"name":"gg_of_hh","declaration":"theorem gg_of_hh {x : â„} (hx : x â‰  0) (i : â„) : gg x i = xâ»Â¹ * hh (1 / (2 * Real.pi)) (i / x)"}
{"name":"mem_Icc_iff_div","declaration":"theorem mem_Icc_iff_div {n : â„•} {a : â„} {b : â„} {x : â„} (hb : 0 â‰¤ b) (hx : 0 < x) : n âˆˆ Finset.Icc âŒˆa * xâŒ‰â‚Š âŒŠb * xâŒ‹â‚Š â†” â†‘n / x âˆˆ Set.Icc a b"}
{"name":"decay_bounds","declaration":"theorem decay_bounds {A : â„} {u : â„} (Ïˆ : CS 2 â„‚) (hA : âˆ€ (t : â„), â€–Ïˆ.toFun tâ€– â‰¤ A / (1 + t ^ 2)) (hA' : âˆ€ (t : â„), â€–deriv^[2] Ïˆ.toFun tâ€– â‰¤ A / (1 + t ^ 2)) : â€–Real.fourierIntegral Ïˆ.toFun uâ€– â‰¤ (Real.pi + 1 / (4 * Real.pi)) * A / (1 + u ^ 2)"}
{"name":"nnabla_bound_aux","declaration":"theorem nnabla_bound_aux {x : â„} (hx : 0 < x) : (nnabla fun n => 1 / (n * ((2 * Real.pi) ^ 2 + Real.log (n / x) ^ 2))) =O[Filter.atTop] fun n =>\n  1 / (Real.log n ^ 2 * n ^ 2)"}
{"name":"Asymptotics.IsBigO.sq","declaration":"theorem Asymptotics.IsBigO.sq {Î± : Type u_1} [Preorder Î±] {f : Î± â†’ â„} {g : Î± â†’ â„} (h : f =O[Filter.atTop] g) : (fun n => f n ^ 2) =O[Filter.atTop] fun n => g n ^ 2"}
{"name":"second_fourier_integrable_aux2","declaration":"theorem second_fourier_integrable_aux2 {x : â„} {t : â„} {Ïƒ' : â„} (hÏƒ : 1 < Ïƒ') : MeasureTheory.IntegrableOn (fun u => Complex.exp ((1 - â†‘Ïƒ' - â†‘t * Complex.I) * â†‘u)) (Set.Ioi (-Real.log x))\n  MeasureTheory.volume"}
{"name":"cancel_main'","declaration":"theorem cancel_main' {C : â„} {f : â„• â†’ â„} {g : â„• â†’ â„} (hf : 0 â‰¤ f) (hf0 : f 0 = 0) (hg : 0 â‰¤ g) (hf' : âˆ€ (n : â„•), cumsum f n â‰¤ C * â†‘n) (hg' : Antitone g) (n : â„•) : cumsum (f * g) n â‰¤ C * cumsum g n"}
{"name":"hh_integral","declaration":"theorem hh_integral {a : â„} {b : â„} {c : â„} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : âˆ« (t : â„) in Set.Ioi 0, a * hh b (t / c) = a * c / b * Real.pi"}
{"name":"second_fourier_integrable_aux1a","declaration":"theorem second_fourier_integrable_aux1a {x : â„} {Ïƒ' : â„} (hÏƒ : 1 < Ïƒ') : MeasureTheory.IntegrableOn (fun x => Complex.exp (-(â†‘x * (â†‘Ïƒ' - 1)))) (Set.Ici (-Real.log x)) MeasureTheory.volume"}
{"name":"pp_deriv_eq","declaration":"theorem pp_deriv_eq (a : â„) : deriv (pp a) = pp' a"}
{"name":"summable_iff_bounded'","declaration":"theorem summable_iff_bounded' {u : â„• â†’ â„} (hu : âˆ€á¶  (n : â„•) in Filter.atTop, 0 â‰¤ u n) : Summable u â†” Filter.BoundedAtFilter Filter.atTop (cumsum u)"}
{"name":"comp_exp_support1","declaration":"theorem comp_exp_support1 {Î¨ : â„ â†’ â„‚} (hplus : closure (Function.support Î¨) âŠ† Set.Ioi 0) : âˆ€á¶  (x : â„) in Filter.atBot, Î¨ (Real.exp x) = 0"}
{"name":"limiting_cor_W21","declaration":"theorem limiting_cor_W21 {A : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„‚} (Ïˆ : W21) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - â†‘A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto\n  (fun x =>\n    âˆ‘' (n : â„•), f n / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x)) -\n      â†‘A * âˆ« (u : â„) in Set.Ici (-Real.log x), Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi)))\n  Filter.atTop (nhds 0)"}
{"name":"WI_sum_Iab_le'","declaration":"theorem WI_sum_Iab_le' {a : â„} {b : â„} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) {C : â„} (hcheby : chebyWith C fun n => â†‘(f n)) (hb : 0 < b) : âˆ€á¶  (x : â„) in Filter.atTop, (âˆ‘' (n : â„•), f n * Set.indicator (Set.Ico a b) 1 (â†‘n / x)) / x â‰¤ C * 2 * b"}
{"name":"summation_by_parts","declaration":"theorem summation_by_parts {E : Type u_1} [Ring E] {a : â„• â†’ E} {A : â„• â†’ E} {b : â„• â†’ E} (ha : a = nabla A) {n : â„•} : cumsum (a * b) (n + 1) = A (n + 1) * b n - A 0 * b 0 - cumsum (shift A * fun i => b (i + 1) - b i) n"}
{"name":"auto_cheby","declaration":"theorem auto_cheby {A : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) : cheby fun n => â†‘(f n)"}
{"name":"ge_of_eventually_nhdsWithin","declaration":"theorem ge_of_eventually_nhdsWithin {a : â„} {b : â„} (h : âˆ€á¶  (c : â„) in nhdsWithin b (Set.Iio b), c â‰¤ a) : b â‰¤ a"}
{"name":"nterm_eq_norm_term","declaration":"theorem nterm_eq_norm_term {n : â„•} {Ïƒ' : â„} {f : â„• â†’ â„‚} : nterm f Ïƒ' n = â€–LSeries.term f (â†‘Ïƒ') nâ€–"}
{"name":"decay_bounds_cor_aux","declaration":"theorem decay_bounds_cor_aux (Ïˆ : CS 2 â„‚) : âˆƒ C, âˆ€ (u : â„), â€–Ïˆ.toFun uâ€– â‰¤ C / (1 + u ^ 2)"}
{"name":"second_fourier","declaration":"theorem second_fourier {Ïˆ : â„ â†’ â„‚} (hcont : Continuous Ïˆ) (hsupp : MeasureTheory.Integrable Ïˆ MeasureTheory.volume) {x : â„} {Ïƒ' : â„} (hx : 0 < x) (hÏƒ : 1 < Ïƒ') : âˆ« (u : â„) in Set.Ici (-Real.log x), â†‘(Real.exp (-u * (Ïƒ' - 1))) * Real.fourierIntegral Ïˆ (u / (2 * Real.pi)) =\n  â†‘(x ^ (Ïƒ' - 1)) * âˆ« (t : â„), 1 / (â†‘Ïƒ' + â†‘t * Complex.I - 1) * Ïˆ t * â†‘x ^ (â†‘t * Complex.I)"}
{"name":"limiting_fourier_lim2","declaration":"theorem limiting_fourier_lim2 {x : â„} (A : â„) (Ïˆ : W21) (hx : 1 â‰¤ x) : Filter.Tendsto\n  (fun Ïƒ' =>\n    â†‘A * â†‘(x ^ (1 - Ïƒ')) *\n      âˆ« (u : â„) in Set.Ici (-Real.log x),\n        â†‘(Real.exp (-u * (Ïƒ' - 1))) * Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi)))\n  (nhdsWithin 1 (Set.Ioi 1))\n  (nhds (â†‘A * âˆ« (u : â„) in Set.Ici (-Real.log x), Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi))))"}
{"name":"pp_pos","declaration":"theorem pp_pos {a : â„} (ha : a âˆˆ Set.Ioo (-1) 1) (x : â„) : 0 < pp a x"}
{"name":"first_fourier_aux2","declaration":"theorem first_fourier_aux2 {x : â„} {y : â„} {Ïƒ' : â„} {Ïˆ : â„ â†’ â„‚} {f : â„• â†’ â„‚} (hx : 0 < x) (n : â„•) : LSeries.term f (â†‘Ïƒ') n * Real.fourierChar (-(y * (1 / (2 * Real.pi) * Real.log (â†‘n / x)))) â€¢ Ïˆ y =\n  LSeries.term f (â†‘Ïƒ' + â†‘y * Complex.I) n â€¢ (Ïˆ y * â†‘x ^ (â†‘y * Complex.I))"}
{"name":"limiting_cor","declaration":"theorem limiting_cor {A : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„‚} (Ïˆ : CS 2 â„‚) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - â†‘A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto\n  (fun x =>\n    âˆ‘' (n : â„•), f n / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x)) -\n      â†‘A * âˆ« (u : â„) in Set.Ici (-Real.log x), Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi)))\n  Filter.atTop (nhds 0)"}
{"name":"bound_I2","declaration":"theorem bound_I2 (x : â„) (Ïˆ : W21) : â€–âˆ« (u : â„) in Set.Ici (-Real.log x), Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi))â€– â‰¤\n  W21.norm Ïˆ.toFun * (2 * Real.pi ^ 2)"}
{"name":"summable_fourier","declaration":"theorem summable_fourier {f : â„• â†’ â„‚} (x : â„) (hx : 0 < x) (Ïˆ : W21) (hcheby : cheby f) : Summable fun i => â€–f i / â†‘i * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘i / x))â€–"}
{"name":"decay_bounds_aux","declaration":"theorem decay_bounds_aux {A : â„} {f : â„ â†’ â„‚} (hf : MeasureTheory.AEStronglyMeasurable f MeasureTheory.volume) (h : âˆ€ (t : â„), â€–f tâ€– â‰¤ A * (1 + t ^ 2)â»Â¹) : âˆ« (t : â„), â€–f tâ€– â‰¤ Real.pi * A"}
{"name":"hh_le","declaration":"theorem hh_le (a : â„) (t : â„) (ht : 0 â‰¤ t) : |hh a t| â‰¤ tâ»Â¹"}
{"name":"WienerIkeharaTheorem''","declaration":"theorem WienerIkeharaTheorem'' {A : â„} {F : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (hG : ContinuousOn F {s | 1 â‰¤ s.re}) (hG' : Set.EqOn F (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto (fun N => cumsum f N / â†‘N) Filter.atTop (nhds A)"}
{"name":"smooth_urysohn_support_Ioo","declaration":"theorem smooth_urysohn_support_Ioo {a : â„} {b : â„} {c : â„} {d : â„} (h1 : a < b) (h3 : c < d) : âˆƒ Î¨,\n  ContDiff â„ âŠ¤ Î¨ âˆ§\n    HasCompactSupport Î¨ âˆ§\n      Set.indicator (Set.Icc b c) 1 â‰¤ Î¨ âˆ§ Î¨ â‰¤ Set.indicator (Set.Ioo a d) 1 âˆ§ Function.support Î¨ = Set.Ioo a d"}
{"name":"summable_inv_mul_log_sq","declaration":"theorem summable_inv_mul_log_sq  : Summable fun n => (â†‘n * Real.log â†‘n ^ 2)â»Â¹"}
{"name":"hh_integrable","declaration":"theorem hh_integrable {a : â„} {b : â„} {c : â„} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : MeasureTheory.IntegrableOn (fun t => a * hh b (t / c)) (Set.Ici 0) MeasureTheory.volume"}
{"name":"dirichlet_test'","declaration":"theorem dirichlet_test' {a : â„• â†’ â„} {b : â„• â†’ â„} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hAb : Filter.BoundedAtFilter Filter.atTop (shift (cumsum a) * b)) (hbb : âˆ€á¶  (n : â„•) in Filter.atTop, b (n + 1) â‰¤ b n) (h : Summable (shift (cumsum a) * nnabla b)) : Summable (a * b)"}
{"name":"Finset.sum_shift_back","declaration":"theorem Finset.sum_shift_back {E : Type u_1} [Ring E] {u : â„• â†’ E} {n : â„•} : cumsum u (n + 1) = cumsum u n + u n"}
{"name":"log_mul_add_isBigO_log","declaration":"theorem log_mul_add_isBigO_log {a : â„} (ha : 0 < a) (b : â„) : (fun x => Real.log (a * x + b)) =O[Filter.atTop] Real.log"}
{"name":"toSchwartz_apply","declaration":"theorem toSchwartz_apply (f : â„ â†’ â„‚) {h1 : ContDiff â„ âŠ¤ f} {h2 : âˆ€ (k n : â„•), âˆƒ C, âˆ€ (x : â„), â€–xâ€– ^ k * â€–iteratedFDeriv â„ n f xâ€– â‰¤ C} {x : â„} : { toFun := f, smooth' := h1, decay' := h2 } x = f x"}
{"name":"nnabla","declaration":"def nnabla {Î± : Type u_1} {E : Type u_2} [OfNat Î± 1] [Add Î±] [Sub E] (u : Î± â†’ E) (n : Î±) : E"}
{"name":"Finset.sum_shift_back'","declaration":"theorem Finset.sum_shift_back' {E : Type u_1} [Ring E] {u : â„• â†’ E} : shift (cumsum u) = cumsum u + u"}
{"name":"exists_antitone_of_eventually","declaration":"theorem exists_antitone_of_eventually {u : â„• â†’ â„} (hu : âˆ€á¶  (n : â„•) in Filter.atTop, u (n + 1) â‰¤ u n) : âˆƒ v, Set.range v âŠ† Set.range u âˆ§ Antitone v âˆ§ v =á¶ [Filter.atTop] u"}
{"name":"nnabla_bound_aux2","declaration":"theorem nnabla_bound_aux2 (a : â„) {b : â„} (hb : 0 < b) : âˆ€á¶  (x : â„) in Filter.atTop, 0 < x * (a + Real.log (x / b) ^ 2)"}
{"name":"cheby.bigO","declaration":"theorem cheby.bigO {f : â„• â†’ â„‚} (h : cheby f) : (cumsum fun x => â€–f xâ€–) =O[Filter.atTop] Nat.cast"}
{"name":"WI_tendsto_aux'","declaration":"theorem WI_tendsto_aux' (a : â„) (b : â„) {A : â„} (hA : 0 < A) : Filter.Tendsto (fun c => b - a - c / A) (nhdsWithin (A * (b - a)) (Set.Iio (A * (b - a)))) (nhdsWithin 0 (Set.Ioi 0))"}
{"name":"one_div_two_pi_mem_Ioo","declaration":"theorem one_div_two_pi_mem_Ioo  : 1 / (2 * Real.pi) âˆˆ Set.Ioo (-1) 1"}
{"name":"isLittleO_const_of_tendsto_atTop","declaration":"theorem isLittleO_const_of_tendsto_atTop {Î± : Type u_1} [Preorder Î±] (a : â„) {f : Î± â†’ â„} (hf : Filter.Tendsto f Filter.atTop Filter.atTop) : (fun x => a) =o[Filter.atTop] f"}
{"name":"WienerIkeharaTheorem'","declaration":"theorem WienerIkeharaTheorem' {A : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (hcheby : cheby fun n => â†‘(f n)) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) : Filter.Tendsto (fun N => cumsum f N / â†‘N) Filter.atTop (nhds A)"}
{"name":"summation_by_parts''","declaration":"theorem summation_by_parts'' {E : Type u_1} [Ring E] {a : â„• â†’ E} {b : â„• â†’ E} : shift (cumsum (a * b)) = shift (cumsum a) * b - cumsum (shift (cumsum a) * nabla b)"}
{"name":"second_fourier_aux","declaration":"theorem second_fourier_aux {x : â„} {t : â„} {Ïƒ' : â„} (hx : 0 < x) : -(Complex.exp (-((1 - â†‘Ïƒ' - â†‘t * Complex.I) * â†‘(Real.log x))) / (1 - â†‘Ïƒ' - â†‘t * Complex.I)) =\n  â†‘(x ^ (Ïƒ' - 1)) * (â†‘Ïƒ' + â†‘t * Complex.I - 1)â»Â¹ * â†‘x ^ (â†‘t * Complex.I)"}
{"name":"tendsto_S_S_zero","declaration":"theorem tendsto_S_S_zero {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hcheby : cheby fun n => â†‘(f n)) : TendstoUniformlyOnFilter (S f) (S f 0) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop"}
{"name":"bound_I1","declaration":"theorem bound_I1 {f : â„• â†’ â„‚} (x : â„) (hx : 0 < x) (Ïˆ : W21) (hcheby : cheby f) : â€–âˆ‘' (n : â„•), f n / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x))â€– â‰¤\n  W21.norm Ïˆ.toFun â€¢ âˆ‘' (i : â„•), â€–f iâ€– / â†‘i * (1 + (1 / (2 * Real.pi) * Real.log (â†‘i / x)) ^ 2)â»Â¹"}
{"name":"instCoeForAllRealForAllComplex_1","declaration":"def instCoeForAllRealForAllComplex_1 {E : Type u_1} : Coe (E â†’ â„) (E â†’ â„‚)"}
{"name":"tendsto_mul_add_atTop","declaration":"theorem tendsto_mul_add_atTop {a : â„} (ha : 0 < a) (b : â„) : Filter.Tendsto (fun x => a * x + b) Filter.atTop Filter.atTop"}
{"name":"bound_main","declaration":"theorem bound_main {f : â„• â†’ â„‚} {C : â„} (A : â„‚) (x : â„) (hx : 1 â‰¤ x) (Ïˆ : W21) (hcheby : chebyWith C f) : â€–âˆ‘' (n : â„•), f n / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x)) -\n      A * âˆ« (u : â„) in Set.Ici (-Real.log x), Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi))â€– â‰¤\n  W21.norm Ïˆ.toFun * (C * (1 + 2 * Real.pi ^ 2) + â€–Aâ€– * (2 * Real.pi ^ 2))"}
{"name":"S","declaration":"def S {ğ•œ : Type} [RCLike ğ•œ] (f : â„• â†’ ğ•œ) (Îµ : â„) (N : â„•) : ğ•œ"}
{"name":"second_fourier_integrable_aux1","declaration":"theorem second_fourier_integrable_aux1 {x : â„} {Ïƒ' : â„} {Ïˆ : â„ â†’ â„‚} (hcont : Continuous Ïˆ) (hsupp : MeasureTheory.Integrable Ïˆ MeasureTheory.volume) (hÏƒ : 1 < Ïƒ') : let Î½ := MeasureTheory.Measure.prod (MeasureTheory.volume.restrict (Set.Ici (-Real.log x))) MeasureTheory.volume;\nMeasureTheory.Integrable\n  (Function.uncurry fun u a =>\n    â†‘(Real.exp (-u * (Ïƒ' - 1))) â€¢ â†‘(Real.fourierChar (Multiplicative.ofAdd (-(a * (u / (2 * Real.pi)))))) â€¢ Ïˆ a)\n  Î½"}
{"name":"pp","declaration":"def pp (a : â„) (x : â„) : â„"}
{"name":"pp_deriv","declaration":"theorem pp_deriv (a : â„) (x : â„) : HasDerivAt (pp a) (pp' a x) x"}
{"name":"nabla","declaration":"def nabla {Î± : Type u_1} {E : Type u_2} [OfNat Î± 1] [Add Î±] [Sub E] (u : Î± â†’ E) (n : Î±) : E"}
{"name":"cumsum_succ","declaration":"theorem cumsum_succ {E : Type u_2} [AddCommMonoid E] {u : â„• â†’ E} (n : â„•) : cumsum u (n + 1) = cumsum u n + u n"}
{"name":"log_add_one_sub_log_le","declaration":"theorem log_add_one_sub_log_le {x : â„} (hx : 0 < x) : nabla Real.log x â‰¤ xâ»Â¹"}
{"name":"residue_nonneg","declaration":"theorem residue_nonneg {A : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (hcheby : cheby fun n => â†‘(f n)) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) : 0 â‰¤ A"}
{"name":"hh","declaration":"def hh (a : â„) (t : â„) : â„"}
{"name":"limiting_fourier_lim2_aux","declaration":"theorem limiting_fourier_lim2_aux (x : â„) (C : â„) : MeasureTheory.Integrable (fun t => |x| * (C / (1 + (t / (2 * Real.pi)) ^ 2)))\n  (MeasureTheory.volume.restrict (Set.Ici (-Real.log x)))"}
{"name":"Finset.sum_shift_front'","declaration":"theorem Finset.sum_shift_front' {E : Type u_1} [Ring E] {u : â„• â†’ E} : shift (cumsum u) = (fun x => u 0) + cumsum (shift u)"}
{"name":"first_fourier_aux2a","declaration":"theorem first_fourier_aux2a {n : â„•} {x : â„} {y : â„} : 2 * â†‘Real.pi * -(â†‘y * (1 / (2 * â†‘Real.pi) * â†‘(Real.log (â†‘n / x)))) = -(â†‘y * â†‘(Real.log (â†‘n / x)))"}
{"name":"mem_Ico_iff_div","declaration":"theorem mem_Ico_iff_div {n : â„•} {a : â„} {b : â„} {x : â„} (hx : 0 < x) : n âˆˆ Finset.Ico âŒˆa * xâŒ‰â‚Š âŒˆb * xâŒ‰â‚Š â†” â†‘n / x âˆˆ Set.Ico a b"}
{"name":"Filter.EventuallyEq.summable","declaration":"theorem Filter.EventuallyEq.summable {u : â„• â†’ â„} {v : â„• â†’ â„} (h : u =á¶ [Filter.atTop] v) (hu : Summable v) : Summable u"}
{"name":"cumsum_nonneg","declaration":"theorem cumsum_nonneg {u : â„• â†’ â„} (hu : 0 â‰¤ u) : 0 â‰¤ cumsum u"}
{"name":"nnabla_mul","declaration":"theorem nnabla_mul {Î± : Type u_1} {E : Type u_2} [OfNat Î± 1] [Add Î±] [Ring E] {u : Î± â†’ E} {c : E} : (nnabla fun n => c * u n) = c â€¢ nnabla u"}
{"name":"vonMangoldt_cheby","declaration":"theorem vonMangoldt_cheby  : cheby fun n => â†‘(ArithmeticFunction.vonMangoldt n)"}
{"name":"cancel_aux'","declaration":"theorem cancel_aux' {C : â„} {f : â„• â†’ â„} {g : â„• â†’ â„} (hf : 0 â‰¤ f) (hg : 0 â‰¤ g) (hf' : âˆ€ (n : â„•), cumsum f n â‰¤ C * â†‘n) (hg' : Antitone g) (n : â„•) : (Finset.sum (Finset.range n) fun i => f i * g i) â‰¤\n  C * â†‘n * g (n - 1) + C * cumsum g (n - 1 - 1 + 1) - C * (â†‘(n - 1 - 1) + 1) * g (n - 1)"}
{"name":"decay_bounds_key","declaration":"theorem decay_bounds_key (f : W21) (u : â„) : â€–Real.fourierIntegral f.toFun uâ€– â‰¤ â€–fâ€– * (1 + u ^ 2)â»Â¹"}
{"name":"continuous_FourierIntegral","declaration":"theorem continuous_FourierIntegral (Ïˆ : W21) : Continuous (Real.fourierIntegral Ïˆ.toFun)"}
{"name":"BoundedAtFilter.comp_add","declaration":"theorem BoundedAtFilter.comp_add {u : â„• â†’ â„} {N : â„•} : (Filter.BoundedAtFilter Filter.atTop fun n => u (n + N)) â†” Filter.BoundedAtFilter Filter.atTop u"}
{"name":"le_of_eventually_nhdsWithin","declaration":"theorem le_of_eventually_nhdsWithin {a : â„} {b : â„} (h : âˆ€á¶  (c : â„) in nhdsWithin b (Set.Ioi b), a â‰¤ c) : a â‰¤ b"}
{"name":"nabla_cumsum","declaration":"theorem nabla_cumsum {E : Type u_2} [AddCommGroup E] {u : â„• â†’ E} : nabla (cumsum u) = u"}
{"name":"first_fourier","declaration":"theorem first_fourier {x : â„} {Ïƒ' : â„} {Ïˆ : â„ â†’ â„‚} {f : â„• â†’ â„‚} (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (hcont : Continuous Ïˆ) (hsupp : MeasureTheory.Integrable Ïˆ MeasureTheory.volume) (hx : 0 < x) (hÏƒ : 1 < Ïƒ') : âˆ‘' (n : â„•), LSeries.term f (â†‘Ïƒ') n * Real.fourierIntegral Ïˆ (1 / (2 * Real.pi) * Real.log (â†‘n / x)) =\n  âˆ« (t : â„), LSeries f (â†‘Ïƒ' + â†‘t * Complex.I) * Ïˆ t * â†‘x ^ (â†‘t * Complex.I)"}
{"name":"one_add_sq_pos","declaration":"theorem one_add_sq_pos (u : â„) : 0 < 1 + u ^ 2"}
{"name":"wiener_ikehara_smooth","declaration":"theorem wiener_ikehara_smooth {A : â„} {Î¨ : â„ â†’ â„‚} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„‚} (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (hcheby : cheby f) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - â†‘A / (s - 1)) {s | 1 < s.re}) (hsmooth : ContDiff â„ âŠ¤ Î¨) (hsupp : HasCompactSupport Î¨) (hplus : closure (Function.support Î¨) âŠ† Set.Ioi 0) : Filter.Tendsto (fun x => (âˆ‘' (n : â„•), f n * Î¨ (â†‘n / x)) / â†‘x - â†‘A * âˆ« (y : â„) in Set.Ioi 0, Î¨ y) Filter.atTop (nhds 0)"}
{"name":"W21.integrable_fourier","declaration":"theorem W21.integrable_fourier {c : â„} (Ïˆ : W21) (hc : c â‰  0) : MeasureTheory.Integrable (fun u => Real.fourierIntegral Ïˆ.toFun (u / c)) MeasureTheory.volume"}
{"name":"pp'_deriv","declaration":"theorem pp'_deriv (a : â„) (x : â„) : HasDerivAt (pp' a) (a ^ 2 * 2) x"}
{"name":"decay_bounds_W21","declaration":"theorem decay_bounds_W21 {A : â„} (f : W21) (hA : âˆ€ (t : â„), â€–f.toFun tâ€– â‰¤ A / (1 + t ^ 2)) (hA' : âˆ€ (t : â„), â€–deriv (deriv f.toFun) tâ€– â‰¤ A / (1 + t ^ 2)) (u : â„) : â€–Real.fourierIntegral f.toFun uâ€– â‰¤ (Real.pi + 1 / (4 * Real.pi)) * A / (1 + u ^ 2)"}
{"name":"bound_sum_log'","declaration":"theorem bound_sum_log' {f : â„• â†’ â„‚} {C : â„} (hf : chebyWith C f) {x : â„} (hx : 1 â‰¤ x) : âˆ‘' (i : â„•), â€–f iâ€– / â†‘i * (1 + (1 / (2 * Real.pi) * Real.log (â†‘i / x)) ^ 2)â»Â¹ â‰¤ C * (1 + 2 * Real.pi ^ 2)"}
{"name":"WienerIkeharaInterval","declaration":"theorem WienerIkeharaInterval {A : â„} {a : â„} {b : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (hcheby : cheby fun n => â†‘(f n)) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) (ha : 0 < a) (hb : a â‰¤ b) : Filter.Tendsto (fun x => (âˆ‘' (n : â„•), f n * Set.indicator (Set.Ico a b) 1 (â†‘n / x)) / x) Filter.atTop\n  (nhds (A * (b - a)))"}
{"name":"comp_exp_support","declaration":"theorem comp_exp_support {Î¨ : â„ â†’ â„‚} (hsupp : HasCompactSupport Î¨) (hplus : closure (Function.support Î¨) âŠ† Set.Ioi 0) : HasCompactSupport (Î¨ âˆ˜ Real.exp)"}
{"name":"limiting_fourier_lim1_aux","declaration":"theorem limiting_fourier_lim1_aux {x : â„} {f : â„• â†’ â„‚} (hcheby : cheby f) (hx : 0 < x) (C : â„) (hC : 0 â‰¤ C) : Summable fun n => â€–f nâ€– / â†‘n * (C / (1 + (1 / (2 * Real.pi) * Real.log (â†‘n / x)) ^ 2))"}
{"name":"toSchwartz","declaration":"def toSchwartz (f : â„ â†’ â„‚) (h1 : ContDiff â„ âŠ¤ f) (h2 : HasCompactSupport f) : SchwartzMap â„ â„‚"}
{"name":"smooth_urysohn","declaration":"theorem smooth_urysohn (a : â„) (b : â„) (c : â„) (d : â„) (h1 : a < b) (h3 : c < d) : âˆƒ Î¨, ContDiff â„ âŠ¤ Î¨ âˆ§ HasCompactSupport Î¨ âˆ§ Set.indicator (Set.Icc b c) 1 â‰¤ Î¨ âˆ§ Î¨ â‰¤ Set.indicator (Set.Ioo a d) 1"}
{"name":"quadratic_pos","declaration":"theorem quadratic_pos (a : â„) (b : â„) (c : â„) (x : â„) (ha : 0 < a) (hÎ” : discrim a b c < 0) : 0 < a * x ^ 2 + b * x + c"}
{"name":"hh'","declaration":"def hh' (a : â„) (t : â„) : â„"}
{"name":"summable_congr_ae","declaration":"theorem summable_congr_ae {u : â„• â†’ â„} {v : â„• â†’ â„} (huv : u =á¶ [Filter.atTop] v) : Summable u â†” Summable v"}
{"name":"tendsto_mul_ceil_div","declaration":"/-- A version of the *Wiener-Ikehara Tauberian Theorem*: If `f` is a nonnegative arithmetic\nfunction whose L-series has a simple pole at `s = 1` with residue `A` and otherwise extends\ncontinuously to the closed half-plane `re s â‰¥ 1`, then `âˆ‘ n < N, f n` is asymptotic to `A*N`. -/\ntheorem tendsto_mul_ceil_div  : Filter.Tendsto (fun p => â†‘âŒˆp.1 * â†‘p.2âŒ‰â‚Š / â†‘p.2) (nhdsWithin 0 (Set.Ioi 0) Ã—Ë¢ Filter.atTop) (nhds 0)"}
{"name":"set_integral_ofReal","declaration":"theorem set_integral_ofReal {f : â„ â†’ â„} {s : Set â„} : âˆ« (x : â„) in s, â†‘(f x) = â†‘(âˆ« (x : â„) in s, f x)"}
{"name":"le_floor_mul_iff","declaration":"theorem le_floor_mul_iff {n : â„•} {b : â„} {x : â„} (hb : 0 â‰¤ b) (hx : 0 < x) : n â‰¤ âŒŠb * xâŒ‹â‚Š â†” â†‘n / x â‰¤ b"}
{"name":"hh_integrable_aux","declaration":"theorem hh_integrable_aux {a : â„} {b : â„} {c : â„} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : MeasureTheory.IntegrableOn (fun t => a * hh b (t / c)) (Set.Ici 0) MeasureTheory.volume âˆ§\n  âˆ« (t : â„) in Set.Ioi 0, a * hh b (t / c) = a * c / b * Real.pi"}
{"name":"gg","declaration":"def gg (x : â„) (i : â„) : â„"}
{"name":"exists_trunc","declaration":"def exists_trunc  : trunc"}
{"name":"comp_exp_support0","declaration":"theorem comp_exp_support0 {Î¨ : â„ â†’ â„‚} (hplus : closure (Function.support Î¨) âŠ† Set.Ioi 0) : âˆ€á¶  (x : â„) in nhds 0, Î¨ x = 0"}
{"name":"limiting_fourier_aux","declaration":"theorem limiting_fourier_aux {A : â„} {x : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„‚} (hG' : Set.EqOn G (fun s => LSeries f s - â†‘A / (s - 1)) {s | 1 < s.re}) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (Ïˆ : CS 2 â„‚) (hx : 1 â‰¤ x) (Ïƒ' : â„) (hÏƒ' : 1 < Ïƒ') : âˆ‘' (n : â„•), LSeries.term f (â†‘Ïƒ') n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x)) -\n    â†‘A * â†‘(x ^ (1 - Ïƒ')) *\n      âˆ« (u : â„) in Set.Ici (-Real.log x),\n        â†‘(Real.exp (-u * (Ïƒ' - 1))) * Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi)) =\n  âˆ« (t : â„), G (â†‘Ïƒ' + â†‘t * Complex.I) * Ïˆ.toFun t * â†‘x ^ (â†‘t * Complex.I)"}
{"name":"isLittleO_mul_add_sq","declaration":"theorem isLittleO_mul_add_sq (a : â„) (b : â„) : (fun x => a * x + b) =o[Filter.atTop] fun x => x ^ 2"}
{"name":"isBigO_log_mul_add","declaration":"theorem isBigO_log_mul_add {a : â„} (ha : 0 < a) (b : â„) : Real.log =O[Filter.atTop] fun x => Real.log (a * x + b)"}
{"name":"hh_continuous","declaration":"theorem hh_continuous (a : â„) : ContinuousOn (hh a) (Set.Ioi 0)"}
{"name":"nabla_log","declaration":"theorem nabla_log {b : â„} (hb : 0 < b) : (nabla fun x => Real.log (x / b)) =O[Filter.atTop] fun x => 1 / x"}
{"name":"cancel_aux","declaration":"theorem cancel_aux {C : â„} {f : â„• â†’ â„} {g : â„• â†’ â„} (hf : 0 â‰¤ f) (hg : 0 â‰¤ g) (hf' : âˆ€ (n : â„•), cumsum f n â‰¤ C * â†‘n) (hg' : Antitone g) (n : â„•) : (Finset.sum (Finset.range n) fun i => f i * g i) â‰¤\n  g (n - 1) * (C * â†‘n) +\n    (C * (â†‘(n - 1 - 1) + 1) * g 0 - C * (â†‘(n - 1 - 1) + 1) * g (n - 1) -\n      ((n - 1 - 1) â€¢ (C * g 0) - Finset.sum (Finset.range (n - 1 - 1)) fun x => C * g (x + 1)))"}
{"name":"S_sub_S","declaration":"theorem S_sub_S {ğ•œ : Type} [RCLike ğ•œ] {f : â„• â†’ ğ•œ} {Îµ : â„} {N : â„•} (hÎµ : Îµ â‰¤ 1) : S f 0 N - S f Îµ N = cumsum f âŒˆÎµ * â†‘NâŒ‰â‚Š / â†‘N"}
{"name":"WI_sum_Iab_le","declaration":"theorem WI_sum_Iab_le {a : â„} {b : â„} {x : â„} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) {C : â„} (hcheby : chebyWith C fun n => â†‘(f n)) (hb : 0 < b) (hxb : 2 / b < x) : (âˆ‘' (n : â„•), f n * Set.indicator (Set.Ico a b) 1 (â†‘n / x)) / x â‰¤ C * 2 * b"}
{"name":"hh_deriv","declaration":"theorem hh_deriv (a : â„) {t : â„} (ht : t â‰  0) : HasDerivAt (hh a) (hh' a t) t"}
{"name":"bound_sum_log","declaration":"theorem bound_sum_log {f : â„• â†’ â„‚} {C : â„} (hf0 : f 0 = 0) (hf : chebyWith C f) {x : â„} (hx : 1 â‰¤ x) : âˆ‘' (i : â„•), â€–f iâ€– / â†‘i * (1 + (1 / (2 * Real.pi) * Real.log (â†‘i / x)) ^ 2)â»Â¹ â‰¤\n  C * (1 + âˆ« (t : â„) in Set.Ioi 0, hh (1 / (2 * Real.pi)) t)"}
{"name":"bound_I1'","declaration":"theorem bound_I1' {f : â„• â†’ â„‚} {C : â„} (x : â„) (hx : 1 â‰¤ x) (Ïˆ : W21) (hcheby : chebyWith C f) : â€–âˆ‘' (n : â„•), f n / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x))â€– â‰¤\n  W21.norm Ïˆ.toFun * C * (1 + 2 * Real.pi ^ 2)"}
{"name":"log_add_div_isBigO_log","declaration":"theorem log_add_div_isBigO_log (a : â„) {b : â„} (hb : 0 < b) : (fun x => Real.log ((x + a) / b)) =O[Filter.atTop] fun x => Real.log x"}
{"name":"wiener_ikehara_smooth_aux","declaration":"theorem wiener_ikehara_smooth_aux {Î¨ : â„ â†’ â„‚} (l0 : Continuous Î¨) (hsupp : HasCompactSupport Î¨) (hplus : closure (Function.support Î¨) âŠ† Set.Ioi 0) (x : â„) (hx : 0 < x) : âˆ« (u : â„) in Set.Ioi (-Real.log x), â†‘(Real.exp u) * Î¨ (Real.exp u) = âˆ« (y : â„) in Set.Ioi (1 / x), Î¨ y"}
{"name":"crude_upper_bound","declaration":"theorem crude_upper_bound {A : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (Ïˆ : CS 2 â„‚) (hÏˆpos : âˆ€ (y : â„), 0 â‰¤ (Real.fourierIntegral Ïˆ.toFun y).re âˆ§ (Real.fourierIntegral Ïˆ.toFun y).im = 0) : âˆƒ B,\n  âˆ€ (x : â„),\n    0 < x â†’ â€–âˆ‘' (n : â„•), â†‘(f n) / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x))â€– â‰¤ B"}
{"name":"Asymptotics.IsBigO.add_isLittleO_right","declaration":"theorem Asymptotics.IsBigO.add_isLittleO_right {f : â„ â†’ â„} {g : â„ â†’ â„} (h : g =o[Filter.atTop] f) : f =O[Filter.atTop] (f + g)"}
{"name":"sum_le_integral","declaration":"theorem sum_le_integral {xâ‚€ : â„} {f : â„ â†’ â„} {n : â„•} (hf : AntitoneOn f (Set.Ioc xâ‚€ (xâ‚€ + â†‘n))) (hfi : MeasureTheory.IntegrableOn f (Set.Icc xâ‚€ (xâ‚€ + â†‘n)) MeasureTheory.volume) : (Finset.sum (Finset.range n) fun i => f (xâ‚€ + â†‘(i + 1))) â‰¤ âˆ« (x : â„) in xâ‚€..xâ‚€ + â†‘n, f x"}
{"name":"summable_iff_bounded","declaration":"theorem summable_iff_bounded {u : â„• â†’ â„} (hu : 0 â‰¤ u) : Summable u â†” Filter.BoundedAtFilter Filter.atTop (cumsum u)"}
{"name":"BoundedAtFilter.add_const","declaration":"theorem BoundedAtFilter.add_const {u : â„• â†’ â„} {c : â„} : (Filter.BoundedAtFilter Filter.atTop fun n => u n + c) â†” Filter.BoundedAtFilter Filter.atTop u"}
{"name":"hh'_nonpos","declaration":"theorem hh'_nonpos {a : â„} {x : â„} (ha : a âˆˆ Set.Ioo (-1) 1) : hh' a x â‰¤ 0"}
{"name":"nnabla_bound","declaration":"theorem nnabla_bound (C : â„) {x : â„} (hx : 0 < x) : (nnabla fun n => C / (1 + (Real.log (n / x) / (2 * Real.pi)) ^ 2) / n) =O[Filter.atTop] fun n =>\n  (n ^ 2 * Real.log n ^ 2)â»Â¹"}
{"name":"gg_l1","declaration":"theorem gg_l1 {x : â„} (hx : 0 < x) (n : â„•) : |gg x â†‘n| â‰¤ 1 / â†‘n"}
{"name":"interval_approx_inf","declaration":"theorem interval_approx_inf {a : â„} {b : â„} (ha : 0 < a) (hab : a < b) : âˆ€á¶  (Îµ : â„) in nhdsWithin 0 (Set.Ioi 0),\n  âˆƒ Ïˆ,\n    ContDiff â„ âŠ¤ Ïˆ âˆ§\n      HasCompactSupport Ïˆ âˆ§\n        closure (Function.support Ïˆ) âŠ† Set.Ioi 0 âˆ§\n          Ïˆ â‰¤ Set.indicator (Set.Ico a b) 1 âˆ§ b - a - Îµ â‰¤ âˆ« (y : â„) in Set.Ioi 0, Ïˆ y"}
{"name":"WI_sum_le","declaration":"theorem WI_sum_le {x : â„} {f : â„• â†’ â„} {gâ‚ : â„ â†’ â„} {gâ‚‚ : â„ â†’ â„} (hf : 0 â‰¤ f) (hg : gâ‚ â‰¤ gâ‚‚) (hx : 0 < x) (hgâ‚ : HasCompactSupport gâ‚) (hgâ‚‚ : HasCompactSupport gâ‚‚) : (âˆ‘' (n : â„•), f n * gâ‚ (â†‘n / x)) / x â‰¤ (âˆ‘' (n : â„•), f n * gâ‚‚ (â†‘n / x)) / x"}
{"name":"lt_ceil_mul_iff","declaration":"theorem lt_ceil_mul_iff {n : â„•} {b : â„} {x : â„} (hx : 0 < x) : n < âŒˆb * xâŒ‰â‚Š â†” â†‘n / x < b"}
{"name":"nabla_log_main","declaration":"theorem nabla_log_main  : nabla Real.log =O[Filter.atTop] fun x => 1 / x"}
{"name":"ceil_mul_le_iff","declaration":"theorem ceil_mul_le_iff {n : â„•} {a : â„} {x : â„} (hx : 0 < x) : âŒˆa * xâŒ‰â‚Š â‰¤ n â†” a â‰¤ â†‘n / x"}
{"name":"nnabla_mul_log_sq","declaration":"theorem nnabla_mul_log_sq (a : â„) {b : â„} (hb : 0 < b) : (nabla fun x => x * (a + Real.log (x / b) ^ 2)) =O[Filter.atTop] fun x => Real.log x ^ 2"}
{"name":"isBigO_pow_pow_of_le","declaration":"theorem isBigO_pow_pow_of_le {m : â„•} {n : â„•} (h : m â‰¤ n) : (fun x => x ^ m) =O[Filter.atTop] fun x => x ^ n"}
{"name":"limiting_fourier_lim1","declaration":"theorem limiting_fourier_lim1 {x : â„} {f : â„• â†’ â„‚} (hcheby : cheby f) (Ïˆ : W21) (hx : 0 < x) : Filter.Tendsto\n  (fun Ïƒ' => âˆ‘' (n : â„•), LSeries.term f (â†‘Ïƒ') n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x)))\n  (nhdsWithin 1 (Set.Ioi 1))\n  (nhds (âˆ‘' (n : â„•), f n / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x))))"}
{"name":"chebyWith","declaration":"def chebyWith (C : â„) (f : â„• â†’ â„‚) : Prop"}
{"name":"nnabla_cast","declaration":"theorem nnabla_cast {E : Type u_2} (u : â„ â†’ E) [Sub E] : nnabla u âˆ˜ Nat.cast = nnabla (u âˆ˜ Nat.cast)"}
{"name":"WI_tendsto_aux","declaration":"theorem WI_tendsto_aux (a : â„) (b : â„) {A : â„} (hA : 0 < A) : Filter.Tendsto (fun c => c / A - (b - a)) (nhdsWithin (A * (b - a)) (Set.Ioi (A * (b - a)))) (nhdsWithin 0 (Set.Ioi 0))"}
{"name":"first_fourier_aux1","declaration":"theorem first_fourier_aux1 {Ïˆ : â„ â†’ â„‚} (hÏˆ : Continuous Ïˆ) {x : â„} (n : â„•) : Measurable fun u => â†‘â€–Real.fourierChar (-(u * (1 / (2 * Real.pi) * Real.log (â†‘n / x)))) â€¢ Ïˆ uâ€–â‚Š"}
{"name":"cumsum_zero","declaration":"theorem cumsum_zero {E : Type u_2} [AddCommMonoid E] {u : â„• â†’ E} : cumsum u 0 = 0"}
{"name":"nnabla_bound_aux1","declaration":"theorem nnabla_bound_aux1 (a : â„) {b : â„} (hb : 0 < b) : Filter.Tendsto (fun x => x * (a + Real.log (x / b) ^ 2)) Filter.atTop Filter.atTop"}
{"name":"neg_cumsum","declaration":"theorem neg_cumsum {E : Type u_2} [AddCommGroup E] {u : â„• â†’ E} : -cumsum u = cumsum (-u)"}
{"name":"neg_nabla","declaration":"theorem neg_nabla {Î± : Type u_1} {E : Type u_2} [OfNat Î± 1] [Add Î±] [Ring E] {u : Î± â†’ E} : -nabla u = nnabla u"}
{"name":"cumsum","declaration":"def cumsum {E : Type u_2} [AddCommMonoid E] (u : â„• â†’ E) (n : â„•) : E"}
{"name":"sum_telescopic","declaration":"theorem sum_telescopic (a : â„• â†’ â„) (n : â„•) : (Finset.sum (Finset.range n) fun i => a (i + 1) - a i) = a n - a 0"}
{"name":"limiting_fourier_variant","declaration":"theorem limiting_fourier_variant {A : â„} {x : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (Ïˆ : CS 2 â„‚) (hÏˆpos : âˆ€ (y : â„), 0 â‰¤ (Real.fourierIntegral Ïˆ.toFun y).re âˆ§ (Real.fourierIntegral Ïˆ.toFun y).im = 0) (hx : 1 â‰¤ x) : âˆ‘' (n : â„•), â†‘(f n) / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x)) -\n    â†‘A * âˆ« (u : â„) in Set.Ici (-Real.log x), Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi)) =\n  âˆ« (t : â„), G (1 + â†‘t * Complex.I) * Ïˆ.toFun t * â†‘x ^ (â†‘t * Complex.I)"}
{"name":"WeakPNT","declaration":"theorem WeakPNT  : Filter.Tendsto (fun N => cumsum (â‡‘ArithmeticFunction.vonMangoldt) N / â†‘N) Filter.atTop (nhds 1)"}
{"name":"interval_approx_sup","declaration":"theorem interval_approx_sup {a : â„} {b : â„} (ha : 0 < a) (hab : a < b) : âˆ€á¶  (Îµ : â„) in nhdsWithin 0 (Set.Ioi 0),\n  âˆƒ Ïˆ,\n    ContDiff â„ âŠ¤ Ïˆ âˆ§\n      HasCompactSupport Ïˆ âˆ§\n        closure (Function.support Ïˆ) âŠ† Set.Ioi 0 âˆ§\n          Set.indicator (Set.Ico a b) 1 â‰¤ Ïˆ âˆ§ âˆ« (y : â„) in Set.Ioi 0, Ïˆ y â‰¤ b - a + Îµ"}
{"name":"gg_le_one","declaration":"theorem gg_le_one {x : â„} (i : â„•) : gg x â†‘i â‰¤ 1"}
{"name":"hh_nonneg","declaration":"theorem hh_nonneg (a : â„) {t : â„} (ht : 0 â‰¤ t) : 0 â‰¤ hh a t"}
{"name":"bound_sum_log0","declaration":"theorem bound_sum_log0 {f : â„• â†’ â„‚} {C : â„} (hf : chebyWith C f) {x : â„} (hx : 1 â‰¤ x) : âˆ‘' (i : â„•), â€–f iâ€– / â†‘i * (1 + (1 / (2 * Real.pi) * Real.log (â†‘i / x)) ^ 2)â»Â¹ â‰¤\n  C * (1 + âˆ« (t : â„) in Set.Ioi 0, hh (1 / (2 * Real.pi)) t)"}
{"name":"pp'_deriv_eq","declaration":"theorem pp'_deriv_eq (a : â„) : deriv (pp' a) = fun x => a ^ 2 * 2"}
{"name":"WienerIkeharaInterval_discrete","declaration":"theorem WienerIkeharaInterval_discrete {A : â„} {a : â„} {b : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„} (hpos : 0 â‰¤ f) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm (fun n => â†‘(f n)) Ïƒ')) (hcheby : cheby fun n => â†‘(f n)) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries (fun n => â†‘(f n)) s - â†‘A / (s - 1)) {s | 1 < s.re}) (ha : 0 < a) (hb : a â‰¤ b) : Filter.Tendsto (fun x => (Finset.sum (Finset.Ico âŒˆa * xâŒ‰â‚Š âŒˆb * xâŒ‰â‚Š) fun n => f n) / x) Filter.atTop (nhds (A * (b - a)))"}
{"name":"limiting_fourier","declaration":"theorem limiting_fourier {A : â„} {x : â„} {G : â„‚ â†’ â„‚} {f : â„• â†’ â„‚} (hcheby : cheby f) (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (hG' : Set.EqOn G (fun s => LSeries f s - â†‘A / (s - 1)) {s | 1 < s.re}) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ')) (Ïˆ : CS 2 â„‚) (hx : 1 â‰¤ x) : âˆ‘' (n : â„•), f n / â†‘n * Real.fourierIntegral Ïˆ.toFun (1 / (2 * Real.pi) * Real.log (â†‘n / x)) -\n    â†‘A * âˆ« (u : â„) in Set.Ici (-Real.log x), Real.fourierIntegral Ïˆ.toFun (u / (2 * Real.pi)) =\n  âˆ« (t : â„), G (1 + â†‘t * Complex.I) * Ïˆ.toFun t * â†‘x ^ (â†‘t * Complex.I)"}
{"name":"limiting_cor_aux","declaration":"theorem limiting_cor_aux {f : â„ â†’ â„‚} : Filter.Tendsto (fun x => âˆ« (t : â„), f t * â†‘x ^ (â†‘t * Complex.I)) Filter.atTop (nhds 0)"}
{"name":"nterm","declaration":"def nterm (f : â„• â†’ â„‚) (Ïƒ' : â„) (n : â„•) : â„"}
{"name":"WI_summable","declaration":"theorem WI_summable {x : â„} {f : â„• â†’ â„} {g : â„ â†’ â„} (hg : HasCompactSupport g) (hx : 0 < x) : Summable fun n => f n * g (â†‘n / x)"}
{"name":"nabla_mul","declaration":"theorem nabla_mul {Î± : Type u_1} {E : Type u_2} [OfNat Î± 1] [Add Î±] [Ring E] {u : Î± â†’ E} {c : E} : (nabla fun n => c * u n) = c â€¢ nabla u"}
{"name":"continuous_multiplicative_ofAdd","declaration":"theorem continuous_multiplicative_ofAdd  : Continuous â‡‘Multiplicative.ofAdd"}
{"name":"log_sq_isbigo_mul","declaration":"theorem log_sq_isbigo_mul {a : â„} {b : â„} (hb : 0 < b) : (fun x => Real.log x ^ 2) =O[Filter.atTop] fun x => a + Real.log (x / b) ^ 2"}
{"name":"Finset.sum_shift_front","declaration":"theorem Finset.sum_shift_front {E : Type u_1} [Ring E] {u : â„• â†’ E} {n : â„•} : cumsum u (n + 1) = u 0 + cumsum (shift u) n"}
{"name":"bounded_of_shift","declaration":"theorem bounded_of_shift {u : â„• â†’ â„} (h : Filter.BoundedAtFilter Filter.atTop (shift u)) : Filter.BoundedAtFilter Filter.atTop u"}
{"name":"shift","declaration":"def shift {Î± : Type u_1} {E : Type u_2} [OfNat Î± 1] [Add Î±] (u : Î± â†’ E) (n : Î±) : E"}
{"name":"fourier_surjection_on_schwartz","declaration":"theorem fourier_surjection_on_schwartz (f : SchwartzMap â„ â„‚) : âˆƒ g, Real.fourierIntegral â‡‘g = â‡‘f"}
{"name":"hh_integral'","declaration":"theorem hh_integral'  : âˆ« (t : â„) in Set.Ioi 0, hh (1 / (2 * Real.pi)) t = 2 * Real.pi ^ 2"}
{"name":"wiener_ikehara_smooth_sub","declaration":"theorem wiener_ikehara_smooth_sub {A : â„} {Î¨ : â„ â†’ â„‚} (h1 : MeasureTheory.Integrable Î¨ MeasureTheory.volume) (hplus : closure (Function.support Î¨) âŠ† Set.Ioi 0) : Filter.Tendsto (fun x => (â†‘A * âˆ« (y : â„) in Set.Ioi xâ»Â¹, Î¨ y) - â†‘A * âˆ« (y : â„) in Set.Ioi 0, Î¨ y) Filter.atTop (nhds 0)"}
{"name":"cancel_main","declaration":"theorem cancel_main {C : â„} {f : â„• â†’ â„} {g : â„• â†’ â„} (hf : 0 â‰¤ f) (hg : 0 â‰¤ g) (hf' : âˆ€ (n : â„•), cumsum f n â‰¤ C * â†‘n) (hg' : Antitone g) (n : â„•) (hn : 2 â‰¤ n) : cumsum (f * g) n â‰¤ C * cumsum g n"}
{"name":"tsum_indicator","declaration":"theorem tsum_indicator {a : â„} {b : â„} {x : â„} {f : â„• â†’ â„} (hx : 0 < x) : âˆ‘' (n : â„•), f n * Set.indicator (Set.Ico a b) 1 (â†‘n / x) = Finset.sum (Finset.Ico âŒˆa * xâŒ‰â‚Š âŒˆb * xâŒ‰â‚Š) fun n => f n"}
{"name":"sum_range_succ","declaration":"theorem sum_range_succ (a : â„• â†’ â„) (n : â„•) : (Finset.sum (Finset.range n) fun i => a (i + 1)) = (Finset.sum (Finset.range (n + 1)) fun i => a i) - a 0"}
{"name":"decay_bounds_cor","declaration":"theorem decay_bounds_cor (Ïˆ : W21) : âˆƒ C, âˆ€ (u : â„), â€–Real.fourierIntegral Ïˆ.toFun uâ€– â‰¤ C / (1 + u ^ 2)"}
{"name":"limiting_fourier_lim3","declaration":"theorem limiting_fourier_lim3 {x : â„} {G : â„‚ â†’ â„‚} (hG : ContinuousOn G {s | 1 â‰¤ s.re}) (Ïˆ : CS 2 â„‚) (hx : 1 â‰¤ x) : Filter.Tendsto (fun Ïƒ' => âˆ« (t : â„), G (â†‘Ïƒ' + â†‘t * Complex.I) * Ïˆ.toFun t * â†‘x ^ (â†‘t * Complex.I))\n  (nhdsWithin 1 (Set.Ioi 1)) (nhds (âˆ« (t : â„), G (1 + â†‘t * Complex.I) * Ïˆ.toFun t * â†‘x ^ (â†‘t * Complex.I)))"}
