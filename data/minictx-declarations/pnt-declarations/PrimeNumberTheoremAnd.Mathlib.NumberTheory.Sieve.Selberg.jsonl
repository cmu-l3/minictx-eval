{"name":"SelbergSieve.selbergBoundingSum_pos","declaration":"theorem SelbergSieve.selbergBoundingSum_pos (s : SelbergSieve) : 0 < SelbergSieve.selbergBoundingSum s"}
{"name":"SelbergSieve.selberg_bound_muPlus","declaration":"theorem SelbergSieve.selberg_bound_muPlus (s : SelbergSieve) (n : ℕ) (hn : n ∈ Nat.divisors s.prodPrimes) : |SelbergSieve.selbergMuPlus s n| ≤ 3 ^ ArithmeticFunction.cardDistinctFactors n"}
{"name":"SelbergSieve.selbergBoundingSum_nonneg","declaration":"theorem SelbergSieve.selbergBoundingSum_nonneg (s : SelbergSieve) : 0 ≤ SelbergSieve.selbergBoundingSum s"}
{"name":"SelbergSieve.selbergWeights_mul_mu_nonneg","declaration":"theorem SelbergSieve.selbergWeights_mul_mu_nonneg (s : SelbergSieve) (d : ℕ) (hdP : d ∣ s.prodPrimes) : 0 ≤ SelbergSieve.selbergWeights s d * ↑(ArithmeticFunction.moebius d)"}
{"name":"SelbergSieve.selbergWeights_eq_zero_of_not_dvd","declaration":"theorem SelbergSieve.selbergWeights_eq_zero_of_not_dvd (s : SelbergSieve) {d : ℕ} (hd : ¬d ∣ s.prodPrimes) : SelbergSieve.selbergWeights s d = 0"}
{"name":"SelbergSieve.selberg_bound_simple_mainSum","declaration":"theorem SelbergSieve.selberg_bound_simple_mainSum (s : SelbergSieve) : Sieve.mainSum s.toSieve (SelbergSieve.selbergMuPlus s) = (SelbergSieve.selbergBoundingSum s)⁻¹"}
{"name":"SelbergSieve.selbergWeights_eq_dvds_sum","declaration":"theorem SelbergSieve.selbergWeights_eq_dvds_sum (s : SelbergSieve) (d : ℕ) : s.nu d * SelbergSieve.selbergWeights s d =\n  (SelbergSieve.selbergBoundingSum s)⁻¹ * ↑(ArithmeticFunction.moebius d) *\n    Finset.sum (Nat.divisors s.prodPrimes) fun l =>\n      if d ∣ l ∧ ↑l ^ 2 ≤ s.level then (Sieve.selbergTerms s.toSieve) l else 0"}
{"name":"SelbergSieve.level","declaration":"def SelbergSieve.level (self : SelbergSieve) : ℝ"}
{"name":"SelbergSieve.selberg_bound_weights","declaration":"theorem SelbergSieve.selberg_bound_weights (s : SelbergSieve) (d : ℕ) : |SelbergSieve.selbergWeights s d| ≤ 1"}
{"name":"SelbergSieve.abs_moebius_eq_one_of_squarefree","declaration":"theorem SelbergSieve.abs_moebius_eq_one_of_squarefree {l : ℕ} (hl : Squarefree l) : |ArithmeticFunction.moebius l| = 1"}
{"name":"SelbergSieve.selbergWeights","declaration":"def SelbergSieve.selbergWeights (s : SelbergSieve) : ℕ → ℝ"}
{"name":"SelbergSieve.selbergWeights_eq_zero","declaration":"theorem SelbergSieve.selbergWeights_eq_zero (s : SelbergSieve) (d : ℕ) (hd : ¬↑d ^ 2 ≤ s.level) : SelbergSieve.selbergWeights s d = 0"}
{"name":"SelbergSieve.selbergUbSieve","declaration":"def SelbergSieve.selbergUbSieve (s : SelbergSieve) : Sieve.UpperBoundSieve"}
{"name":"SelbergSieve","declaration":"structure SelbergSieve  : Type"}
{"name":"SelbergSieve.mainSum_eq_diag_quad_form","declaration":"theorem SelbergSieve.mainSum_eq_diag_quad_form (s : SelbergSieve) : Sieve.mainSum s.toSieve (SelbergSieve.selbergMuPlus s) =\n  Finset.sum (Nat.divisors s.prodPrimes) fun l =>\n    1 / (Sieve.selbergTerms s.toSieve) l *\n      (Finset.sum (Nat.divisors s.prodPrimes) fun d => if l ∣ d then s.nu d * SelbergSieve.selbergWeights s d else 0) ^\n        2"}
{"name":"SelbergSieve.selbergBoundingSum_ge","declaration":"theorem SelbergSieve.selbergBoundingSum_ge (s : SelbergSieve) {d : ℕ} (hdP : d ∣ s.prodPrimes) : SelbergSieve.selbergBoundingSum s ≥\n  SelbergSieve.selbergWeights s d * ↑(ArithmeticFunction.moebius d) * SelbergSieve.selbergBoundingSum s"}
{"name":"SelbergSieve.moebius_sq_eq_one_of_squarefree","declaration":"/-- These two are in Mathlib per #10672 -/\ntheorem SelbergSieve.moebius_sq_eq_one_of_squarefree {l : ℕ} (hl : Squarefree l) : ArithmeticFunction.moebius l ^ 2 = 1"}
{"name":"SelbergSieve.weight_one_of_selberg","declaration":"theorem SelbergSieve.weight_one_of_selberg (s : SelbergSieve) : SelbergSieve.selbergWeights s 1 = 1"}
{"name":"SelbergSieve.selbergBoundingSum_ne_zero","declaration":"theorem SelbergSieve.selbergBoundingSum_ne_zero (s : SelbergSieve) : SelbergSieve.selbergBoundingSum s ≠ 0"}
{"name":"SelbergSieve.selbergMuPlus","declaration":"def SelbergSieve.selbergMuPlus (s : SelbergSieve) : ℕ → ℝ"}
{"name":"SelbergSieve.selberg_bound_simple","declaration":"theorem SelbergSieve.selberg_bound_simple (s : SelbergSieve) : Sieve.siftedSum s.toSieve ≤\n  s.totalMass / SelbergSieve.selbergBoundingSum s +\n    Finset.sum (Nat.divisors s.prodPrimes) fun d =>\n      if ↑d ≤ s.level then 3 ^ ArithmeticFunction.cardDistinctFactors d * |Sieve.rem s.toSieve d| else 0"}
{"name":"SelbergSieve.one_le_level","declaration":"def SelbergSieve.one_le_level (self : SelbergSieve) : 1 ≤ self.level"}
{"name":"SelbergSieve.selbergμPlus_eq_zero","declaration":"theorem SelbergSieve.selbergμPlus_eq_zero (s : SelbergSieve) (d : ℕ) (hd : ¬↑d ≤ s.level) : SelbergSieve.selbergMuPlus s d = 0"}
{"name":"SelbergSieve.sum_mul_subst","declaration":"theorem SelbergSieve.sum_mul_subst (k : ℕ) (n : ℕ) {f : ℕ → ℝ} (h : ∀ (l : ℕ), l ∣ n → ¬k ∣ l → f l = 0) : (Finset.sum (Nat.divisors n) fun l => f l) = Finset.sum (Nat.divisors n) fun m => if k * m ∣ n then f (k * m) else 0"}
{"name":"SelbergSieve.selbergWeights_diagonalisation","declaration":"theorem SelbergSieve.selbergWeights_diagonalisation (s : SelbergSieve) (l : ℕ) (hl : l ∈ Nat.divisors s.prodPrimes) : (Finset.sum (Nat.divisors s.prodPrimes) fun d => if l ∣ d then s.nu d * SelbergSieve.selbergWeights s d else 0) =\n  if ↑l ^ 2 ≤ s.level then\n    (Sieve.selbergTerms s.toSieve) l * ↑(ArithmeticFunction.moebius l) * (SelbergSieve.selbergBoundingSum s)⁻¹\n  else 0"}
{"name":"SelbergSieve.eq_gcd_mul_of_dvd_of_coprime","declaration":"theorem SelbergSieve.eq_gcd_mul_of_dvd_of_coprime {k : ℕ} {d : ℕ} {m : ℕ} (hkd : k ∣ d) (hmd : Nat.Coprime m d) (hk : k ≠ 0) : k = Nat.gcd d (k * m)"}
{"name":"SelbergSieve.mk","declaration":"ctor SelbergSieve.mk (toSieve : Sieve) (level : ℝ) (one_le_level : 1 ≤ level) : SelbergSieve"}
{"name":"SelbergSieve.selbergBoundingSum","declaration":"def SelbergSieve.selbergBoundingSum (s : SelbergSieve) : ℝ"}
{"name":"SelbergSieve.selberg_bound_simple_errSum","declaration":"theorem SelbergSieve.selberg_bound_simple_errSum (s : SelbergSieve) : Sieve.errSum s.toSieve (SelbergSieve.selbergMuPlus s) ≤\n  Finset.sum (Nat.divisors s.prodPrimes) fun d =>\n    if ↑d ≤ s.level then 3 ^ ArithmeticFunction.cardDistinctFactors d * |Sieve.rem s.toSieve d| else 0"}
