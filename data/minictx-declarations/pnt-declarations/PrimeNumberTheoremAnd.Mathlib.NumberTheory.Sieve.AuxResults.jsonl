{"name":"Aux.primeDivisors_nonempty","declaration":"theorem Aux.primeDivisors_nonempty (n : ℕ) (hn : 2 ≤ n) : n.primeFactors.Nonempty"}
{"name":"Aux.div_mult_of_dvd_squarefree","declaration":"theorem Aux.div_mult_of_dvd_squarefree (f : ArithmeticFunction ℝ) (h_mult : ArithmeticFunction.IsMultiplicative f) (l : ℕ) (d : ℕ) (hdl : d ∣ l) (hl : Squarefree l) (hd : f d ≠ 0) : f l / f d = f (l / d)"}
{"name":"Aux.inv_antitoneOn_pos","declaration":"theorem Aux.inv_antitoneOn_pos {R : Type u_1} [LinearOrderedField R] : AntitoneOn (fun x => x⁻¹) (Set.Ioi 0)"}
{"name":"Aux.gcd_dvd_mul","declaration":"theorem Aux.gcd_dvd_mul (m : ℕ) (n : ℕ) : Nat.gcd m n ∣ m * n"}
{"name":"Aux.sum_over_dvd_ite","declaration":"theorem Aux.sum_over_dvd_ite {α : Type u_1} [Ring α] {P : ℕ} (hP : P ≠ 0) {n : ℕ} (hn : n ∣ P) {f : ℕ → α} : (Finset.sum (Nat.divisors n) fun d => f d) = Finset.sum (Nat.divisors P) fun d => if d ∣ n then f d else 0"}
{"name":"Aux.sum_inv_le_log","declaration":"theorem Aux.sum_inv_le_log (n : ℕ) (hn : 1 ≤ n) : (Finset.sum (Finset.Icc 1 n) fun d => (↑d)⁻¹) ≤ 1 + Real.log ↑n"}
{"name":"Aux.inv_sub_antitoneOn_gt","declaration":"theorem Aux.inv_sub_antitoneOn_gt {R : Type u_1} [LinearOrderedField R] (c : R) : AntitoneOn (fun x => (x - c)⁻¹) (Set.Ioi c)"}
{"name":"Aux.sum_pow_cardDistinctFactors_div_self_le_log_pow","declaration":"theorem Aux.sum_pow_cardDistinctFactors_div_self_le_log_pow {P : ℕ} {k : ℕ} (x : ℝ) (hx : 1 ≤ x) (hP : Squarefree P) : (Finset.sum (Nat.divisors P) fun d => if ↑d ≤ x then ↑k ^ ArithmeticFunction.cardDistinctFactors d / ↑d else 0) ≤\n  (1 + Real.log x) ^ k"}
{"name":"ArithmeticFunction.IsMultiplicative.prod_factors_of_mult","declaration":"theorem ArithmeticFunction.IsMultiplicative.prod_factors_of_mult (f : ArithmeticFunction ℝ) (h_mult : ArithmeticFunction.IsMultiplicative f) {l : ℕ} (hl : Squarefree l) : (Finset.prod l.primeFactors fun a => f a) = f l"}
{"name":"ArithmeticFunction.IsMultiplicative.mult_lcm_eq_of_ne_zero","declaration":"theorem ArithmeticFunction.IsMultiplicative.mult_lcm_eq_of_ne_zero {R : Type u_1} [CommGroupWithZero R] (f : ArithmeticFunction R) (h_mult : ArithmeticFunction.IsMultiplicative f) (x : ℕ) (y : ℕ) (hf : f (Nat.gcd x y) ≠ 0) : f (Nat.lcm x y) = f x * f y / f (Nat.gcd x y)"}
{"name":"Aux.moebius_inv_dvd_lower_bound_real","declaration":"theorem Aux.moebius_inv_dvd_lower_bound_real {P : ℕ} (hP : Squarefree P) (l : ℕ) (m : ℕ) (hm : m ∣ P) : (Finset.sum (Nat.divisors P) fun d => if l ∣ d ∧ d ∣ m then ↑(ArithmeticFunction.moebius d) else 0) =\n  if l = m then ↑(ArithmeticFunction.moebius l) else 0"}
{"name":"Aux.log_add_one_le_sum_inv","declaration":"theorem Aux.log_add_one_le_sum_inv (n : ℕ) : Real.log ↑(n + 1) ≤ Finset.sum (Finset.Icc 1 n) fun d => (↑d)⁻¹"}
{"name":"Aux.conv_lambda_sq_larger_sum","declaration":"theorem Aux.conv_lambda_sq_larger_sum (f : ℕ → ℕ → ℕ → ℝ) (n : ℕ) : (Finset.sum (Nat.divisors n) fun d =>\n    Finset.sum (Nat.divisors d) fun d1 =>\n      Finset.sum (Nat.divisors d) fun d2 => if d = Nat.lcm d1 d2 then f d1 d2 d else 0) =\n  Finset.sum (Nat.divisors n) fun d =>\n    Finset.sum (Nat.divisors n) fun d1 =>\n      Finset.sum (Nat.divisors n) fun d2 => if d = Nat.lcm d1 d2 then f d1 d2 d else 0"}
{"name":"Aux.log_le_sum_inv","declaration":"theorem Aux.log_le_sum_inv (y : ℝ) (hy : 1 ≤ y) : Real.log y ≤ Finset.sum (Finset.Icc 1 ⌊y⌋₊) fun d => (↑d)⁻¹"}
{"name":"Aux.sum_inv_le_log_real","declaration":"theorem Aux.sum_inv_le_log_real (y : ℝ) (hy : 1 ≤ y) : (Finset.sum (Finset.Icc 1 ⌊y⌋₊) fun d => (↑d)⁻¹) ≤ 1 + Real.log y"}
{"name":"Aux.inv_sub_antitoneOn_Icc","declaration":"theorem Aux.inv_sub_antitoneOn_Icc {R : Type u_1} [LinearOrderedField R] (a : R) (b : R) (c : R) (ha : c < a) : AntitoneOn (fun x => (x - c)⁻¹) (Set.Icc a b)"}
{"name":"Aux.sum_intro","declaration":"theorem Aux.sum_intro {α : Type u_1} {M : Type u_2} [AddCommMonoid M] [DecidableEq α] (s : Finset α) {f : α → M} (d : α) (hd : d ∈ s) : f d = Finset.sum s fun k => if k = d then f k else 0"}
{"name":"Aux.moebius_inv_dvd_lower_bound'","declaration":"theorem Aux.moebius_inv_dvd_lower_bound' {P : ℕ} (hP : Squarefree P) (l : ℕ) (m : ℕ) (hm : m ∣ P) : (Finset.sum (Nat.divisors P) fun d => if l ∣ d ∧ d ∣ m then ArithmeticFunction.moebius d else 0) =\n  if l = m then ArithmeticFunction.moebius l else 0"}
{"name":"Aux.sum_pow_cardDistinctFactors_le_self_mul_log_pow","declaration":"theorem Aux.sum_pow_cardDistinctFactors_le_self_mul_log_pow {P : ℕ} {h : ℕ} (x : ℝ) (hx : 1 ≤ x) (hP : Squarefree P) : (Finset.sum (Nat.divisors P) fun d => if ↑d ≤ x then ↑h ^ ArithmeticFunction.cardDistinctFactors d else 0) ≤\n  x * (1 + Real.log x) ^ h"}
{"name":"Aux.ite_sum_zero","declaration":"theorem Aux.ite_sum_zero {p : Prop} [Decidable p] (s : Finset ℕ) (f : ℕ → ℝ) : (if p then Finset.sum s fun x => f x else 0) = Finset.sum s fun x => if p then f x else 0"}
{"name":"Aux.multiplicative_zero_of_zero_dvd","declaration":"theorem Aux.multiplicative_zero_of_zero_dvd (f : ArithmeticFunction ℝ) (h_mult : ArithmeticFunction.IsMultiplicative f) {m : ℕ} {n : ℕ} (h_sq : Squarefree n) (hmn : m ∣ n) (h_zero : f m = 0) : f n = 0"}
{"name":"Aux.inv_antitoneOn_Icc","declaration":"theorem Aux.inv_antitoneOn_Icc {R : Type u_1} [LinearOrderedField R] (a : R) (b : R) (ha : 0 < a) : AntitoneOn (fun x => x⁻¹) (Set.Icc a b)"}
{"name":"Aux.moebius_inv_dvd_lower_bound","declaration":"theorem Aux.moebius_inv_dvd_lower_bound (l : ℕ) (m : ℕ) (hm : Squarefree m) : (Finset.sum (Nat.divisors m) fun d => if l ∣ d then ArithmeticFunction.moebius d else 0) =\n  if l = m then ArithmeticFunction.moebius l else 0"}
{"name":"Aux.Nat.le_prod","declaration":"theorem Aux.Nat.le_prod {ι : Type u_1} [DecidableEq ι] {f : ι → ℕ} {s : Finset ι} {i : ι} (hi : i ∈ s) (hf : ∀ i ∈ s, f i ≠ 0) : f i ≤ Finset.prod s fun j => f j"}
