{"name":"mem_Rect","declaration":"theorem mem_Rect {z : ℂ} {w : ℂ} (zRe_lt_wRe : z.re ≤ w.re) (zIm_lt_wIm : z.im ≤ w.im) (p : ℂ) : p ∈ Rectangle z w ↔ z.re ≤ p.re ∧ p.re ≤ w.re ∧ z.im ≤ p.im ∧ p.im ≤ w.im"}
{"name":"mapsTo_rectangle_left_re","declaration":"theorem mapsTo_rectangle_left_re (z : ℂ) (w : ℂ) : Set.MapsTo (fun y => ↑z.re + ↑y * Complex.I) (Set.uIcc z.im w.im) (Rectangle z w)"}
{"name":"mapsTo_rectangleBorder_right_re","declaration":"theorem mapsTo_rectangleBorder_right_re (z : ℂ) (w : ℂ) : Set.MapsTo (fun y => ↑w.re + ↑y * Complex.I) (Set.uIcc z.im w.im) (RectangleBorder z w)"}
{"name":"Square_apply","declaration":"theorem Square_apply {c : ℝ} (p : ℂ) (cpos : c > 0) : Square p c = Set.Icc (-c + p.re) (c + p.re) ×ℂ Set.Icc (-c + p.im) (c + p.im)"}
{"name":"Set.ne_left_of_mem_uIoo","declaration":"theorem Set.ne_left_of_mem_uIoo {a : ℝ} {b : ℝ} {c : ℝ} (hc : c ∈ Set.uIoo a b) : c ≠ a"}
{"name":"square_subset_square","declaration":"theorem square_subset_square {p : ℂ} {c₁ : ℝ} {c₂ : ℝ} (hc₁ : 0 < c₁) (hc : c₁ ≤ c₂) : Square p c₁ ⊆ Square p c₂"}
{"name":"Rectangle.symm","declaration":"theorem Rectangle.symm {z : ℂ} {w : ℂ} : Rectangle z w = Rectangle w z"}
{"name":"segment_reProdIm_segment_eq_convexHull","declaration":"/-- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\nof two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\ntheorem segment_reProdIm_segment_eq_convexHull (z : ℂ) (w : ℂ) : Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im = (convexHull ℝ) {z, ↑z.re + ↑w.im * Complex.I, ↑w.re + ↑z.im * Complex.I, w}"}
{"name":"RectangleBorder","declaration":"/-- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z : ℂ) (w : ℂ) : Set ℂ"}
{"name":"horizontalSegment_eq","declaration":"/-- A real segment `[a₁, a₂]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\ntheorem horizontalSegment_eq (a₁ : ℝ) (a₂ : ℝ) (b : ℝ) : (fun x => ↑x + ↑b * Complex.I) '' Set.uIcc a₁ a₂ = Set.uIcc a₁ a₂ ×ℂ {b}"}
{"name":"mapsTo_rectangle_left_im_NoP","declaration":"theorem mapsTo_rectangle_left_im_NoP (z : ℂ) (w : ℂ) {p : ℂ} (pNotOnBorder : p ∉ RectangleBorder z w) : Set.MapsTo (fun x => ↑x + ↑z.im * Complex.I) (Set.uIcc z.re w.re) (Rectangle z w \\ {p})"}
{"name":"mapsTo_rectangleBorder_right_im","declaration":"theorem mapsTo_rectangleBorder_right_im (z : ℂ) (w : ℂ) : Set.MapsTo (fun x => ↑x + ↑w.im * Complex.I) (Set.uIcc z.re w.re) (RectangleBorder z w)"}
{"name":"rectangle_subset_punctured_rect","declaration":"theorem rectangle_subset_punctured_rect {z₀ : ℂ} {z₁ : ℂ} {z₂ : ℂ} {z₃ : ℂ} {p : ℂ} (hz : z₀.re ≤ z₁.re ∧ z₁.re ≤ z₂.re ∧ z₂.re ≤ z₃.re ∧ z₀.im ≤ z₁.im ∧ z₁.im ≤ z₂.im ∧ z₂.im ≤ z₃.im) (hp : p.re < z₁.re ∧ p.re < z₂.re ∨ p.im < z₁.im ∧ p.im < z₂.im ∨ z₁.re < p.re ∧ z₂.re < p.re ∨ z₁.im < p.im ∧ z₂.im < p.im) : Rectangle z₁ z₂ ⊆ Rectangle z₀ z₃ \\ {p}"}
{"name":"rectangleBorder_subset_rectangle","declaration":"theorem rectangleBorder_subset_rectangle (z : ℂ) (w : ℂ) : RectangleBorder z w ⊆ Rectangle z w"}
{"name":"RectSubRect'","declaration":"theorem RectSubRect' {z₀ : ℂ} {z₁ : ℂ} {z₂ : ℂ} {z₃ : ℂ} (x₀_le_x₁ : z₀.re ≤ z₁.re) (x₁_le_x₂ : z₁.re ≤ z₂.re) (x₂_le_x₃ : z₂.re ≤ z₃.re) (y₀_le_y₁ : z₀.im ≤ z₁.im) (y₁_le_y₂ : z₁.im ≤ z₂.im) (y₂_le_y₃ : z₂.im ≤ z₃.im) : Rectangle z₁ z₂ ⊆ Rectangle z₀ z₃"}
{"name":"mapsTo_rectangleBorder_left_im","declaration":"theorem mapsTo_rectangleBorder_left_im (z : ℂ) (w : ℂ) : Set.MapsTo (fun x => ↑x + ↑z.im * Complex.I) (Set.uIcc z.re w.re) (RectangleBorder z w)"}
{"name":"rectangle_mem_nhds_iff","declaration":"theorem rectangle_mem_nhds_iff {z : ℂ} {w : ℂ} {p : ℂ} : Rectangle z w ∈ nhds p ↔ p ∈ Set.uIoo z.re w.re ×ℂ Set.uIoo z.im w.im"}
{"name":"reProdIm_subset_iff'","declaration":"/-- If `s ⊆ s₁ ⊆ ℝ` and `t ⊆ t₁ ⊆ ℝ`, then `s × t ⊆ s₁ × t₁` in `ℂ`. -/\ntheorem reProdIm_subset_iff' {s : Set ℝ} {s₁ : Set ℝ} {t : Set ℝ} {t₁ : Set ℝ} : s ×ℂ t ⊆ s₁ ×ℂ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅"}
{"name":"ContinuousLinearEquiv.coe_toLinearEquiv_symm","declaration":"theorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type u_1} {S : Type u_2} [Semiring R] [Semiring S] {σ : R →+* S} {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] (M : Type u_3) [TopologicalSpace M] [AddCommMonoid M] {M₂ : Type u_4} [TopologicalSpace M₂] [AddCommMonoid M₂] [Module R M] [Module S M₂] (e : M ≃SL[σ] M₂) : ⇑(LinearEquiv.symm e.toLinearEquiv) = ⇑(ContinuousLinearEquiv.symm e)"}
{"name":"SmallSquareInRectangle","declaration":"theorem SmallSquareInRectangle {z : ℂ} {w : ℂ} {p : ℂ} (pInRectInterior : Rectangle z w ∈ nhds p) : ∀ᶠ (c : ℝ) in nhdsWithin 0 (Set.Ioi 0), Square p c ⊆ Rectangle z w"}
{"name":"Set.uIoo","declaration":"def Set.uIoo {α : Type u_1} [Lattice α] (a : α) (b : α) : Set α"}
{"name":"rectangle_disjoint_singleton","declaration":"/-- Note: try using `by simp` for `h`. -/\ntheorem rectangle_disjoint_singleton {z : ℂ} {w : ℂ} {p : ℂ} (h : p.re < z.re ∧ p.re < w.re ∨ p.im < z.im ∧ p.im < w.im ∨ z.re < p.re ∧ w.re < p.re ∨ z.im < p.im ∧ w.im < p.im) : Disjoint (Rectangle z w) {p}"}
{"name":"mapsTo_rectangleBorder_left_re","declaration":"theorem mapsTo_rectangleBorder_left_re (z : ℂ) (w : ℂ) : Set.MapsTo (fun y => ↑z.re + ↑y * Complex.I) (Set.uIcc z.im w.im) (RectangleBorder z w)"}
{"name":"verticalSegment_eq","declaration":"/-- A vertical segment `[b₁, b₂]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\ntheorem verticalSegment_eq (a : ℝ) (b₁ : ℝ) (b₂ : ℝ) : (fun y => ↑a + ↑y * Complex.I) '' Set.uIcc b₁ b₂ = {a} ×ℂ Set.uIcc b₁ b₂"}
{"name":"square_neg","declaration":"theorem square_neg (p : ℂ) (c : ℝ) : Square p (-c) = Square p c"}
{"name":"reProdIm_subset_iff","declaration":"/-- The inequality `s × t ⊆ s₁ × t₁` holds in `ℂ` iff it holds in `ℝ × ℝ`. -/\ntheorem reProdIm_subset_iff {s : Set ℝ} {s₁ : Set ℝ} {t : Set ℝ} {t₁ : Set ℝ} : s ×ℂ t ⊆ s₁ ×ℂ t₁ ↔ s ×ˢ t ⊆ s₁ ×ˢ t₁"}
{"name":"uIoo_of_le","declaration":"theorem uIoo_of_le {α : Type u_1} [Lattice α] {a : α} {b : α} (h : a ≤ b) : Set.uIoo a b = Set.Ioo a b"}
{"name":"preimage_equivRealProdCLM_reProdIm","declaration":"theorem preimage_equivRealProdCLM_reProdIm (s : Set ℝ) (t : Set ℝ) : ⇑(ContinuousLinearEquiv.symm Complex.equivRealProdCLM) ⁻¹' (s ×ℂ t) = s ×ˢ t"}
{"name":"left_mem_rect","declaration":"theorem left_mem_rect (z : ℂ) (w : ℂ) : z ∈ Rectangle z w"}
{"name":"mapsTo_rectangle_left_im","declaration":"theorem mapsTo_rectangle_left_im (z : ℂ) (w : ℂ) : Set.MapsTo (fun x => ↑x + ↑z.im * Complex.I) (Set.uIcc z.re w.re) (Rectangle z w)"}
{"name":"rect_subset_iff","declaration":"theorem rect_subset_iff {z : ℂ} {w : ℂ} {z' : ℂ} {w' : ℂ} : Rectangle z' w' ⊆ Rectangle z w ↔ z' ∈ Rectangle z w ∧ w' ∈ Rectangle z w"}
{"name":"Set.ne_right_of_mem_uIoo","declaration":"theorem Set.ne_right_of_mem_uIoo {a : ℝ} {b : ℝ} {c : ℝ} (hc : c ∈ Set.uIoo a b) : c ≠ b"}
{"name":"Complex.nhds_hasBasis_square","declaration":"theorem Complex.nhds_hasBasis_square (p : ℂ) : Filter.HasBasis (nhds p) (fun x => 0 < x) fun x => Square p x"}
{"name":"right_mem_rect","declaration":"theorem right_mem_rect (z : ℂ) (w : ℂ) : w ∈ Rectangle z w"}
{"name":"rectangleBorder_disjoint_singleton","declaration":"theorem rectangleBorder_disjoint_singleton {z : ℂ} {w : ℂ} {p : ℂ} (h : p.re ≠ z.re ∧ p.re ≠ w.re ∧ p.im ≠ z.im ∧ p.im ≠ w.im) : Disjoint (RectangleBorder z w) {p}"}
{"name":"Set.left_not_mem_uIoo","declaration":"theorem Set.left_not_mem_uIoo {a : ℝ} {b : ℝ} : a ∉ Set.uIoo a b"}
{"name":"square_mem_nhds","declaration":"theorem square_mem_nhds (p : ℂ) {c : ℝ} (hc : c ≠ 0) : Square p c ∈ nhds p"}
{"name":"RectSubRect","declaration":"theorem RectSubRect {x₀ : ℝ} {x₁ : ℝ} {x₂ : ℝ} {x₃ : ℝ} {y₀ : ℝ} {y₁ : ℝ} {y₂ : ℝ} {y₃ : ℝ} (x₀_le_x₁ : x₀ ≤ x₁) (x₁_le_x₂ : x₁ ≤ x₂) (x₂_le_x₃ : x₂ ≤ x₃) (y₀_le_y₁ : y₀ ≤ y₁) (y₁_le_y₂ : y₁ ≤ y₂) (y₂_le_y₃ : y₂ ≤ y₃) : Rectangle (↑x₁ + ↑y₁ * Complex.I) (↑x₂ + ↑y₂ * Complex.I) ⊆ Rectangle (↑x₀ + ↑y₀ * Complex.I) (↑x₃ + ↑y₃ * Complex.I)"}
{"name":"mapsTo_rectangle_right_re","declaration":"theorem mapsTo_rectangle_right_re (z : ℂ) (w : ℂ) : Set.MapsTo (fun y => ↑w.re + ↑y * Complex.I) (Set.uIcc z.im w.im) (Rectangle z w)"}
{"name":"preimage_equivRealProd_prod","declaration":"/-- The preimage under `equivRealProd` of `s ×ˢ t` is `s ×ℂ t`. -/\ntheorem preimage_equivRealProd_prod (s : Set ℝ) (t : Set ℝ) : ⇑Complex.equivRealProd ⁻¹' s ×ˢ t = s ×ℂ t"}
{"name":"Square","declaration":"def Square (p : ℂ) (c : ℝ) : Set ℂ"}
{"name":"rectangle_in_convex","declaration":"/-- If the four corners of a rectangle are contained in a convex set `U`, then the whole\nrectangle is. Golfed from mathlib4\\#9598.-/\ntheorem rectangle_in_convex {U : Set ℂ} (U_convex : Convex ℝ U) {z : ℂ} {w : ℂ} (hz : z ∈ U) (hw : w ∈ U) (hzw : ↑z.re + ↑w.im * Complex.I ∈ U) (hwz : ↑w.re + ↑z.im * Complex.I ∈ U) : Rectangle z w ⊆ U"}
{"name":"not_mem_rectangleBorder_of_rectangle_mem_nhds","declaration":"theorem not_mem_rectangleBorder_of_rectangle_mem_nhds {z : ℂ} {w : ℂ} {p : ℂ} (hp : Rectangle z w ∈ nhds p) : p ∉ RectangleBorder z w"}
{"name":"mapsTo_rectangle_right_im_NoP","declaration":"theorem mapsTo_rectangle_right_im_NoP (z : ℂ) (w : ℂ) {p : ℂ} (pNotOnBorder : p ∉ RectangleBorder z w) : Set.MapsTo (fun x => ↑x + ↑w.im * Complex.I) (Set.uIcc z.re w.re) (Rectangle z w \\ {p})"}
{"name":"mapsTo_rectangle_left_re_NoP","declaration":"theorem mapsTo_rectangle_left_re_NoP (z : ℂ) (w : ℂ) {p : ℂ} (pNotOnBorder : p ∉ RectangleBorder z w) : Set.MapsTo (fun y => ↑z.re + ↑y * Complex.I) (Set.uIcc z.im w.im) (Rectangle z w \\ {p})"}
{"name":"rectangleBorder_subset_punctured_rect","declaration":"theorem rectangleBorder_subset_punctured_rect {z₀ : ℂ} {z₁ : ℂ} {z₂ : ℂ} {z₃ : ℂ} {p : ℂ} (hz : z₀.re ≤ z₁.re ∧ z₁.re ≤ z₂.re ∧ z₂.re ≤ z₃.re ∧ z₀.im ≤ z₁.im ∧ z₁.im ≤ z₂.im ∧ z₂.im ≤ z₃.im) (hp : p.re ≠ z₁.re ∧ p.re ≠ z₂.re ∧ p.im ≠ z₁.im ∧ p.im ≠ z₂.im) : RectangleBorder z₁ z₂ ⊆ Rectangle z₀ z₃ \\ {p}"}
{"name":"Rectangle.symm_re","declaration":"theorem Rectangle.symm_re {z : ℂ} {w : ℂ} : Rectangle (↑w.re + ↑z.im * Complex.I) (↑z.re + ↑w.im * Complex.I) = Rectangle z w"}
{"name":"mapsTo_rectangle_right_re_NoP","declaration":"theorem mapsTo_rectangle_right_re_NoP (z : ℂ) (w : ℂ) {p : ℂ} (pNotOnBorder : p ∉ RectangleBorder z w) : Set.MapsTo (fun y => ↑w.re + ↑y * Complex.I) (Set.uIcc z.im w.im) (Rectangle z w \\ {p})"}
{"name":"Set.right_not_mem_uIoo","declaration":"theorem Set.right_not_mem_uIoo {a : ℝ} {b : ℝ} : b ∉ Set.uIoo a b"}
{"name":"mapsTo_rectangle_right_im","declaration":"theorem mapsTo_rectangle_right_im (z : ℂ) (w : ℂ) : Set.MapsTo (fun x => ↑x + ↑w.im * Complex.I) (Set.uIcc z.re w.re) (Rectangle z w)"}
{"name":"Rectangle","declaration":"/-- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z : ℂ) (w : ℂ) : Set ℂ"}
