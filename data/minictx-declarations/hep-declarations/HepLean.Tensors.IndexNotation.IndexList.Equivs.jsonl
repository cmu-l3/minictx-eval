{"name":"IndexNotation.IndexList.getDualInOtherEquiv","declaration":"/-- An equivalence from `l.withUniqueDualInOther l2 ` to\n`l2.withUniqueDualInOther l` obtained by taking the dual index. -/\ndef IndexNotation.IndexList.getDualInOtherEquiv {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l l2 } ≃\n  { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l2 l }"}
{"name":"IndexNotation.IndexList.withUniqueDualLTEquivGT","declaration":"/-- The equivalence between `l.withUniqueDualLT` and `l.withUniqueDualGT` obtained by\ntaking an index to its dual. -/\ndef IndexNotation.IndexList.withUniqueDualLTEquivGT {X : Type} (l : IndexNotation.IndexList X) : { x // x ∈ IndexNotation.IndexList.withUniqueDualLT l } ≃ { x // x ∈ IndexNotation.IndexList.withUniqueDualGT l }"}
{"name":"IndexNotation.IndexList.getDualEquiv","declaration":"/-- An equivalence from `l.withUniqueDual` to itself obtained by taking the dual index. -/\ndef IndexNotation.IndexList.getDualEquiv {X : Type} (l : IndexNotation.IndexList X) : { x // x ∈ IndexNotation.IndexList.withUniqueDual l } ≃ { x // x ∈ IndexNotation.IndexList.withUniqueDual l }"}
{"name":"IndexNotation.IndexList.withUniqueLTGTEquiv","declaration":"/-- An equivalence from `l.withUniqueDualLT ⊕ l.withUniqueDualLT` to `l.withUniqueDual`.\nThe first `l.withUniqueDualLT` are taken to themselves, whilst the second copy are\ntaken to their dual. -/\ndef IndexNotation.IndexList.withUniqueLTGTEquiv {X : Type} (l : IndexNotation.IndexList X) : { x // x ∈ IndexNotation.IndexList.withUniqueDualLT l } ⊕ { x // x ∈ IndexNotation.IndexList.withUniqueDualLT l } ≃\n  { x // x ∈ IndexNotation.IndexList.withUniqueDual l }"}
{"name":"IndexNotation.IndexList.list_ofFn_withoutDualEquiv_eq_sort","declaration":"theorem IndexNotation.IndexList.list_ofFn_withoutDualEquiv_eq_sort {X : Type} (l : IndexNotation.IndexList X) : List.ofFn (Subtype.val ∘ ⇑(IndexNotation.IndexList.withoutDualEquiv l)) =\n  Finset.sort (fun i j => i ≤ j) (IndexNotation.IndexList.withoutDual l)"}
{"name":"IndexNotation.IndexList.getDualInOtherEquiv_symm","declaration":"theorem IndexNotation.IndexList.getDualInOtherEquiv_symm {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : (IndexNotation.IndexList.getDualInOtherEquiv l l2).symm = IndexNotation.IndexList.getDualInOtherEquiv l2 l"}
{"name":"IndexNotation.IndexList.getDualInOtherEquiv_self_refl","declaration":"theorem IndexNotation.IndexList.getDualInOtherEquiv_self_refl {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : IndexNotation.IndexList.getDualInOtherEquiv l l =\n  Equiv.refl { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l l }"}
{"name":"IndexNotation.IndexList.option_not_lt","declaration":"theorem IndexNotation.IndexList.option_not_lt {X : Type} (l : IndexNotation.IndexList X) (i : Option (Fin (IndexNotation.IndexList.length l))) (j : Option (Fin (IndexNotation.IndexList.length l))) : i < j → i ≠ j → ¬j < i"}
{"name":"IndexNotation.IndexList.getDualInOtherEquiv_cast","declaration":"theorem IndexNotation.IndexList.getDualInOtherEquiv_cast {X : Type} [DecidableEq X] {l1 : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l1' : IndexNotation.IndexList X} {l2' : IndexNotation.IndexList X} (h : l1 = l1') (h2 : l2 = l2') : IndexNotation.IndexList.getDualInOtherEquiv l1 l2 =\n  ((IndexNotation.IndexList.withUniqueDualCast h h2).trans (IndexNotation.IndexList.getDualInOtherEquiv l1' l2')).trans\n    (IndexNotation.IndexList.withUniqueDualCast h2 h).symm"}
{"name":"List.ext_get_iff","declaration":"theorem List.ext_get_iff {α : Type u_1} {l₁ : List α} {l₂ : List α} : l₁ = l₂ ↔\n  List.length l₁ = List.length l₂ ∧\n    ∀ (n : ℕ) (h₁ : n < List.length l₁) (h₂ : n < List.length l₂),\n      List.get l₁ { val := n, isLt := h₁ } = List.get l₂ { val := n, isLt := h₂ }"}
{"name":"IndexNotation.IndexList.getDualInOtherEquiv_cast_right","declaration":"theorem IndexNotation.IndexList.getDualInOtherEquiv_cast_right {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (l3 : IndexNotation.IndexList X) (h : l2 = l3) : IndexNotation.IndexList.getDualInOtherEquiv l l2 =\n  ((IndexNotation.IndexList.withUniqueDualCastRight l l2 l3 h).trans\n        (IndexNotation.IndexList.getDualInOtherEquiv l l3)).trans\n    (IndexNotation.IndexList.withUniqueDualCastLeft l2 l l3 h).symm"}
{"name":"IndexNotation.IndexList.withUniqueDualCast","declaration":"/-- An equivalence casting `withUniqueDualInOther` based on an equality of both index lists. -/\ndef IndexNotation.IndexList.withUniqueDualCast {X : Type} {l1 : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l1' : IndexNotation.IndexList X} {l2' : IndexNotation.IndexList X} (h : l1 = l1') (h2 : l2 = l2') : { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l1 l2 } ≃\n  { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l1' l2' }"}
{"name":"IndexNotation.IndexList.getDual?_getDualEquiv","declaration":"theorem IndexNotation.IndexList.getDual?_getDualEquiv {X : Type} (l : IndexNotation.IndexList X) (i : { x // x ∈ IndexNotation.IndexList.withUniqueDual l }) : IndexNotation.IndexList.getDual? l ↑((IndexNotation.IndexList.getDualEquiv l) i) = some ↑i"}
{"name":"List.getElem_ofFn","declaration":"theorem List.getElem_ofFn {α : Type u_1} {n : ℕ} (f : Fin n → α) (i : ℕ) (h : i < List.length (List.ofFn f)) : (List.ofFn f)[i] = f { val := i, isLt := ⋯ }"}
{"name":"IndexNotation.IndexList.lt_option_of_not","declaration":"theorem IndexNotation.IndexList.lt_option_of_not {X : Type} (l : IndexNotation.IndexList X) (i : Option (Fin (IndexNotation.IndexList.length l))) (j : Option (Fin (IndexNotation.IndexList.length l))) : ¬j < i → i ≠ j → i < j"}
{"name":"IndexNotation.IndexList.withUniqueDualCastRight","declaration":"/-- An equivalence casting `withUniqueDualInOther` based on an equality of the right index list. -/\ndef IndexNotation.IndexList.withUniqueDualCastRight {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (l3 : IndexNotation.IndexList X) (h : l2 = l3) : { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l l2 } ≃\n  { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l l3 }"}
{"name":"IndexNotation.IndexList.getDualInOtherEquiv_cast_left","declaration":"theorem IndexNotation.IndexList.getDualInOtherEquiv_cast_left {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (l3 : IndexNotation.IndexList X) (h : l = l3) : IndexNotation.IndexList.getDualInOtherEquiv l l2 =\n  ((IndexNotation.IndexList.withUniqueDualCastLeft l l2 l3 h).trans\n        (IndexNotation.IndexList.getDualInOtherEquiv l3 l2)).trans\n    (IndexNotation.IndexList.withUniqueDualCastRight l2 l l3 h).symm"}
{"name":"IndexNotation.IndexList.withoutDualEquiv","declaration":"/-- An equivalence from `Fin l.withoutDual.card` to `l.withoutDual` determined by\nthe order on `l.withoutDual` inherted from `Fin`. -/\ndef IndexNotation.IndexList.withoutDualEquiv {X : Type} (l : IndexNotation.IndexList X) : Fin (IndexNotation.IndexList.withoutDual l).card ≃ { x // x ∈ IndexNotation.IndexList.withoutDual l }"}
{"name":"IndexNotation.IndexList.withUniqueDualCastLeft","declaration":"/-- An equivalence casting `withUniqueDualInOther` based on an equality of the left index list. -/\ndef IndexNotation.IndexList.withUniqueDualCastLeft {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (l3 : IndexNotation.IndexList X) (h : l = l3) : { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l l2 } ≃\n  { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l3 l2 }"}
{"name":"IndexNotation.IndexList.dualEquiv","declaration":"/-- An equivalence splitting the indices of an index list `l` into those indices\nwhich have a dual in `l` and those which do not have a dual in `l`. -/\ndef IndexNotation.IndexList.dualEquiv {X : Type} (l : IndexNotation.IndexList X) : { x // x ∈ IndexNotation.IndexList.withDual l } ⊕ Fin (IndexNotation.IndexList.withoutDual l).card ≃\n  Fin (IndexNotation.IndexList.length l)"}
