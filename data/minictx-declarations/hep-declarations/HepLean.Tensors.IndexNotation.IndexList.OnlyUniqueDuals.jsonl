{"name":"IndexNotation.IndexList.OnlyUniqueDuals.iff_countId_leq_two","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.iff_countId_leq_two {X : Type} {l : IndexNotation.IndexList X} : IndexNotation.IndexList.OnlyUniqueDuals l ↔\n  ∀ (i : Fin (List.length l.val)), IndexNotation.IndexList.countId l (List.get l.val i) ≤ 2"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.contrIndexList_left","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.contrIndexList_left {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h1 : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) : IndexNotation.IndexList.OnlyUniqueDuals (IndexNotation.IndexList.contrIndexList l ++ l2)"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.contrIndexList","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.contrIndexList {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} (h : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.OnlyUniqueDuals (IndexNotation.IndexList.contrIndexList l)"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.symm'","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.symm' {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) : IndexNotation.IndexList.OnlyUniqueDuals (l2 ++ l)"}
{"name":"IndexNotation.IndexList.countId_eq_two_ofcontrIndexList_left_of_OnlyUniqueDuals","declaration":"theorem IndexNotation.IndexList.countId_eq_two_ofcontrIndexList_left_of_OnlyUniqueDuals {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (h : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (I : IndexNotation.Index X) (h' : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l ++ l2) I = 2) : IndexNotation.IndexList.countId (l ++ l2) I = 2"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.iff_unique_forall","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.iff_unique_forall {X : Type} {l : IndexNotation.IndexList X} : IndexNotation.IndexList.OnlyUniqueDuals l ↔\n  ∀ (i : { x // x ∈ IndexNotation.IndexList.withDual l }) (j : Fin (IndexNotation.IndexList.length l)),\n    IndexNotation.IndexList.AreDualInSelf l (↑i) j → some j = IndexNotation.IndexList.getDual? l ↑i"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.iff_countId_leq_two'","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.iff_countId_leq_two' {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} : IndexNotation.IndexList.OnlyUniqueDuals l ↔ ∀ (I : IndexNotation.Index X), IndexNotation.IndexList.countId l I ≤ 2"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.symm","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.symm {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2) ↔ IndexNotation.IndexList.OnlyUniqueDuals (l2 ++ l)"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals","declaration":"/-- The conditon on an index list which is true if and only if for every index with a dual,\nthat dual is unique. -/\ndef IndexNotation.IndexList.OnlyUniqueDuals {X : Type} (l : IndexNotation.IndexList X) : Prop"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.inl","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.inl {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) : IndexNotation.IndexList.OnlyUniqueDuals l"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.inr","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.inr {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) : IndexNotation.IndexList.OnlyUniqueDuals l2"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.swap","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.swap {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l3 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2 ++ l3)) : IndexNotation.IndexList.OnlyUniqueDuals (l2 ++ l ++ l3)"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.contrIndexList_append","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.contrIndexList_append {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h1 : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) : IndexNotation.IndexList.OnlyUniqueDuals\n  (IndexNotation.IndexList.contrIndexList l ++ IndexNotation.IndexList.contrIndexList l2)"}
{"name":"IndexNotation.IndexList.countId_of_OnlyUniqueDuals","declaration":"theorem IndexNotation.IndexList.countId_of_OnlyUniqueDuals {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (h : IndexNotation.IndexList.OnlyUniqueDuals l) (I : IndexNotation.Index X) : IndexNotation.IndexList.countId l I ≤ 2"}
{"name":"IndexNotation.IndexList.OnlyUniqueDuals.contrIndexList_right","declaration":"theorem IndexNotation.IndexList.OnlyUniqueDuals.contrIndexList_right {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h1 : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) : IndexNotation.IndexList.OnlyUniqueDuals (l ++ IndexNotation.IndexList.contrIndexList l2)"}
