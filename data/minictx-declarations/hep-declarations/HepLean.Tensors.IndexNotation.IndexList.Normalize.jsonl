{"name":"IndexNotation.IndexList.normalize_length_eq_of_eq_length","declaration":"theorem IndexNotation.IndexList.normalize_length_eq_of_eq_length {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (h : IndexNotation.IndexList.length l = IndexNotation.IndexList.length l2) : IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l) =\n  IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l2)"}
{"name":"IndexNotation.IndexList.GetDualCast.idMap_eq_of","declaration":"theorem IndexNotation.IndexList.GetDualCast.idMap_eq_of {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l)) (hm : IndexNotation.IndexList.idMap l i = IndexNotation.IndexList.idMap l j) : IndexNotation.IndexList.idMap l2 (Fin.cast ⋯ i) = IndexNotation.IndexList.idMap l2 (Fin.cast ⋯ j)"}
{"name":"IndexNotation.IndexList.GetDualCast","declaration":"/-- Two `IndexList`s are related by `GetDualCast` if they are the same length,\nand have the same dual structure.\n\nFor example, `['ᵘ¹', 'ᵘ²', 'ᵤ₁']` and `['ᵤ₄', 'ᵘ⁵', 'ᵤ₄']` are related by `GetDualCast`,\nbut `['ᵘ¹', 'ᵘ²', 'ᵤ₁']` and `['ᵘ¹', 'ᵘ²', 'ᵤ₃']` are not. -/\ndef IndexNotation.IndexList.GetDualCast {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Prop"}
{"name":"IndexNotation.IndexList.normalize_countId","declaration":"theorem IndexNotation.IndexList.normalize_countId {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l))) : IndexNotation.IndexList.countId (IndexNotation.IndexList.normalize l) (IndexNotation.IndexList.normalize l).val[↑i] =\n  IndexNotation.IndexList.countId l (List.get l.val { val := ↑i, isLt := ⋯ })"}
{"name":"IndexNotation.IndexList.GetDualCast.countId_cast","declaration":"theorem IndexNotation.IndexList.GetDualCast.countId_cast {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.countId l (List.get l.val i) =\n  IndexNotation.IndexList.countId l2 (List.get l2.val (Fin.cast ⋯ i))"}
{"name":"IndexNotation.IndexList.GetDualCast.areDualInSelf_iff","declaration":"theorem IndexNotation.IndexList.GetDualCast.areDualInSelf_iff {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.AreDualInSelf l i j ↔ IndexNotation.IndexList.AreDualInSelf l2 (Fin.cast ⋯ i) (Fin.cast ⋯ j)"}
{"name":"IndexNotation.IndexList.idListFin","declaration":"/-- The list of elements of `Fin l.length` `i` is in `idListFin` if\n`l.idMap i` appears for the first time in the `i`th spot.\n\nFor example, for the list `['ᵘ¹', 'ᵘ²', 'ᵤ₁']` the `idListFin` is `[0, 1]`.\n-/\ndef IndexNotation.IndexList.idListFin {X : Type} (l : IndexNotation.IndexList X) : List (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.GetDualCast.idMap_eq_iff","declaration":"theorem IndexNotation.IndexList.GetDualCast.idMap_eq_iff {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.idMap l i = IndexNotation.IndexList.idMap l j ↔\n  IndexNotation.IndexList.idMap l2 (Fin.cast ⋯ i) = IndexNotation.IndexList.idMap l2 (Fin.cast ⋯ j)"}
{"name":"IndexNotation.IndexList.normalize_countId'","declaration":"theorem IndexNotation.IndexList.normalize_countId' {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (hi : ↑i < IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l)) : IndexNotation.IndexList.countId (IndexNotation.IndexList.normalize l) (IndexNotation.IndexList.normalize l).val[↑i] =\n  IndexNotation.IndexList.countId l (List.get l.val i)"}
{"name":"IndexNotation.IndexList.normalize_filter_countId_not_eq_one","declaration":"theorem IndexNotation.IndexList.normalize_filter_countId_not_eq_one {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : List.map IndexNotation.Index.id\n    (List.filter (fun I => decide ¬IndexNotation.IndexList.countId (IndexNotation.IndexList.normalize l) I = 1)\n      (IndexNotation.IndexList.normalize l).val) =\n  List.map (fun a => List.indexOf a (IndexNotation.IndexList.idList l))\n    (List.map IndexNotation.Index.id (List.filter (fun I => decide ¬IndexNotation.IndexList.countId l I = 1) l.val))"}
{"name":"IndexNotation.IndexList.self_reindexing_normalize","declaration":"theorem IndexNotation.IndexList.self_reindexing_normalize {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : IndexNotation.IndexList.Reindexing l (IndexNotation.IndexList.normalize l)"}
{"name":"IndexNotation.IndexList.Reindexing.iff_normalize","declaration":"theorem IndexNotation.IndexList.Reindexing.iff_normalize {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} : IndexNotation.IndexList.Reindexing l l2 ↔ IndexNotation.IndexList.normalize l = IndexNotation.IndexList.normalize l2"}
{"name":"IndexNotation.IndexList.normalize_idMap_apply","declaration":"theorem IndexNotation.IndexList.normalize_idMap_apply {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l))) : IndexNotation.IndexList.idMap (IndexNotation.IndexList.normalize l) i =\n  List.indexOf (IndexNotation.Index.id (List.get l.val { val := ↑i, isLt := ⋯ })) (IndexNotation.IndexList.idList l)"}
{"name":"IndexNotation.IndexList.normalize_colorMap_eq_of_eq_colorMap","declaration":"theorem IndexNotation.IndexList.normalize_colorMap_eq_of_eq_colorMap {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (h : IndexNotation.IndexList.length l = IndexNotation.IndexList.length l2) (hc : IndexNotation.IndexList.colorMap l = IndexNotation.IndexList.colorMap l2 ∘ Fin.cast h) : IndexNotation.IndexList.colorMap (IndexNotation.IndexList.normalize l) =\n  IndexNotation.IndexList.colorMap (IndexNotation.IndexList.normalize l2) ∘ Fin.cast ⋯"}
{"name":"IndexNotation.IndexList.idList_indexOf_mem","declaration":"theorem IndexNotation.IndexList.idList_indexOf_mem {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} {J : IndexNotation.Index X} (hI : I ∈ l.val) (hJ : J ∈ l.val) : List.indexOf (IndexNotation.Index.id I) (IndexNotation.IndexList.idList l) =\n    List.indexOf (IndexNotation.Index.id J) (IndexNotation.IndexList.idList l) ↔\n  IndexNotation.Index.id I = IndexNotation.Index.id J"}
{"name":"IndexNotation.IndexList.GetDualCast.symm","declaration":"theorem IndexNotation.IndexList.GetDualCast.symm {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) : IndexNotation.IndexList.GetDualCast l2 l"}
{"name":"IndexNotation.IndexList.Reindexing.trans","declaration":"theorem IndexNotation.IndexList.Reindexing.trans {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l3 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.Reindexing l l2) (h' : IndexNotation.IndexList.Reindexing l2 l3) : IndexNotation.IndexList.Reindexing l l3"}
{"name":"IndexNotation.IndexList.Reindexing","declaration":"/-- Two `ColorIndexList` are said to be reindexes of one another if they:\n1. have the same length.\n2. every corresponding index has the same color, and duals which correspond.\n\nNote: This does not allow for reordering of indices.\n-/\ndef IndexNotation.IndexList.Reindexing {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Prop"}
{"name":"IndexNotation.IndexList.idMap_mem_idList","declaration":"theorem IndexNotation.IndexList.idMap_mem_idList {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.idMap l i ∈ IndexNotation.IndexList.idList l"}
{"name":"IndexNotation.IndexList.indexOf_map","declaration":"theorem IndexNotation.IndexList.indexOf_map {α : Type} [DecidableEq α] (f : α → ℕ) (l : List α) (n : α) (hf : ∀ I ∈ l, ∀ (J : α), f I = f J ↔ I = J) : List.indexOf n l = List.indexOf (f n) (List.map f l)"}
{"name":"IndexNotation.IndexList.normalize_eq_map","declaration":"theorem IndexNotation.IndexList.normalize_eq_map {X : Type} (l : IndexNotation.IndexList X) : (IndexNotation.IndexList.normalize l).val =\n  List.map\n    (fun I =>\n      (IndexNotation.Index.toColor I, List.indexOf (IndexNotation.Index.id I) (IndexNotation.IndexList.idList l)))\n    l.val"}
{"name":"IndexNotation.IndexList.indexOf_map'","declaration":"theorem IndexNotation.IndexList.indexOf_map' {α : Type} [DecidableEq α] (f : α → ℕ) (g : α → α) (l : List α) (n : α) (hf : ∀ I ∈ l, ∀ (J : α), f I = f J ↔ g I = g J) (hg : ∀ I ∈ l, g I = I) (hs : ∀ (I : α), f I = f (g I)) : List.indexOf (g n) l = List.indexOf (f n) (List.map f l)"}
{"name":"IndexNotation.IndexList.Reindexing.refl","declaration":"theorem IndexNotation.IndexList.Reindexing.refl {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : IndexNotation.IndexList.Reindexing l l"}
{"name":"IndexNotation.IndexList.GetDualCast.trans","declaration":"theorem IndexNotation.IndexList.GetDualCast.trans {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l3 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (h' : IndexNotation.IndexList.GetDualCast l2 l3) : IndexNotation.IndexList.GetDualCast l l3"}
{"name":"IndexNotation.IndexList.GetDualCast.refl","declaration":"theorem IndexNotation.IndexList.GetDualCast.refl {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.GetDualCast l l"}
{"name":"IndexNotation.IndexList.self_getDualCast_normalize","declaration":"theorem IndexNotation.IndexList.self_getDualCast_normalize {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : IndexNotation.IndexList.GetDualCast l (IndexNotation.IndexList.normalize l)"}
{"name":"IndexNotation.IndexList.GetDualCast.iff_normalize","declaration":"theorem IndexNotation.IndexList.GetDualCast.iff_normalize {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} : IndexNotation.IndexList.GetDualCast l l2 ↔\n  IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l) =\n      IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l2) ∧\n    ∀\n      (h :\n        IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l) =\n          IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l2)),\n      IndexNotation.IndexList.idMap (IndexNotation.IndexList.normalize l) =\n        IndexNotation.IndexList.idMap (IndexNotation.IndexList.normalize l2) ∘ Fin.cast h"}
{"name":"IndexNotation.IndexList.dedup_map_of_injective'","declaration":"theorem IndexNotation.IndexList.dedup_map_of_injective' {α : Type} [DecidableEq α] (f : α → ℕ) (l : List α) (hf : ∀ I ∈ l, ∀ J ∈ l, f I = f J ↔ I = J) : List.dedup (List.map f l) = List.map f (List.dedup l)"}
{"name":"IndexNotation.IndexList.normalize","declaration":"/-- Given an index list `l`, the corresponding index list where id's are set to\nsequentially lowest values.\n\nE.g. on `['ᵘ¹', 'ᵘ³', 'ᵤ₁']` this gives `['ᵘ⁰', 'ᵘ¹', 'ᵤ₀']`.\n\n-/\ndef IndexNotation.IndexList.normalize {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList X"}
{"name":"IndexNotation.IndexList.normalize_length","declaration":"theorem IndexNotation.IndexList.normalize_length {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.length (IndexNotation.IndexList.normalize l) = IndexNotation.IndexList.length l"}
{"name":"IndexNotation.IndexList.Reindexing.symm","declaration":"theorem IndexNotation.IndexList.Reindexing.symm {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.Reindexing l l2) : IndexNotation.IndexList.Reindexing l2 l"}
{"name":"IndexNotation.IndexList.GetDualCast.to_normalize","declaration":"theorem IndexNotation.IndexList.GetDualCast.to_normalize {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) : IndexNotation.IndexList.GetDualCast (IndexNotation.IndexList.normalize l) (IndexNotation.IndexList.normalize l2)"}
{"name":"IndexNotation.IndexList.GetDualCast.getDualInOther?_get","declaration":"theorem IndexNotation.IndexList.GetDualCast.getDualInOther?_get {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) : Option.get (IndexNotation.IndexList.getDualInOther? l l i) ⋯ =\n  Fin.cast ⋯ (Option.get (IndexNotation.IndexList.getDualInOther? l2 l2 (Fin.cast ⋯ i)) ⋯)"}
{"name":"IndexNotation.IndexList.GetDualCast.getDual?_get","declaration":"theorem IndexNotation.IndexList.GetDualCast.getDual?_get {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) (h1 : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : Option.get (IndexNotation.IndexList.getDual? l i) h1 =\n  Fin.cast ⋯ (Option.get (IndexNotation.IndexList.getDual? l2 (Fin.cast ⋯ i)) ⋯)"}
{"name":"IndexNotation.IndexList.normalize_countId_mem","declaration":"theorem IndexNotation.IndexList.normalize_countId_mem {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) (h : I ∈ l.val) : IndexNotation.IndexList.countId (IndexNotation.IndexList.normalize l)\n    (IndexNotation.Index.toColor I, List.indexOf (IndexNotation.Index.id I) (IndexNotation.IndexList.idList l)) =\n  IndexNotation.IndexList.countId l I"}
{"name":"IndexNotation.IndexList.GetDualCast.getDual?_isSome_iff","declaration":"theorem IndexNotation.IndexList.GetDualCast.getDual?_isSome_iff {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) : Option.isSome (IndexNotation.IndexList.getDual? l i) = true ↔\n  Option.isSome (IndexNotation.IndexList.getDual? l2 (Fin.cast ⋯ i)) = true"}
{"name":"IndexNotation.IndexList.GetDualCast.areDualInSelf_of","declaration":"theorem IndexNotation.IndexList.GetDualCast.areDualInSelf_of {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l)) (hA : IndexNotation.IndexList.AreDualInSelf l i j) : IndexNotation.IndexList.AreDualInSelf l2 (Fin.cast ⋯ i) (Fin.cast ⋯ j)"}
{"name":"IndexNotation.IndexList.normalize_reindexing_self","declaration":"theorem IndexNotation.IndexList.normalize_reindexing_self {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : IndexNotation.IndexList.Reindexing (IndexNotation.IndexList.normalize l) l"}
{"name":"IndexNotation.IndexList.colorMap_normalize","declaration":"theorem IndexNotation.IndexList.colorMap_normalize {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.colorMap l = IndexNotation.IndexList.colorMap (IndexNotation.IndexList.normalize l) ∘ Fin.cast ⋯"}
{"name":"List.getElem_map","declaration":"theorem List.getElem_map {α : Type u_1} {β : Type u_2} (f : α → β) {l : List α} {n : ℕ} {h : n < List.length (List.map f l)} : (List.map f l)[n] = f l[n]"}
{"name":"IndexNotation.IndexList.idList","declaration":"/-- The list of ids keeping only the first appearance of each id. -/\ndef IndexNotation.IndexList.idList {X : Type} (l : IndexNotation.IndexList X) : List ℕ"}
{"name":"IndexNotation.IndexList.GetDualCast.normalize_idMap_eq","declaration":"theorem IndexNotation.IndexList.GetDualCast.normalize_idMap_eq {X : Type} [DecidableEq X] {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) : IndexNotation.IndexList.idMap (IndexNotation.IndexList.normalize l) =\n  IndexNotation.IndexList.idMap (IndexNotation.IndexList.normalize l2) ∘ Fin.cast ⋯"}
{"name":"List.ext_get_iff'","declaration":"theorem List.ext_get_iff' {α : Type u_1} {l₁ : List α} {l₂ : List α} : l₁ = l₂ ↔\n  List.length l₁ = List.length l₂ ∧\n    ∀ (n : ℕ) (h₁ : n < List.length l₁) (h₂ : n < List.length l₂),\n      List.get l₁ { val := n, isLt := h₁ } = List.get l₂ { val := n, isLt := h₂ }"}
{"name":"IndexNotation.IndexList.normalize_normalize","declaration":"theorem IndexNotation.IndexList.normalize_normalize {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : IndexNotation.IndexList.normalize (IndexNotation.IndexList.normalize l) = IndexNotation.IndexList.normalize l"}
{"name":"IndexNotation.IndexList.Reindexing.iff_getDualCast","declaration":"theorem IndexNotation.IndexList.Reindexing.iff_getDualCast {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} : IndexNotation.IndexList.Reindexing l l2 ↔\n  IndexNotation.IndexList.GetDualCast l l2 ∧\n    ∀ (h : IndexNotation.IndexList.length l = IndexNotation.IndexList.length l2),\n      IndexNotation.IndexList.colorMap l = IndexNotation.IndexList.colorMap l2 ∘ Fin.cast h"}
{"name":"IndexNotation.IndexList.GetDualCast.idListFin_cast","declaration":"theorem IndexNotation.IndexList.GetDualCast.idListFin_cast {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) : List.map (Fin.cast ⋯) (IndexNotation.IndexList.idListFin l) = IndexNotation.IndexList.idListFin l2"}
{"name":"IndexNotation.IndexList.idListFin_getDualInOther?","declaration":"theorem IndexNotation.IndexList.idListFin_getDualInOther? {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.idListFin l =\n  List.filter (fun i => decide (IndexNotation.IndexList.getDualInOther? l l i = some i))\n    (List.finRange (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.normalize_val_length","declaration":"theorem IndexNotation.IndexList.normalize_val_length {X : Type} (l : IndexNotation.IndexList X) : List.length (IndexNotation.IndexList.normalize l).val = List.length l.val"}
{"name":"IndexNotation.IndexList.indexOf_map_fin","declaration":"theorem IndexNotation.IndexList.indexOf_map_fin {α : Type} {m : ℕ} [DecidableEq α] (f : α → Fin m) (l : List α) (n : α) (hf : ∀ I ∈ l, ∀ (J : α), f I = f J ↔ I = J) : List.indexOf n l = List.indexOf (f n) (List.map f l)"}
{"name":"IndexNotation.IndexList.filter_dedup","declaration":"theorem IndexNotation.IndexList.filter_dedup {α : Type} [DecidableEq α] (l : List α) (p : α → Prop) [DecidablePred p] : List.dedup (List.filter (fun b => decide (p b)) l) = List.filter (fun b => decide (p b)) (List.dedup l)"}
{"name":"IndexNotation.IndexList.findIdx?_on_finRange_eq_findIdx","declaration":"theorem IndexNotation.IndexList.findIdx?_on_finRange_eq_findIdx {n : ℕ} (p : Fin n → Prop) [DecidablePred p] : List.findIdx? (fun b => decide (p b)) (List.finRange n) = Option.map Fin.val (Fin.find p)"}
{"name":"IndexNotation.IndexList.idList_getDualInOther?","declaration":"theorem IndexNotation.IndexList.idList_getDualInOther? {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.idList l =\n  List.map (IndexNotation.IndexList.idMap l)\n    (List.filter (fun i => decide (IndexNotation.IndexList.getDualInOther? l l i = some i))\n      (List.finRange (IndexNotation.IndexList.length l)))"}
{"name":"IndexNotation.IndexList.normalize_filter_countId_eq_one","declaration":"theorem IndexNotation.IndexList.normalize_filter_countId_eq_one {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : List.map IndexNotation.Index.id\n    (List.filter (fun I => decide (IndexNotation.IndexList.countId (IndexNotation.IndexList.normalize l) I = 1))\n      (IndexNotation.IndexList.normalize l).val) =\n  List.map (fun a => List.indexOf a (IndexNotation.IndexList.idList l))\n    (List.map IndexNotation.Index.id (List.filter (fun I => decide (IndexNotation.IndexList.countId l I = 1)) l.val))"}
{"name":"IndexNotation.IndexList.normalize_colorMap","declaration":"theorem IndexNotation.IndexList.normalize_colorMap {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.colorMap (IndexNotation.IndexList.normalize l) = IndexNotation.IndexList.colorMap l ∘ Fin.cast ⋯"}
{"name":"IndexNotation.IndexList.mem_idList_of_mem","declaration":"theorem IndexNotation.IndexList.mem_idList_of_mem {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} (hI : I ∈ l.val) : IndexNotation.Index.id I ∈ IndexNotation.IndexList.idList l"}
{"name":"IndexNotation.IndexList.findIdx?_map","declaration":"theorem IndexNotation.IndexList.findIdx?_map {α : Type} {β : Type} (p : α → Bool) (f : β → α) (l : List β) : List.findIdx? p (List.map f l) = List.findIdx? (p ∘ f) l"}
{"name":"IndexNotation.IndexList.GetDualCast.iff_idMap_eq","declaration":"theorem IndexNotation.IndexList.GetDualCast.iff_idMap_eq {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} : IndexNotation.IndexList.GetDualCast l l2 ↔\n  IndexNotation.IndexList.length l = IndexNotation.IndexList.length l2 ∧\n    ∀ (h : IndexNotation.IndexList.length l = IndexNotation.IndexList.length l2)\n      (i j : Fin (IndexNotation.IndexList.length l)),\n      IndexNotation.IndexList.idMap l i = IndexNotation.IndexList.idMap l j ↔\n        IndexNotation.IndexList.idMap l2 (Fin.cast h i) = IndexNotation.IndexList.idMap l2 (Fin.cast h j)"}
{"name":"IndexNotation.IndexList.idList_indexOf_get","declaration":"theorem IndexNotation.IndexList.idList_indexOf_get {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : List.indexOf (IndexNotation.IndexList.idMap l i) (IndexNotation.IndexList.idList l) =\n  List.indexOf (Option.get (IndexNotation.IndexList.getDualInOther? l l i) ⋯) (IndexNotation.IndexList.idListFin l)"}
{"name":"IndexNotation.IndexList.normalize_getDualCast_self","declaration":"theorem IndexNotation.IndexList.normalize_getDualCast_self {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) : IndexNotation.IndexList.GetDualCast (IndexNotation.IndexList.normalize l) l"}
{"name":"IndexNotation.IndexList.findIdx?_on_finRange","declaration":"theorem IndexNotation.IndexList.findIdx?_on_finRange {n : ℕ} (p : Fin (Nat.succ n) → Prop) [DecidablePred p] (hp : ¬p 0) : List.findIdx? (fun b => decide (p b)) (List.finRange (Nat.succ n)) =\n  Option.map (fun i => i + 1) (List.findIdx? ((fun b => decide (p b)) ∘ Fin.succ) (List.finRange n))"}
{"name":"IndexNotation.IndexList.GetDualCast.idList_indexOf","declaration":"theorem IndexNotation.IndexList.GetDualCast.idList_indexOf {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : IndexNotation.IndexList.GetDualCast l l2) (i : Fin (IndexNotation.IndexList.length l)) : List.indexOf (IndexNotation.IndexList.idMap l2 (Fin.cast ⋯ i)) (IndexNotation.IndexList.idList l2) =\n  List.indexOf (IndexNotation.IndexList.idMap l i) (IndexNotation.IndexList.idList l)"}
