{"name":"IndexNotation.IndexList.ColorCond.contrIndexList_left","declaration":"theorem IndexNotation.IndexList.ColorCond.contrIndexList_left {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} {l2 : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (h1 : IndexNotation.IndexList.ColorCond (l ++ l2)) : IndexNotation.IndexList.ColorCond (IndexNotation.IndexList.contrIndexList l ++ l2)"}
{"name":"IndexNotation.IndexList.ColorCond.swap","declaration":"theorem IndexNotation.IndexList.ColorCond.swap {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} {l2 : IndexNotation.IndexList ğ“’.Color} {l3 : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2 ++ l3)) (h : IndexNotation.IndexList.ColorCond (l ++ l2 ++ l3)) : IndexNotation.IndexList.ColorCond (l2 ++ l ++ l3)"}
{"name":"IndexNotation.IndexList.ColorCond.iff_on_isSome","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_on_isSome {ğ“’ : TensorColor} {l : IndexNotation.IndexList ğ“’.Color} : IndexNotation.IndexList.ColorCond l â†”\n  âˆ€ (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDual? l i) = true),\n    ğ“’.Ï„ (IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l i) h)) =\n      IndexNotation.IndexList.colorMap l i"}
{"name":"IndexNotation.IndexList.ColorCond.symm","declaration":"theorem IndexNotation.IndexList.ColorCond.symm {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} {l2 : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (h : IndexNotation.IndexList.ColorCond (l ++ l2)) : IndexNotation.IndexList.ColorCond (l2 ++ l)"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_eq_of_countId_eq","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_eq_of_countId_eq {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} (h1 : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countId l I) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countSelf l I"}
{"name":"IndexNotation.IndexList.ColorCond.iff_withDual","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_withDual {ğ“’ : TensorColor} {l : IndexNotation.IndexList ğ“’.Color} : IndexNotation.IndexList.ColorCond l â†”\n  âˆ€ (i : { x // x âˆˆ IndexNotation.IndexList.withDual l }),\n    ğ“’.Ï„ (IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l â†‘i) â‹¯)) =\n      IndexNotation.IndexList.colorMap l â†‘i"}
{"name":"IndexNotation.IndexList.countSelf_eq_countDual_iff_of_isSome","declaration":"theorem IndexNotation.IndexList.countSelf_eq_countDual_iff_of_isSome {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (hl : IndexNotation.IndexList.OnlyUniqueDuals l) (i : Fin (IndexNotation.IndexList.length l)) (hi : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : IndexNotation.IndexList.countSelf l (List.get l.val i) = IndexNotation.IndexList.countDual l (List.get l.val i) â†”\n  IndexNotation.IndexList.colorMap l i =\n      ğ“’.Ï„ (IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l i) hi)) âˆ¨\n    IndexNotation.IndexList.colorMap l i = ğ“’.Ï„ (IndexNotation.IndexList.colorMap l i)"}
{"name":"IndexNotation.IndexList.ColorCond.bool","declaration":"/-- A bool which is true for an index list if and only if every index and its' dual, when it exists,\nhave dual colors. -/\ndef IndexNotation.IndexList.ColorCond.bool {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) : Bool"}
{"name":"IndexNotation.IndexList.countDual_eq_countSelf_Dual","declaration":"theorem IndexNotation.IndexList.countDual_eq_countSelf_Dual {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countDual l I = IndexNotation.IndexList.countSelf l (IndexNotation.Index.dual I)"}
{"name":"IndexNotation.IndexList.countColorQuot_eq_countId_iff_of_isSome","declaration":"theorem IndexNotation.IndexList.countColorQuot_eq_countId_iff_of_isSome {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (hl : IndexNotation.IndexList.OnlyUniqueDuals l) (i : Fin (IndexNotation.IndexList.length l)) (hi : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : IndexNotation.IndexList.countColorQuot l (List.get l.val i) = IndexNotation.IndexList.countId l (List.get l.val i) â†”\n  IndexNotation.IndexList.colorMap l i =\n      IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l i) hi) âˆ¨\n    IndexNotation.IndexList.colorMap l i =\n      ğ“’.Ï„ (IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l i) hi))"}
{"name":"IndexNotation.IndexList.countColorQuot_of_countId_zero","declaration":"theorem IndexNotation.IndexList.countColorQuot_of_countId_zero {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} (h : IndexNotation.IndexList.countId l I = 0) : IndexNotation.IndexList.countColorQuot l I = 0"}
{"name":"IndexNotation.IndexList.ColorCond.iff_countColorCond","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_countColorCond {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.ColorCond l â†”\n  âˆ€ (I : IndexNotation.Index ğ“’.Color),\n    IndexNotation.IndexList.countSelf l I â‰  0 â†’\n      IndexNotation.IndexList.countId l I = 2 â†’ IndexNotation.IndexList.ColorCond.countColorCond l I"}
{"name":"IndexNotation.Index.dual","declaration":"/-- The dual of an index is the index with the same id, but opposite color. -/\ndef IndexNotation.Index.dual {ğ“’ : TensorColor} (I : IndexNotation.Index ğ“’.Color) : IndexNotation.Index ğ“’.Color"}
{"name":"IndexNotation.IndexList.countSelf_eq_one_of_countId_eq_one","declaration":"theorem IndexNotation.IndexList.countSelf_eq_one_of_countId_eq_one {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) (h1 : IndexNotation.IndexList.countId l I = 1) (hme : I âˆˆ l.val) : IndexNotation.IndexList.countSelf l I = 1"}
{"name":"IndexNotation.IndexList.countSelf_of_countId_zero","declaration":"theorem IndexNotation.IndexList.countSelf_of_countId_zero {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} (h : IndexNotation.IndexList.countId l I = 0) : IndexNotation.IndexList.countSelf l I = 0"}
{"name":"IndexNotation.IndexList.countSelf_eq_zero","declaration":"theorem IndexNotation.IndexList.countSelf_eq_zero {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countSelf l I = 0 â†” I âˆ‰ l.val"}
{"name":"IndexNotation.IndexList.ColorCond.assoc","declaration":"theorem IndexNotation.IndexList.ColorCond.assoc {ğ“’ : TensorColor} {l : IndexNotation.IndexList ğ“’.Color} {l2 : IndexNotation.IndexList ğ“’.Color} {l3 : IndexNotation.IndexList ğ“’.Color} (h : IndexNotation.IndexList.ColorCond (l ++ l2 ++ l3)) : IndexNotation.IndexList.ColorCond (l ++ (l2 ++ l3))"}
{"name":"IndexNotation.IndexList.ColorCond.iff_countColorCond_isSome","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_countColorCond_isSome {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.ColorCond l â†”\n  âˆ€ (i : Fin (IndexNotation.IndexList.length l)),\n    Option.isSome (IndexNotation.IndexList.getDual? l i) = true â†’\n      IndexNotation.IndexList.ColorCond.countColorCond l (List.get l.val i)"}
{"name":"IndexNotation.IndexList.countSelf_eq_filter_id_countP","declaration":"theorem IndexNotation.IndexList.countSelf_eq_filter_id_countP {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} : IndexNotation.IndexList.countSelf l I =\n  List.countP (fun J => decide (IndexNotation.Index.toColor I = IndexNotation.Index.toColor J))\n    (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
{"name":"IndexNotation.IndexList.countSelf_append","declaration":"theorem IndexNotation.IndexList.countSelf_append {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (l2 : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countSelf (l ++ l2) I =\n  IndexNotation.IndexList.countSelf l I + IndexNotation.IndexList.countSelf l2 I"}
{"name":"IndexNotation.IndexList.ColorCond.mem_iff_dual_mem","declaration":"theorem IndexNotation.IndexList.ColorCond.mem_iff_dual_mem {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) (hc : IndexNotation.IndexList.ColorCond l) (I : IndexNotation.Index ğ“’.Color) (hId : IndexNotation.IndexList.countId l I = 2) : I âˆˆ l.val â†” IndexNotation.Index.dual I âˆˆ l.val"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_eq_zero_of_zero","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_eq_zero_of_zero {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) (h : IndexNotation.IndexList.countSelf l I = 0) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I = 0"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_get","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_get {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l)\n    (IndexNotation.IndexList.contrIndexList l).val[â†‘i] =\n  1"}
{"name":"IndexNotation.IndexList.countColorQuot_append","declaration":"theorem IndexNotation.IndexList.countColorQuot_append {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (l2 : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countColorQuot (l ++ l2) I =\n  IndexNotation.IndexList.countColorQuot l I + IndexNotation.IndexList.countColorQuot l2 I"}
{"name":"IndexNotation.Index.dual_color","declaration":"theorem IndexNotation.Index.dual_color {ğ“’ : TensorColor} (I : IndexNotation.Index ğ“’.Color) : IndexNotation.Index.toColor (IndexNotation.Index.dual I) = ğ“’.Ï„ (IndexNotation.Index.toColor I)"}
{"name":"IndexNotation.Index.dual_dual","declaration":"theorem IndexNotation.Index.dual_dual {ğ“’ : TensorColor} (I : IndexNotation.Index ğ“’.Color) : IndexNotation.Index.dual (IndexNotation.Index.dual I) = I"}
{"name":"IndexNotation.IndexList.ColorCond.countColorCond","declaration":"/-- A condition on an index list `l` and and index `I`. If the id of `I` appears\ntwice in `l` (and `I` at least once) then this condition is equivalent to the dual of `I` having\ndual color to `I`, but written totally in terms of lists. -/\ndef IndexNotation.IndexList.ColorCond.countColorCond {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : Prop"}
{"name":"IndexNotation.IndexList.countColorQuot_contrIndexList_eq_zero_or_one","declaration":"theorem IndexNotation.IndexList.countColorQuot_contrIndexList_eq_zero_or_one {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I = 0 âˆ¨\n  IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I = 1"}
{"name":"IndexNotation.IndexList.countDual_of_countId_zero","declaration":"theorem IndexNotation.IndexList.countDual_of_countId_zero {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} (h : IndexNotation.IndexList.countId l I = 0) : IndexNotation.IndexList.countDual l I = 0"}
{"name":"IndexNotation.IndexList.countColorQuot_contrIndexList_le_one","declaration":"theorem IndexNotation.IndexList.countColorQuot_contrIndexList_le_one {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I â‰¤ 1"}
{"name":"IndexNotation.IndexList.countSelf_neq_zero","declaration":"theorem IndexNotation.IndexList.countSelf_neq_zero {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countSelf l I â‰  0 â†” I âˆˆ l.val"}
{"name":"IndexNotation.IndexList.ColorCond.iff_countColorCond_index","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_countColorCond_index {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.ColorCond l â†”\n  âˆ€ (i : Fin (IndexNotation.IndexList.length l)),\n    IndexNotation.IndexList.countId l (List.get l.val i) = 2 â†’\n      IndexNotation.IndexList.ColorCond.countColorCond l (List.get l.val i)"}
{"name":"IndexNotation.IndexList.ColorCond.iff_countColorCond_mem","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_countColorCond_mem {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.ColorCond l â†”\n  âˆ€ I âˆˆ l.val, IndexNotation.IndexList.countId l I = 2 â†’ IndexNotation.IndexList.ColorCond.countColorCond l I"}
{"name":"IndexNotation.IndexList.countColorQuot_contrIndexList_eq_of_countId_eq","declaration":"theorem IndexNotation.IndexList.countColorQuot_contrIndexList_eq_of_countId_eq {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} (h1 : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countId l I) : IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I =\n  IndexNotation.IndexList.countColorQuot l I"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_eq_zero_or_one","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_eq_zero_or_one {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I = 0 âˆ¨\n  IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I = 1"}
{"name":"IndexNotation.IndexList.countColorQuot","declaration":"/-- The number of times `I` or its dual appears in an `IndexList`. -/\ndef IndexNotation.IndexList.countColorQuot {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : â„•"}
{"name":"IndexNotation.Index.dual_id","declaration":"theorem IndexNotation.Index.dual_id {ğ“’ : TensorColor} (I : IndexNotation.Index ğ“’.Color) : IndexNotation.Index.id (IndexNotation.Index.dual I) = IndexNotation.Index.id I"}
{"name":"IndexNotation.IndexList.countDual_append","declaration":"theorem IndexNotation.IndexList.countDual_append {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (l2 : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countDual (l ++ l2) I =\n  IndexNotation.IndexList.countDual l I + IndexNotation.IndexList.countDual l2 I"}
{"name":"IndexNotation.IndexList.countColorQuot_eq_filter_id_countP","declaration":"theorem IndexNotation.IndexList.countColorQuot_eq_filter_id_countP {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countColorQuot l I =\n  List.countP\n    (fun J =>\n      decide\n        (IndexNotation.Index.toColor I = IndexNotation.Index.toColor J âˆ¨\n          IndexNotation.Index.toColor I = ğ“’.Ï„ (IndexNotation.Index.toColor J)))\n    (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
{"name":"IndexNotation.IndexList.ColorCond","declaration":"/-- The condition an index and its' dual, when it exists, have dual colors. -/\ndef IndexNotation.IndexList.ColorCond {ğ“’ : TensorColor} (l : IndexNotation.IndexList ğ“’.Color) : Prop"}
{"name":"IndexNotation.IndexList.countDual","declaration":"/-- The number of times the dual of an index `I` appears in an index list. -/\ndef IndexNotation.IndexList.countDual {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : â„•"}
{"name":"IndexNotation.IndexList.countSelf_count","declaration":"theorem IndexNotation.IndexList.countSelf_count {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countSelf l I = List.count I l.val"}
{"name":"IndexNotation.IndexList.countDual_eq_filter_id_countP","declaration":"theorem IndexNotation.IndexList.countDual_eq_filter_id_countP {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} : IndexNotation.IndexList.countDual l I =\n  List.countP (fun J => decide (IndexNotation.Index.toColor I = ğ“’.Ï„ (IndexNotation.Index.toColor J)))\n    (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_le_countSelf","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_le_countSelf {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I â‰¤ IndexNotation.IndexList.countSelf l I"}
{"name":"IndexNotation.IndexList.ColorCond.iff_bool","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_bool {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} : IndexNotation.IndexList.ColorCond l â†” IndexNotation.IndexList.ColorCond.bool l = true"}
{"name":"IndexNotation.IndexList.countDual_contrIndexList_eq_of_countId_eq","declaration":"theorem IndexNotation.IndexList.countDual_contrIndexList_eq_of_countId_eq {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} (h1 : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countId l I) : IndexNotation.IndexList.countDual (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countDual l I"}
{"name":"IndexNotation.IndexList.countSelf","declaration":"/-- The number of times an index `I` appears in an index list. -/\ndef IndexNotation.IndexList.countSelf {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : â„•"}
{"name":"IndexNotation.IndexList.countSelf_le_countId","declaration":"theorem IndexNotation.IndexList.countSelf_le_countId {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countSelf l I â‰¤ IndexNotation.IndexList.countId l I"}
{"name":"IndexNotation.IndexList.ColorCond.inl","declaration":"theorem IndexNotation.IndexList.ColorCond.inl {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} {l2 : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (h : IndexNotation.IndexList.ColorCond (l ++ l2)) : IndexNotation.IndexList.ColorCond l"}
{"name":"IndexNotation.IndexList.countColorQuot_eq_filter_color_countP","declaration":"theorem IndexNotation.IndexList.countColorQuot_eq_filter_color_countP {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countColorQuot l I =\n  List.countP (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J))\n    (List.filter\n      (fun J =>\n        decide\n          (IndexNotation.Index.toColor I = IndexNotation.Index.toColor J âˆ¨\n            IndexNotation.Index.toColor I = ğ“’.Ï„ (IndexNotation.Index.toColor J)))\n      l.val)"}
{"name":"IndexNotation.IndexList.countSelf_eq_filter_color_countP","declaration":"theorem IndexNotation.IndexList.countSelf_eq_filter_color_countP {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} : IndexNotation.IndexList.countSelf l I =\n  List.countP (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J))\n    (List.filter (fun J => decide (IndexNotation.Index.toColor I = IndexNotation.Index.toColor J)) l.val)"}
{"name":"IndexNotation.IndexList.countColorQuot_contrIndexList_le_countColorQuot","declaration":"theorem IndexNotation.IndexList.countColorQuot_contrIndexList_le_countColorQuot {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I â‰¤\n  IndexNotation.IndexList.countColorQuot l I"}
{"name":"IndexNotation.IndexList.countColorQuot_le_countId","declaration":"theorem IndexNotation.IndexList.countColorQuot_le_countId {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countColorQuot l I â‰¤ IndexNotation.IndexList.countId l I"}
{"name":"IndexNotation.IndexList.ColorCond.countColorCond_of_filter_eq","declaration":"theorem IndexNotation.IndexList.ColorCond.countColorCond_of_filter_eq {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (l2 : IndexNotation.IndexList ğ“’.Color) {I : IndexNotation.Index ğ“’.Color} (hf : List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val =\n  List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l2.val) (h1 : IndexNotation.IndexList.ColorCond.countColorCond l I) : IndexNotation.IndexList.ColorCond.countColorCond l2 I"}
{"name":"IndexNotation.IndexList.ColorCond.contrIndexList","declaration":"theorem IndexNotation.IndexList.ColorCond.contrIndexList {ğ“’ : TensorColor} {l : IndexNotation.IndexList ğ“’.Color} : IndexNotation.IndexList.ColorCond (IndexNotation.IndexList.contrIndexList l)"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_le_one","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_le_one {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I â‰¤ 1"}
{"name":"IndexNotation.IndexList.ColorCond.inr","declaration":"theorem IndexNotation.IndexList.ColorCond.inr {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {l : IndexNotation.IndexList ğ“’.Color} {l2 : IndexNotation.IndexList ğ“’.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (h : IndexNotation.IndexList.ColorCond (l ++ l2)) : IndexNotation.IndexList.ColorCond l2"}
