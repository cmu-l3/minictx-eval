{"name":"IndexNotation.IndexList.ColorCond.contrIndexList_left","declaration":"theorem IndexNotation.IndexList.ColorCond.contrIndexList_left {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} {l2 : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (h1 : IndexNotation.IndexList.ColorCond (l ++ l2)) : IndexNotation.IndexList.ColorCond (IndexNotation.IndexList.contrIndexList l ++ l2)"}
{"name":"IndexNotation.IndexList.ColorCond.swap","declaration":"theorem IndexNotation.IndexList.ColorCond.swap {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} {l2 : IndexNotation.IndexList 𝓒.Color} {l3 : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2 ++ l3)) (h : IndexNotation.IndexList.ColorCond (l ++ l2 ++ l3)) : IndexNotation.IndexList.ColorCond (l2 ++ l ++ l3)"}
{"name":"IndexNotation.IndexList.ColorCond.iff_on_isSome","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_on_isSome {𝓒 : TensorColor} {l : IndexNotation.IndexList 𝓒.Color} : IndexNotation.IndexList.ColorCond l ↔\n  ∀ (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDual? l i) = true),\n    𝓒.τ (IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l i) h)) =\n      IndexNotation.IndexList.colorMap l i"}
{"name":"IndexNotation.IndexList.ColorCond.symm","declaration":"theorem IndexNotation.IndexList.ColorCond.symm {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} {l2 : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (h : IndexNotation.IndexList.ColorCond (l ++ l2)) : IndexNotation.IndexList.ColorCond (l2 ++ l)"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_eq_of_countId_eq","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_eq_of_countId_eq {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} (h1 : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countId l I) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countSelf l I"}
{"name":"IndexNotation.IndexList.ColorCond.iff_withDual","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_withDual {𝓒 : TensorColor} {l : IndexNotation.IndexList 𝓒.Color} : IndexNotation.IndexList.ColorCond l ↔\n  ∀ (i : { x // x ∈ IndexNotation.IndexList.withDual l }),\n    𝓒.τ (IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l ↑i) ⋯)) =\n      IndexNotation.IndexList.colorMap l ↑i"}
{"name":"IndexNotation.IndexList.countSelf_eq_countDual_iff_of_isSome","declaration":"theorem IndexNotation.IndexList.countSelf_eq_countDual_iff_of_isSome {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (hl : IndexNotation.IndexList.OnlyUniqueDuals l) (i : Fin (IndexNotation.IndexList.length l)) (hi : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : IndexNotation.IndexList.countSelf l (List.get l.val i) = IndexNotation.IndexList.countDual l (List.get l.val i) ↔\n  IndexNotation.IndexList.colorMap l i =\n      𝓒.τ (IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l i) hi)) ∨\n    IndexNotation.IndexList.colorMap l i = 𝓒.τ (IndexNotation.IndexList.colorMap l i)"}
{"name":"IndexNotation.IndexList.ColorCond.bool","declaration":"/-- A bool which is true for an index list if and only if every index and its' dual, when it exists,\nhave dual colors. -/\ndef IndexNotation.IndexList.ColorCond.bool {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) : Bool"}
{"name":"IndexNotation.IndexList.countDual_eq_countSelf_Dual","declaration":"theorem IndexNotation.IndexList.countDual_eq_countSelf_Dual {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countDual l I = IndexNotation.IndexList.countSelf l (IndexNotation.Index.dual I)"}
{"name":"IndexNotation.IndexList.countColorQuot_eq_countId_iff_of_isSome","declaration":"theorem IndexNotation.IndexList.countColorQuot_eq_countId_iff_of_isSome {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (hl : IndexNotation.IndexList.OnlyUniqueDuals l) (i : Fin (IndexNotation.IndexList.length l)) (hi : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : IndexNotation.IndexList.countColorQuot l (List.get l.val i) = IndexNotation.IndexList.countId l (List.get l.val i) ↔\n  IndexNotation.IndexList.colorMap l i =\n      IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l i) hi) ∨\n    IndexNotation.IndexList.colorMap l i =\n      𝓒.τ (IndexNotation.IndexList.colorMap l (Option.get (IndexNotation.IndexList.getDual? l i) hi))"}
{"name":"IndexNotation.IndexList.countColorQuot_of_countId_zero","declaration":"theorem IndexNotation.IndexList.countColorQuot_of_countId_zero {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} (h : IndexNotation.IndexList.countId l I = 0) : IndexNotation.IndexList.countColorQuot l I = 0"}
{"name":"IndexNotation.IndexList.ColorCond.iff_countColorCond","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_countColorCond {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.ColorCond l ↔\n  ∀ (I : IndexNotation.Index 𝓒.Color),\n    IndexNotation.IndexList.countSelf l I ≠ 0 →\n      IndexNotation.IndexList.countId l I = 2 → IndexNotation.IndexList.ColorCond.countColorCond l I"}
{"name":"IndexNotation.Index.dual","declaration":"/-- The dual of an index is the index with the same id, but opposite color. -/\ndef IndexNotation.Index.dual {𝓒 : TensorColor} (I : IndexNotation.Index 𝓒.Color) : IndexNotation.Index 𝓒.Color"}
{"name":"IndexNotation.IndexList.countSelf_eq_one_of_countId_eq_one","declaration":"theorem IndexNotation.IndexList.countSelf_eq_one_of_countId_eq_one {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) (h1 : IndexNotation.IndexList.countId l I = 1) (hme : I ∈ l.val) : IndexNotation.IndexList.countSelf l I = 1"}
{"name":"IndexNotation.IndexList.countSelf_of_countId_zero","declaration":"theorem IndexNotation.IndexList.countSelf_of_countId_zero {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} (h : IndexNotation.IndexList.countId l I = 0) : IndexNotation.IndexList.countSelf l I = 0"}
{"name":"IndexNotation.IndexList.countSelf_eq_zero","declaration":"theorem IndexNotation.IndexList.countSelf_eq_zero {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countSelf l I = 0 ↔ I ∉ l.val"}
{"name":"IndexNotation.IndexList.ColorCond.assoc","declaration":"theorem IndexNotation.IndexList.ColorCond.assoc {𝓒 : TensorColor} {l : IndexNotation.IndexList 𝓒.Color} {l2 : IndexNotation.IndexList 𝓒.Color} {l3 : IndexNotation.IndexList 𝓒.Color} (h : IndexNotation.IndexList.ColorCond (l ++ l2 ++ l3)) : IndexNotation.IndexList.ColorCond (l ++ (l2 ++ l3))"}
{"name":"IndexNotation.IndexList.ColorCond.iff_countColorCond_isSome","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_countColorCond_isSome {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.ColorCond l ↔\n  ∀ (i : Fin (IndexNotation.IndexList.length l)),\n    Option.isSome (IndexNotation.IndexList.getDual? l i) = true →\n      IndexNotation.IndexList.ColorCond.countColorCond l (List.get l.val i)"}
{"name":"IndexNotation.IndexList.countSelf_eq_filter_id_countP","declaration":"theorem IndexNotation.IndexList.countSelf_eq_filter_id_countP {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} : IndexNotation.IndexList.countSelf l I =\n  List.countP (fun J => decide (IndexNotation.Index.toColor I = IndexNotation.Index.toColor J))\n    (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
{"name":"IndexNotation.IndexList.countSelf_append","declaration":"theorem IndexNotation.IndexList.countSelf_append {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (l2 : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countSelf (l ++ l2) I =\n  IndexNotation.IndexList.countSelf l I + IndexNotation.IndexList.countSelf l2 I"}
{"name":"IndexNotation.IndexList.ColorCond.mem_iff_dual_mem","declaration":"theorem IndexNotation.IndexList.ColorCond.mem_iff_dual_mem {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) (hc : IndexNotation.IndexList.ColorCond l) (I : IndexNotation.Index 𝓒.Color) (hId : IndexNotation.IndexList.countId l I = 2) : I ∈ l.val ↔ IndexNotation.Index.dual I ∈ l.val"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_eq_zero_of_zero","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_eq_zero_of_zero {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) (h : IndexNotation.IndexList.countSelf l I = 0) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I = 0"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_get","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_get {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l)\n    (IndexNotation.IndexList.contrIndexList l).val[↑i] =\n  1"}
{"name":"IndexNotation.IndexList.countColorQuot_append","declaration":"theorem IndexNotation.IndexList.countColorQuot_append {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (l2 : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countColorQuot (l ++ l2) I =\n  IndexNotation.IndexList.countColorQuot l I + IndexNotation.IndexList.countColorQuot l2 I"}
{"name":"IndexNotation.Index.dual_color","declaration":"theorem IndexNotation.Index.dual_color {𝓒 : TensorColor} (I : IndexNotation.Index 𝓒.Color) : IndexNotation.Index.toColor (IndexNotation.Index.dual I) = 𝓒.τ (IndexNotation.Index.toColor I)"}
{"name":"IndexNotation.Index.dual_dual","declaration":"theorem IndexNotation.Index.dual_dual {𝓒 : TensorColor} (I : IndexNotation.Index 𝓒.Color) : IndexNotation.Index.dual (IndexNotation.Index.dual I) = I"}
{"name":"IndexNotation.IndexList.ColorCond.countColorCond","declaration":"/-- A condition on an index list `l` and and index `I`. If the id of `I` appears\ntwice in `l` (and `I` at least once) then this condition is equivalent to the dual of `I` having\ndual color to `I`, but written totally in terms of lists. -/\ndef IndexNotation.IndexList.ColorCond.countColorCond {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : Prop"}
{"name":"IndexNotation.IndexList.countColorQuot_contrIndexList_eq_zero_or_one","declaration":"theorem IndexNotation.IndexList.countColorQuot_contrIndexList_eq_zero_or_one {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I = 0 ∨\n  IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I = 1"}
{"name":"IndexNotation.IndexList.countDual_of_countId_zero","declaration":"theorem IndexNotation.IndexList.countDual_of_countId_zero {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} (h : IndexNotation.IndexList.countId l I = 0) : IndexNotation.IndexList.countDual l I = 0"}
{"name":"IndexNotation.IndexList.countColorQuot_contrIndexList_le_one","declaration":"theorem IndexNotation.IndexList.countColorQuot_contrIndexList_le_one {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I ≤ 1"}
{"name":"IndexNotation.IndexList.countSelf_neq_zero","declaration":"theorem IndexNotation.IndexList.countSelf_neq_zero {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countSelf l I ≠ 0 ↔ I ∈ l.val"}
{"name":"IndexNotation.IndexList.ColorCond.iff_countColorCond_index","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_countColorCond_index {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.ColorCond l ↔\n  ∀ (i : Fin (IndexNotation.IndexList.length l)),\n    IndexNotation.IndexList.countId l (List.get l.val i) = 2 →\n      IndexNotation.IndexList.ColorCond.countColorCond l (List.get l.val i)"}
{"name":"IndexNotation.IndexList.ColorCond.iff_countColorCond_mem","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_countColorCond_mem {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals l) : IndexNotation.IndexList.ColorCond l ↔\n  ∀ I ∈ l.val, IndexNotation.IndexList.countId l I = 2 → IndexNotation.IndexList.ColorCond.countColorCond l I"}
{"name":"IndexNotation.IndexList.countColorQuot_contrIndexList_eq_of_countId_eq","declaration":"theorem IndexNotation.IndexList.countColorQuot_contrIndexList_eq_of_countId_eq {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} (h1 : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countId l I) : IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I =\n  IndexNotation.IndexList.countColorQuot l I"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_eq_zero_or_one","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_eq_zero_or_one {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I = 0 ∨\n  IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I = 1"}
{"name":"IndexNotation.IndexList.countColorQuot","declaration":"/-- The number of times `I` or its dual appears in an `IndexList`. -/\ndef IndexNotation.IndexList.countColorQuot {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : ℕ"}
{"name":"IndexNotation.Index.dual_id","declaration":"theorem IndexNotation.Index.dual_id {𝓒 : TensorColor} (I : IndexNotation.Index 𝓒.Color) : IndexNotation.Index.id (IndexNotation.Index.dual I) = IndexNotation.Index.id I"}
{"name":"IndexNotation.IndexList.countDual_append","declaration":"theorem IndexNotation.IndexList.countDual_append {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (l2 : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countDual (l ++ l2) I =\n  IndexNotation.IndexList.countDual l I + IndexNotation.IndexList.countDual l2 I"}
{"name":"IndexNotation.IndexList.countColorQuot_eq_filter_id_countP","declaration":"theorem IndexNotation.IndexList.countColorQuot_eq_filter_id_countP {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countColorQuot l I =\n  List.countP\n    (fun J =>\n      decide\n        (IndexNotation.Index.toColor I = IndexNotation.Index.toColor J ∨\n          IndexNotation.Index.toColor I = 𝓒.τ (IndexNotation.Index.toColor J)))\n    (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
{"name":"IndexNotation.IndexList.ColorCond","declaration":"/-- The condition an index and its' dual, when it exists, have dual colors. -/\ndef IndexNotation.IndexList.ColorCond {𝓒 : TensorColor} (l : IndexNotation.IndexList 𝓒.Color) : Prop"}
{"name":"IndexNotation.IndexList.countDual","declaration":"/-- The number of times the dual of an index `I` appears in an index list. -/\ndef IndexNotation.IndexList.countDual {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : ℕ"}
{"name":"IndexNotation.IndexList.countSelf_count","declaration":"theorem IndexNotation.IndexList.countSelf_count {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countSelf l I = List.count I l.val"}
{"name":"IndexNotation.IndexList.countDual_eq_filter_id_countP","declaration":"theorem IndexNotation.IndexList.countDual_eq_filter_id_countP {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} : IndexNotation.IndexList.countDual l I =\n  List.countP (fun J => decide (IndexNotation.Index.toColor I = 𝓒.τ (IndexNotation.Index.toColor J)))\n    (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_le_countSelf","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_le_countSelf {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I ≤ IndexNotation.IndexList.countSelf l I"}
{"name":"IndexNotation.IndexList.ColorCond.iff_bool","declaration":"theorem IndexNotation.IndexList.ColorCond.iff_bool {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} : IndexNotation.IndexList.ColorCond l ↔ IndexNotation.IndexList.ColorCond.bool l = true"}
{"name":"IndexNotation.IndexList.countDual_contrIndexList_eq_of_countId_eq","declaration":"theorem IndexNotation.IndexList.countDual_contrIndexList_eq_of_countId_eq {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} (h1 : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countId l I) : IndexNotation.IndexList.countDual (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countDual l I"}
{"name":"IndexNotation.IndexList.countSelf","declaration":"/-- The number of times an index `I` appears in an index list. -/\ndef IndexNotation.IndexList.countSelf {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : ℕ"}
{"name":"IndexNotation.IndexList.countSelf_le_countId","declaration":"theorem IndexNotation.IndexList.countSelf_le_countId {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countSelf l I ≤ IndexNotation.IndexList.countId l I"}
{"name":"IndexNotation.IndexList.ColorCond.inl","declaration":"theorem IndexNotation.IndexList.ColorCond.inl {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} {l2 : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (h : IndexNotation.IndexList.ColorCond (l ++ l2)) : IndexNotation.IndexList.ColorCond l"}
{"name":"IndexNotation.IndexList.countColorQuot_eq_filter_color_countP","declaration":"theorem IndexNotation.IndexList.countColorQuot_eq_filter_color_countP {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countColorQuot l I =\n  List.countP (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J))\n    (List.filter\n      (fun J =>\n        decide\n          (IndexNotation.Index.toColor I = IndexNotation.Index.toColor J ∨\n            IndexNotation.Index.toColor I = 𝓒.τ (IndexNotation.Index.toColor J)))\n      l.val)"}
{"name":"IndexNotation.IndexList.countSelf_eq_filter_color_countP","declaration":"theorem IndexNotation.IndexList.countSelf_eq_filter_color_countP {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} : IndexNotation.IndexList.countSelf l I =\n  List.countP (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J))\n    (List.filter (fun J => decide (IndexNotation.Index.toColor I = IndexNotation.Index.toColor J)) l.val)"}
{"name":"IndexNotation.IndexList.countColorQuot_contrIndexList_le_countColorQuot","declaration":"theorem IndexNotation.IndexList.countColorQuot_contrIndexList_le_countColorQuot {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countColorQuot (IndexNotation.IndexList.contrIndexList l) I ≤\n  IndexNotation.IndexList.countColorQuot l I"}
{"name":"IndexNotation.IndexList.countColorQuot_le_countId","declaration":"theorem IndexNotation.IndexList.countColorQuot_le_countId {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countColorQuot l I ≤ IndexNotation.IndexList.countId l I"}
{"name":"IndexNotation.IndexList.ColorCond.countColorCond_of_filter_eq","declaration":"theorem IndexNotation.IndexList.ColorCond.countColorCond_of_filter_eq {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (l2 : IndexNotation.IndexList 𝓒.Color) {I : IndexNotation.Index 𝓒.Color} (hf : List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val =\n  List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l2.val) (h1 : IndexNotation.IndexList.ColorCond.countColorCond l I) : IndexNotation.IndexList.ColorCond.countColorCond l2 I"}
{"name":"IndexNotation.IndexList.ColorCond.contrIndexList","declaration":"theorem IndexNotation.IndexList.ColorCond.contrIndexList {𝓒 : TensorColor} {l : IndexNotation.IndexList 𝓒.Color} : IndexNotation.IndexList.ColorCond (IndexNotation.IndexList.contrIndexList l)"}
{"name":"IndexNotation.IndexList.countSelf_contrIndexList_le_one","declaration":"theorem IndexNotation.IndexList.countSelf_contrIndexList_le_one {𝓒 : TensorColor} [DecidableEq 𝓒.Color] (l : IndexNotation.IndexList 𝓒.Color) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countSelf (IndexNotation.IndexList.contrIndexList l) I ≤ 1"}
{"name":"IndexNotation.IndexList.ColorCond.inr","declaration":"theorem IndexNotation.IndexList.ColorCond.inr {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {l : IndexNotation.IndexList 𝓒.Color} {l2 : IndexNotation.IndexList 𝓒.Color} (hl : IndexNotation.IndexList.OnlyUniqueDuals (l ++ l2)) (h : IndexNotation.IndexList.ColorCond (l ++ l2)) : IndexNotation.IndexList.ColorCond l2"}
