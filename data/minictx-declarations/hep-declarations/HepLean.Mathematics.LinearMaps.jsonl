{"name":"BiLinearSymm.toLinear₁_apply","declaration":"theorem BiLinearSymm.toLinear₁_apply {V : Type} [AddCommMonoid V] [Module ℚ V] (f : BiLinearSymm V) (S : V) (T : V) : (f S) T = (BiLinearSymm.toLinear₁ f T) S"}
{"name":"BiLinearSymm.toHomogeneousQuad_apply","declaration":"theorem BiLinearSymm.toHomogeneousQuad_apply {V : Type} [AddCommMonoid V] [Module ℚ V] (τ : BiLinearSymm V) (S : V) : (BiLinearSymm.toHomogeneousQuad τ) S = (τ S) S"}
{"name":"BiLinearSymm.mk₂_toFun_apply","declaration":"theorem BiLinearSymm.mk₂_toFun_apply {V : Type} [AddCommMonoid V] [Module ℚ V] (f : V × V → ℚ) (map_smul : ∀ (a : ℚ) (S T : V), f (a • S, T) = a * f (S, T)) (map_add : ∀ (S1 S2 T : V), f (S1 + S2, T) = f (S1, T) + f (S2, T)) (swap : ∀ (S T : V), f (S, T) = f (T, S)) (S : V) (T : V) : ((BiLinearSymm.mk₂ f map_smul map_add swap) S) T = f (S, T)"}
{"name":"MulActionHom'","declaration":"/-- Equivariant functions. -/\nstructure MulActionHom' {M : Type u_3} {N : Type u_4} (φ : M → N) (X : Type u_1) [SMul M X] (Y : Type u_2) [SMul N Y] : Type (max u_1 u_2)"}
{"name":"HomogeneousQuadratic.map_smul","declaration":"theorem HomogeneousQuadratic.map_smul {V : Type} [AddCommMonoid V] [Module ℚ V] (f : HomogeneousQuadratic V) (a : ℚ) (S : V) : f (a • S) = a ^ 2 * f S"}
{"name":"BiLinearSymm.toLinear₁","declaration":"/-- Fixing the second input vectors, the resulting linear map. -/\ndef BiLinearSymm.toLinear₁ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : BiLinearSymm V) (T : V) : V →ₗ[ℚ] ℚ"}
{"name":"BiLinearSymm.swap'","declaration":"def BiLinearSymm.swap' {V : Type} [AddCommMonoid V] [Module ℚ V] (self : BiLinearSymm V) (S : V) (T : V) : (self.toFun S) T = (self.toFun T) S"}
{"name":"TriLinearSymm.swap₁'","declaration":"def TriLinearSymm.swap₁' {V : Type} [AddCommMonoid V] [Module ℚ V] (self : TriLinearSymm V) (S : V) (T : V) (L : V) : ((self.toFun S) T) L = ((self.toFun T) S) L"}
{"name":"BiLinearSymm.map_smul₁","declaration":"theorem BiLinearSymm.map_smul₁ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : BiLinearSymm V) (a : ℚ) (S : V) (T : V) : (f (a • S)) T = a * (f S) T"}
{"name":"IsSymmetric","declaration":"/-- A symmetric bilinear function. -/\nclass IsSymmetric {V : Type} [AddCommMonoid V] [Module ℚ V] (f : V →ₗ[ℚ] V →ₗ[ℚ] ℚ) : Prop"}
{"name":"TriLinearSymm.toCubic","declaration":"/-- The homogenous cubic equation obtainable from a symmetric trilinear function. -/\ndef TriLinearSymm.toCubic {charges : Type} [AddCommMonoid charges] [Module ℚ charges] (τ : TriLinearSymm charges) : HomogeneousCubic charges"}
{"name":"TriLinearSymm.toCubic_toFun","declaration":"theorem TriLinearSymm.toCubic_toFun {charges : Type} [AddCommMonoid charges] [Module ℚ charges] (τ : TriLinearSymm charges) (S : charges) : (TriLinearSymm.toCubic τ).toFun S = ((τ S) S) S"}
{"name":"BiLinearSymm.map_add₁","declaration":"theorem BiLinearSymm.map_add₁ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : BiLinearSymm V) (S1 : V) (S2 : V) (T : V) : (f (S1 + S2)) T = (f S1) T + (f S2) T"}
{"name":"IsSymmetric.swap","declaration":"def IsSymmetric.swap {V : Type} [AddCommMonoid V] [Module ℚ V] {f : V →ₗ[ℚ] V →ₗ[ℚ] ℚ} [self : IsSymmetric f] (S : V) (T : V) : (f S) T = (f T) S"}
{"name":"TriLinearSymm.swap₃","declaration":"theorem TriLinearSymm.swap₃ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S : V) (T : V) (L : V) : ((f S) T) L = ((f L) T) S"}
{"name":"TriLinearSymm.swap₂","declaration":"theorem TriLinearSymm.swap₂ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S : V) (T : V) (L : V) : ((f S) T) L = ((f S) L) T"}
{"name":"TriLinearSymm.mk","declaration":"ctor TriLinearSymm.mk {V : Type} [AddCommMonoid V] [Module ℚ V] (toLinearMap : V →ₗ[ℚ] V →ₗ[ℚ] V →ₗ[ℚ] ℚ) (swap₁' : ∀ (S T L : V), ((toLinearMap.toFun S) T) L = ((toLinearMap.toFun T) S) L) (swap₂' : ∀ (S T L : V), ((toLinearMap.toFun S) T) L = ((toLinearMap.toFun S) L) T) : TriLinearSymm V"}
{"name":"BiLinearSymm.map_smul₂","declaration":"theorem BiLinearSymm.map_smul₂ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : BiLinearSymm V) (a : ℚ) (S : V) (T : V) : (f S) (a • T) = a * (f S) T"}
{"name":"TriLinearSymm.map_smul₁","declaration":"theorem TriLinearSymm.map_smul₁ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (a : ℚ) (S : V) (T : V) (L : V) : ((f (a • S)) T) L = a * ((f S) T) L"}
{"name":"BiLinearSymm.swap","declaration":"theorem BiLinearSymm.swap {V : Type} [AddCommMonoid V] [Module ℚ V] (f : BiLinearSymm V) (S : V) (T : V) : (f S) T = (f T) S"}
{"name":"TriLinearSymm.map_sum₃","declaration":"theorem TriLinearSymm.map_sum₃ {V : Type} [AddCommMonoid V] [Module ℚ V] {n : ℕ} (f : TriLinearSymm V) (S : Fin n → V) (T : V) (L : V) : ((f T) L) (Finset.sum Finset.univ fun i => S i) = Finset.sum Finset.univ fun i => ((f T) L) (S i)"}
{"name":"BiLinearSymm.mk","declaration":"ctor BiLinearSymm.mk {V : Type} [AddCommMonoid V] [Module ℚ V] (toLinearMap : V →ₗ[ℚ] V →ₗ[ℚ] ℚ) (swap' : ∀ (S T : V), (toLinearMap.toFun S) T = (toLinearMap.toFun T) S) : BiLinearSymm V"}
{"name":"HomogeneousCubic.map_smul","declaration":"theorem HomogeneousCubic.map_smul {V : Type} [AddCommMonoid V] [Module ℚ V] (f : HomogeneousCubic V) (a : ℚ) (S : V) : f (a • S) = a ^ 3 * f S"}
{"name":"TriLinearSymm.map_sum₁","declaration":"theorem TriLinearSymm.map_sum₁ {V : Type} [AddCommMonoid V] [Module ℚ V] {n : ℕ} (f : TriLinearSymm V) (S : Fin n → V) (T : V) (L : V) : ((f (Finset.sum Finset.univ fun i => S i)) T) L = Finset.sum Finset.univ fun i => ((f (S i)) T) L"}
{"name":"TriLinearSymm","declaration":"/-- The structure of a symmetric trilinear function. -/\nstructure TriLinearSymm (V : Type) [AddCommMonoid V] [Module ℚ V] : Type"}
{"name":"HomogeneousCubic","declaration":"/-- The structure of a homogeneous cubic equation. -/\ndef HomogeneousCubic (V : Type) [AddCommMonoid V] [Module ℚ V] : Type"}
{"name":"MulActionHom'.toFun","declaration":"/-- The underlying function. -/\ndef MulActionHom'.toFun {M : Type u_3} {N : Type u_4} {φ : M → N} {X : Type u_1} [SMul M X] {Y : Type u_2} [SMul N Y] (self : X →ₑ[φ] Y) : X → Y"}
{"name":"TriLinearSymm.toCubic_apply","declaration":"theorem TriLinearSymm.toCubic_apply {charges : Type} [AddCommMonoid charges] [Module ℚ charges] (τ : TriLinearSymm charges) (S : charges) : (TriLinearSymm.toCubic τ) S = ((τ S) S) S"}
{"name":"MulActionHom'.mk","declaration":"ctor MulActionHom'.mk {M : Type u_3} {N : Type u_4} {φ : M → N} {X : Type u_1} [SMul M X] {Y : Type u_2} [SMul N Y] (toFun : X → Y) (map_smul' : ∀ (m : M) (x : X), toFun (m • x) = φ m • toFun x) : X →ₑ[φ] Y"}
{"name":"BiLinearSymm.mk₂","declaration":"/-- The construction of a symmetric bilinear map from `smul` and `map_add` in the first factor,\nand swap. -/\ndef BiLinearSymm.mk₂ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : V × V → ℚ) (map_smul : ∀ (a : ℚ) (S T : V), f (a • S, T) = a * f (S, T)) (map_add : ∀ (S1 S2 T : V), f (S1 + S2, T) = f (S1, T) + f (S2, T)) (swap : ∀ (S T : V), f (S, T) = f (T, S)) : BiLinearSymm V"}
{"name":"TriLinearSymm.map_add₃","declaration":"theorem TriLinearSymm.map_add₃ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S : V) (T : V) (L1 : V) (L2 : V) : ((f S) T) (L1 + L2) = ((f S) T) L1 + ((f S) T) L2"}
{"name":"TriLinearSymm.map_sum₂","declaration":"theorem TriLinearSymm.map_sum₂ {V : Type} [AddCommMonoid V] [Module ℚ V] {n : ℕ} (f : TriLinearSymm V) (S : Fin n → V) (T : V) (L : V) : ((f T) (Finset.sum Finset.univ fun i => S i)) L = Finset.sum Finset.univ fun i => ((f T) (S i)) L"}
{"name":"HomogeneousCubic.instFun","declaration":"instance HomogeneousCubic.instFun {V : Type} [AddCommMonoid V] [Module ℚ V] : FunLike (HomogeneousCubic V) V ℚ"}
{"name":"TriLinearSymm.swap₁","declaration":"theorem TriLinearSymm.swap₁ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S : V) (T : V) (L : V) : ((f S) T) L = ((f T) S) L"}
{"name":"BiLinearSymm.toHomogeneousQuad_toFun","declaration":"theorem BiLinearSymm.toHomogeneousQuad_toFun {V : Type} [AddCommMonoid V] [Module ℚ V] (τ : BiLinearSymm V) (S : V) : (BiLinearSymm.toHomogeneousQuad τ).toFun S = (τ S) S"}
{"name":"BiLinearSymm","declaration":"/-- The structure of a symmetric bilinear function. -/\nstructure BiLinearSymm (V : Type) [AddCommMonoid V] [Module ℚ V] : Type"}
{"name":"HomogeneousQuadratic.instFun","declaration":"instance HomogeneousQuadratic.instFun {V : Type} [AddCommMonoid V] [Module ℚ V] : FunLike (HomogeneousQuadratic V) V ℚ"}
{"name":"«MulActionHom'Local≺»","declaration":"/-- `φ`-equivariant functions `X → Y`,\nwhere `φ : M → N`, where `M` and `N` act on `X` and `Y` respectively -/\ndef «MulActionHom'Local≺»  : Lean.TrailingParserDescr"}
{"name":"BiLinearSymm.instFun","declaration":"instance BiLinearSymm.instFun (V : Type) [AddCommMonoid V] [Module ℚ V] : FunLike (BiLinearSymm V) V (V →ₗ[ℚ] ℚ)"}
{"name":"TriLinearSymm.toCubic_add","declaration":"theorem TriLinearSymm.toCubic_add {charges : Type} [AddCommMonoid charges] [Module ℚ charges] (τ : TriLinearSymm charges) (S : charges) (T : charges) : (TriLinearSymm.toCubic τ) (S + T) =\n  (TriLinearSymm.toCubic τ) S + (TriLinearSymm.toCubic τ) T + 3 * ((τ S) S) T + 3 * ((τ T) T) S"}
{"name":"HomogeneousQuadratic","declaration":"/-- The structure defining a homogeneous quadratic equation. -/\ndef HomogeneousQuadratic (V : Type) [AddCommMonoid V] [Module ℚ V] : Type"}
{"name":"BiLinearSymm.map_add₂","declaration":"theorem BiLinearSymm.map_add₂ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : BiLinearSymm V) (S : V) (T1 : V) (T2 : V) : (f S) (T1 + T2) = (f S) T1 + (f S) T2"}
{"name":"TriLinearSymm.map_add₁","declaration":"theorem TriLinearSymm.map_add₁ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S1 : V) (S2 : V) (T : V) (L : V) : ((f (S1 + S2)) T) L = ((f S1) T) L + ((f S2) T) L"}
{"name":"BiLinearSymm.map_sum₂","declaration":"theorem BiLinearSymm.map_sum₂ {V : Type} [AddCommMonoid V] [Module ℚ V] {n : ℕ} (f : BiLinearSymm V) (S : Fin n → V) (T : V) : (f T) (Finset.sum Finset.univ fun i => S i) = Finset.sum Finset.univ fun i => (f T) (S i)"}
{"name":"TriLinearSymm.mk₃","declaration":"/-- The construction of a symmetric trilinear map from `smul` and `map_add` in the first factor,\nand two swap. -/\ndef TriLinearSymm.mk₃ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : V × V × V → ℚ) (map_smul : ∀ (a : ℚ) (S T L : V), f (a • S, T, L) = a * f (S, T, L)) (map_add : ∀ (S1 S2 T L : V), f (S1 + S2, T, L) = f (S1, T, L) + f (S2, T, L)) (swap₁ : ∀ (S T L : V), f (S, T, L) = f (T, S, L)) (swap₂ : ∀ (S T L : V), f (S, T, L) = f (S, L, T)) : TriLinearSymm V"}
{"name":"TriLinearSymm.instFun","declaration":"instance TriLinearSymm.instFun {V : Type} [AddCommMonoid V] [Module ℚ V] : FunLike (TriLinearSymm V) V (V →ₗ[ℚ] V →ₗ[ℚ] ℚ)"}
{"name":"TriLinearSymm.map_smul₃","declaration":"theorem TriLinearSymm.map_smul₃ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S : V) (T : V) (a : ℚ) (L : V) : ((f S) T) (a • L) = a * ((f S) T) L"}
{"name":"TriLinearSymm.map_smul₂","declaration":"theorem TriLinearSymm.map_smul₂ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S : V) (a : ℚ) (T : V) (L : V) : ((f S) (a • T)) L = a * ((f S) T) L"}
{"name":"MulActionHom'.map_smul'","declaration":"/-- The proposition that the function preserves the action. -/\ndef MulActionHom'.map_smul' {M : Type u_3} {N : Type u_4} {φ : M → N} {X : Type u_1} [SMul M X] {Y : Type u_2} [SMul N Y] (self : X →ₑ[φ] Y) (m : M) (x : X) : self.toFun (m • x) = φ m • self.toFun x"}
{"name":"BiLinearSymm.map_sum₁","declaration":"theorem BiLinearSymm.map_sum₁ {V : Type} [AddCommMonoid V] [Module ℚ V] {n : ℕ} (f : BiLinearSymm V) (S : Fin n → V) (T : V) : (f (Finset.sum Finset.univ fun i => S i)) T = Finset.sum Finset.univ fun i => (f (S i)) T"}
{"name":"BiLinearSymm.toHomogeneousQuad_add","declaration":"theorem BiLinearSymm.toHomogeneousQuad_add {V : Type} [AddCommMonoid V] [Module ℚ V] (τ : BiLinearSymm V) (S : V) (T : V) : (BiLinearSymm.toHomogeneousQuad τ) (S + T) =\n  (BiLinearSymm.toHomogeneousQuad τ) S + (BiLinearSymm.toHomogeneousQuad τ) T + 2 * (τ S) T"}
{"name":"TriLinearSymm.map_sum₁₂₃","declaration":"theorem TriLinearSymm.map_sum₁₂₃ {V : Type} [AddCommMonoid V] [Module ℚ V] {n1 : ℕ} {n2 : ℕ} {n3 : ℕ} (f : TriLinearSymm V) (S : Fin n1 → V) (T : Fin n2 → V) (L : Fin n3 → V) : ((f (Finset.sum Finset.univ fun i => S i)) (Finset.sum Finset.univ fun i => T i))\n    (Finset.sum Finset.univ fun i => L i) =\n  Finset.sum Finset.univ fun i =>\n    Finset.sum Finset.univ fun k => Finset.sum Finset.univ fun l => ((f (S i)) (T k)) (L l)"}
{"name":"IsSymmetric.mk","declaration":"ctor IsSymmetric.mk {V : Type} [AddCommMonoid V] [Module ℚ V] {f : V →ₗ[ℚ] V →ₗ[ℚ] ℚ} (swap : ∀ (S T : V), (f S) T = (f T) S) : IsSymmetric f"}
{"name":"BiLinearSymm.toHomogeneousQuad","declaration":"/-- The homogenous quadratic equation obtainable from a bilinear function. -/\ndef BiLinearSymm.toHomogeneousQuad {V : Type} [AddCommMonoid V] [Module ℚ V] (τ : BiLinearSymm V) : HomogeneousQuadratic V"}
{"name":"TriLinearSymm.swap₂'","declaration":"def TriLinearSymm.swap₂' {V : Type} [AddCommMonoid V] [Module ℚ V] (self : TriLinearSymm V) (S : V) (T : V) (L : V) : ((self.toFun S) T) L = ((self.toFun S) L) T"}
{"name":"TriLinearSymm.toLinear₁","declaration":"/-- Fixing the second and third input vectors, the resulting linear map. -/\ndef TriLinearSymm.toLinear₁ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (T : V) (L : V) : V →ₗ[ℚ] ℚ"}
{"name":"TriLinearSymm.toLinear₁_apply","declaration":"theorem TriLinearSymm.toLinear₁_apply {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S : V) (T : V) (L : V) : ((f S) T) L = (TriLinearSymm.toLinear₁ f T L) S"}
{"name":"TriLinearSymm.mk₃_toFun_apply_apply","declaration":"theorem TriLinearSymm.mk₃_toFun_apply_apply {V : Type} [AddCommMonoid V] [Module ℚ V] (f : V × V × V → ℚ) (map_smul : ∀ (a : ℚ) (S T L : V), f (a • S, T, L) = a * f (S, T, L)) (map_add : ∀ (S1 S2 T L : V), f (S1 + S2, T, L) = f (S1, T, L) + f (S2, T, L)) (swap₁ : ∀ (S T L : V), f (S, T, L) = f (T, S, L)) (swap₂ : ∀ (S T L : V), f (S, T, L) = f (S, L, T)) (S : V) (S : V) (T : V) : (((TriLinearSymm.mk₃ f map_smul map_add swap₁ swap₂) S✝) S) T = f (S✝, S, T)"}
{"name":"TriLinearSymm.map_add₂","declaration":"theorem TriLinearSymm.map_add₂ {V : Type} [AddCommMonoid V] [Module ℚ V] (f : TriLinearSymm V) (S : V) (T1 : V) (T2 : V) (L : V) : ((f S) (T1 + T2)) L = ((f S) T1) L + ((f S) T2) L"}
