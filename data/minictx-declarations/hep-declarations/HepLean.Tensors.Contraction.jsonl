{"name":"TensorStructure.contr_cond","declaration":"theorem TensorStructure.contr_cond {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} (e : (C âŠ• C) âŠ• P â‰ƒ X) : TensorColor.ColorMap.MapIso e.symm cX\n  (Sum.elim (Sum.elim (TensorColor.ColorMap.contrLeft e cX) (TensorColor.ColorMap.contrRight e cX))\n    (TensorColor.ColorMap.contr e cX))"}
{"name":"TensorStructure.contrAll'_mapIso","declaration":"theorem TensorStructure.contrAll'_mapIso {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [Fintype Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.MapIso e cX cY) : TensorStructure.contrAll' ğ“£ âˆ˜â‚—\n    â†‘(TensorProduct.congr (TensorStructure.mapIso ğ“£ e h) (LinearEquiv.refl R (TensorStructure.Tensor ğ“£ (ğ“£.Ï„ âˆ˜ cY)))) =\n  TensorStructure.contrAll' ğ“£ âˆ˜â‚—\n    â†‘(TensorProduct.congr (LinearEquiv.refl R (TensorStructure.Tensor ğ“£ cX)) (TensorStructure.mapIso ğ“£ e.symm â‹¯))"}
{"name":"TensorColor.ColorMap.ContrAll","declaration":"/-- Given an equivalence `e` of types the condition that the color map `cX` is the dual to `cY`\nup to this equivalence. -/\ndef TensorColor.ColorMap.ContrAll {X : Type} {Y : Type} {ğ“’ : TensorColor} (e : X â‰ƒ Y) (cX : TensorColor.ColorMap ğ“’ X) (cY : TensorColor.ColorMap ğ“’ Y) : Prop"}
{"name":"TensorStructure.contrAll_mapIso_left_tmul","declaration":"theorem TensorStructure.contrAll_mapIso_left_tmul {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] [Fintype Z] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {e : X â‰ƒ Y} {e' : Z â‰ƒ X} (h : TensorColor.ColorMap.ContrAll e cX cY) (h' : TensorColor.ColorMap.MapIso e' cZ cX) (x : TensorStructure.Tensor ğ“£ cZ) (y : TensorStructure.Tensor ğ“£ cY) : (TensorStructure.contrAll ğ“£ e h) ((TensorStructure.mapIso ğ“£ e' h') x âŠ—â‚œ[R] y) =\n  (TensorStructure.contrAll ğ“£ (e'.trans e) â‹¯) (x âŠ—â‚œ[R] y)"}
{"name":"TensorStructure.contrAll_tmul","declaration":"theorem TensorStructure.contrAll_tmul {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) (x : TensorStructure.Tensor ğ“£ cX) (y : TensorStructure.Tensor ğ“£ cY) : (TensorStructure.contrAll ğ“£ e h) (x âŠ—â‚œ[R] y) =\n  (TensorStructure.contrAll' ğ“£) (x âŠ—â‚œ[R] (TensorStructure.mapIso ğ“£ e.symm â‹¯) y)"}
{"name":"TensorStructure.contrElim","declaration":"/-- The linear map from `ğ“£.Tensor (Sum.elim cW cX) âŠ—[R] ğ“£.Tensor (Sum.elim cY cZ)`\nto `ğ“£.Tensor (Sum.elim cW cZ)` formed by contracting the indices specified by\n`cX` and `cY`, which are assumed to be dual. -/\ndef TensorStructure.contrElim {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [Fintype X] [DecidableEq X] [DecidableEq Y] [DecidableEq Z] [DecidableEq W] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {cW : TensorColor.ColorMap ğ“£.toTensorColor W} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorProduct R (TensorStructure.Tensor ğ“£ (Sum.elim cW cX)) (TensorStructure.Tensor ğ“£ (Sum.elim cY cZ)) â†’â‚—[R]\n  TensorStructure.Tensor ğ“£ (Sum.elim cW cZ)"}
{"name":"TensorColor.ColorMap.ContrAll.toMapIso","declaration":"theorem TensorColor.ColorMap.ContrAll.toMapIso {X : Type} {Y : Type} {ğ“’ : TensorColor} {e : X â‰ƒ Y} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorColor.ColorMap.MapIso e cX (TensorColor.ColorMap.dual cY)"}
{"name":"TensorColor.ColorMap.ContrAll.mapIso_trans","declaration":"theorem TensorColor.ColorMap.ContrAll.mapIso_trans {X : Type} {Y : Type} {Z : Type} {ğ“’ : TensorColor} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} {cZ : TensorColor.ColorMap ğ“’ Z} {e : X â‰ƒ Y} {e' : Z â‰ƒ X} (h : TensorColor.ColorMap.ContrAll e cX cY) (h' : TensorColor.ColorMap.MapIso e' cZ cX) : TensorColor.ColorMap.ContrAll (e'.trans e) cZ cY"}
{"name":"TensorStructure.contrAll_comp_mapIso_right","declaration":"theorem TensorStructure.contrAll_comp_mapIso_right {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {c : TensorColor.ColorMap ğ“£.toTensorColor X} (e : X â‰ƒ Y) (e' : Z â‰ƒ Y) (h : TensorColor.ColorMap.ContrAll e c cY) (h' : TensorColor.ColorMap.MapIso e' cZ cY) : TensorStructure.contrAll ğ“£ e h âˆ˜â‚—\n    â†‘(TensorProduct.congr (LinearEquiv.refl R (TensorStructure.Tensor ğ“£ c)) (TensorStructure.mapIso ğ“£ e' h')) =\n  TensorStructure.contrAll ğ“£ (e.trans e'.symm) â‹¯"}
{"name":"TensorStructure.contrAllLeft","declaration":"/-- The linear map from `ğ“£.Tensor cX âŠ—[R] ğ“£.Tensor cY âŠ—[R] ğ“£.Tensor cZ` to\n`ğ“£.Tensor cZ` obtained by contracting all indices in `ğ“£.Tensor cX` and `ğ“£.Tensor cY`,\ngiven a proof that this is possible. -/\ndef TensorStructure.contrAllLeft {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorProduct R (TensorStructure.Tensor ğ“£ cX)\n    (TensorProduct R (TensorStructure.Tensor ğ“£ cY) (TensorStructure.Tensor ğ“£ cZ)) â†’â‚—[R]\n  TensorStructure.Tensor ğ“£ cZ"}
{"name":"TensorStructure.contr_tprod_isEmpty","declaration":"theorem TensorStructure.contr_tprod_isEmpty {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [Fintype C] [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} [IsEmpty C] (e : (C âŠ• C) âŠ• P â‰ƒ X) (h : TensorColor.ColorMap.ContrCond e cX) (f : (i : X) â†’ ğ“£.ColorModule (cX i)) : (TensorStructure.contr ğ“£ e h) ((PiTensorProduct.tprod R) f) = (PiTensorProduct.tprod R) fun p => f (e (Sum.inr p))"}
{"name":"TensorColor.ColorMap.ContrAll.symm","declaration":"theorem TensorColor.ColorMap.ContrAll.symm {X : Type} {Y : Type} {ğ“’ : TensorColor} {e : X â‰ƒ Y} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorColor.ColorMap.ContrAll e.symm cY cX"}
{"name":"TensorStructure.pairProd","declaration":"/-- A linear map taking tensors mapped with the same index set to the product of paired tensors. -/\ndef TensorStructure.pairProd {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cX2 : TensorColor.ColorMap ğ“£.toTensorColor X} : TensorProduct R (TensorStructure.Tensor ğ“£ cX) (TensorStructure.Tensor ğ“£ cX2) â†’â‚—[R]\n  PiTensorProduct R fun x => TensorProduct R (ğ“£.ColorModule (cX x)) (ğ“£.ColorModule (cX2 x))"}
{"name":"TensorStructure.contrAll'","declaration":"/-- Given a tensor in `ğ“£.Tensor cX` and a tensor in `ğ“£.Tensor (ğ“£.Ï„ âˆ˜ cX)`, the element of\n`R` formed by contracting all of their indices. -/\ndef TensorStructure.contrAll' {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} [Fintype X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} : TensorProduct R (TensorStructure.Tensor ğ“£ cX) (TensorStructure.Tensor ğ“£ (ğ“£.Ï„ âˆ˜ cX)) â†’â‚—[R] R"}
{"name":"TensorColor.ColorMap.contr","declaration":"/-- Given an equivalence `(C âŠ• C) âŠ• P â‰ƒ X` the restriction of a color map `cX` on to `P`. -/\ndef TensorColor.ColorMap.contr {X : Type} {C : Type} {P : Type} {ğ“’ : TensorColor} (e : (C âŠ• C) âŠ• P â‰ƒ X) (cX : TensorColor.ColorMap ğ“’ X) : TensorColor.ColorMap ğ“’ P"}
{"name":"TensorStructure.contrAll_rep_apply","declaration":"theorem TensorStructure.contrAll_rep_apply {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {G : Type} [Group G] [MulActionTensor G ğ“£] {c : X â†’ ğ“£.Color} {d : Y â†’ ğ“£.Color} (e : X â‰ƒ Y) (h : c = ğ“£.Ï„ âˆ˜ d âˆ˜ â‡‘e) (g : G) (x : TensorProduct R (TensorStructure.Tensor ğ“£ c) (TensorStructure.Tensor ğ“£ d)) : (TensorStructure.contrAll ğ“£ e h) ((TensorProduct.map ((TensorStructure.rep ğ“£) g) ((TensorStructure.rep ğ“£) g)) x) =\n  (TensorStructure.contrAll ğ“£ e h) x"}
{"name":"TensorColor.ColorMap.contrLeft","declaration":"/-- Given an equivalence `(C âŠ• C) âŠ• P â‰ƒ X` the restriction of a color map `cX` on `X`\nto the first `C`. -/\ndef TensorColor.ColorMap.contrLeft {X : Type} {C : Type} {P : Type} {ğ“’ : TensorColor} (e : (C âŠ• C) âŠ• P â‰ƒ X) (cX : TensorColor.ColorMap ğ“’ X) : TensorColor.ColorMap ğ“’ C"}
{"name":"TensorStructure.pairProd_tmul_tprod_tprod","declaration":"theorem TensorStructure.pairProd_tmul_tprod_tprod {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cX2 : TensorColor.ColorMap ğ“£.toTensorColor X} (fx : (i : X) â†’ ğ“£.ColorModule (cX i)) (fx2 : (i : X) â†’ ğ“£.ColorModule (cX2 i)) : (TensorStructure.pairProd ğ“£) ((PiTensorProduct.tprod R) fx âŠ—â‚œ[R] (PiTensorProduct.tprod R) fx2) =\n  (PiTensorProduct.tprod R) fun x => fx x âŠ—â‚œ[R] fx2 x"}
{"name":"LinearEquiv.ofLinear_toLinearMap'","declaration":"theorem LinearEquiv.ofLinear_toLinearMap' {Râ‚‚ : Type u_2} {M : Type u_3} {Mâ‚‚ : Type u_1} {R : Type} [Semiring R] [Semiring Râ‚‚] [AddCommMonoid M] [AddCommMonoid Mâ‚‚] {module_M : Module R M} {module_Mâ‚‚ : Module Râ‚‚ Mâ‚‚} {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} {reâ‚â‚‚ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚} {reâ‚‚â‚ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚} (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (g : Mâ‚‚ â†’â‚›â‚—[Ïƒâ‚‚â‚] M) {hâ‚ : LinearMap.comp f g = LinearMap.id} {hâ‚‚ : LinearMap.comp g f = LinearMap.id} : â†‘(LinearEquiv.ofLinear f g hâ‚ hâ‚‚) = f"}
{"name":"TensorStructure.contrAll_mapIso_right_tmul","declaration":"theorem TensorStructure.contrAll_mapIso_right_tmul {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {c : TensorColor.ColorMap ğ“£.toTensorColor X} (e : X â‰ƒ Y) (e' : Z â‰ƒ Y) (h : TensorColor.ColorMap.ContrAll e c cY) (h' : TensorColor.ColorMap.MapIso e' cZ cY) (x : TensorStructure.Tensor ğ“£ c) (z : TensorStructure.Tensor ğ“£ cZ) : (TensorStructure.contrAll ğ“£ e h) (x âŠ—â‚œ[R] (TensorStructure.mapIso ğ“£ e' h') z) =\n  (TensorStructure.contrAll ğ“£ (e.trans e'.symm) â‹¯) (x âŠ—â‚œ[R] z)"}
{"name":"TensorColor.ColorMap.ContrCond.to_contrAll","declaration":"theorem TensorColor.ColorMap.ContrCond.to_contrAll {X : Type} {C : Type} {P : Type} {ğ“’ : TensorColor} {e : (C âŠ• C) âŠ• P â‰ƒ X} {cX : TensorColor.ColorMap ğ“’ X} (h : TensorColor.ColorMap.ContrCond e cX) : TensorColor.ColorMap.ContrAll (Equiv.refl C) (TensorColor.ColorMap.contrLeft e cX)\n  (TensorColor.ColorMap.contrRight e cX)"}
{"name":"TensorStructure.contr_equivariant","declaration":"/-- The contraction of indices via `contr` is equivariant. -/\ntheorem TensorStructure.contr_equivariant {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [Fintype C] [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {G : Type} [Group G] [MulActionTensor G ğ“£] (e : (C âŠ• C) âŠ• P â‰ƒ X) (h : TensorColor.ColorMap.ContrCond e cX) (g : G) (x : TensorStructure.Tensor ğ“£ cX) : (TensorStructure.contr ğ“£ e h) (((TensorStructure.rep ğ“£) g) x) =\n  ((TensorStructure.rep ğ“£) g) ((TensorStructure.contr ğ“£ e h) x)"}
{"name":"TensorColor.ColorMap.ContrCond","declaration":"/-- Given an equivalence `(C âŠ• C) âŠ• P â‰ƒ X` the condition on `cX` so that we contract\nthe indices of the `C`'s under this equivalence. -/\ndef TensorColor.ColorMap.ContrCond {X : Type} {C : Type} {P : Type} {ğ“’ : TensorColor} (e : (C âŠ• C) âŠ• P â‰ƒ X) (cX : TensorColor.ColorMap ğ“’ X) : Prop"}
{"name":"TensorStructure.contrAll","declaration":"/-- The contraction of all the indices of two tensors with dual colors. -/\ndef TensorStructure.contrAll {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorProduct R (TensorStructure.Tensor ğ“£ cX) (TensorStructure.Tensor ğ“£ cY) â†’â‚—[R] R"}
{"name":"TensorStructure.contrAll'_tmul_tprod_tprod","declaration":"theorem TensorStructure.contrAll'_tmul_tprod_tprod {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} [Fintype X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} (fx : (i : X) â†’ ğ“£.ColorModule (cX i)) (fy : (i : X) â†’ ğ“£.ColorModule (ğ“£.Ï„ (cX i))) : (TensorStructure.contrAll' ğ“£) ((PiTensorProduct.tprod R) fx âŠ—â‚œ[R] (PiTensorProduct.tprod R) fy) =\n  (PiTensorProduct.lift (MultilinearMap.mkPiAlgebra R X R))\n    ((PiTensorProduct.tprod R) fun x => (ğ“£.contrDual (cX x)) (fx x âŠ—â‚œ[R] fy x))"}
{"name":"TensorStructure.contrDualLeft","declaration":"/-- The contraction of a vector in `ğ“£.ColorModule Î½` with a vector in\n`ğ“£.ColorModule (ğ“£.Ï„ Î½) âŠ—[R] ğ“£.ColorModule Î·` to form a vector in `ğ“£.ColorModule Î·`. -/\ndef TensorStructure.contrDualLeft {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î½ : ğ“£.Color} {Î· : ğ“£.Color} : TensorProduct R (ğ“£.ColorModule Î½) (TensorProduct R (ğ“£.ColorModule (ğ“£.Ï„ Î½)) (ğ“£.ColorModule Î·)) â†’â‚—[R] ğ“£.ColorModule Î·"}
{"name":"TensorStructure.contrAll'_mapIso_tmul","declaration":"theorem TensorStructure.contrAll'_mapIso_tmul {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [Fintype Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.MapIso e cX cY) (x : TensorStructure.Tensor ğ“£ cX) (y : TensorStructure.Tensor ğ“£ (ğ“£.Ï„ âˆ˜ cY)) : (TensorStructure.contrAll' ğ“£) ((TensorStructure.mapIso ğ“£ e h) x âŠ—â‚œ[R] y) =\n  (TensorStructure.contrAll' ğ“£) (x âŠ—â‚œ[R] (TensorStructure.mapIso ğ“£ e.symm â‹¯) y)"}
{"name":"TensorStructure.contrAll_rep_tmul","declaration":"theorem TensorStructure.contrAll_rep_tmul {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {G : Type} [Group G] [MulActionTensor G ğ“£] {c : X â†’ ğ“£.Color} {d : Y â†’ ğ“£.Color} (e : X â‰ƒ Y) (h : c = ğ“£.Ï„ âˆ˜ d âˆ˜ â‡‘e) (g : G) (x : TensorStructure.Tensor ğ“£ c) (y : TensorStructure.Tensor ğ“£ d) : (TensorStructure.contrAll ğ“£ e h) (((TensorStructure.rep ğ“£) g) x âŠ—â‚œ[R] ((TensorStructure.rep ğ“£) g) y) =\n  (TensorStructure.contrAll ğ“£ e h) (x âŠ—â‚œ[R] y)"}
{"name":"TensorColor.ColorMap.ContrAll.trans_mapIso","declaration":"theorem TensorColor.ColorMap.ContrAll.trans_mapIso {X : Type} {Y : Type} {Z : Type} {ğ“’ : TensorColor} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} {cZ : TensorColor.ColorMap ğ“’ Z} {e : X â‰ƒ Y} {e' : Z â‰ƒ Y} (h : TensorColor.ColorMap.ContrAll e cX cY) (h' : TensorColor.ColorMap.MapIso e' cZ cY) : TensorColor.ColorMap.ContrAll (e.trans e'.symm) cX cZ"}
{"name":"TensorStructure.contrAll_rep","declaration":"theorem TensorStructure.contrAll_rep {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {G : Type} [Group G] [MulActionTensor G ğ“£] (e : X â‰ƒ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) (g : G) : TensorStructure.contrAll ğ“£ e h âˆ˜â‚— TensorProduct.map ((TensorStructure.rep ğ“£) g) ((TensorStructure.rep ğ“£) g) =\n  TensorStructure.contrAll ğ“£ e h"}
{"name":"TensorStructure.contr_tprod","declaration":"theorem TensorStructure.contr_tprod {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [Fintype C] [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} (e : (C âŠ• C) âŠ• P â‰ƒ X) (h : TensorColor.ColorMap.ContrCond e cX) (f : (i : X) â†’ ğ“£.ColorModule (cX i)) : (TensorStructure.contr ğ“£ e h) ((PiTensorProduct.tprod R) f) =\n  (TensorStructure.contrAll ğ“£ (Equiv.refl C) â‹¯)\n      (((PiTensorProduct.tprod R) fun i => f (e (Sum.inl (Sum.inl i)))) âŠ—â‚œ[R]\n        (PiTensorProduct.tprod R) fun i => f (e (Sum.inl (Sum.inr i)))) â€¢\n    (PiTensorProduct.tprod R) fun p => f (e (Sum.inr p))"}
{"name":"TensorStructure.contrAll'_isEmpty_tmul","declaration":"theorem TensorStructure.contrAll'_isEmpty_tmul {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} [Fintype X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} [IsEmpty X] (x : TensorStructure.Tensor ğ“£ cX) (y : TensorStructure.Tensor ğ“£ (ğ“£.Ï„ âˆ˜ cX)) : (TensorStructure.contrAll' ğ“£) (x âŠ—â‚œ[R] y) = (TensorStructure.isEmptyEquiv ğ“£) x * (TensorStructure.isEmptyEquiv ğ“£) y"}
{"name":"TensorStructure.mkPiAlgebra_equiv","declaration":"theorem TensorStructure.mkPiAlgebra_equiv {R : Type} [CommSemiring R] {X : Type} {Y : Type} [Fintype X] [Fintype Y] (e : X â‰ƒ Y) : PiTensorProduct.lift (MultilinearMap.mkPiAlgebra R X R) =\n  PiTensorProduct.lift (MultilinearMap.mkPiAlgebra R Y R) âˆ˜â‚— â†‘(PiTensorProduct.reindex R (fun i => R) e)"}
{"name":"TensorColor.ColorMap.contrRight","declaration":"/-- Given an equivalence `(C âŠ• C) âŠ• P â‰ƒ X` the restriction of a color map `cX` on `X`\nto the second `C`. -/\ndef TensorColor.ColorMap.contrRight {X : Type} {C : Type} {P : Type} {ğ“’ : TensorColor} (e : (C âŠ• C) âŠ• P â‰ƒ X) (cX : TensorColor.ColorMap ğ“’ X) : TensorColor.ColorMap ğ“’ C"}
{"name":"TensorStructure.contr","declaration":"/-- Contraction of indices based on an equivalence `(C âŠ• C) âŠ• P â‰ƒ X`. The indices\nin `C` are contracted pair-wise, whilst the indices in `P` are preserved. -/\ndef TensorStructure.contr {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [Fintype C] [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} (e : (C âŠ• C) âŠ• P â‰ƒ X) (h : TensorColor.ColorMap.ContrCond e cX) : TensorStructure.Tensor ğ“£ cX â†’â‚—[R] TensorStructure.Tensor ğ“£ (TensorColor.ColorMap.contr e cX)"}
{"name":"TensorStructure.contrAll_mapIso_left","declaration":"theorem TensorStructure.contrAll_mapIso_left {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] [Fintype Z] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {e : X â‰ƒ Y} {e' : Z â‰ƒ X} (h : TensorColor.ColorMap.ContrAll e cX cY) (h' : TensorColor.ColorMap.MapIso e' cZ cX) : TensorStructure.contrAll ğ“£ e h âˆ˜â‚—\n    â†‘(TensorProduct.congr (TensorStructure.mapIso ğ“£ e' h') (LinearEquiv.refl R (TensorStructure.Tensor ğ“£ cY))) =\n  TensorStructure.contrAll ğ“£ (e'.trans e) â‹¯"}
{"name":"TensorStructure.contrDualMid","declaration":"/-- The contraction of a vector in `ğ“£.ColorModule Î¼ âŠ—[R] ğ“£.ColorModule Î½` with a vector in\n`ğ“£.ColorModule (ğ“£.Ï„ Î½) âŠ—[R] ğ“£.ColorModule Î·` to form a vector in\n`ğ“£.ColorModule Î¼ âŠ—[R] ğ“£.ColorModule Î·`. -/\ndef TensorStructure.contrDualMid {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {Î½ : ğ“£.Color} {Î· : ğ“£.Color} : TensorProduct R (TensorProduct R (ğ“£.ColorModule Î¼) (ğ“£.ColorModule Î½))\n    (TensorProduct R (ğ“£.ColorModule (ğ“£.Ï„ Î½)) (ğ“£.ColorModule Î·)) â†’â‚—[R]\n  TensorProduct R (ğ“£.ColorModule Î¼) (ğ“£.ColorModule Î·)"}
{"name":"TensorStructure.contrAllMid","declaration":"/-- The linear map from `(ğ“£.Tensor cW âŠ—[R] ğ“£.Tensor cX) âŠ—[R] (ğ“£.Tensor cY âŠ—[R] ğ“£.Tensor cZ)`\nto `ğ“£.Tensor cW âŠ—[R] ğ“£.Tensor cZ` obtained by contracting all indices of the tensors\nin the middle. -/\ndef TensorStructure.contrAllMid {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [Fintype X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {cW : TensorColor.ColorMap ğ“£.toTensorColor W} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorProduct R (TensorProduct R (TensorStructure.Tensor ğ“£ cW) (TensorStructure.Tensor ğ“£ cX))\n    (TensorProduct R (TensorStructure.Tensor ğ“£ cY) (TensorStructure.Tensor ğ“£ cZ)) â†’â‚—[R]\n  TensorProduct R (TensorStructure.Tensor ğ“£ cW) (TensorStructure.Tensor ğ“£ cZ)"}
