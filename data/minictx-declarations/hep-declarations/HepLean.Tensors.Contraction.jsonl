{"name":"TensorStructure.contr_cond","declaration":"theorem TensorStructure.contr_cond {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {C : Type} {P : Type} {cX : TensorColor.ColorMap ùì£.toTensorColor X} (e : (C ‚äï C) ‚äï P ‚âÉ X) : TensorColor.ColorMap.MapIso e.symm cX\n  (Sum.elim (Sum.elim (TensorColor.ColorMap.contrLeft e cX) (TensorColor.ColorMap.contrRight e cX))\n    (TensorColor.ColorMap.contr e cX))"}
{"name":"TensorStructure.contrAll'_mapIso","declaration":"theorem TensorStructure.contrAll'_mapIso {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [Fintype Y] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} (e : X ‚âÉ Y) (h : TensorColor.ColorMap.MapIso e cX cY) : TensorStructure.contrAll' ùì£ ‚àò‚Çó\n    ‚Üë(TensorProduct.congr (TensorStructure.mapIso ùì£ e h) (LinearEquiv.refl R (TensorStructure.Tensor ùì£ (ùì£.œÑ ‚àò cY)))) =\n  TensorStructure.contrAll' ùì£ ‚àò‚Çó\n    ‚Üë(TensorProduct.congr (LinearEquiv.refl R (TensorStructure.Tensor ùì£ cX)) (TensorStructure.mapIso ùì£ e.symm ‚ãØ))"}
{"name":"TensorColor.ColorMap.ContrAll","declaration":"/-- Given an equivalence `e` of types the condition that the color map `cX` is the dual to `cY`\nup to this equivalence. -/\ndef TensorColor.ColorMap.ContrAll {X : Type} {Y : Type} {ùìí : TensorColor} (e : X ‚âÉ Y) (cX : TensorColor.ColorMap ùìí X) (cY : TensorColor.ColorMap ùìí Y) : Prop"}
{"name":"TensorStructure.contrAll_mapIso_left_tmul","declaration":"theorem TensorStructure.contrAll_mapIso_left_tmul {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] [Fintype Z] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} {cZ : TensorColor.ColorMap ùì£.toTensorColor Z} {e : X ‚âÉ Y} {e' : Z ‚âÉ X} (h : TensorColor.ColorMap.ContrAll e cX cY) (h' : TensorColor.ColorMap.MapIso e' cZ cX) (x : TensorStructure.Tensor ùì£ cZ) (y : TensorStructure.Tensor ùì£ cY) : (TensorStructure.contrAll ùì£ e h) ((TensorStructure.mapIso ùì£ e' h') x ‚äó‚Çú[R] y) =\n  (TensorStructure.contrAll ùì£ (e'.trans e) ‚ãØ) (x ‚äó‚Çú[R] y)"}
{"name":"TensorStructure.contrAll_tmul","declaration":"theorem TensorStructure.contrAll_tmul {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} (e : X ‚âÉ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) (x : TensorStructure.Tensor ùì£ cX) (y : TensorStructure.Tensor ùì£ cY) : (TensorStructure.contrAll ùì£ e h) (x ‚äó‚Çú[R] y) =\n  (TensorStructure.contrAll' ùì£) (x ‚äó‚Çú[R] (TensorStructure.mapIso ùì£ e.symm ‚ãØ) y)"}
{"name":"TensorStructure.contrElim","declaration":"/-- The linear map from `ùì£.Tensor (Sum.elim cW cX) ‚äó[R] ùì£.Tensor (Sum.elim cY cZ)`\nto `ùì£.Tensor (Sum.elim cW cZ)` formed by contracting the indices specified by\n`cX` and `cY`, which are assumed to be dual. -/\ndef TensorStructure.contrElim {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [Fintype X] [DecidableEq X] [DecidableEq Y] [DecidableEq Z] [DecidableEq W] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} {cZ : TensorColor.ColorMap ùì£.toTensorColor Z} {cW : TensorColor.ColorMap ùì£.toTensorColor W} (e : X ‚âÉ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorProduct R (TensorStructure.Tensor ùì£ (Sum.elim cW cX)) (TensorStructure.Tensor ùì£ (Sum.elim cY cZ)) ‚Üí‚Çó[R]\n  TensorStructure.Tensor ùì£ (Sum.elim cW cZ)"}
{"name":"TensorColor.ColorMap.ContrAll.toMapIso","declaration":"theorem TensorColor.ColorMap.ContrAll.toMapIso {X : Type} {Y : Type} {ùìí : TensorColor} {e : X ‚âÉ Y} {cX : TensorColor.ColorMap ùìí X} {cY : TensorColor.ColorMap ùìí Y} (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorColor.ColorMap.MapIso e cX (TensorColor.ColorMap.dual cY)"}
{"name":"TensorColor.ColorMap.ContrAll.mapIso_trans","declaration":"theorem TensorColor.ColorMap.ContrAll.mapIso_trans {X : Type} {Y : Type} {Z : Type} {ùìí : TensorColor} {cX : TensorColor.ColorMap ùìí X} {cY : TensorColor.ColorMap ùìí Y} {cZ : TensorColor.ColorMap ùìí Z} {e : X ‚âÉ Y} {e' : Z ‚âÉ X} (h : TensorColor.ColorMap.ContrAll e cX cY) (h' : TensorColor.ColorMap.MapIso e' cZ cX) : TensorColor.ColorMap.ContrAll (e'.trans e) cZ cY"}
{"name":"TensorStructure.contrAll_comp_mapIso_right","declaration":"theorem TensorStructure.contrAll_comp_mapIso_right {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] {cY : TensorColor.ColorMap ùì£.toTensorColor Y} {cZ : TensorColor.ColorMap ùì£.toTensorColor Z} {c : TensorColor.ColorMap ùì£.toTensorColor X} (e : X ‚âÉ Y) (e' : Z ‚âÉ Y) (h : TensorColor.ColorMap.ContrAll e c cY) (h' : TensorColor.ColorMap.MapIso e' cZ cY) : TensorStructure.contrAll ùì£ e h ‚àò‚Çó\n    ‚Üë(TensorProduct.congr (LinearEquiv.refl R (TensorStructure.Tensor ùì£ c)) (TensorStructure.mapIso ùì£ e' h')) =\n  TensorStructure.contrAll ùì£ (e.trans e'.symm) ‚ãØ"}
{"name":"TensorStructure.contrAllLeft","declaration":"/-- The linear map from `ùì£.Tensor cX ‚äó[R] ùì£.Tensor cY ‚äó[R] ùì£.Tensor cZ` to\n`ùì£.Tensor cZ` obtained by contracting all indices in `ùì£.Tensor cX` and `ùì£.Tensor cY`,\ngiven a proof that this is possible. -/\ndef TensorStructure.contrAllLeft {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} {cZ : TensorColor.ColorMap ùì£.toTensorColor Z} (e : X ‚âÉ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorProduct R (TensorStructure.Tensor ùì£ cX)\n    (TensorProduct R (TensorStructure.Tensor ùì£ cY) (TensorStructure.Tensor ùì£ cZ)) ‚Üí‚Çó[R]\n  TensorStructure.Tensor ùì£ cZ"}
{"name":"TensorStructure.contr_tprod_isEmpty","declaration":"theorem TensorStructure.contr_tprod_isEmpty {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [Fintype C] [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ùì£.toTensorColor X} [IsEmpty C] (e : (C ‚äï C) ‚äï P ‚âÉ X) (h : TensorColor.ColorMap.ContrCond e cX) (f : (i : X) ‚Üí ùì£.ColorModule (cX i)) : (TensorStructure.contr ùì£ e h) ((PiTensorProduct.tprod R) f) = (PiTensorProduct.tprod R) fun p => f (e (Sum.inr p))"}
{"name":"TensorColor.ColorMap.ContrAll.symm","declaration":"theorem TensorColor.ColorMap.ContrAll.symm {X : Type} {Y : Type} {ùìí : TensorColor} {e : X ‚âÉ Y} {cX : TensorColor.ColorMap ùìí X} {cY : TensorColor.ColorMap ùìí Y} (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorColor.ColorMap.ContrAll e.symm cY cX"}
{"name":"TensorStructure.pairProd","declaration":"/-- A linear map taking tensors mapped with the same index set to the product of paired tensors. -/\ndef TensorStructure.pairProd {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cX2 : TensorColor.ColorMap ùì£.toTensorColor X} : TensorProduct R (TensorStructure.Tensor ùì£ cX) (TensorStructure.Tensor ùì£ cX2) ‚Üí‚Çó[R]\n  PiTensorProduct R fun x => TensorProduct R (ùì£.ColorModule (cX x)) (ùì£.ColorModule (cX2 x))"}
{"name":"TensorStructure.contrAll'","declaration":"/-- Given a tensor in `ùì£.Tensor cX` and a tensor in `ùì£.Tensor (ùì£.œÑ ‚àò cX)`, the element of\n`R` formed by contracting all of their indices. -/\ndef TensorStructure.contrAll' {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} [Fintype X] {cX : TensorColor.ColorMap ùì£.toTensorColor X} : TensorProduct R (TensorStructure.Tensor ùì£ cX) (TensorStructure.Tensor ùì£ (ùì£.œÑ ‚àò cX)) ‚Üí‚Çó[R] R"}
{"name":"TensorColor.ColorMap.contr","declaration":"/-- Given an equivalence `(C ‚äï C) ‚äï P ‚âÉ X` the restriction of a color map `cX` on to `P`. -/\ndef TensorColor.ColorMap.contr {X : Type} {C : Type} {P : Type} {ùìí : TensorColor} (e : (C ‚äï C) ‚äï P ‚âÉ X) (cX : TensorColor.ColorMap ùìí X) : TensorColor.ColorMap ùìí P"}
{"name":"TensorStructure.contrAll_rep_apply","declaration":"theorem TensorStructure.contrAll_rep_apply {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {G : Type} [Group G] [MulActionTensor G ùì£] {c : X ‚Üí ùì£.Color} {d : Y ‚Üí ùì£.Color} (e : X ‚âÉ Y) (h : c = ùì£.œÑ ‚àò d ‚àò ‚áëe) (g : G) (x : TensorProduct R (TensorStructure.Tensor ùì£ c) (TensorStructure.Tensor ùì£ d)) : (TensorStructure.contrAll ùì£ e h) ((TensorProduct.map ((TensorStructure.rep ùì£) g) ((TensorStructure.rep ùì£) g)) x) =\n  (TensorStructure.contrAll ùì£ e h) x"}
{"name":"TensorColor.ColorMap.contrLeft","declaration":"/-- Given an equivalence `(C ‚äï C) ‚äï P ‚âÉ X` the restriction of a color map `cX` on `X`\nto the first `C`. -/\ndef TensorColor.ColorMap.contrLeft {X : Type} {C : Type} {P : Type} {ùìí : TensorColor} (e : (C ‚äï C) ‚äï P ‚âÉ X) (cX : TensorColor.ColorMap ùìí X) : TensorColor.ColorMap ùìí C"}
{"name":"TensorStructure.pairProd_tmul_tprod_tprod","declaration":"theorem TensorStructure.pairProd_tmul_tprod_tprod {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cX2 : TensorColor.ColorMap ùì£.toTensorColor X} (fx : (i : X) ‚Üí ùì£.ColorModule (cX i)) (fx2 : (i : X) ‚Üí ùì£.ColorModule (cX2 i)) : (TensorStructure.pairProd ùì£) ((PiTensorProduct.tprod R) fx ‚äó‚Çú[R] (PiTensorProduct.tprod R) fx2) =\n  (PiTensorProduct.tprod R) fun x => fx x ‚äó‚Çú[R] fx2 x"}
{"name":"LinearEquiv.ofLinear_toLinearMap'","declaration":"theorem LinearEquiv.ofLinear_toLinearMap' {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_1} {R : Type} [Semiring R] [Semiring R‚ÇÇ] [AddCommMonoid M] [AddCommMonoid M‚ÇÇ] {module_M : Module R M} {module_M‚ÇÇ : Module R‚ÇÇ M‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} {re‚ÇÅ‚ÇÇ : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ} {re‚ÇÇ‚ÇÅ : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ} (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (g : M‚ÇÇ ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÅ] M) {h‚ÇÅ : LinearMap.comp f g = LinearMap.id} {h‚ÇÇ : LinearMap.comp g f = LinearMap.id} : ‚Üë(LinearEquiv.ofLinear f g h‚ÇÅ h‚ÇÇ) = f"}
{"name":"TensorStructure.contrAll_mapIso_right_tmul","declaration":"theorem TensorStructure.contrAll_mapIso_right_tmul {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] {cY : TensorColor.ColorMap ùì£.toTensorColor Y} {cZ : TensorColor.ColorMap ùì£.toTensorColor Z} {c : TensorColor.ColorMap ùì£.toTensorColor X} (e : X ‚âÉ Y) (e' : Z ‚âÉ Y) (h : TensorColor.ColorMap.ContrAll e c cY) (h' : TensorColor.ColorMap.MapIso e' cZ cY) (x : TensorStructure.Tensor ùì£ c) (z : TensorStructure.Tensor ùì£ cZ) : (TensorStructure.contrAll ùì£ e h) (x ‚äó‚Çú[R] (TensorStructure.mapIso ùì£ e' h') z) =\n  (TensorStructure.contrAll ùì£ (e.trans e'.symm) ‚ãØ) (x ‚äó‚Çú[R] z)"}
{"name":"TensorColor.ColorMap.ContrCond.to_contrAll","declaration":"theorem TensorColor.ColorMap.ContrCond.to_contrAll {X : Type} {C : Type} {P : Type} {ùìí : TensorColor} {e : (C ‚äï C) ‚äï P ‚âÉ X} {cX : TensorColor.ColorMap ùìí X} (h : TensorColor.ColorMap.ContrCond e cX) : TensorColor.ColorMap.ContrAll (Equiv.refl C) (TensorColor.ColorMap.contrLeft e cX)\n  (TensorColor.ColorMap.contrRight e cX)"}
{"name":"TensorStructure.contr_equivariant","declaration":"/-- The contraction of indices via `contr` is equivariant. -/\ntheorem TensorStructure.contr_equivariant {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [Fintype C] [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {G : Type} [Group G] [MulActionTensor G ùì£] (e : (C ‚äï C) ‚äï P ‚âÉ X) (h : TensorColor.ColorMap.ContrCond e cX) (g : G) (x : TensorStructure.Tensor ùì£ cX) : (TensorStructure.contr ùì£ e h) (((TensorStructure.rep ùì£) g) x) =\n  ((TensorStructure.rep ùì£) g) ((TensorStructure.contr ùì£ e h) x)"}
{"name":"TensorColor.ColorMap.ContrCond","declaration":"/-- Given an equivalence `(C ‚äï C) ‚äï P ‚âÉ X` the condition on `cX` so that we contract\nthe indices of the `C`'s under this equivalence. -/\ndef TensorColor.ColorMap.ContrCond {X : Type} {C : Type} {P : Type} {ùìí : TensorColor} (e : (C ‚äï C) ‚äï P ‚âÉ X) (cX : TensorColor.ColorMap ùìí X) : Prop"}
{"name":"TensorStructure.contrAll","declaration":"/-- The contraction of all the indices of two tensors with dual colors. -/\ndef TensorStructure.contrAll {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} (e : X ‚âÉ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorProduct R (TensorStructure.Tensor ùì£ cX) (TensorStructure.Tensor ùì£ cY) ‚Üí‚Çó[R] R"}
{"name":"TensorStructure.contrAll'_tmul_tprod_tprod","declaration":"theorem TensorStructure.contrAll'_tmul_tprod_tprod {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} [Fintype X] {cX : TensorColor.ColorMap ùì£.toTensorColor X} (fx : (i : X) ‚Üí ùì£.ColorModule (cX i)) (fy : (i : X) ‚Üí ùì£.ColorModule (ùì£.œÑ (cX i))) : (TensorStructure.contrAll' ùì£) ((PiTensorProduct.tprod R) fx ‚äó‚Çú[R] (PiTensorProduct.tprod R) fy) =\n  (PiTensorProduct.lift (MultilinearMap.mkPiAlgebra R X R))\n    ((PiTensorProduct.tprod R) fun x => (ùì£.contrDual (cX x)) (fx x ‚äó‚Çú[R] fy x))"}
{"name":"TensorStructure.contrDualLeft","declaration":"/-- The contraction of a vector in `ùì£.ColorModule ŒΩ` with a vector in\n`ùì£.ColorModule (ùì£.œÑ ŒΩ) ‚äó[R] ùì£.ColorModule Œ∑` to form a vector in `ùì£.ColorModule Œ∑`. -/\ndef TensorStructure.contrDualLeft {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {ŒΩ : ùì£.Color} {Œ∑ : ùì£.Color} : TensorProduct R (ùì£.ColorModule ŒΩ) (TensorProduct R (ùì£.ColorModule (ùì£.œÑ ŒΩ)) (ùì£.ColorModule Œ∑)) ‚Üí‚Çó[R] ùì£.ColorModule Œ∑"}
{"name":"TensorStructure.contrAll'_mapIso_tmul","declaration":"theorem TensorStructure.contrAll'_mapIso_tmul {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [Fintype Y] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} (e : X ‚âÉ Y) (h : TensorColor.ColorMap.MapIso e cX cY) (x : TensorStructure.Tensor ùì£ cX) (y : TensorStructure.Tensor ùì£ (ùì£.œÑ ‚àò cY)) : (TensorStructure.contrAll' ùì£) ((TensorStructure.mapIso ùì£ e h) x ‚äó‚Çú[R] y) =\n  (TensorStructure.contrAll' ùì£) (x ‚äó‚Çú[R] (TensorStructure.mapIso ùì£ e.symm ‚ãØ) y)"}
{"name":"TensorStructure.contrAll_rep_tmul","declaration":"theorem TensorStructure.contrAll_rep_tmul {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {G : Type} [Group G] [MulActionTensor G ùì£] {c : X ‚Üí ùì£.Color} {d : Y ‚Üí ùì£.Color} (e : X ‚âÉ Y) (h : c = ùì£.œÑ ‚àò d ‚àò ‚áëe) (g : G) (x : TensorStructure.Tensor ùì£ c) (y : TensorStructure.Tensor ùì£ d) : (TensorStructure.contrAll ùì£ e h) (((TensorStructure.rep ùì£) g) x ‚äó‚Çú[R] ((TensorStructure.rep ùì£) g) y) =\n  (TensorStructure.contrAll ùì£ e h) (x ‚äó‚Çú[R] y)"}
{"name":"TensorColor.ColorMap.ContrAll.trans_mapIso","declaration":"theorem TensorColor.ColorMap.ContrAll.trans_mapIso {X : Type} {Y : Type} {Z : Type} {ùìí : TensorColor} {cX : TensorColor.ColorMap ùìí X} {cY : TensorColor.ColorMap ùìí Y} {cZ : TensorColor.ColorMap ùìí Z} {e : X ‚âÉ Y} {e' : Z ‚âÉ Y} (h : TensorColor.ColorMap.ContrAll e cX cY) (h' : TensorColor.ColorMap.MapIso e' cZ cY) : TensorColor.ColorMap.ContrAll (e.trans e'.symm) cX cZ"}
{"name":"TensorStructure.contrAll_rep","declaration":"theorem TensorStructure.contrAll_rep {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} {G : Type} [Group G] [MulActionTensor G ùì£] (e : X ‚âÉ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) (g : G) : TensorStructure.contrAll ùì£ e h ‚àò‚Çó TensorProduct.map ((TensorStructure.rep ùì£) g) ((TensorStructure.rep ùì£) g) =\n  TensorStructure.contrAll ùì£ e h"}
{"name":"TensorStructure.contr_tprod","declaration":"theorem TensorStructure.contr_tprod {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [Fintype C] [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ùì£.toTensorColor X} (e : (C ‚äï C) ‚äï P ‚âÉ X) (h : TensorColor.ColorMap.ContrCond e cX) (f : (i : X) ‚Üí ùì£.ColorModule (cX i)) : (TensorStructure.contr ùì£ e h) ((PiTensorProduct.tprod R) f) =\n  (TensorStructure.contrAll ùì£ (Equiv.refl C) ‚ãØ)\n      (((PiTensorProduct.tprod R) fun i => f (e (Sum.inl (Sum.inl i)))) ‚äó‚Çú[R]\n        (PiTensorProduct.tprod R) fun i => f (e (Sum.inl (Sum.inr i)))) ‚Ä¢\n    (PiTensorProduct.tprod R) fun p => f (e (Sum.inr p))"}
{"name":"TensorStructure.contrAll'_isEmpty_tmul","declaration":"theorem TensorStructure.contrAll'_isEmpty_tmul {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} [Fintype X] {cX : TensorColor.ColorMap ùì£.toTensorColor X} [IsEmpty X] (x : TensorStructure.Tensor ùì£ cX) (y : TensorStructure.Tensor ùì£ (ùì£.œÑ ‚àò cX)) : (TensorStructure.contrAll' ùì£) (x ‚äó‚Çú[R] y) = (TensorStructure.isEmptyEquiv ùì£) x * (TensorStructure.isEmptyEquiv ùì£) y"}
{"name":"TensorStructure.mkPiAlgebra_equiv","declaration":"theorem TensorStructure.mkPiAlgebra_equiv {R : Type} [CommSemiring R] {X : Type} {Y : Type} [Fintype X] [Fintype Y] (e : X ‚âÉ Y) : PiTensorProduct.lift (MultilinearMap.mkPiAlgebra R X R) =\n  PiTensorProduct.lift (MultilinearMap.mkPiAlgebra R Y R) ‚àò‚Çó ‚Üë(PiTensorProduct.reindex R (fun i => R) e)"}
{"name":"TensorColor.ColorMap.contrRight","declaration":"/-- Given an equivalence `(C ‚äï C) ‚äï P ‚âÉ X` the restriction of a color map `cX` on `X`\nto the second `C`. -/\ndef TensorColor.ColorMap.contrRight {X : Type} {C : Type} {P : Type} {ùìí : TensorColor} (e : (C ‚äï C) ‚äï P ‚âÉ X) (cX : TensorColor.ColorMap ùìí X) : TensorColor.ColorMap ùìí C"}
{"name":"TensorStructure.contr","declaration":"/-- Contraction of indices based on an equivalence `(C ‚äï C) ‚äï P ‚âÉ X`. The indices\nin `C` are contracted pair-wise, whilst the indices in `P` are preserved. -/\ndef TensorStructure.contr {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [Fintype C] [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ùì£.toTensorColor X} (e : (C ‚äï C) ‚äï P ‚âÉ X) (h : TensorColor.ColorMap.ContrCond e cX) : TensorStructure.Tensor ùì£ cX ‚Üí‚Çó[R] TensorStructure.Tensor ùì£ (TensorColor.ColorMap.contr e cX)"}
{"name":"TensorStructure.contrAll_mapIso_left","declaration":"theorem TensorStructure.contrAll_mapIso_left {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} [Fintype X] [Fintype Z] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} {cZ : TensorColor.ColorMap ùì£.toTensorColor Z} {e : X ‚âÉ Y} {e' : Z ‚âÉ X} (h : TensorColor.ColorMap.ContrAll e cX cY) (h' : TensorColor.ColorMap.MapIso e' cZ cX) : TensorStructure.contrAll ùì£ e h ‚àò‚Çó\n    ‚Üë(TensorProduct.congr (TensorStructure.mapIso ùì£ e' h') (LinearEquiv.refl R (TensorStructure.Tensor ùì£ cY))) =\n  TensorStructure.contrAll ùì£ (e'.trans e) ‚ãØ"}
{"name":"TensorStructure.contrDualMid","declaration":"/-- The contraction of a vector in `ùì£.ColorModule Œº ‚äó[R] ùì£.ColorModule ŒΩ` with a vector in\n`ùì£.ColorModule (ùì£.œÑ ŒΩ) ‚äó[R] ùì£.ColorModule Œ∑` to form a vector in\n`ùì£.ColorModule Œº ‚äó[R] ùì£.ColorModule Œ∑`. -/\ndef TensorStructure.contrDualMid {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {Œº : ùì£.Color} {ŒΩ : ùì£.Color} {Œ∑ : ùì£.Color} : TensorProduct R (TensorProduct R (ùì£.ColorModule Œº) (ùì£.ColorModule ŒΩ))\n    (TensorProduct R (ùì£.ColorModule (ùì£.œÑ ŒΩ)) (ùì£.ColorModule Œ∑)) ‚Üí‚Çó[R]\n  TensorProduct R (ùì£.ColorModule Œº) (ùì£.ColorModule Œ∑)"}
{"name":"TensorStructure.contrAllMid","declaration":"/-- The linear map from `(ùì£.Tensor cW ‚äó[R] ùì£.Tensor cX) ‚äó[R] (ùì£.Tensor cY ‚äó[R] ùì£.Tensor cZ)`\nto `ùì£.Tensor cW ‚äó[R] ùì£.Tensor cZ` obtained by contracting all indices of the tensors\nin the middle. -/\ndef TensorStructure.contrAllMid {R : Type} [CommSemiring R] (ùì£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [Fintype X] {cX : TensorColor.ColorMap ùì£.toTensorColor X} {cY : TensorColor.ColorMap ùì£.toTensorColor Y} {cZ : TensorColor.ColorMap ùì£.toTensorColor Z} {cW : TensorColor.ColorMap ùì£.toTensorColor W} (e : X ‚âÉ Y) (h : TensorColor.ColorMap.ContrAll e cX cY) : TensorProduct R (TensorProduct R (TensorStructure.Tensor ùì£ cW) (TensorStructure.Tensor ùì£ cX))\n    (TensorProduct R (TensorStructure.Tensor ùì£ cY) (TensorStructure.Tensor ùì£ cZ)) ‚Üí‚Çó[R]\n  TensorProduct R (TensorStructure.Tensor ùì£ cW) (TensorStructure.Tensor ùì£ cZ)"}
