{"name":"SMνCharges.toSpecies","declaration":"/-- Given an `i ∈ Fin 6`, the projection of charges onto a given species. -/\ndef SMνCharges.toSpecies {n : ℕ} (i : Fin 6) : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ACCSystemCharges.Charges (SMνSpecies n)"}
{"name":"SMνACCs.quadBiLin","declaration":"/-- The quadratic bilinear map. -/\ndef SMνACCs.quadBiLin {n : ℕ} : BiLinearSymm (ACCSystemCharges.Charges (SMνCharges n))"}
{"name":"SMνCharges.toSpeciesEquiv_apply","declaration":"theorem SMνCharges.toSpeciesEquiv_apply {n : ℕ} : ∀ (a : Fin (6 * n) → ℚ) (a_1 : Fin 6) (a_2 : Fin n),\n  SMνCharges.toSpeciesEquiv a a_1 a_2 = a (finProdFinEquiv (a_1, a_2))"}
{"name":"SMνACCs.accCube_decomp","declaration":"theorem SMνACCs.accCube_decomp {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) : SMνACCs.accCube S =\n  (((((6 * Finset.sum Finset.univ fun i => SMνCharges.Q S i ^ 3) +\n            3 * Finset.sum Finset.univ fun i => SMνCharges.U S i ^ 3) +\n          3 * Finset.sum Finset.univ fun i => SMνCharges.D S i ^ 3) +\n        2 * Finset.sum Finset.univ fun i => SMνCharges.L S i ^ 3) +\n      Finset.sum Finset.univ fun i => SMνCharges.E S i ^ 3) +\n    Finset.sum Finset.univ fun i => SMνCharges.N S i ^ 3"}
{"name":"SMνACCs.quadBiLin_decomp","declaration":"theorem SMνACCs.quadBiLin_decomp {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) (T : ACCSystemCharges.Charges (SMνCharges n)) : (SMνACCs.quadBiLin S) T =\n  ((((Finset.sum Finset.univ fun i => SMνCharges.Q S i * SMνCharges.Q T i) -\n          2 * Finset.sum Finset.univ fun i => SMνCharges.U S i * SMνCharges.U T i) +\n        Finset.sum Finset.univ fun i => SMνCharges.D S i * SMνCharges.D T i) -\n      Finset.sum Finset.univ fun i => SMνCharges.L S i * SMνCharges.L T i) +\n    Finset.sum Finset.univ fun i => SMνCharges.E S i * SMνCharges.E T i"}
{"name":"SMνACCs.accSU3_decomp","declaration":"theorem SMνACCs.accSU3_decomp {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) : SMνACCs.accSU3 S =\n  ((2 * Finset.sum Finset.univ fun i => SMνCharges.Q S i) + Finset.sum Finset.univ fun i => SMνCharges.U S i) +\n    Finset.sum Finset.univ fun i => SMνCharges.D S i"}
{"name":"SMνSpecies","declaration":"/-- The vector spaces of charges of one species of fermions in the SM. -/\ndef SMνSpecies (n : ℕ) : ACCSystemCharges"}
{"name":"SMνCharges.N","declaration":"/-- The `N` charges as a map `Fin n → ℚ`. -/\ndef SMνCharges.N {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ACCSystemCharges.Charges (SMνSpecies n)"}
{"name":"SMνCharges.toSMSpecies_toSpecies_inv","declaration":"theorem SMνCharges.toSMSpecies_toSpecies_inv {n : ℕ} (i : Fin 6) (f : Fin 6 → Fin n → ℚ) : (SMνCharges.toSpecies i) (SMνCharges.toSpeciesEquiv.symm f) = f i"}
{"name":"SMνACCs.accSU3_ext","declaration":"/-- Extensionality lemma for `accSU3`. -/\ntheorem SMνACCs.accSU3_ext {n : ℕ} {S : ACCSystemCharges.Charges (SMνCharges n)} {T : ACCSystemCharges.Charges (SMνCharges n)} (hj : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => (SMνCharges.toSpecies j) S i) =\n    Finset.sum Finset.univ fun i => (SMνCharges.toSpecies j) T i) : SMνACCs.accSU3 S = SMνACCs.accSU3 T"}
{"name":"SMνCharges.toSpecies_one","declaration":"theorem SMνCharges.toSpecies_one (S : ACCSystemCharges.Charges (SMνCharges 1)) (j : Fin 6) : (SMνCharges.toSpecies j) S { val := 0, isLt := ⋯ } = S j"}
{"name":"SMνACCs.cubeTriLin_decomp","declaration":"theorem SMνACCs.cubeTriLin_decomp {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) (T : ACCSystemCharges.Charges (SMνCharges n)) (R : ACCSystemCharges.Charges (SMνCharges n)) : ((SMνACCs.cubeTriLin S) T) R =\n  (((((6 * Finset.sum Finset.univ fun i => SMνCharges.Q S i * SMνCharges.Q T i * SMνCharges.Q R i) +\n            3 * Finset.sum Finset.univ fun i => SMνCharges.U S i * SMνCharges.U T i * SMνCharges.U R i) +\n          3 * Finset.sum Finset.univ fun i => SMνCharges.D S i * SMνCharges.D T i * SMνCharges.D R i) +\n        2 * Finset.sum Finset.univ fun i => SMνCharges.L S i * SMνCharges.L T i * SMνCharges.L R i) +\n      Finset.sum Finset.univ fun i => SMνCharges.E S i * SMνCharges.E T i * SMνCharges.E R i) +\n    Finset.sum Finset.univ fun i => SMνCharges.N S i * SMνCharges.N T i * SMνCharges.N R i"}
{"name":"SMνCharges.U","declaration":"/-- The `U` charges as a map `Fin n → ℚ`. -/\ndef SMνCharges.U {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ACCSystemCharges.Charges (SMνSpecies n)"}
{"name":"SMνACCs.accCube_ext","declaration":"/-- Extensionality lemma for `accCube`. -/\ntheorem SMνACCs.accCube_ext {n : ℕ} {S : ACCSystemCharges.Charges (SMνCharges n)} {T : ACCSystemCharges.Charges (SMνCharges n)} (h : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => ((fun a => a ^ 3) ∘ (SMνCharges.toSpecies j) S) i) =\n    Finset.sum Finset.univ fun i => ((fun a => a ^ 3) ∘ (SMνCharges.toSpecies j) T) i) : SMνACCs.accCube S = SMνACCs.accCube T"}
{"name":"SMνCharges","declaration":"/-- The vector space of charges corresponding to the SM fermions with RHN. -/\ndef SMνCharges (n : ℕ) : ACCSystemCharges"}
{"name":"SMνACCs.accQuad_decomp","declaration":"theorem SMνACCs.accQuad_decomp {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) : SMνACCs.accQuad S =\n  ((((Finset.sum Finset.univ fun i => SMνCharges.Q S i ^ 2) -\n          2 * Finset.sum Finset.univ fun i => SMνCharges.U S i ^ 2) +\n        Finset.sum Finset.univ fun i => SMνCharges.D S i ^ 2) -\n      Finset.sum Finset.univ fun i => SMνCharges.L S i ^ 2) +\n    Finset.sum Finset.univ fun i => SMνCharges.E S i ^ 2"}
{"name":"SMνACCs.quadBiLin_toFun_apply","declaration":"theorem SMνACCs.quadBiLin_toFun_apply {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) (T : ACCSystemCharges.Charges (SMνCharges n)) : (SMνACCs.quadBiLin S) T =\n  Finset.sum Finset.univ fun x =>\n    S (finProdFinEquiv (0, x)) * T (finProdFinEquiv (0, x)) +\n            -(2 * (S (finProdFinEquiv (1, x)) * T (finProdFinEquiv (1, x)))) +\n          S (finProdFinEquiv (2, x)) * T (finProdFinEquiv (2, x)) +\n        -(S (finProdFinEquiv (3, x)) * T (finProdFinEquiv (3, x))) +\n      S (finProdFinEquiv (4, x)) * T (finProdFinEquiv (4, x))"}
{"name":"SMνACCs.accGrav","declaration":"/-- The gravitational anomaly equation. -/\ndef SMνACCs.accGrav {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ℚ"}
{"name":"SMνACCs.accQuad","declaration":"/-- The quadratic anomaly cancellation condition. -/\ndef SMνACCs.accQuad {n : ℕ} : HomogeneousQuadratic (ACCSystemCharges.Charges (SMνCharges n))"}
{"name":"SMνCharges.toSpeciesEquiv","declaration":"/-- An equivalence between `(SMνCharges n).charges` and `(Fin 6 → Fin n → ℚ)`\nsplitting the charges into species. -/\ndef SMνCharges.toSpeciesEquiv {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) ≃ (Fin 6 → Fin n → ℚ)"}
{"name":"SMνACCs.accQuad_ext","declaration":"/-- Extensionality lemma for `accQuad`. -/\ntheorem SMνACCs.accQuad_ext {n : ℕ} {S : ACCSystemCharges.Charges (SMνCharges n)} {T : ACCSystemCharges.Charges (SMνCharges n)} (h : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => ((fun a => a ^ 2) ∘ (SMνCharges.toSpecies j) S) i) =\n    Finset.sum Finset.univ fun i => ((fun a => a ^ 2) ∘ (SMνCharges.toSpecies j) T) i) : SMνACCs.accQuad S = SMνACCs.accQuad T"}
{"name":"SMνACCs.accGrav_ext","declaration":"/-- Extensionality lemma for `accGrav`. -/\ntheorem SMνACCs.accGrav_ext {n : ℕ} {S : ACCSystemCharges.Charges (SMνCharges n)} {T : ACCSystemCharges.Charges (SMνCharges n)} (hj : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => (SMνCharges.toSpecies j) S i) =\n    Finset.sum Finset.univ fun i => (SMνCharges.toSpecies j) T i) : SMνACCs.accGrav S = SMνACCs.accGrav T"}
{"name":"SMνACCs.accSU3","declaration":"/-- The `SU(3)` anomaly equations. -/\ndef SMνACCs.accSU3 {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ℚ"}
{"name":"SMνACCs.accSU2","declaration":"/-- The `SU(2)` anomaly equation. -/\ndef SMνACCs.accSU2 {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ℚ"}
{"name":"SMνCharges.charges_eq_toSpecies_eq","declaration":"theorem SMνCharges.charges_eq_toSpecies_eq {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) (T : ACCSystemCharges.Charges (SMνCharges n)) : S = T ↔ ∀ (i : Fin 6), (SMνCharges.toSpecies i) S = (SMνCharges.toSpecies i) T"}
{"name":"SMνCharges.E","declaration":"/-- The `E` charges as a map `Fin n → ℚ`. -/\ndef SMνCharges.E {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ACCSystemCharges.Charges (SMνSpecies n)"}
{"name":"SMνACCs.accCube","declaration":"/-- The cubic ACC. -/\ndef SMνACCs.accCube {n : ℕ} : HomogeneousCubic (ACCSystemCharges.Charges (SMνCharges n))"}
{"name":"SMνCharges_numberCharges","declaration":"theorem SMνCharges_numberCharges (n : ℕ) : (SMνCharges n).numberCharges = 6 * n"}
{"name":"SMνCharges.Q","declaration":"/-- The `Q` charges as a map `Fin n → ℚ`. -/\ndef SMνCharges.Q {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ACCSystemCharges.Charges (SMνSpecies n)"}
{"name":"SMνCharges.D","declaration":"/-- The `D` charges as a map `Fin n → ℚ`. -/\ndef SMνCharges.D {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ACCSystemCharges.Charges (SMνSpecies n)"}
{"name":"SMνACCs.accYY","declaration":"/-- The `Y²` anomaly equation. -/\ndef SMνACCs.accYY {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ℚ"}
{"name":"SMνCharges.toSpeciesEquiv_symm_apply","declaration":"theorem SMνCharges.toSpeciesEquiv_symm_apply {n : ℕ} : ∀ (a : Fin 6 → Fin n → ℚ) (a_1 : Fin (6 * n)),\n  SMνCharges.toSpeciesEquiv.symm a a_1 = a (Fin.divNat a_1) (Fin.modNat a_1)"}
{"name":"SMνACCs.accSU2_decomp","declaration":"theorem SMνACCs.accSU2_decomp {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) : SMνACCs.accSU2 S =\n  (3 * Finset.sum Finset.univ fun i => SMνCharges.Q S i) + Finset.sum Finset.univ fun i => SMνCharges.L S i"}
{"name":"SMνACCs.cubeTriLin_toFun_apply_apply","declaration":"theorem SMνACCs.cubeTriLin_toFun_apply_apply {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) (S : ACCSystemCharges.Charges (SMνCharges n)) (T : ACCSystemCharges.Charges (SMνCharges n)) : ((SMνACCs.cubeTriLin S✝) S) T =\n  Finset.sum Finset.univ fun i =>\n    6 * (S✝ (finProdFinEquiv (0, i)) * S (finProdFinEquiv (0, i)) * T (finProdFinEquiv (0, i))) +\n              3 * (S✝ (finProdFinEquiv (1, i)) * S (finProdFinEquiv (1, i)) * T (finProdFinEquiv (1, i))) +\n            3 * (S✝ (finProdFinEquiv (2, i)) * S (finProdFinEquiv (2, i)) * T (finProdFinEquiv (2, i))) +\n          2 * (S✝ (finProdFinEquiv (3, i)) * S (finProdFinEquiv (3, i)) * T (finProdFinEquiv (3, i))) +\n        S✝ (finProdFinEquiv (4, i)) * S (finProdFinEquiv (4, i)) * T (finProdFinEquiv (4, i)) +\n      S✝ (finProdFinEquiv (5, i)) * S (finProdFinEquiv (5, i)) * T (finProdFinEquiv (5, i))"}
{"name":"SMνACCs.accYY_ext","declaration":"/-- Extensionality lemma for `accYY`. -/\ntheorem SMνACCs.accYY_ext {n : ℕ} {S : ACCSystemCharges.Charges (SMνCharges n)} {T : ACCSystemCharges.Charges (SMνCharges n)} (hj : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => (SMνCharges.toSpecies j) S i) =\n    Finset.sum Finset.univ fun i => (SMνCharges.toSpecies j) T i) : SMνACCs.accYY S = SMνACCs.accYY T"}
{"name":"SMνSpecies_numberCharges","declaration":"theorem SMνSpecies_numberCharges (n : ℕ) : (SMνSpecies n).numberCharges = n"}
{"name":"SMνACCs.cubeTriLin","declaration":"/-- The symmetric trilinear form used to define the cubic acc. -/\ndef SMνACCs.cubeTriLin {n : ℕ} : TriLinearSymm (ACCSystemCharges.Charges (SMνCharges n))"}
{"name":"SMνACCs.accGrav_decomp","declaration":"theorem SMνACCs.accGrav_decomp {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) : SMνACCs.accGrav S =\n  (((((6 * Finset.sum Finset.univ fun i => SMνCharges.Q S i) + 3 * Finset.sum Finset.univ fun i => SMνCharges.U S i) +\n          3 * Finset.sum Finset.univ fun i => SMνCharges.D S i) +\n        2 * Finset.sum Finset.univ fun i => SMνCharges.L S i) +\n      Finset.sum Finset.univ fun i => SMνCharges.E S i) +\n    Finset.sum Finset.univ fun i => SMνCharges.N S i"}
{"name":"SMνACCs.accSU2_ext","declaration":"/-- Extensionality lemma for `accSU2`. -/\ntheorem SMνACCs.accSU2_ext {n : ℕ} {S : ACCSystemCharges.Charges (SMνCharges n)} {T : ACCSystemCharges.Charges (SMνCharges n)} (hj : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => (SMνCharges.toSpecies j) S i) =\n    Finset.sum Finset.univ fun i => (SMνCharges.toSpecies j) T i) : SMνACCs.accSU2 S = SMνACCs.accSU2 T"}
{"name":"SMνCharges.toSpecies_apply","declaration":"theorem SMνCharges.toSpecies_apply {n : ℕ} (i : Fin 6) (S : ACCSystemCharges.Charges (SMνCharges n)) : ∀ (a : Fin (SMνSpecies n).numberCharges), (SMνCharges.toSpecies i) S a = S (finProdFinEquiv (i, a))"}
{"name":"SMνCharges.L","declaration":"/-- The `L` charges as a map `Fin n → ℚ`. -/\ndef SMνCharges.L {n : ℕ} : ACCSystemCharges.Charges (SMνCharges n) →ₗ[ℚ] ACCSystemCharges.Charges (SMνSpecies n)"}
{"name":"SMνACCs.accYY_decomp","declaration":"theorem SMνACCs.accYY_decomp {n : ℕ} (S : ACCSystemCharges.Charges (SMνCharges n)) : SMνACCs.accYY S =\n  ((((Finset.sum Finset.univ fun i => SMνCharges.Q S i) + 8 * Finset.sum Finset.univ fun i => SMνCharges.U S i) +\n        2 * Finset.sum Finset.univ fun i => SMνCharges.D S i) +\n      3 * Finset.sum Finset.univ fun i => SMνCharges.L S i) +\n    6 * Finset.sum Finset.univ fun i => SMνCharges.E S i"}
