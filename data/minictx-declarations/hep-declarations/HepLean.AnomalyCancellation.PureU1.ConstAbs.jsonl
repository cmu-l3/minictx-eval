{"name":"PureU1.ConstAbsSorted.AFL_odd_noBoundary","declaration":"theorem PureU1.ConstAbsSorted.AFL_odd_noBoundary {n : ℕ} {A : ACCSystemLinear.LinSols (PureU1 (2 * n + 1)).toACCSystemLinear} (h : PureU1.ConstAbsSorted A.val) (hA : A.val 0 ≠ 0) : ¬PureU1.ConstAbsSorted.HasBoundary A.val"}
{"name":"PureU1.ConstAbsSorted.AFL_odd","declaration":"theorem PureU1.ConstAbsSorted.AFL_odd {n : ℕ} (A : ACCSystemLinear.LinSols (PureU1 (2 * n + 1)).toACCSystemLinear) (h : PureU1.ConstAbsSorted A.val) : A = 0"}
{"name":"PureU1.ConstAbsSorted.HasBoundary","declaration":"/-- A `S ∈ charges` has a boundary if there exists a `k ∈ Fin n` which is a boundary. -/\ndef PureU1.ConstAbsSorted.HasBoundary {n : ℕ} (S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges) : Prop"}
{"name":"PureU1.ConstAbs.boundary_value_odd","declaration":"theorem PureU1.ConstAbs.boundary_value_odd {n : ℕ} (S : ACCSystemLinear.LinSols (PureU1 (2 * n + 1)).toACCSystemLinear) (hs : PureU1.ConstAbs S.val) : S = 0"}
{"name":"PureU1.ConstAbsSorted.AFL_even_Boundary","declaration":"theorem PureU1.ConstAbsSorted.AFL_even_Boundary {n : ℕ} {A : ACCSystemLinear.LinSols (PureU1 (2 * Nat.succ n)).toACCSystemLinear} (h : PureU1.ConstAbsSorted A.val) (hA : A.val 0 ≠ 0) {k : Fin (2 * n + 1)} (hk : PureU1.ConstAbsSorted.Boundary A.val k) : ↑k = n"}
{"name":"PureU1.ConstAbsSorted.boundary_castSucc","declaration":"theorem PureU1.ConstAbsSorted.boundary_castSucc {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) {k : Fin n} (hk : PureU1.ConstAbsSorted.Boundary S k) : S (Fin.castSucc k) = S 0"}
{"name":"PureU1.ConstAbsSorted.not_hasBoundary_grav","declaration":"theorem PureU1.ConstAbsSorted.not_hasBoundary_grav {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) (hnot : ¬PureU1.ConstAbsSorted.HasBoundary S) : (PureU1.accGrav (Nat.succ n)) S = ↑(Nat.succ n) * S 0"}
{"name":"PureU1.ConstAbs","declaration":"/-- The condition on a charge assignment `S` to have constant absolute value among charges. -/\ndef PureU1.ConstAbs {n : ℕ} (S : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges) : Prop"}
{"name":"PureU1.ConstAbsSorted.lt_eq","declaration":"theorem PureU1.ConstAbsSorted.lt_eq {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) {k : Fin (Nat.succ n)} {i : Fin (Nat.succ n)} (hk : S k ≤ 0) (hik : i ≤ k) : S i = S k"}
{"name":"PureU1.ConstAbsSorted.AFL_even_below","declaration":"theorem PureU1.ConstAbsSorted.AFL_even_below {n : ℕ} (A : ACCSystemLinear.LinSols (PureU1 (2 * Nat.succ n)).toACCSystemLinear) (h : PureU1.ConstAbsSorted A.val) (i : Fin (Nat.succ n)) : A.val (Fin.cast ⋯ (Fin.castAdd (Nat.succ n) i)) = A.val 0"}
{"name":"PureU1.constAbs_sort","declaration":"theorem PureU1.constAbs_sort {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges} (CA : PureU1.ConstAbs S) : PureU1.ConstAbs (PureU1.sort S)"}
{"name":"PureU1.ConstAbsSorted.boundary_succ","declaration":"theorem PureU1.ConstAbsSorted.boundary_succ {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) {k : Fin n} (hk : PureU1.ConstAbsSorted.Boundary S k) : S (Fin.succ k) = -S 0"}
{"name":"PureU1.ConstAbsSorted.gt_eq","declaration":"theorem PureU1.ConstAbsSorted.gt_eq {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) {k : Fin (Nat.succ n)} {i : Fin (Nat.succ n)} (hk : 0 ≤ S k) (hik : k ≤ i) : S i = S k"}
{"name":"PureU1.ConstAbsProp","declaration":"/-- The condition for two rationals to have the same square (equivalent to same abs). -/\ndef PureU1.ConstAbsProp  : ℚ × ℚ → Prop"}
{"name":"PureU1.ConstAbsSorted.not_hasBoundary_zero_le","declaration":"theorem PureU1.ConstAbsSorted.not_hasBoundary_zero_le {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) (hnot : ¬PureU1.ConstAbsSorted.HasBoundary S) (h0 : S 0 < 0) (i : Fin (PureU1 (Nat.succ n)).numberCharges) : S 0 = S i"}
{"name":"PureU1.ConstAbsSorted.zero_gt","declaration":"theorem PureU1.ConstAbsSorted.zero_gt {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) (h0 : 0 ≤ S 0) (i : Fin (Nat.succ n)) : S 0 = S i"}
{"name":"PureU1.ConstAbsSorted.AFL_even_above'","declaration":"theorem PureU1.ConstAbsSorted.AFL_even_above' {n : ℕ} {A : ACCSystemLinear.LinSols (PureU1 (2 * Nat.succ n)).toACCSystemLinear} (h : PureU1.ConstAbsSorted A.val) (hA : A.val 0 ≠ 0) (i : Fin (Nat.succ n)) : A.val (Fin.cast ⋯ (Fin.natAdd (Nat.succ n) i)) = -A.val 0"}
{"name":"PureU1.ConstAbsSorted.boundary_split","declaration":"theorem PureU1.ConstAbsSorted.boundary_split {n : ℕ} (k : Fin n) : ↑(Fin.succ k) + (Nat.succ n - ↑(Fin.succ k)) = Nat.succ n"}
{"name":"PureU1.ConstAbsSorted.boundary_accGrav''","declaration":"theorem PureU1.ConstAbsSorted.boundary_accGrav'' {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) (k : Fin n) (hk : PureU1.ConstAbsSorted.Boundary S k) : (PureU1.accGrav (Nat.succ n)) S = (2 * ↑↑k + 1 - ↑n) * S 0"}
{"name":"PureU1.ConstAbsSorted","declaration":"/-- The condition for a set of charges to be `sorted`, and have `constAbs`-/\ndef PureU1.ConstAbsSorted {n : ℕ} (S : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges) : Prop"}
{"name":"PureU1.ConstAbsSorted.val_le_zero","declaration":"theorem PureU1.ConstAbsSorted.val_le_zero {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) {i : Fin (Nat.succ n)} (hi : S i ≤ 0) : S i = S 0"}
{"name":"PureU1.ConstAbsSorted.not_hasBoundry_zero","declaration":"theorem PureU1.ConstAbsSorted.not_hasBoundry_zero {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) (hnot : ¬PureU1.ConstAbsSorted.HasBoundary S) (i : Fin (Nat.succ n)) : S 0 = S i"}
{"name":"PureU1.constAbs_perm","declaration":"theorem PureU1.constAbs_perm {n : ℕ} (S : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges) (M : (PureU1.FamilyPermutations n).group) : PureU1.ConstAbs (((PureU1.FamilyPermutations n).rep M) S) ↔ PureU1.ConstAbs S"}
{"name":"PureU1.ConstAbs.boundary_value_even","declaration":"theorem PureU1.ConstAbs.boundary_value_even {n : ℕ} (S : ACCSystemLinear.LinSols (PureU1 (2 * Nat.succ n)).toACCSystemLinear) (hs : PureU1.ConstAbs S.val) : PureU1.VectorLikeEven S.val"}
{"name":"PureU1.ConstAbsSorted.AFL_odd_zero","declaration":"theorem PureU1.ConstAbsSorted.AFL_odd_zero {n : ℕ} {A : ACCSystemLinear.LinSols (PureU1 (2 * n + 1)).toACCSystemLinear} (h : PureU1.ConstAbsSorted A.val) : A.val 0 = 0"}
{"name":"PureU1.ConstAbsSorted.AFL_hasBoundary","declaration":"theorem PureU1.ConstAbsSorted.AFL_hasBoundary {n : ℕ} {A : ACCSystemLinear.LinSols (PureU1 (Nat.succ n)).toACCSystemLinear} (hA : PureU1.ConstAbsSorted A.val) (h : A.val 0 ≠ 0) : PureU1.ConstAbsSorted.HasBoundary A.val"}
{"name":"PureU1.ConstAbsSorted.AFL_even_above","declaration":"theorem PureU1.ConstAbsSorted.AFL_even_above {n : ℕ} (A : ACCSystemLinear.LinSols (PureU1 (2 * Nat.succ n)).toACCSystemLinear) (h : PureU1.ConstAbsSorted A.val) (i : Fin (Nat.succ n)) : A.val (Fin.cast ⋯ (Fin.natAdd (Nat.succ n) i)) = -A.val 0"}
{"name":"PureU1.ConstAbsSorted.opposite_signs_eq_neg","declaration":"theorem PureU1.ConstAbsSorted.opposite_signs_eq_neg {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) {i : Fin (Nat.succ n)} {j : Fin (Nat.succ n)} (hi : S i ≤ 0) (hj : 0 ≤ S j) : S i = -S j"}
{"name":"PureU1.ConstAbsSorted.AFL_even_below'","declaration":"theorem PureU1.ConstAbsSorted.AFL_even_below' {n : ℕ} {A : ACCSystemLinear.LinSols (PureU1 (2 * Nat.succ n)).toACCSystemLinear} (h : PureU1.ConstAbsSorted A.val) (hA : A.val 0 ≠ 0) (i : Fin (Nat.succ n)) : A.val (Fin.cast ⋯ (Fin.castAdd (Nat.succ n) i)) = A.val 0"}
{"name":"PureU1.ConstAbsSorted.is_zero","declaration":"theorem PureU1.ConstAbsSorted.is_zero {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (hS : PureU1.ConstAbsSorted S) (h0 : S 0 = 0) : S = 0"}
{"name":"PureU1.ConstAbsSorted.Boundary","declaration":"/-- A boundary of `S : (PureU1 n.succ).charges` (assumed sorted, constAbs and non-zero)\nis defined as a element of `k ∈ Fin n` such that `S k.castSucc` and `S k.succ` are different signs.\n-/\ndef PureU1.ConstAbsSorted.Boundary {n : ℕ} (S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges) (k : Fin n) : Prop"}
{"name":"PureU1.ConstAbsSorted.boundary_accGrav'","declaration":"theorem PureU1.ConstAbsSorted.boundary_accGrav' {n : ℕ} {S : ACCSystemCharges.Charges (PureU1 (Nat.succ n)).toACCSystemCharges} (k : Fin n) : (PureU1.accGrav (Nat.succ n)) S = Finset.sum Finset.univ fun i => S (Fin.cast ⋯ i)"}
