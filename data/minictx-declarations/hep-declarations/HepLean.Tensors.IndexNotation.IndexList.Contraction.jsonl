{"name":"IndexNotation.IndexList.contrIndexList_val","declaration":"theorem IndexNotation.IndexList.contrIndexList_val {X : Type} (l : IndexNotation.IndexList X) : (IndexNotation.IndexList.contrIndexList l).val =\n  List.filter (fun I => decide (IndexNotation.IndexList.countId l I = 1)) l.val"}
{"name":"IndexNotation.IndexList.contrIndexList_eq_contrIndexList'","declaration":"theorem IndexNotation.IndexList.contrIndexList_eq_contrIndexList' {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.contrIndexList l = IndexNotation.IndexList.contrIndexList' l"}
{"name":"IndexNotation.IndexList.countId_contrIndexList_le_one","declaration":"theorem IndexNotation.IndexList.countId_contrIndexList_le_one {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I ≤ 1"}
{"name":"IndexNotation.IndexList.withoutDual_sort_eq_filter","declaration":"theorem IndexNotation.IndexList.withoutDual_sort_eq_filter {X : Type} (l : IndexNotation.IndexList X) : Finset.sort (fun i j => i ≤ j) (IndexNotation.IndexList.withoutDual l) =\n  List.filter (fun i => decide (i ∈ IndexNotation.IndexList.withoutDual l))\n    (List.finRange (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.mem_contrIndexList_countId","declaration":"theorem IndexNotation.IndexList.mem_contrIndexList_countId {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} (h : I ∈ (IndexNotation.IndexList.contrIndexList l).val) : IndexNotation.IndexList.countId l I = 1"}
{"name":"IndexNotation.IndexList.countId_contrIndexList_eq_one_iff_countId_eq_one","declaration":"theorem IndexNotation.IndexList.countId_contrIndexList_eq_one_iff_countId_eq_one {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = 1 ↔\n  IndexNotation.IndexList.countId l I = 1"}
{"name":"IndexNotation.IndexList.filter_id_contrIndexList_eq_of_countId_contrIndexList","declaration":"theorem IndexNotation.IndexList.filter_id_contrIndexList_eq_of_countId_contrIndexList {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) (h : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = IndexNotation.IndexList.countId l I) : List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J))\n    (IndexNotation.IndexList.contrIndexList l).val =\n  List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val"}
{"name":"IndexNotation.IndexList.cons_contrIndexList_of_countId_neq_zero","declaration":"theorem IndexNotation.IndexList.cons_contrIndexList_of_countId_neq_zero {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} (h : IndexNotation.IndexList.countId l I ≠ 0) : (IndexNotation.IndexList.contrIndexList (IndexNotation.IndexList.cons l I)).val =\n  List.filter (fun J => decide ¬IndexNotation.Index.id I = IndexNotation.Index.id J)\n    (IndexNotation.IndexList.contrIndexList l).val"}
{"name":"IndexNotation.IndexList.countId_contrIndexList_zero_of_countId","declaration":"theorem IndexNotation.IndexList.countId_contrIndexList_zero_of_countId {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) (h : IndexNotation.IndexList.countId l I = 0) : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = 0"}
{"name":"IndexNotation.IndexList.contrIndexList_areDualInSelf_false","declaration":"theorem IndexNotation.IndexList.contrIndexList_areDualInSelf_false {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) (j : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.AreDualInSelf (IndexNotation.IndexList.contrIndexList l) i j ↔ False"}
{"name":"IndexNotation.IndexList.contrIndexList_contrIndexList","declaration":"theorem IndexNotation.IndexList.contrIndexList_contrIndexList {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.contrIndexList (IndexNotation.IndexList.contrIndexList l) =\n  IndexNotation.IndexList.contrIndexList l"}
{"name":"IndexNotation.IndexList.countId_contrIndexList_le_countId","declaration":"theorem IndexNotation.IndexList.countId_contrIndexList_le_countId {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I ≤ IndexNotation.IndexList.countId l I"}
{"name":"IndexNotation.IndexList.contrIndexList_areDualInSelf","declaration":"theorem IndexNotation.IndexList.contrIndexList_areDualInSelf {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) (j : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.AreDualInSelf (IndexNotation.IndexList.contrIndexList l) i j ↔\n  IndexNotation.IndexList.AreDualInSelf l ↑((IndexNotation.IndexList.withoutDualEquiv l) (Fin.cast ⋯ i))\n    ↑((IndexNotation.IndexList.withoutDualEquiv l) (Fin.cast ⋯ j))"}
{"name":"IndexNotation.IndexList.contrIndexList_withUniqueDual","declaration":"theorem IndexNotation.IndexList.contrIndexList_withUniqueDual {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.withUniqueDual (IndexNotation.IndexList.contrIndexList l) = ∅"}
{"name":"IndexNotation.IndexList.contrIndexList_length","declaration":"theorem IndexNotation.IndexList.contrIndexList_length {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l) = (IndexNotation.IndexList.withoutDual l).card"}
{"name":"IndexNotation.IndexList.contrIndexList_of_withDual_empty","declaration":"theorem IndexNotation.IndexList.contrIndexList_of_withDual_empty {X : Type} (l : IndexNotation.IndexList X) (h : IndexNotation.IndexList.withDual l = ∅) : IndexNotation.IndexList.contrIndexList l = l"}
{"name":"IndexNotation.IndexList.contrIndexList_getDualInOther?_self","declaration":"theorem IndexNotation.IndexList.contrIndexList_getDualInOther?_self {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.getDualInOther? (IndexNotation.IndexList.contrIndexList l)\n    (IndexNotation.IndexList.contrIndexList l) i =\n  some i"}
{"name":"IndexNotation.IndexList.contrIndexList_append_eq_filter","declaration":"theorem IndexNotation.IndexList.contrIndexList_append_eq_filter {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : (IndexNotation.IndexList.contrIndexList (l ++ l2)).val =\n  List.filter (fun I => decide (IndexNotation.IndexList.countId l2 I = 0))\n      (IndexNotation.IndexList.contrIndexList l).val ++\n    List.filter (fun I => decide (IndexNotation.IndexList.countId l I = 0))\n      (IndexNotation.IndexList.contrIndexList l2).val"}
{"name":"IndexNotation.IndexList.contrIndexList_colorMap","declaration":"theorem IndexNotation.IndexList.contrIndexList_colorMap {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.colorMap (IndexNotation.IndexList.contrIndexList l) i =\n  IndexNotation.IndexList.colorMap l ↑((IndexNotation.IndexList.withoutDualEquiv l) (Fin.cast ⋯ i))"}
{"name":"IndexNotation.IndexList.contrIndexList_getDual?","declaration":"theorem IndexNotation.IndexList.contrIndexList_getDual? {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.getDual? (IndexNotation.IndexList.contrIndexList l) i = none"}
{"name":"IndexNotation.IndexList.contrIndexList'","declaration":"/-- An alternative form of the contracted index list. -/\ndef IndexNotation.IndexList.contrIndexList' {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList X"}
{"name":"IndexNotation.IndexList.contrIndexList_empty","declaration":"theorem IndexNotation.IndexList.contrIndexList_empty {X : Type} : IndexNotation.IndexList.contrIndexList { val := [] } = { val := [] }"}
{"name":"IndexNotation.IndexList.contrIndexList","declaration":"/-- The index list formed from `l` by selecting only those indices in `l` which\ndo not have a dual. -/\ndef IndexNotation.IndexList.contrIndexList {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList X"}
{"name":"IndexNotation.IndexList.cons_contrIndexList_of_countId_eq_zero","declaration":"theorem IndexNotation.IndexList.cons_contrIndexList_of_countId_eq_zero {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} (h : IndexNotation.IndexList.countId l I = 0) : IndexNotation.IndexList.contrIndexList (IndexNotation.IndexList.cons l I) =\n  IndexNotation.IndexList.cons (IndexNotation.IndexList.contrIndexList l) I"}
{"name":"IndexNotation.IndexList.countId_contrIndexList_get","declaration":"theorem IndexNotation.IndexList.countId_contrIndexList_get {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l)\n    (IndexNotation.IndexList.contrIndexList l).val[↑i] =\n  1"}
{"name":"IndexNotation.IndexList.contrIndexList_idMap","declaration":"theorem IndexNotation.IndexList.contrIndexList_idMap {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length (IndexNotation.IndexList.contrIndexList l))) : IndexNotation.IndexList.idMap (IndexNotation.IndexList.contrIndexList l) i =\n  IndexNotation.IndexList.idMap l ↑((IndexNotation.IndexList.withoutDualEquiv l) (Fin.cast ⋯ i))"}
{"name":"IndexNotation.IndexList.mem_contrIndexList_filter","declaration":"theorem IndexNotation.IndexList.mem_contrIndexList_filter {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} (h : I ∈ (IndexNotation.IndexList.contrIndexList l).val) : List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val = [I]"}
{"name":"IndexNotation.IndexList.contrIndexList_withDual","declaration":"theorem IndexNotation.IndexList.contrIndexList_withDual {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.withDual (IndexNotation.IndexList.contrIndexList l) = ∅"}
{"name":"IndexNotation.IndexList.mem_contrIndexList_countId_contrIndexList","declaration":"theorem IndexNotation.IndexList.mem_contrIndexList_countId_contrIndexList {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} (h : I ∈ (IndexNotation.IndexList.contrIndexList l).val) : IndexNotation.IndexList.countId (IndexNotation.IndexList.contrIndexList l) I = 1"}
{"name":"Subtype.coe_ne_coe","declaration":"theorem Subtype.coe_ne_coe {α : Sort u_1} {p : α → Prop} {a : Subtype p} {b : Subtype p} : ↑a ≠ ↑b ↔ a ≠ b"}
