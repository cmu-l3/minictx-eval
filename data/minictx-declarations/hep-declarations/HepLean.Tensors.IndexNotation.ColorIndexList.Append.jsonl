{"name":"IndexNotation.ColorIndexList.AppendCond.inr","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.inr {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} {l3 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) (h' : IndexNotation.ColorIndexList.AppendCond (IndexNotation.ColorIndexList.append l l2 h) l3) : IndexNotation.ColorIndexList.AppendCond l2 l3"}
{"name":"IndexNotation.ColorIndexList.append_contr_right","declaration":"theorem IndexNotation.ColorIndexList.append_contr_right {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (l2 : IndexNotation.ColorIndexList ğ“’) (h : IndexNotation.ColorIndexList.AppendCond l l2) : IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.append l (IndexNotation.ColorIndexList.contr l2) â‹¯) =\n  IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.append l l2 h)"}
{"name":"IndexNotation.ColorIndexList.AppendCond.contr_left","declaration":"/-- If `AppendCond l l2` then `AppendCond l.contr l2`. Note that the inverse\nis generally not true. -/\ntheorem IndexNotation.ColorIndexList.AppendCond.contr_left {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) : IndexNotation.ColorIndexList.AppendCond (IndexNotation.ColorIndexList.contr l) l2"}
{"name":"IndexNotation.ColorIndexList.AppendCond.symm","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.symm {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) : IndexNotation.ColorIndexList.AppendCond l2 l"}
{"name":"IndexNotation.ColorIndexList.AppendCond.assoc","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.assoc {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} {l3 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) (h' : IndexNotation.ColorIndexList.AppendCond (IndexNotation.ColorIndexList.append l l2 h) l3) : IndexNotation.ColorIndexList.AppendCond l (IndexNotation.ColorIndexList.append l2 l3 â‹¯)"}
{"name":"IndexNotation.ColorIndexList.append_contr","declaration":"theorem IndexNotation.ColorIndexList.append_contr {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (l2 : IndexNotation.ColorIndexList ğ“’) (h : IndexNotation.ColorIndexList.AppendCond l l2) : IndexNotation.ColorIndexList.contr\n    (IndexNotation.ColorIndexList.append (IndexNotation.ColorIndexList.contr l) (IndexNotation.ColorIndexList.contr l2)\n      â‹¯) =\n  IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.append l l2 h)"}
{"name":"IndexNotation.ColorIndexList.AppendCond.countId_contr_snd_eq_zero_mem_fst","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.countId_contr_snd_eq_zero_mem_fst {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) {I : IndexNotation.Index ğ“’.Color} (hI : I âˆˆ l.val) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l2).toIndexList I = 0 â†”\n  IndexNotation.IndexList.countId l2.toIndexList I = 0"}
{"name":"IndexNotation.ColorIndexList.AppendCond","declaration":"/-- The condition on the `ColorIndexList`s `l` and `l2` so that on appending they form\na `ColorIndexList`.\n\nNote: `AppendCond` does not form an equivalence relation as it is not reflexive or\ntransitive. -/\ndef IndexNotation.ColorIndexList.AppendCond {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (l2 : IndexNotation.ColorIndexList ğ“’) : Prop"}
{"name":"IndexNotation.ColorIndexList.append_toIndexList","declaration":"theorem IndexNotation.ColorIndexList.append_toIndexList {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (l2 : IndexNotation.ColorIndexList ğ“’) (h : IndexNotation.ColorIndexList.AppendCond l l2) : (IndexNotation.ColorIndexList.append l l2 h).toIndexList = l.toIndexList ++ l2.toIndexList"}
{"name":"IndexNotation.ColorIndexList.AppendCond.contr","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.contr {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) : IndexNotation.ColorIndexList.AppendCond (IndexNotation.ColorIndexList.contr l) (IndexNotation.ColorIndexList.contr l2)"}
{"name":"IndexNotation.ColorIndexList.AppendCond.countId_contr_fst_eq_zero_mem_snd","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.countId_contr_fst_eq_zero_mem_snd {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) {I : IndexNotation.Index ğ“’.Color} (hI : I âˆˆ l2.val) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I = 0 â†”\n  IndexNotation.IndexList.countId l.toIndexList I = 0"}
{"name":"IndexNotation.ColorIndexList.AppendCond.swap","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.swap {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} {l3 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) (h' : IndexNotation.ColorIndexList.AppendCond (IndexNotation.ColorIndexList.append l l2 h) l3) : IndexNotation.ColorIndexList.AppendCond (IndexNotation.ColorIndexList.append l2 l â‹¯) l3"}
{"name":"IndexNotation.ColorIndexList.append","declaration":"/-- Given two `ColorIndexList`s satisfying `AppendCond`. The correponding combined\n`ColorIndexList`. -/\ndef IndexNotation.ColorIndexList.append {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (l2 : IndexNotation.ColorIndexList ğ“’) (h : IndexNotation.ColorIndexList.AppendCond l l2) : IndexNotation.ColorIndexList ğ“’"}
{"name":"IndexNotation.ColorIndexList.AppendCond.bool_iff","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.bool_iff {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (l2 : IndexNotation.IndexList ğ“’.Color) : IndexNotation.ColorIndexList.AppendCond.bool l l2 = true â†”\n  IndexNotation.IndexList.withUniqueDual (l ++ l2) = IndexNotation.IndexList.withDual (l ++ l2) âˆ§\n    IndexNotation.IndexList.ColorCond.bool (l ++ l2) = true"}
{"name":"IndexNotation.ColorIndexList.AppendCond.bool","declaration":"/-- A boolean which is true for two index lists `l` and `l2` if on appending\nthey can form a `ColorIndexList`. -/\ndef IndexNotation.ColorIndexList.AppendCond.bool {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] (l : IndexNotation.IndexList ğ“’.Color) (l2 : IndexNotation.IndexList ğ“’.Color) : Bool"}
{"name":"IndexNotation.ColorIndexList.AppendCond.contr_right","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.contr_right {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.AppendCond l l2) : IndexNotation.ColorIndexList.AppendCond l (IndexNotation.ColorIndexList.contr l2)"}
{"name":"IndexNotation.ColorIndexList.Â«term_++[_]_Â»","declaration":"/-- The join of two `ColorIndexList` satisfying the condition `AppendCond` that they\ncan be appended to form a `ColorIndexList`. -/\ndef IndexNotation.ColorIndexList.Â«term_++[_]_Â»  : Lean.TrailingParserDescr"}
{"name":"IndexNotation.ColorIndexList.append_contr_left","declaration":"theorem IndexNotation.ColorIndexList.append_contr_left {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (l2 : IndexNotation.ColorIndexList ğ“’) (h : IndexNotation.ColorIndexList.AppendCond l l2) : IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.append (IndexNotation.ColorIndexList.contr l) l2 â‹¯) =\n  IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.append l l2 h)"}
{"name":"IndexNotation.ColorIndexList.AppendCond.iff_bool","declaration":"theorem IndexNotation.ColorIndexList.AppendCond.iff_bool {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (l2 : IndexNotation.ColorIndexList ğ“’) : IndexNotation.ColorIndexList.AppendCond l l2 â†”\n  IndexNotation.ColorIndexList.AppendCond.bool l.toIndexList l2.toIndexList = true"}
