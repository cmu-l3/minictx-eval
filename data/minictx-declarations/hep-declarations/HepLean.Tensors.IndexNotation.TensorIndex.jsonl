{"name":"TensorStructure.TensorIndex.ProdCond.symm","declaration":"theorem TensorStructure.TensorIndex.ProdCond.symm {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.ProdCond T₁ T₂) : TensorStructure.TensorIndex.ProdCond T₂ T₁"}
{"name":"TensorStructure.TensorIndex.contr_tensor","declaration":"theorem TensorStructure.TensorIndex.contr_tensor {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) : (TensorStructure.TensorIndex.contr T).tensor =\n  (TensorStructure.mapIso 𝓣\n      (Equiv.refl\n        (Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr T.toColorIndexList).toIndexList)))\n      ⋯)\n    ((TensorStructure.contr 𝓣 (IndexNotation.ColorIndexList.contrEquiv T.toColorIndexList) ⋯) T.tensor)"}
{"name":"TensorStructure.TensorIndex.Rel.isEquivalence","declaration":"/-- Rel forms an equivalence relation. -/\ntheorem TensorStructure.TensorIndex.Rel.isEquivalence {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] : Equivalence TensorStructure.TensorIndex.Rel"}
{"name":"TensorStructure.TensorIndex.AddCond.of_add_left'","declaration":"theorem TensorStructure.TensorIndex.AddCond.of_add_left' {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} {h' : TensorStructure.TensorIndex.AddCond T₁ T₂} (h : TensorStructure.TensorIndex.AddCond (T₁+[h']T₂) T₃) : TensorStructure.TensorIndex.AddCond T₁ T₃"}
{"name":"TensorStructure.TensorIndex.AddCond.add_right_of_add_left","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_right_of_add_left {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} {h' : TensorStructure.TensorIndex.AddCond T₁ T₂} (h : TensorStructure.TensorIndex.AddCond (T₁+[h']T₂) T₃) : TensorStructure.TensorIndex.AddCond T₁ (T₂+[⋯]T₃)"}
{"name":"TensorStructure.TensorIndex.add_rel_left","declaration":"theorem TensorStructure.TensorIndex.add_rel_left {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₁' : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) (h' : T₁ ≈ T₁') : T₁+[h]T₂ ≈ T₁'+[⋯]T₂"}
{"name":"TensorStructure.TensorIndex.AddCond.add_comm","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_comm {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : TensorStructure.TensorIndex.AddCond (T₁+[h]T₂) (T₂+[⋯]T₁)"}
{"name":"TensorStructure.TensorIndex.AddCond.of_add_right'","declaration":"theorem TensorStructure.TensorIndex.AddCond.of_add_right' {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} {h' : TensorStructure.TensorIndex.AddCond T₂ T₃} (h : TensorStructure.TensorIndex.AddCond T₁ (T₂+[h']T₃)) : TensorStructure.TensorIndex.AddCond T₁ T₃"}
{"name":"TensorStructure.TensorIndex.instSMulTensorIndex","declaration":"/-- The scalar multiplication of a `TensorIndex` by an element of `R`. -/\ninstance TensorStructure.TensorIndex.instSMulTensorIndex {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] : SMul R (TensorStructure.TensorIndex 𝓣)"}
{"name":"TensorStructure.TensorIndex.addCondEquiv_colorMap","declaration":"theorem TensorStructure.TensorIndex.addCondEquiv_colorMap {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : TensorColor.ColorMap.MapIso (TensorStructure.TensorIndex.addCondEquiv h)\n  (IndexNotation.ColorIndexList.colorMap' (TensorStructure.TensorIndex.contr T₁).toColorIndexList)\n  (IndexNotation.ColorIndexList.colorMap' (TensorStructure.TensorIndex.contr T₂).toColorIndexList)"}
{"name":"TensorStructure.TensorIndex.AddCond.of_add_left","declaration":"theorem TensorStructure.TensorIndex.AddCond.of_add_left {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} {h' : TensorStructure.TensorIndex.AddCond T₁ T₂} (h : TensorStructure.TensorIndex.AddCond (T₁+[h']T₂) T₃) : TensorStructure.TensorIndex.AddCond T₂ T₃"}
{"name":"TensorStructure.TensorIndex.Rel.to_eq","declaration":"/-- The equality of tensors corresponding to related tensor indices. -/\ntheorem TensorStructure.TensorIndex.Rel.to_eq {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.Rel T₁ T₂) : (TensorStructure.TensorIndex.contr T₁).tensor =\n  (TensorStructure.mapIso 𝓣 (IndexNotation.ColorIndexList.contrPermEquiv ⋯).symm ⋯)\n    (TensorStructure.TensorIndex.contr T₂).tensor"}
{"name":"TensorStructure.TensorIndex.add","declaration":"/-- The addition of two `TensorIndex` given the condition that, after contraction,\ntheir index lists are the same. -/\ndef TensorStructure.TensorIndex.add {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : TensorStructure.TensorIndex 𝓣"}
{"name":"TensorStructure.TensorIndex.contr_of_withDual_empty","declaration":"/-- Applying contr to a tensor whose indices has no contracts does not do anything. -/\ntheorem TensorStructure.TensorIndex.contr_of_withDual_empty {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) (h : IndexNotation.IndexList.withDual T.toIndexList = ∅) : TensorStructure.TensorIndex.contr T = T"}
{"name":"TensorStructure.TensorIndex.Rel","declaration":"/-- An (equivalence) relation on two `TensorIndex`.\nThe point in this equivalence relation is that certain things (like the\npermutation of indices, the contraction of indices, or rising or lowering indices) can be placed\nin the indices or moved to the tensor itself. These two descriptions are equivalent. -/\ndef TensorStructure.TensorIndex.Rel {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) : Prop"}
{"name":"TensorStructure.TensorIndex.contr_add_tensor","declaration":"theorem TensorStructure.TensorIndex.contr_add_tensor {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : (TensorStructure.TensorIndex.contr (T₁+[h]T₂)).tensor =\n  (TensorStructure.mapIso 𝓣 (Fin.castIso ⋯).toEquiv ⋯) (T₁+[h]T₂).tensor"}
{"name":"TensorStructure.TensorIndex.tensorIso","declaration":"/-- Given an equality of `TensorIndex`, the isomorphism taking one underlying\ntensor to the other. -/\ndef TensorStructure.TensorIndex.tensorIso {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : T₁ = T₂) : TensorStructure.Tensor 𝓣 (IndexNotation.ColorIndexList.colorMap' T₂.toColorIndexList) ≃ₗ[R]\n  TensorStructure.Tensor 𝓣 (IndexNotation.ColorIndexList.colorMap' T₁.toColorIndexList)"}
{"name":"TensorStructure.TensorIndex.smul_index","declaration":"theorem TensorStructure.TensorIndex.smul_index {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (r : R) (T : TensorStructure.TensorIndex 𝓣) : (r • T).toColorIndexList = T.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.contr_toColorIndexList","declaration":"theorem TensorStructure.TensorIndex.contr_toColorIndexList {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) : (TensorStructure.TensorIndex.contr T).toColorIndexList = IndexNotation.ColorIndexList.contr T.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.contr_add","declaration":"theorem TensorStructure.TensorIndex.contr_add {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : TensorStructure.TensorIndex.contr (T₁+[h]T₂) = T₁+[h]T₂"}
{"name":"TensorStructure.TensorIndex.rel_contr","declaration":"/-- A tensor index is equivalent to its contraction. -/\ntheorem TensorStructure.TensorIndex.rel_contr {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) : T ≈ TensorStructure.TensorIndex.contr T"}
{"name":"TensorStructure.TensorIndex.contr_contr","declaration":"theorem TensorStructure.TensorIndex.contr_contr {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) : TensorStructure.TensorIndex.contr (TensorStructure.TensorIndex.contr T) = TensorStructure.TensorIndex.contr T"}
{"name":"TensorStructure.TensorIndex.add_assoc","declaration":"theorem TensorStructure.TensorIndex.add_assoc {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} {h' : TensorStructure.TensorIndex.AddCond T₁ T₂} (h : TensorStructure.TensorIndex.AddCond (T₁+[h']T₂) T₃) : T₁+[h']T₂+[h]T₃ = T₁+[⋯](T₂+[⋯]T₃)"}
{"name":"TensorStructure.TensorIndex.smul_rel","declaration":"theorem TensorStructure.TensorIndex.smul_rel {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : T₁ ≈ T₂) (r : R) : r • T₁ ≈ r • T₂"}
{"name":"TensorStructure.TensorIndex.mkDualMap","declaration":"/-- The construction of a `TensorIndex` from a tensor, a IndexListColor, and a condition\non the dual maps. -/\ndef TensorStructure.TensorIndex.mkDualMap {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {n : ℕ} {cn : Fin n → 𝓣.Color} (T : TensorStructure.Tensor 𝓣 cn) (l : IndexNotation.ColorIndexList 𝓣.toTensorColor) (hn : n = IndexNotation.IndexList.length l.toIndexList) (hd : TensorColor.ColorMap.DualMap (IndexNotation.ColorIndexList.colorMap' l) (cn ∘ Fin.cast ⋯)) : TensorStructure.TensorIndex 𝓣"}
{"name":"TensorStructure.TensorIndex.AddCond.rel_left","declaration":"theorem TensorStructure.TensorIndex.AddCond.rel_left {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₁' : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) (h' : T₁ ≈ T₁') : TensorStructure.TensorIndex.AddCond T₁' T₂"}
{"name":"TensorStructure.TensorIndex.AddCond.add_left_of_add_right","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_left_of_add_right {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} {h' : TensorStructure.TensorIndex.AddCond T₂ T₃} (h : TensorStructure.TensorIndex.AddCond T₁ (T₂+[h']T₃)) : TensorStructure.TensorIndex.AddCond (T₁+[⋯]T₂) T₃"}
{"name":"TensorStructure.TensorIndex.smul_contr","declaration":"theorem TensorStructure.TensorIndex.smul_contr {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (r : R) (T : TensorStructure.TensorIndex 𝓣) : TensorStructure.TensorIndex.contr (r • T) = r • TensorStructure.TensorIndex.contr T"}
{"name":"TensorStructure.TensorIndex.AddCond.add_left","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_left {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) (h' : TensorStructure.TensorIndex.AddCond T₂ T₃) : TensorStructure.TensorIndex.AddCond (T₁+[h]T₂) T₃"}
{"name":"TensorStructure.TensorIndex.smul_add","declaration":"/-- Scalar multiplication commutes with addition. -/\ntheorem TensorStructure.TensorIndex.smul_add {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (r : R) (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : r • (T₁+[h]T₂) = r • T₁+[h]r • T₂"}
{"name":"TensorStructure.TensorIndex.smul_tensor","declaration":"theorem TensorStructure.TensorIndex.smul_tensor {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (r : R) (T : TensorStructure.TensorIndex 𝓣) : (r • T).tensor = r • T.tensor"}
{"name":"TensorStructure.TensorIndex.addCondEquiv","declaration":"/-- The equivalence between indices after contraction given a `AddCond`. -/\ndef TensorStructure.TensorIndex.addCondEquiv {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : Fin (IndexNotation.IndexList.length (TensorStructure.TensorIndex.contr T₁).toIndexList) ≃\n  Fin (IndexNotation.IndexList.length (TensorStructure.TensorIndex.contr T₂).toIndexList)"}
{"name":"TensorStructure.TensorIndex.prod_toIndexList","declaration":"theorem TensorStructure.TensorIndex.prod_toIndexList {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.ProdCond T₁ T₂) : (TensorStructure.TensorIndex.prod T₁ T₂ h).toIndexList = T₁.toIndexList ++ T₂.toIndexList"}
{"name":"TensorStructure.TensorIndex.mk","declaration":"ctor TensorStructure.TensorIndex.mk {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (toColorIndexList : IndexNotation.ColorIndexList 𝓣.toTensorColor) (tensor : TensorStructure.Tensor 𝓣 (IndexNotation.ColorIndexList.colorMap' toColorIndexList)) : TensorStructure.TensorIndex 𝓣"}
{"name":"TensorStructure.TensorIndex.AddCond.rel_right","declaration":"theorem TensorStructure.TensorIndex.AddCond.rel_right {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₂' : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) (h' : T₂ ≈ T₂') : TensorStructure.TensorIndex.AddCond T₁ T₂'"}
{"name":"TensorStructure.TensorIndex.index_eq_of_eq","declaration":"theorem TensorStructure.TensorIndex.index_eq_of_eq {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : T₁ = T₂) : T₁.toColorIndexList = T₂.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.contr","declaration":"/-- The contraction of indices in a `TensorIndex`. -/\ndef TensorStructure.TensorIndex.contr {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) : TensorStructure.TensorIndex 𝓣"}
{"name":"TensorStructure.TensorIndex.AddCond.trans","declaration":"theorem TensorStructure.TensorIndex.AddCond.trans {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} (h1 : TensorStructure.TensorIndex.AddCond T₁ T₂) (h2 : TensorStructure.TensorIndex.AddCond T₂ T₃) : TensorStructure.TensorIndex.AddCond T₁ T₃"}
{"name":"TensorStructure.TensorIndex.add_toColorIndexList","declaration":"theorem TensorStructure.TensorIndex.add_toColorIndexList {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : (T₁+[h]T₂).toColorIndexList = IndexNotation.ColorIndexList.contr T₂.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.AddCond.symm","declaration":"theorem TensorStructure.TensorIndex.AddCond.symm {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : TensorStructure.TensorIndex.AddCond T₂ T₁"}
{"name":"TensorStructure.TensorIndex.AddCond.add_right","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_right {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₃) (h' : TensorStructure.TensorIndex.AddCond T₂ T₃) : TensorStructure.TensorIndex.AddCond T₁ (T₂+[h']T₃)"}
{"name":"TensorStructure.TensorIndex.colormap_mapIso","declaration":"theorem TensorStructure.TensorIndex.colormap_mapIso {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (hi : T₁.toColorIndexList = T₂.toColorIndexList) : TensorColor.ColorMap.MapIso (Fin.castIso ⋯).toEquiv (IndexNotation.ColorIndexList.colorMap' T₁.toColorIndexList)\n  (IndexNotation.ColorIndexList.colorMap' T₂.toColorIndexList)"}
{"name":"TensorStructure.TensorIndex.add_comm","declaration":"theorem TensorStructure.TensorIndex.add_comm {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : T₁+[h]T₂ ≈ T₂+[⋯]T₁"}
{"name":"TensorStructure.TensorIndex.Rel.of_withDual_empty","declaration":"theorem TensorStructure.TensorIndex.Rel.of_withDual_empty {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : IndexNotation.ColorIndexList.ContrPerm T₁.toColorIndexList T₂.toColorIndexList) (h1 : IndexNotation.IndexList.withDual T₁.toIndexList = ∅) (h2 : IndexNotation.IndexList.withDual T₂.toIndexList = ∅) (hT : T₁.tensor = (TensorStructure.mapIso 𝓣 (IndexNotation.ColorIndexList.permEquiv h h1 h2).symm ⋯) T₂.tensor) : TensorStructure.TensorIndex.Rel T₁ T₂"}
{"name":"TensorStructure.TensorIndex.tensor_eq_of_eq","declaration":"theorem TensorStructure.TensorIndex.tensor_eq_of_eq {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : T₁ = T₂) : T₁.tensor = (TensorStructure.TensorIndex.tensorIso h) T₂.tensor"}
{"name":"TensorStructure.TensorIndex.tensor","declaration":"/-- The underlying tensor. -/\ndef TensorStructure.TensorIndex.tensor {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (self : TensorStructure.TensorIndex 𝓣) : TensorStructure.Tensor 𝓣 (IndexNotation.ColorIndexList.colorMap' self.toColorIndexList)"}
{"name":"TensorStructure.TensorIndex.AddCond.of_add_right","declaration":"theorem TensorStructure.TensorIndex.AddCond.of_add_right {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} {h' : TensorStructure.TensorIndex.AddCond T₂ T₃} (h : TensorStructure.TensorIndex.AddCond T₁ (T₂+[h']T₃)) : TensorStructure.TensorIndex.AddCond T₁ T₂"}
{"name":"TensorStructure.TensorIndex.prod","declaration":"/-- The tensor product of two `TensorIndex`.\n\nNote: By defualt contraction is NOT done before taking the products. -/\ndef TensorStructure.TensorIndex.prod {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.ProdCond T₁ T₂) : TensorStructure.TensorIndex 𝓣"}
{"name":"TensorStructure.TensorIndex.asSetoid","declaration":"/-- The structure of a Setoid on `𝓣.TensorIndex` induced by `Rel`. -/\ninstance TensorStructure.TensorIndex.asSetoid {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] : Setoid (TensorStructure.TensorIndex 𝓣)"}
{"name":"TensorStructure.TensorIndex.AddCond.to_PermContr","declaration":"theorem TensorStructure.TensorIndex.AddCond.to_PermContr {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : IndexNotation.ColorIndexList.ContrPerm T₁.toColorIndexList T₂.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.ProdCond.to_AppendCond","declaration":"theorem TensorStructure.TensorIndex.ProdCond.to_AppendCond {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.ProdCond T₁ T₂) : IndexNotation.ColorIndexList.AppendCond T₁.toColorIndexList T₂.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.«term_+[_]_»","declaration":"/-- Notation for addition of tensor indices. -/\ndef TensorStructure.TensorIndex.«term_+[_]_»  : Lean.TrailingParserDescr"}
{"name":"TensorStructure.TensorIndex.Rel.symm","declaration":"/-- Rel is symmetric. -/\ntheorem TensorStructure.TensorIndex.Rel.symm {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.Rel T₁ T₂) : TensorStructure.TensorIndex.Rel T₂ T₁"}
{"name":"TensorStructure.TensorIndex.contr_toIndexList","declaration":"theorem TensorStructure.TensorIndex.contr_toIndexList {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) : (TensorStructure.TensorIndex.contr T).toIndexList = IndexNotation.IndexList.contrIndexList T.toIndexList"}
{"name":"TensorStructure.TensorIndex.instCoeTensorIndexColorIndexListToTensorColor","declaration":"instance TensorStructure.TensorIndex.instCoeTensorIndexColorIndexListToTensorColor {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] : Coe (TensorStructure.TensorIndex 𝓣) (IndexNotation.ColorIndexList 𝓣.toTensorColor)"}
{"name":"TensorStructure.TensorIndex.ProdCond","declaration":"/-- The condition on two `TensorIndex` which is true if and only if their `ColorIndexList`s\nare related by the condition `AppendCond`. That is, they can be appended to form a\n`ColorIndexList`. -/\ndef TensorStructure.TensorIndex.ProdCond {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) : Prop"}
{"name":"TensorStructure.TensorIndex.AddCond","declaration":"/-- The condition on tensors with indices for their addition to exists.\nThis condition states that the the indices of one tensor are exact permutations of indices\nof another after contraction. This includes the id of the index and the color.\n\nThis condition is general enough to allow addition of e.g. `ψᵤ₁ᵤ₂ + φᵤ₂ᵤ₁`, but\nwill NOT allow e.g. `ψᵤ₁ᵤ₂ + φᵘ²ᵤ₁`. -/\ndef TensorStructure.TensorIndex.AddCond {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) : Prop"}
{"name":"TensorStructure.TensorIndex.Rel.trans","declaration":"/-- Rel is transitive. -/\ntheorem TensorStructure.TensorIndex.Rel.trans {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} (h1 : TensorStructure.TensorIndex.Rel T₁ T₂) (h2 : TensorStructure.TensorIndex.Rel T₂ T₃) : TensorStructure.TensorIndex.Rel T₁ T₃"}
{"name":"TensorStructure.TensorIndex.add_rel_right","declaration":"theorem TensorStructure.TensorIndex.add_rel_right {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₂' : TensorStructure.TensorIndex 𝓣} (h : TensorStructure.TensorIndex.AddCond T₁ T₂) (h' : T₂ ≈ T₂') : T₁+[h]T₂ ≈ T₁+[⋯]T₂'"}
{"name":"TensorStructure.TensorIndex.prod_toColorIndexList","declaration":"theorem TensorStructure.TensorIndex.prod_toColorIndexList {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.ProdCond T₁ T₂) : (TensorStructure.TensorIndex.prod T₁ T₂ h).toColorIndexList =\n  IndexNotation.ColorIndexList.append T₁.toColorIndexList T₂.toColorIndexList h"}
{"name":"TensorStructure.TensorIndex.contr_tensor_of_withDual_empty","declaration":"theorem TensorStructure.TensorIndex.contr_tensor_of_withDual_empty {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) (h : IndexNotation.IndexList.withDual T.toIndexList = ∅) : (TensorStructure.TensorIndex.contr T).tensor = (TensorStructure.TensorIndex.tensorIso ⋯) T.tensor"}
{"name":"TensorStructure.TensorIndex","declaration":"/-- The structure an tensor with a index specification e.g. `ᵘ¹ᵤ₂`. -/\nstructure TensorStructure.TensorIndex {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) [IndexNotation 𝓣.Color] : Type"}
{"name":"TensorStructure.TensorIndex.ext","declaration":"theorem TensorStructure.TensorIndex.ext {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} (hi : T₁.toColorIndexList = T₂.toColorIndexList) (h : T₁.tensor = (TensorStructure.mapIso 𝓣 (Fin.castIso ⋯).toEquiv ⋯) T₂.tensor) : T₁ = T₂"}
{"name":"TensorStructure.TensorIndex.add_assoc'","declaration":"theorem TensorStructure.TensorIndex.add_assoc' {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] {T₁ : TensorStructure.TensorIndex 𝓣} {T₂ : TensorStructure.TensorIndex 𝓣} {T₃ : TensorStructure.TensorIndex 𝓣} {h' : TensorStructure.TensorIndex.AddCond T₂ T₃} (h : TensorStructure.TensorIndex.AddCond T₁ (T₂+[h']T₃)) : T₁+[h](T₂+[h']T₃) = T₁+[⋯]T₂+[⋯]T₃"}
{"name":"TensorStructure.TensorIndex.AddCond.refl","declaration":"theorem TensorStructure.TensorIndex.AddCond.refl {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) : TensorStructure.TensorIndex.AddCond T T"}
{"name":"TensorStructure.TensorIndex.Rel.refl","declaration":"/-- Rel is reflexive. -/\ntheorem TensorStructure.TensorIndex.Rel.refl {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T : TensorStructure.TensorIndex 𝓣) : TensorStructure.TensorIndex.Rel T T"}
{"name":"TensorStructure.TensorIndex.add_tensor","declaration":"theorem TensorStructure.TensorIndex.add_tensor {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : (T₁+[h]T₂).tensor =\n  (TensorStructure.mapIso 𝓣 (TensorStructure.TensorIndex.addCondEquiv h) ⋯)\n      (TensorStructure.TensorIndex.contr T₁).tensor +\n    (TensorStructure.TensorIndex.contr T₂).tensor"}
{"name":"TensorStructure.TensorIndex.add_withDual_empty","declaration":"theorem TensorStructure.TensorIndex.add_withDual_empty {R : Type} [CommSemiring R] {𝓣 : TensorStructure R} [IndexNotation 𝓣.Color] [DecidableEq 𝓣.Color] (T₁ : TensorStructure.TensorIndex 𝓣) (T₂ : TensorStructure.TensorIndex 𝓣) (h : TensorStructure.TensorIndex.AddCond T₁ T₂) : IndexNotation.IndexList.withDual (T₁+[h]T₂).toIndexList = ∅"}
