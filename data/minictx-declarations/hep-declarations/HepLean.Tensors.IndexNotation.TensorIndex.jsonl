{"name":"TensorStructure.TensorIndex.ProdCond.symm","declaration":"theorem TensorStructure.TensorIndex.ProdCond.symm {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.ProdCond Tâ‚ Tâ‚‚) : TensorStructure.TensorIndex.ProdCond Tâ‚‚ Tâ‚"}
{"name":"TensorStructure.TensorIndex.contr_tensor","declaration":"theorem TensorStructure.TensorIndex.contr_tensor {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) : (TensorStructure.TensorIndex.contr T).tensor =\n  (TensorStructure.mapIso ğ“£\n      (Equiv.refl\n        (Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr T.toColorIndexList).toIndexList)))\n      â‹¯)\n    ((TensorStructure.contr ğ“£ (IndexNotation.ColorIndexList.contrEquiv T.toColorIndexList) â‹¯) T.tensor)"}
{"name":"TensorStructure.TensorIndex.Rel.isEquivalence","declaration":"/-- Rel forms an equivalence relation. -/\ntheorem TensorStructure.TensorIndex.Rel.isEquivalence {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] : Equivalence TensorStructure.TensorIndex.Rel"}
{"name":"TensorStructure.TensorIndex.AddCond.of_add_left'","declaration":"theorem TensorStructure.TensorIndex.AddCond.of_add_left' {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} {h' : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚} (h : TensorStructure.TensorIndex.AddCond (Tâ‚+[h']Tâ‚‚) Tâ‚ƒ) : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚ƒ"}
{"name":"TensorStructure.TensorIndex.AddCond.add_right_of_add_left","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_right_of_add_left {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} {h' : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚} (h : TensorStructure.TensorIndex.AddCond (Tâ‚+[h']Tâ‚‚) Tâ‚ƒ) : TensorStructure.TensorIndex.AddCond Tâ‚ (Tâ‚‚+[â‹¯]Tâ‚ƒ)"}
{"name":"TensorStructure.TensorIndex.add_rel_left","declaration":"theorem TensorStructure.TensorIndex.add_rel_left {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚' : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) (h' : Tâ‚ â‰ˆ Tâ‚') : Tâ‚+[h]Tâ‚‚ â‰ˆ Tâ‚'+[â‹¯]Tâ‚‚"}
{"name":"TensorStructure.TensorIndex.AddCond.add_comm","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_comm {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : TensorStructure.TensorIndex.AddCond (Tâ‚+[h]Tâ‚‚) (Tâ‚‚+[â‹¯]Tâ‚)"}
{"name":"TensorStructure.TensorIndex.AddCond.of_add_right'","declaration":"theorem TensorStructure.TensorIndex.AddCond.of_add_right' {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} {h' : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚ƒ} (h : TensorStructure.TensorIndex.AddCond Tâ‚ (Tâ‚‚+[h']Tâ‚ƒ)) : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚ƒ"}
{"name":"TensorStructure.TensorIndex.instSMulTensorIndex","declaration":"/-- The scalar multiplication of a `TensorIndex` by an element of `R`. -/\ninstance TensorStructure.TensorIndex.instSMulTensorIndex {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] : SMul R (TensorStructure.TensorIndex ğ“£)"}
{"name":"TensorStructure.TensorIndex.addCondEquiv_colorMap","declaration":"theorem TensorStructure.TensorIndex.addCondEquiv_colorMap {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : TensorColor.ColorMap.MapIso (TensorStructure.TensorIndex.addCondEquiv h)\n  (IndexNotation.ColorIndexList.colorMap' (TensorStructure.TensorIndex.contr Tâ‚).toColorIndexList)\n  (IndexNotation.ColorIndexList.colorMap' (TensorStructure.TensorIndex.contr Tâ‚‚).toColorIndexList)"}
{"name":"TensorStructure.TensorIndex.AddCond.of_add_left","declaration":"theorem TensorStructure.TensorIndex.AddCond.of_add_left {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} {h' : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚} (h : TensorStructure.TensorIndex.AddCond (Tâ‚+[h']Tâ‚‚) Tâ‚ƒ) : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚ƒ"}
{"name":"TensorStructure.TensorIndex.Rel.to_eq","declaration":"/-- The equality of tensors corresponding to related tensor indices. -/\ntheorem TensorStructure.TensorIndex.Rel.to_eq {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.Rel Tâ‚ Tâ‚‚) : (TensorStructure.TensorIndex.contr Tâ‚).tensor =\n  (TensorStructure.mapIso ğ“£ (IndexNotation.ColorIndexList.contrPermEquiv â‹¯).symm â‹¯)\n    (TensorStructure.TensorIndex.contr Tâ‚‚).tensor"}
{"name":"TensorStructure.TensorIndex.add","declaration":"/-- The addition of two `TensorIndex` given the condition that, after contraction,\ntheir index lists are the same. -/\ndef TensorStructure.TensorIndex.add {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : TensorStructure.TensorIndex ğ“£"}
{"name":"TensorStructure.TensorIndex.contr_of_withDual_empty","declaration":"/-- Applying contr to a tensor whose indices has no contracts does not do anything. -/\ntheorem TensorStructure.TensorIndex.contr_of_withDual_empty {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) (h : IndexNotation.IndexList.withDual T.toIndexList = âˆ…) : TensorStructure.TensorIndex.contr T = T"}
{"name":"TensorStructure.TensorIndex.Rel","declaration":"/-- An (equivalence) relation on two `TensorIndex`.\nThe point in this equivalence relation is that certain things (like the\npermutation of indices, the contraction of indices, or rising or lowering indices) can be placed\nin the indices or moved to the tensor itself. These two descriptions are equivalent. -/\ndef TensorStructure.TensorIndex.Rel {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) : Prop"}
{"name":"TensorStructure.TensorIndex.contr_add_tensor","declaration":"theorem TensorStructure.TensorIndex.contr_add_tensor {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : (TensorStructure.TensorIndex.contr (Tâ‚+[h]Tâ‚‚)).tensor =\n  (TensorStructure.mapIso ğ“£ (Fin.castIso â‹¯).toEquiv â‹¯) (Tâ‚+[h]Tâ‚‚).tensor"}
{"name":"TensorStructure.TensorIndex.tensorIso","declaration":"/-- Given an equality of `TensorIndex`, the isomorphism taking one underlying\ntensor to the other. -/\ndef TensorStructure.TensorIndex.tensorIso {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : Tâ‚ = Tâ‚‚) : TensorStructure.Tensor ğ“£ (IndexNotation.ColorIndexList.colorMap' Tâ‚‚.toColorIndexList) â‰ƒâ‚—[R]\n  TensorStructure.Tensor ğ“£ (IndexNotation.ColorIndexList.colorMap' Tâ‚.toColorIndexList)"}
{"name":"TensorStructure.TensorIndex.smul_index","declaration":"theorem TensorStructure.TensorIndex.smul_index {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (r : R) (T : TensorStructure.TensorIndex ğ“£) : (r â€¢ T).toColorIndexList = T.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.contr_toColorIndexList","declaration":"theorem TensorStructure.TensorIndex.contr_toColorIndexList {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) : (TensorStructure.TensorIndex.contr T).toColorIndexList = IndexNotation.ColorIndexList.contr T.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.contr_add","declaration":"theorem TensorStructure.TensorIndex.contr_add {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : TensorStructure.TensorIndex.contr (Tâ‚+[h]Tâ‚‚) = Tâ‚+[h]Tâ‚‚"}
{"name":"TensorStructure.TensorIndex.rel_contr","declaration":"/-- A tensor index is equivalent to its contraction. -/\ntheorem TensorStructure.TensorIndex.rel_contr {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) : T â‰ˆ TensorStructure.TensorIndex.contr T"}
{"name":"TensorStructure.TensorIndex.contr_contr","declaration":"theorem TensorStructure.TensorIndex.contr_contr {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) : TensorStructure.TensorIndex.contr (TensorStructure.TensorIndex.contr T) = TensorStructure.TensorIndex.contr T"}
{"name":"TensorStructure.TensorIndex.add_assoc","declaration":"theorem TensorStructure.TensorIndex.add_assoc {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} {h' : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚} (h : TensorStructure.TensorIndex.AddCond (Tâ‚+[h']Tâ‚‚) Tâ‚ƒ) : Tâ‚+[h']Tâ‚‚+[h]Tâ‚ƒ = Tâ‚+[â‹¯](Tâ‚‚+[â‹¯]Tâ‚ƒ)"}
{"name":"TensorStructure.TensorIndex.smul_rel","declaration":"theorem TensorStructure.TensorIndex.smul_rel {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : Tâ‚ â‰ˆ Tâ‚‚) (r : R) : r â€¢ Tâ‚ â‰ˆ r â€¢ Tâ‚‚"}
{"name":"TensorStructure.TensorIndex.mkDualMap","declaration":"/-- The construction of a `TensorIndex` from a tensor, a IndexListColor, and a condition\non the dual maps. -/\ndef TensorStructure.TensorIndex.mkDualMap {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {n : â„•} {cn : Fin n â†’ ğ“£.Color} (T : TensorStructure.Tensor ğ“£ cn) (l : IndexNotation.ColorIndexList ğ“£.toTensorColor) (hn : n = IndexNotation.IndexList.length l.toIndexList) (hd : TensorColor.ColorMap.DualMap (IndexNotation.ColorIndexList.colorMap' l) (cn âˆ˜ Fin.cast â‹¯)) : TensorStructure.TensorIndex ğ“£"}
{"name":"TensorStructure.TensorIndex.AddCond.rel_left","declaration":"theorem TensorStructure.TensorIndex.AddCond.rel_left {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚' : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) (h' : Tâ‚ â‰ˆ Tâ‚') : TensorStructure.TensorIndex.AddCond Tâ‚' Tâ‚‚"}
{"name":"TensorStructure.TensorIndex.AddCond.add_left_of_add_right","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_left_of_add_right {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} {h' : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚ƒ} (h : TensorStructure.TensorIndex.AddCond Tâ‚ (Tâ‚‚+[h']Tâ‚ƒ)) : TensorStructure.TensorIndex.AddCond (Tâ‚+[â‹¯]Tâ‚‚) Tâ‚ƒ"}
{"name":"TensorStructure.TensorIndex.smul_contr","declaration":"theorem TensorStructure.TensorIndex.smul_contr {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (r : R) (T : TensorStructure.TensorIndex ğ“£) : TensorStructure.TensorIndex.contr (r â€¢ T) = r â€¢ TensorStructure.TensorIndex.contr T"}
{"name":"TensorStructure.TensorIndex.AddCond.add_left","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_left {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) (h' : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚ƒ) : TensorStructure.TensorIndex.AddCond (Tâ‚+[h]Tâ‚‚) Tâ‚ƒ"}
{"name":"TensorStructure.TensorIndex.smul_add","declaration":"/-- Scalar multiplication commutes with addition. -/\ntheorem TensorStructure.TensorIndex.smul_add {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (r : R) (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : r â€¢ (Tâ‚+[h]Tâ‚‚) = r â€¢ Tâ‚+[h]r â€¢ Tâ‚‚"}
{"name":"TensorStructure.TensorIndex.smul_tensor","declaration":"theorem TensorStructure.TensorIndex.smul_tensor {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (r : R) (T : TensorStructure.TensorIndex ğ“£) : (r â€¢ T).tensor = r â€¢ T.tensor"}
{"name":"TensorStructure.TensorIndex.addCondEquiv","declaration":"/-- The equivalence between indices after contraction given a `AddCond`. -/\ndef TensorStructure.TensorIndex.addCondEquiv {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : Fin (IndexNotation.IndexList.length (TensorStructure.TensorIndex.contr Tâ‚).toIndexList) â‰ƒ\n  Fin (IndexNotation.IndexList.length (TensorStructure.TensorIndex.contr Tâ‚‚).toIndexList)"}
{"name":"TensorStructure.TensorIndex.prod_toIndexList","declaration":"theorem TensorStructure.TensorIndex.prod_toIndexList {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.ProdCond Tâ‚ Tâ‚‚) : (TensorStructure.TensorIndex.prod Tâ‚ Tâ‚‚ h).toIndexList = Tâ‚.toIndexList ++ Tâ‚‚.toIndexList"}
{"name":"TensorStructure.TensorIndex.mk","declaration":"ctor TensorStructure.TensorIndex.mk {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (toColorIndexList : IndexNotation.ColorIndexList ğ“£.toTensorColor) (tensor : TensorStructure.Tensor ğ“£ (IndexNotation.ColorIndexList.colorMap' toColorIndexList)) : TensorStructure.TensorIndex ğ“£"}
{"name":"TensorStructure.TensorIndex.AddCond.rel_right","declaration":"theorem TensorStructure.TensorIndex.AddCond.rel_right {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚' : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) (h' : Tâ‚‚ â‰ˆ Tâ‚‚') : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚'"}
{"name":"TensorStructure.TensorIndex.index_eq_of_eq","declaration":"theorem TensorStructure.TensorIndex.index_eq_of_eq {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : Tâ‚ = Tâ‚‚) : Tâ‚.toColorIndexList = Tâ‚‚.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.contr","declaration":"/-- The contraction of indices in a `TensorIndex`. -/\ndef TensorStructure.TensorIndex.contr {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) : TensorStructure.TensorIndex ğ“£"}
{"name":"TensorStructure.TensorIndex.AddCond.trans","declaration":"theorem TensorStructure.TensorIndex.AddCond.trans {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} (h1 : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) (h2 : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚ƒ) : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚ƒ"}
{"name":"TensorStructure.TensorIndex.add_toColorIndexList","declaration":"theorem TensorStructure.TensorIndex.add_toColorIndexList {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : (Tâ‚+[h]Tâ‚‚).toColorIndexList = IndexNotation.ColorIndexList.contr Tâ‚‚.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.AddCond.symm","declaration":"theorem TensorStructure.TensorIndex.AddCond.symm {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚"}
{"name":"TensorStructure.TensorIndex.AddCond.add_right","declaration":"theorem TensorStructure.TensorIndex.AddCond.add_right {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚ƒ) (h' : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚ƒ) : TensorStructure.TensorIndex.AddCond Tâ‚ (Tâ‚‚+[h']Tâ‚ƒ)"}
{"name":"TensorStructure.TensorIndex.colormap_mapIso","declaration":"theorem TensorStructure.TensorIndex.colormap_mapIso {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (hi : Tâ‚.toColorIndexList = Tâ‚‚.toColorIndexList) : TensorColor.ColorMap.MapIso (Fin.castIso â‹¯).toEquiv (IndexNotation.ColorIndexList.colorMap' Tâ‚.toColorIndexList)\n  (IndexNotation.ColorIndexList.colorMap' Tâ‚‚.toColorIndexList)"}
{"name":"TensorStructure.TensorIndex.add_comm","declaration":"theorem TensorStructure.TensorIndex.add_comm {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : Tâ‚+[h]Tâ‚‚ â‰ˆ Tâ‚‚+[â‹¯]Tâ‚"}
{"name":"TensorStructure.TensorIndex.Rel.of_withDual_empty","declaration":"theorem TensorStructure.TensorIndex.Rel.of_withDual_empty {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : IndexNotation.ColorIndexList.ContrPerm Tâ‚.toColorIndexList Tâ‚‚.toColorIndexList) (h1 : IndexNotation.IndexList.withDual Tâ‚.toIndexList = âˆ…) (h2 : IndexNotation.IndexList.withDual Tâ‚‚.toIndexList = âˆ…) (hT : Tâ‚.tensor = (TensorStructure.mapIso ğ“£ (IndexNotation.ColorIndexList.permEquiv h h1 h2).symm â‹¯) Tâ‚‚.tensor) : TensorStructure.TensorIndex.Rel Tâ‚ Tâ‚‚"}
{"name":"TensorStructure.TensorIndex.tensor_eq_of_eq","declaration":"theorem TensorStructure.TensorIndex.tensor_eq_of_eq {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : Tâ‚ = Tâ‚‚) : Tâ‚.tensor = (TensorStructure.TensorIndex.tensorIso h) Tâ‚‚.tensor"}
{"name":"TensorStructure.TensorIndex.tensor","declaration":"/-- The underlying tensor. -/\ndef TensorStructure.TensorIndex.tensor {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (self : TensorStructure.TensorIndex ğ“£) : TensorStructure.Tensor ğ“£ (IndexNotation.ColorIndexList.colorMap' self.toColorIndexList)"}
{"name":"TensorStructure.TensorIndex.AddCond.of_add_right","declaration":"theorem TensorStructure.TensorIndex.AddCond.of_add_right {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} {h' : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚ƒ} (h : TensorStructure.TensorIndex.AddCond Tâ‚ (Tâ‚‚+[h']Tâ‚ƒ)) : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚"}
{"name":"TensorStructure.TensorIndex.prod","declaration":"/-- The tensor product of two `TensorIndex`.\n\nNote: By defualt contraction is NOT done before taking the products. -/\ndef TensorStructure.TensorIndex.prod {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.ProdCond Tâ‚ Tâ‚‚) : TensorStructure.TensorIndex ğ“£"}
{"name":"TensorStructure.TensorIndex.asSetoid","declaration":"/-- The structure of a Setoid on `ğ“£.TensorIndex` induced by `Rel`. -/\ninstance TensorStructure.TensorIndex.asSetoid {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] : Setoid (TensorStructure.TensorIndex ğ“£)"}
{"name":"TensorStructure.TensorIndex.AddCond.to_PermContr","declaration":"theorem TensorStructure.TensorIndex.AddCond.to_PermContr {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : IndexNotation.ColorIndexList.ContrPerm Tâ‚.toColorIndexList Tâ‚‚.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.ProdCond.to_AppendCond","declaration":"theorem TensorStructure.TensorIndex.ProdCond.to_AppendCond {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.ProdCond Tâ‚ Tâ‚‚) : IndexNotation.ColorIndexList.AppendCond Tâ‚.toColorIndexList Tâ‚‚.toColorIndexList"}
{"name":"TensorStructure.TensorIndex.Â«term_+[_]_Â»","declaration":"/-- Notation for addition of tensor indices. -/\ndef TensorStructure.TensorIndex.Â«term_+[_]_Â»  : Lean.TrailingParserDescr"}
{"name":"TensorStructure.TensorIndex.Rel.symm","declaration":"/-- Rel is symmetric. -/\ntheorem TensorStructure.TensorIndex.Rel.symm {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.Rel Tâ‚ Tâ‚‚) : TensorStructure.TensorIndex.Rel Tâ‚‚ Tâ‚"}
{"name":"TensorStructure.TensorIndex.contr_toIndexList","declaration":"theorem TensorStructure.TensorIndex.contr_toIndexList {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) : (TensorStructure.TensorIndex.contr T).toIndexList = IndexNotation.IndexList.contrIndexList T.toIndexList"}
{"name":"TensorStructure.TensorIndex.instCoeTensorIndexColorIndexListToTensorColor","declaration":"instance TensorStructure.TensorIndex.instCoeTensorIndexColorIndexListToTensorColor {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] : Coe (TensorStructure.TensorIndex ğ“£) (IndexNotation.ColorIndexList ğ“£.toTensorColor)"}
{"name":"TensorStructure.TensorIndex.ProdCond","declaration":"/-- The condition on two `TensorIndex` which is true if and only if their `ColorIndexList`s\nare related by the condition `AppendCond`. That is, they can be appended to form a\n`ColorIndexList`. -/\ndef TensorStructure.TensorIndex.ProdCond {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) : Prop"}
{"name":"TensorStructure.TensorIndex.AddCond","declaration":"/-- The condition on tensors with indices for their addition to exists.\nThis condition states that the the indices of one tensor are exact permutations of indices\nof another after contraction. This includes the id of the index and the color.\n\nThis condition is general enough to allow addition of e.g. `Ïˆáµ¤â‚áµ¤â‚‚ + Ï†áµ¤â‚‚áµ¤â‚`, but\nwill NOT allow e.g. `Ïˆáµ¤â‚áµ¤â‚‚ + Ï†áµ˜Â²áµ¤â‚`. -/\ndef TensorStructure.TensorIndex.AddCond {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) : Prop"}
{"name":"TensorStructure.TensorIndex.Rel.trans","declaration":"/-- Rel is transitive. -/\ntheorem TensorStructure.TensorIndex.Rel.trans {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} (h1 : TensorStructure.TensorIndex.Rel Tâ‚ Tâ‚‚) (h2 : TensorStructure.TensorIndex.Rel Tâ‚‚ Tâ‚ƒ) : TensorStructure.TensorIndex.Rel Tâ‚ Tâ‚ƒ"}
{"name":"TensorStructure.TensorIndex.add_rel_right","declaration":"theorem TensorStructure.TensorIndex.add_rel_right {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚' : TensorStructure.TensorIndex ğ“£} (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) (h' : Tâ‚‚ â‰ˆ Tâ‚‚') : Tâ‚+[h]Tâ‚‚ â‰ˆ Tâ‚+[â‹¯]Tâ‚‚'"}
{"name":"TensorStructure.TensorIndex.prod_toColorIndexList","declaration":"theorem TensorStructure.TensorIndex.prod_toColorIndexList {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.ProdCond Tâ‚ Tâ‚‚) : (TensorStructure.TensorIndex.prod Tâ‚ Tâ‚‚ h).toColorIndexList =\n  IndexNotation.ColorIndexList.append Tâ‚.toColorIndexList Tâ‚‚.toColorIndexList h"}
{"name":"TensorStructure.TensorIndex.contr_tensor_of_withDual_empty","declaration":"theorem TensorStructure.TensorIndex.contr_tensor_of_withDual_empty {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) (h : IndexNotation.IndexList.withDual T.toIndexList = âˆ…) : (TensorStructure.TensorIndex.contr T).tensor = (TensorStructure.TensorIndex.tensorIso â‹¯) T.tensor"}
{"name":"TensorStructure.TensorIndex","declaration":"/-- The structure an tensor with a index specification e.g. `áµ˜Â¹áµ¤â‚‚`. -/\nstructure TensorStructure.TensorIndex {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) [IndexNotation ğ“£.Color] : Type"}
{"name":"TensorStructure.TensorIndex.ext","declaration":"theorem TensorStructure.TensorIndex.ext {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} (hi : Tâ‚.toColorIndexList = Tâ‚‚.toColorIndexList) (h : Tâ‚.tensor = (TensorStructure.mapIso ğ“£ (Fin.castIso â‹¯).toEquiv â‹¯) Tâ‚‚.tensor) : Tâ‚ = Tâ‚‚"}
{"name":"TensorStructure.TensorIndex.add_assoc'","declaration":"theorem TensorStructure.TensorIndex.add_assoc' {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] {Tâ‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚‚ : TensorStructure.TensorIndex ğ“£} {Tâ‚ƒ : TensorStructure.TensorIndex ğ“£} {h' : TensorStructure.TensorIndex.AddCond Tâ‚‚ Tâ‚ƒ} (h : TensorStructure.TensorIndex.AddCond Tâ‚ (Tâ‚‚+[h']Tâ‚ƒ)) : Tâ‚+[h](Tâ‚‚+[h']Tâ‚ƒ) = Tâ‚+[â‹¯]Tâ‚‚+[â‹¯]Tâ‚ƒ"}
{"name":"TensorStructure.TensorIndex.AddCond.refl","declaration":"theorem TensorStructure.TensorIndex.AddCond.refl {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) : TensorStructure.TensorIndex.AddCond T T"}
{"name":"TensorStructure.TensorIndex.Rel.refl","declaration":"/-- Rel is reflexive. -/\ntheorem TensorStructure.TensorIndex.Rel.refl {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (T : TensorStructure.TensorIndex ğ“£) : TensorStructure.TensorIndex.Rel T T"}
{"name":"TensorStructure.TensorIndex.add_tensor","declaration":"theorem TensorStructure.TensorIndex.add_tensor {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : (Tâ‚+[h]Tâ‚‚).tensor =\n  (TensorStructure.mapIso ğ“£ (TensorStructure.TensorIndex.addCondEquiv h) â‹¯)\n      (TensorStructure.TensorIndex.contr Tâ‚).tensor +\n    (TensorStructure.TensorIndex.contr Tâ‚‚).tensor"}
{"name":"TensorStructure.TensorIndex.add_withDual_empty","declaration":"theorem TensorStructure.TensorIndex.add_withDual_empty {R : Type} [CommSemiring R] {ğ“£ : TensorStructure R} [IndexNotation ğ“£.Color] [DecidableEq ğ“£.Color] (Tâ‚ : TensorStructure.TensorIndex ğ“£) (Tâ‚‚ : TensorStructure.TensorIndex ğ“£) (h : TensorStructure.TensorIndex.AddCond Tâ‚ Tâ‚‚) : IndexNotation.IndexList.withDual (Tâ‚+[h]Tâ‚‚).toIndexList = âˆ…"}
