{"name":"MSSMCharges.Hu","declaration":"/-- The charge `Hu`. -/\ndef MSSMCharges.Hu  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ℚ"}
{"name":"MSSMCharges.toSMSpecies_toSpecies_inv","declaration":"theorem MSSMCharges.toSMSpecies_toSpecies_inv (i : Fin 6) (f : (Fin 6 → Fin 3 → ℚ) × (Fin 2 → ℚ)) : (MSSMCharges.toSMSpecies i) (MSSMCharges.toSpecies.symm f) = f.1 i"}
{"name":"MSSMCharges.L","declaration":"/-- The `L` charges as a map `Fin 3 → ℚ`. -/\ndef MSSMCharges.L  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ACCSystemCharges.Charges MSSMSpecies"}
{"name":"MSSMCharges.Q","declaration":"/-- The `Q` charges as a map `Fin 3 → ℚ`. -/\ndef MSSMCharges.Q  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ACCSystemCharges.Charges MSSMSpecies"}
{"name":"MSSMCharges.toSplitSMPlusH","declaration":"/-- An equivalence between `MSSMCharges.charges` and `(Fin 18 → ℚ) × (Fin 2 → ℚ)`. This\nsplits the charges up into the SM and the additional ones for the MSSM. -/\ndef MSSMCharges.toSplitSMPlusH  : ACCSystemCharges.Charges MSSMCharges ≃ (Fin 18 → ℚ) × (Fin 2 → ℚ)"}
{"name":"MSSMCharges.splitSMPlusH_apply","declaration":"theorem MSSMCharges.splitSMPlusH_apply (f : Fin 18 ⊕ Fin 2 → ℚ) : MSSMCharges.splitSMPlusH f = (f ∘ Sum.inl, f ∘ Sum.inr)"}
{"name":"MSSMACCs.accYY_ext","declaration":"/-- Extensionality lemma for `accGrav`. -/\ntheorem MSSMACCs.accYY_ext {S : ACCSystemCharges.Charges MSSMCharges} {T : ACCSystemCharges.Charges MSSMCharges} (hj : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => (MSSMCharges.toSMSpecies j) S i) =\n    Finset.sum Finset.univ fun i => (MSSMCharges.toSMSpecies j) T i) (hd : MSSMCharges.Hd S = MSSMCharges.Hd T) (hu : MSSMCharges.Hu S = MSSMCharges.Hu T) : MSSMACCs.accYY S = MSSMACCs.accYY T"}
{"name":"MSSMACCs.accCube_ext","declaration":"/-- Extensionality lemma for `accCube`. -/\ntheorem MSSMACCs.accCube_ext {S : ACCSystemCharges.Charges MSSMCharges} {T : ACCSystemCharges.Charges MSSMCharges} (h : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => ((fun a => a ^ 3) ∘ (MSSMCharges.toSMSpecies j) S) i) =\n    Finset.sum Finset.univ fun i => ((fun a => a ^ 3) ∘ (MSSMCharges.toSMSpecies j) T) i) (hd : MSSMCharges.Hd S = MSSMCharges.Hd T) (hu : MSSMCharges.Hu S = MSSMCharges.Hu T) : MSSMACCs.accCube S = MSSMACCs.accCube T"}
{"name":"MSSMCharges.Hu_apply","declaration":"theorem MSSMCharges.Hu_apply (S : ACCSystemCharges.Charges MSSMCharges) : MSSMCharges.Hu S = S { val := 19, isLt := MSSMCharges.Hu.proof_1 }"}
{"name":"MSSMCharges.toSpecies_apply","declaration":"theorem MSSMCharges.toSpecies_apply  : ∀ (a : ACCSystemCharges.Charges MSSMCharges),\n  MSSMCharges.toSpecies a =\n    (MSSMCharges.toSpeciesMaps' (MSSMCharges.toSMPlusH a ∘ Sum.inl), MSSMCharges.toSMPlusH a ∘ Sum.inr)"}
{"name":"MSSMACC.AnomalyFreeQuadMk'","declaration":"/-- A `QuadSol` from a `LinSol` satisfying the quadratic ACC. -/\ndef MSSMACC.AnomalyFreeQuadMk' (S : ACCSystemLinear.LinSols MSSMACC.toACCSystemLinear) (hquad : MSSMACCs.accQuad S.val = 0) : ACCSystemQuad.QuadSols MSSMACC.toACCSystemQuad"}
{"name":"MSSMACCs.accCube","declaration":"/-- The cubic ACC. -/\ndef MSSMACCs.accCube  : HomogeneousCubic (ACCSystemCharges.Charges MSSMCharges)"}
{"name":"MSSMCharges.splitSMPlusH","declaration":"/-- An equivalence between `Fin 18 ⊕ Fin 2 → ℚ` and `(Fin 18 → ℚ) × (Fin 2 → ℚ)`. -/\ndef MSSMCharges.splitSMPlusH  : (Fin 18 ⊕ Fin 2 → ℚ) ≃ (Fin 18 → ℚ) × (Fin 2 → ℚ)"}
{"name":"MSSMCharges.toSMPlusH_apply","declaration":"theorem MSSMCharges.toSMPlusH_apply  : ∀ (a : Fin (18 + 2) → ℚ) (a_1 : Fin 18 ⊕ Fin 2), MSSMCharges.toSMPlusH a a_1 = a (finSumFinEquiv a_1)"}
{"name":"MSSMACC.dot","declaration":"/-- The dot product on the vector space of charges. -/\ndef MSSMACC.dot  : BiLinearSymm (ACCSystemCharges.Charges MSSMCharges)"}
{"name":"MSSMACCs.accGrav_ext","declaration":"/-- Extensionality lemma for `accGrav`. -/\ntheorem MSSMACCs.accGrav_ext {S : ACCSystemCharges.Charges MSSMCharges} {T : ACCSystemCharges.Charges MSSMCharges} (hj : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => (MSSMCharges.toSMSpecies j) S i) =\n    Finset.sum Finset.univ fun i => (MSSMCharges.toSMSpecies j) T i) (hd : MSSMCharges.Hd S = MSSMCharges.Hd T) (hu : MSSMCharges.Hu S = MSSMCharges.Hu T) : MSSMACCs.accGrav S = MSSMACCs.accGrav T"}
{"name":"MSSMCharges.splitSMPlusH_symm_apply","declaration":"theorem MSSMCharges.splitSMPlusH_symm_apply (f : (Fin 18 → ℚ) × (Fin 2 → ℚ)) : ∀ (a : Fin 18 ⊕ Fin 2), MSSMCharges.splitSMPlusH.symm f a = Sum.elim f.1 f.2 a"}
{"name":"MSSMCharges.toSpeciesMaps'_symm_apply","declaration":"theorem MSSMCharges.toSpeciesMaps'_symm_apply  : ∀ (a : Fin 6 → Fin 3 → ℚ) (a_1 : Fin (6 * 3)),\n  MSSMCharges.toSpeciesMaps'.symm a a_1 = a (Fin.divNat a_1) (Fin.modNat a_1)"}
{"name":"MSSMSpecies_numberCharges","declaration":"theorem MSSMSpecies_numberCharges  : MSSMSpecies.numberCharges = 3"}
{"name":"MSSMACCs.cubeTriLinToFun_map_smul₁","declaration":"theorem MSSMACCs.cubeTriLinToFun_map_smul₁ (a : ℚ) (S : ACCSystemCharges.Charges MSSMCharges) (T : ACCSystemCharges.Charges MSSMCharges) (R : ACCSystemCharges.Charges MSSMCharges) : MSSMACCs.cubeTriLinToFun (a • S, T, R) = a * MSSMACCs.cubeTriLinToFun (S, T, R)"}
{"name":"MSSMCharges.D","declaration":"/-- The `D` charges as a map `Fin 3 → ℚ`. -/\ndef MSSMCharges.D  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ACCSystemCharges.Charges MSSMSpecies"}
{"name":"MSSMACC_numberQuadratic","declaration":"theorem MSSMACC_numberQuadratic  : MSSMACC.numberQuadratic = 1"}
{"name":"MSSMACC_numberLinear","declaration":"theorem MSSMACC_numberLinear  : MSSMACC.numberLinear = 4"}
{"name":"MSSMCharges.toSpeciesMaps'","declaration":"/-- An equivalence between `(Fin 18 → ℚ)` and `(Fin 6 → Fin 3 → ℚ)`. -/\ndef MSSMCharges.toSpeciesMaps'  : (Fin 18 → ℚ) ≃ (Fin 6 → Fin 3 → ℚ)"}
{"name":"MSSMCharges.Hd_toSpecies_inv","declaration":"theorem MSSMCharges.Hd_toSpecies_inv (f : (Fin 6 → Fin 3 → ℚ) × (Fin 2 → ℚ)) : MSSMCharges.Hd (MSSMCharges.toSpecies.symm f) = f.2 0"}
{"name":"MSSMACCs.cubeTriLinToFun_swap2","declaration":"theorem MSSMACCs.cubeTriLinToFun_swap2 (S : ACCSystemCharges.Charges MSSMCharges) (T : ACCSystemCharges.Charges MSSMCharges) (R : ACCSystemCharges.Charges MSSMCharges) : MSSMACCs.cubeTriLinToFun (S, T, R) = MSSMACCs.cubeTriLinToFun (S, R, T)"}
{"name":"MSSMCharges.toSplitSMPlusH_apply","declaration":"theorem MSSMCharges.toSplitSMPlusH_apply  : ∀ (a : ACCSystemCharges.Charges MSSMCharges),\n  MSSMCharges.toSplitSMPlusH a = (MSSMCharges.toSMPlusH a ∘ Sum.inl, MSSMCharges.toSMPlusH a ∘ Sum.inr)"}
{"name":"MSSMACC.AnomalyFreeMk_val","declaration":"theorem MSSMACC.AnomalyFreeMk_val (S : ACCSystemCharges.Charges MSSMACC.toACCSystemCharges) (hg : MSSMACCs.accGrav S = 0) (hsu2 : MSSMACCs.accSU2 S = 0) (hsu3 : MSSMACCs.accSU3 S = 0) (hyy : MSSMACCs.accYY S = 0) (hquad : MSSMACCs.accQuad S = 0) (hcube : MSSMACCs.accCube S = 0) : (MSSMACC.AnomalyFreeMk S hg hsu2 hsu3 hyy hquad hcube).val = S"}
{"name":"MSSMCharges.toSplitSMPlusH_symm_apply","declaration":"theorem MSSMCharges.toSplitSMPlusH_symm_apply  : ∀ (a : (Fin 18 → ℚ) × (Fin 2 → ℚ)),\n  MSSMCharges.toSplitSMPlusH.symm a = MSSMCharges.toSMPlusH.symm (MSSMCharges.splitSMPlusH.symm a)"}
{"name":"MSSMACC.dot_toFun_apply","declaration":"theorem MSSMACC.dot_toFun_apply (S : ACCSystemCharges.Charges MSSMCharges) (T : ACCSystemCharges.Charges MSSMCharges) : (MSSMACC.dot S) T =\n  (Finset.sum Finset.univ fun i =>\n        S (Fin.castAdd 2 (finProdFinEquiv (0, i))) * T (Fin.castAdd 2 (finProdFinEquiv (0, i))) +\n                  S (Fin.castAdd 2 (finProdFinEquiv (1, i))) * T (Fin.castAdd 2 (finProdFinEquiv (1, i))) +\n                S (Fin.castAdd 2 (finProdFinEquiv (2, i))) * T (Fin.castAdd 2 (finProdFinEquiv (2, i))) +\n              S (Fin.castAdd 2 (finProdFinEquiv (3, i))) * T (Fin.castAdd 2 (finProdFinEquiv (3, i))) +\n            S (Fin.castAdd 2 (finProdFinEquiv (4, i))) * T (Fin.castAdd 2 (finProdFinEquiv (4, i))) +\n          S (Fin.castAdd 2 (finProdFinEquiv (5, i))) * T (Fin.castAdd 2 (finProdFinEquiv (5, i)))) +\n      S { val := 18, isLt := MSSMCharges.Hd.proof_1 } * T { val := 18, isLt := MSSMCharges.Hd.proof_1 } +\n    S { val := 19, isLt := MSSMCharges.Hu.proof_1 } * T { val := 19, isLt := MSSMCharges.Hu.proof_1 }"}
{"name":"MSSMCharges.Hd_apply","declaration":"theorem MSSMCharges.Hd_apply (S : ACCSystemCharges.Charges MSSMCharges) : MSSMCharges.Hd S = S { val := 18, isLt := MSSMCharges.Hd.proof_1 }"}
{"name":"MSSMCharges.U","declaration":"/-- The `U` charges as a map `Fin 3 → ℚ`. -/\ndef MSSMCharges.U  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ACCSystemCharges.Charges MSSMSpecies"}
{"name":"MSSMACC","declaration":"/-- The ACCSystem for the MSSM without RHN. -/\ndef MSSMACC  : ACCSystem"}
{"name":"MSSMACC.AnomalyFreeMk'","declaration":"/-- A `Sol` from a `LinSol` satisfying the quadratic and cubic ACCs. -/\ndef MSSMACC.AnomalyFreeMk' (S : ACCSystemLinear.LinSols MSSMACC.toACCSystemLinear) (hquad : MSSMACCs.accQuad S.val = 0) (hcube : MSSMACCs.accCube S.val = 0) : ACCSystem.Sols MSSMACC"}
{"name":"MSSMCharges.toSMSpecies_apply","declaration":"theorem MSSMCharges.toSMSpecies_apply (i : Fin 6) (S : ACCSystemCharges.Charges MSSMCharges) : ∀ (a : Fin 3), (MSSMCharges.toSMSpecies i) S a = S (Fin.castAdd 2 (finProdFinEquiv (i, a)))"}
{"name":"MSSMCharges.toSpecies","declaration":"/-- An equivalence between `MSSMCharges.charges` and `(Fin 6 → Fin 3 → ℚ) × (Fin 2 → ℚ))`.\nThis splits charges up into the SM and additional fermions, and further splits the SM into\nspecies. -/\ndef MSSMCharges.toSpecies  : ACCSystemCharges.Charges MSSMCharges ≃ (Fin 6 → Fin 3 → ℚ) × (Fin 2 → ℚ)"}
{"name":"MSSMACCs.cubeTriLinToFun","declaration":"/-- The function underlying the symmetric trilinear form used to define the cubic ACC. -/\ndef MSSMACCs.cubeTriLinToFun (S : ACCSystemCharges.Charges MSSMCharges × ACCSystemCharges.Charges MSSMCharges × ACCSystemCharges.Charges MSSMCharges) : ℚ"}
{"name":"MSSMSpecies","declaration":"/-- The vector spaces of charges of one species of fermions in the MSSM. -/\ndef MSSMSpecies  : ACCSystemCharges"}
{"name":"MSSMACCs.cubeTriLinToFun_swap1","declaration":"theorem MSSMACCs.cubeTriLinToFun_swap1 (S : ACCSystemCharges.Charges MSSMCharges) (T : ACCSystemCharges.Charges MSSMCharges) (R : ACCSystemCharges.Charges MSSMCharges) : MSSMACCs.cubeTriLinToFun (S, T, R) = MSSMACCs.cubeTriLinToFun (T, S, R)"}
{"name":"MSSMACC_linearACCs","declaration":"theorem MSSMACC_linearACCs (i : Fin 4) : MSSMACC.linearACCs i =\n  match i with\n  | 0 =>\n    {\n      toAddHom :=\n        {\n          toFun := fun S =>\n            (Finset.sum Finset.univ fun i =>\n                6 * S (Fin.castAdd 2 (finProdFinEquiv (0, i))) + 3 * S (Fin.castAdd 2 (finProdFinEquiv (1, i))) +\n                        3 * S (Fin.castAdd 2 (finProdFinEquiv (2, i))) +\n                      2 * S (Fin.castAdd 2 (finProdFinEquiv (3, i))) +\n                    S (Fin.castAdd 2 (finProdFinEquiv (4, i))) +\n                  S (Fin.castAdd 2 (finProdFinEquiv (5, i)))) +\n              2 * (S { val := 18, isLt := MSSMCharges.Hd.proof_1 } + S { val := 19, isLt := MSSMCharges.Hu.proof_1 }),\n          map_add' := MSSMACCs.accGrav.proof_1 },\n      map_smul' := MSSMACCs.accGrav.proof_2 }\n  | 1 =>\n    {\n      toAddHom :=\n        {\n          toFun := fun S =>\n            (Finset.sum Finset.univ fun i =>\n                  3 * S (Fin.castAdd 2 (finProdFinEquiv (0, i))) + S (Fin.castAdd 2 (finProdFinEquiv (3, i)))) +\n                S { val := 18, isLt := MSSMCharges.Hd.proof_1 } +\n              S { val := 19, isLt := MSSMCharges.Hu.proof_1 },\n          map_add' := MSSMACCs.accSU2.proof_1 },\n      map_smul' := MSSMACCs.accSU2.proof_2 }\n  | 2 =>\n    {\n      toAddHom :=\n        {\n          toFun := fun S =>\n            Finset.sum Finset.univ fun i =>\n              2 * S (Fin.castAdd 2 (finProdFinEquiv (0, i))) + S (Fin.castAdd 2 (finProdFinEquiv (1, i))) +\n                S (Fin.castAdd 2 (finProdFinEquiv (2, i))),\n          map_add' := MSSMACCs.accSU3.proof_1 },\n      map_smul' := MSSMACCs.accSU3.proof_2 }\n  | 3 =>\n    {\n      toAddHom :=\n        {\n          toFun := fun S =>\n            (Finset.sum Finset.univ fun i =>\n                S (Fin.castAdd 2 (finProdFinEquiv (0, i))) + 8 * S (Fin.castAdd 2 (finProdFinEquiv (1, i))) +\n                      2 * S (Fin.castAdd 2 (finProdFinEquiv (2, i))) +\n                    3 * S (Fin.castAdd 2 (finProdFinEquiv (3, i))) +\n                  6 * S (Fin.castAdd 2 (finProdFinEquiv (4, i)))) +\n              3 * (S { val := 18, isLt := MSSMCharges.Hd.proof_1 } + S { val := 19, isLt := MSSMCharges.Hu.proof_1 }),\n          map_add' := MSSMACCs.accYY.proof_1 },\n      map_smul' := MSSMACCs.accYY.proof_2 }"}
{"name":"MSSMCharges","declaration":"/-- The vector space of charges corresponding to the MSSM fermions. -/\ndef MSSMCharges  : ACCSystemCharges"}
{"name":"MSSMACC.AnomalyFreeMk''","declaration":"/-- A `Sol` from a `QuadSol` satisfying the cubic ACCs. -/\ndef MSSMACC.AnomalyFreeMk'' (S : ACCSystemQuad.QuadSols MSSMACC.toACCSystemQuad) (hcube : MSSMACCs.accCube S.val = 0) : ACCSystem.Sols MSSMACC"}
{"name":"MSSMCharges.Hu_toSpecies_inv","declaration":"theorem MSSMCharges.Hu_toSpecies_inv (f : (Fin 6 → Fin 3 → ℚ) × (Fin 2 → ℚ)) : MSSMCharges.Hu (MSSMCharges.toSpecies.symm f) = f.2 1"}
{"name":"MSSMACC.AnomalyFreeMk","declaration":"/-- A solution from a charge satisfying the ACCs. -/\ndef MSSMACC.AnomalyFreeMk (S : ACCSystemCharges.Charges MSSMACC.toACCSystemCharges) (hg : MSSMACCs.accGrav S = 0) (hsu2 : MSSMACCs.accSU2 S = 0) (hsu3 : MSSMACCs.accSU3 S = 0) (hyy : MSSMACCs.accYY S = 0) (hquad : MSSMACCs.accQuad S = 0) (hcube : MSSMACCs.accCube S = 0) : ACCSystem.Sols MSSMACC"}
{"name":"MSSMACC_cubicACC_toFun","declaration":"theorem MSSMACC_cubicACC_toFun (S : ACCSystemCharges.Charges MSSMCharges) : MSSMACC.cubicACC.toFun S =\n  (Finset.sum Finset.univ fun i =>\n      6 *\n                  (S (Fin.castAdd 2 (finProdFinEquiv (0, i))) * S (Fin.castAdd 2 (finProdFinEquiv (0, i))) *\n                    S (Fin.castAdd 2 (finProdFinEquiv (0, i)))) +\n                3 *\n                  (S (Fin.castAdd 2 (finProdFinEquiv (1, i))) * S (Fin.castAdd 2 (finProdFinEquiv (1, i))) *\n                    S (Fin.castAdd 2 (finProdFinEquiv (1, i)))) +\n              3 *\n                (S (Fin.castAdd 2 (finProdFinEquiv (2, i))) * S (Fin.castAdd 2 (finProdFinEquiv (2, i))) *\n                  S (Fin.castAdd 2 (finProdFinEquiv (2, i)))) +\n            2 *\n              (S (Fin.castAdd 2 (finProdFinEquiv (3, i))) * S (Fin.castAdd 2 (finProdFinEquiv (3, i))) *\n                S (Fin.castAdd 2 (finProdFinEquiv (3, i)))) +\n          S (Fin.castAdd 2 (finProdFinEquiv (4, i))) * S (Fin.castAdd 2 (finProdFinEquiv (4, i))) *\n            S (Fin.castAdd 2 (finProdFinEquiv (4, i))) +\n        S (Fin.castAdd 2 (finProdFinEquiv (5, i))) * S (Fin.castAdd 2 (finProdFinEquiv (5, i))) *\n          S (Fin.castAdd 2 (finProdFinEquiv (5, i)))) +\n    (2 * S { val := 18, isLt := MSSMCharges.Hd.proof_1 } * S { val := 18, isLt := MSSMCharges.Hd.proof_1 } *\n        S { val := 18, isLt := MSSMCharges.Hd.proof_1 } +\n      2 * S { val := 19, isLt := MSSMCharges.Hu.proof_1 } * S { val := 19, isLt := MSSMCharges.Hu.proof_1 } *\n        S { val := 19, isLt := MSSMCharges.Hu.proof_1 })"}
{"name":"MSSMCharges.toSpeciesMaps'_apply","declaration":"theorem MSSMCharges.toSpeciesMaps'_apply  : ∀ (a : Fin (6 * 3) → ℚ) (a_1 : Fin 6) (a_2 : Fin 3),\n  MSSMCharges.toSpeciesMaps' a a_1 a_2 = a (finProdFinEquiv (a_1, a_2))"}
{"name":"MSSMACCs.accYY","declaration":"/-- The ACC for `Y²`. -/\ndef MSSMACCs.accYY  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ℚ"}
{"name":"MSSMCharges.toSMPlusH","declaration":"/-- An equivalence between `MSSMCharges.charges` and the space of maps\n`(Fin 18 ⊕ Fin 2 → ℚ)`. The first 18 factors corresponds to the SM fermions, while the last two\nare the higgsions. -/\ndef MSSMCharges.toSMPlusH  : ACCSystemCharges.Charges MSSMCharges ≃ (Fin 18 ⊕ Fin 2 → ℚ)"}
{"name":"MSSMACC.quadSol","declaration":"theorem MSSMACC.quadSol (S : ACCSystemQuad.QuadSols MSSMACC.toACCSystemQuad) : MSSMACCs.accQuad S.val = 0"}
{"name":"MSSMACCs.accSU3","declaration":"/-- The anomaly cancellation condition for SU(3) anomaly. -/\ndef MSSMACCs.accSU3  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ℚ"}
{"name":"MSSMACCs.accSU2","declaration":"/-- The anomaly cancellation condition for SU(2) anomaly. -/\ndef MSSMACCs.accSU2  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ℚ"}
{"name":"MSSMCharges.toSpecies_symm_apply","declaration":"theorem MSSMCharges.toSpecies_symm_apply  : ∀ (a : (Fin 6 → Fin 3 → ℚ) × (Fin 2 → ℚ)),\n  MSSMCharges.toSpecies.symm a =\n    MSSMCharges.toSMPlusH.symm (MSSMCharges.splitSMPlusH.symm (MSSMCharges.toSpeciesMaps'.symm a.1, a.2))"}
{"name":"MSSMACCs.accSU2_ext","declaration":"/-- Extensionality lemma for `accSU2`. -/\ntheorem MSSMACCs.accSU2_ext {S : ACCSystemCharges.Charges MSSMCharges} {T : ACCSystemCharges.Charges MSSMCharges} (hj : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => (MSSMCharges.toSMSpecies j) S i) =\n    Finset.sum Finset.univ fun i => (MSSMCharges.toSMSpecies j) T i) (hd : MSSMCharges.Hd S = MSSMCharges.Hd T) (hu : MSSMCharges.Hu S = MSSMCharges.Hu T) : MSSMACCs.accSU2 S = MSSMACCs.accSU2 T"}
{"name":"MSSMACC_quadraticACCs","declaration":"theorem MSSMACC_quadraticACCs (i : Fin 1) : MSSMACC.quadraticACCs i =\n  match i with\n  | 0 => BiLinearSymm.toHomogeneousQuad MSSMACCs.quadBiLin"}
{"name":"MSSMACCs.quadBiLin","declaration":"/-- The symmetric bilinear function used to define the quadratic ACC. -/\ndef MSSMACCs.quadBiLin  : BiLinearSymm (ACCSystemCharges.Charges MSSMCharges)"}
{"name":"MSSMCharges.E","declaration":"/-- The `E` charges as a map `Fin 3 → ℚ`. -/\ndef MSSMCharges.E  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ACCSystemCharges.Charges MSSMSpecies"}
{"name":"MSSMACCs.accQuad_ext","declaration":"/-- Extensionality lemma for `accQuad`. -/\ntheorem MSSMACCs.accQuad_ext {S : ACCSystemCharges.Charges MSSMCharges} {T : ACCSystemCharges.Charges MSSMCharges} (h : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => ((fun a => a ^ 2) ∘ (MSSMCharges.toSMSpecies j) S) i) =\n    Finset.sum Finset.univ fun i => ((fun a => a ^ 2) ∘ (MSSMCharges.toSMSpecies j) T) i) (hd : MSSMCharges.Hd S = MSSMCharges.Hd T) (hu : MSSMCharges.Hu S = MSSMCharges.Hu T) : MSSMACCs.accQuad S = MSSMACCs.accQuad T"}
{"name":"MSSMACCs.quadBiLin_toFun_apply","declaration":"theorem MSSMACCs.quadBiLin_toFun_apply (S : ACCSystemCharges.Charges MSSMCharges) (T : ACCSystemCharges.Charges MSSMCharges) : (MSSMACCs.quadBiLin S) T =\n  (Finset.sum Finset.univ fun x =>\n      S (Fin.castAdd 2 (finProdFinEquiv (0, x))) * T (Fin.castAdd 2 (finProdFinEquiv (0, x))) +\n              -(2 * (S (Fin.castAdd 2 (finProdFinEquiv (1, x))) * T (Fin.castAdd 2 (finProdFinEquiv (1, x))))) +\n            S (Fin.castAdd 2 (finProdFinEquiv (2, x))) * T (Fin.castAdd 2 (finProdFinEquiv (2, x))) +\n          -(S (Fin.castAdd 2 (finProdFinEquiv (3, x))) * T (Fin.castAdd 2 (finProdFinEquiv (3, x)))) +\n        S (Fin.castAdd 2 (finProdFinEquiv (4, x))) * T (Fin.castAdd 2 (finProdFinEquiv (4, x)))) +\n    (-(S { val := 18, isLt := MSSMCharges.Hd.proof_1 } * T { val := 18, isLt := MSSMCharges.Hd.proof_1 }) +\n      S { val := 19, isLt := MSSMCharges.Hu.proof_1 } * T { val := 19, isLt := MSSMCharges.Hu.proof_1 })"}
{"name":"MSSMCharges_numberCharges","declaration":"theorem MSSMCharges_numberCharges  : MSSMCharges.numberCharges = 20"}
{"name":"MSSMACC_numberCharges","declaration":"theorem MSSMACC_numberCharges  : MSSMACC.numberCharges = 20"}
{"name":"MSSMCharges.Hd","declaration":"/-- The charge `Hd`. -/\ndef MSSMCharges.Hd  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ℚ"}
{"name":"MSSMCharges.N","declaration":"/-- The `N` charges as a map `Fin 3 → ℚ`. -/\ndef MSSMCharges.N  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ACCSystemCharges.Charges MSSMSpecies"}
{"name":"MSSMACCs.accQuad","declaration":"/-- The quadratic ACC. -/\ndef MSSMACCs.accQuad  : HomogeneousQuadratic (ACCSystemCharges.Charges MSSMCharges)"}
{"name":"MSSMACC.AnomalyFreeMk''_val","declaration":"theorem MSSMACC.AnomalyFreeMk''_val (S : ACCSystemQuad.QuadSols MSSMACC.toACCSystemQuad) (hcube : MSSMACCs.accCube S.val = 0) : (MSSMACC.AnomalyFreeMk'' S hcube).val = S.val"}
{"name":"MSSMCharges.charges_eq_toSpecies_eq","declaration":"theorem MSSMCharges.charges_eq_toSpecies_eq (S : ACCSystemCharges.Charges MSSMCharges) (T : ACCSystemCharges.Charges MSSMCharges) : S = T ↔\n  (∀ (i : Fin 6), (MSSMCharges.toSMSpecies i) S = (MSSMCharges.toSMSpecies i) T) ∧\n    MSSMCharges.Hd S = MSSMCharges.Hd T ∧ MSSMCharges.Hu S = MSSMCharges.Hu T"}
{"name":"MSSMACCs.accGrav","declaration":"/-- The gravitational anomaly equation. -/\ndef MSSMACCs.accGrav  : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ℚ"}
{"name":"MSSMACCs.cubeTriLin","declaration":"/-- The symmetric trilinear form used to define the cubic ACC. -/\ndef MSSMACCs.cubeTriLin  : TriLinearSymm (ACCSystemCharges.Charges MSSMCharges)"}
{"name":"MSSMACCs.accSU3_ext","declaration":"/-- Extensionality lemma for `accSU3`. -/\ntheorem MSSMACCs.accSU3_ext {S : ACCSystemCharges.Charges MSSMCharges} {T : ACCSystemCharges.Charges MSSMCharges} (hj : ∀ (j : Fin 6),\n  (Finset.sum Finset.univ fun i => (MSSMCharges.toSMSpecies j) S i) =\n    Finset.sum Finset.univ fun i => (MSSMCharges.toSMSpecies j) T i) : MSSMACCs.accSU3 S = MSSMACCs.accSU3 T"}
{"name":"MSSMACCs.cubeTriLin_toFun_apply_apply","declaration":"theorem MSSMACCs.cubeTriLin_toFun_apply_apply (S : ACCSystemCharges.Charges MSSMCharges) (S : ACCSystemCharges.Charges MSSMCharges) (T : ACCSystemCharges.Charges MSSMCharges) : ((MSSMACCs.cubeTriLin S✝) S) T =\n  (Finset.sum Finset.univ fun i =>\n      6 *\n                  (S✝ (Fin.castAdd 2 (finProdFinEquiv (0, i))) * S (Fin.castAdd 2 (finProdFinEquiv (0, i))) *\n                    T (Fin.castAdd 2 (finProdFinEquiv (0, i)))) +\n                3 *\n                  (S✝ (Fin.castAdd 2 (finProdFinEquiv (1, i))) * S (Fin.castAdd 2 (finProdFinEquiv (1, i))) *\n                    T (Fin.castAdd 2 (finProdFinEquiv (1, i)))) +\n              3 *\n                (S✝ (Fin.castAdd 2 (finProdFinEquiv (2, i))) * S (Fin.castAdd 2 (finProdFinEquiv (2, i))) *\n                  T (Fin.castAdd 2 (finProdFinEquiv (2, i)))) +\n            2 *\n              (S✝ (Fin.castAdd 2 (finProdFinEquiv (3, i))) * S (Fin.castAdd 2 (finProdFinEquiv (3, i))) *\n                T (Fin.castAdd 2 (finProdFinEquiv (3, i)))) +\n          S✝ (Fin.castAdd 2 (finProdFinEquiv (4, i))) * S (Fin.castAdd 2 (finProdFinEquiv (4, i))) *\n            T (Fin.castAdd 2 (finProdFinEquiv (4, i))) +\n        S✝ (Fin.castAdd 2 (finProdFinEquiv (5, i))) * S (Fin.castAdd 2 (finProdFinEquiv (5, i))) *\n          T (Fin.castAdd 2 (finProdFinEquiv (5, i)))) +\n    (2 * S✝ { val := 18, isLt := MSSMCharges.Hd.proof_1 } * S { val := 18, isLt := MSSMCharges.Hd.proof_1 } *\n        T { val := 18, isLt := MSSMCharges.Hd.proof_1 } +\n      2 * S✝ { val := 19, isLt := MSSMCharges.Hu.proof_1 } * S { val := 19, isLt := MSSMCharges.Hu.proof_1 } *\n        T { val := 19, isLt := MSSMCharges.Hu.proof_1 })"}
{"name":"MSSMACCs.cubeTriLinToFun_map_add₁","declaration":"theorem MSSMACCs.cubeTriLinToFun_map_add₁ (S : ACCSystemCharges.Charges MSSMCharges) (T : ACCSystemCharges.Charges MSSMCharges) (R : ACCSystemCharges.Charges MSSMCharges) (L : ACCSystemCharges.Charges MSSMCharges) : MSSMACCs.cubeTriLinToFun (S + T, R, L) = MSSMACCs.cubeTriLinToFun (S, R, L) + MSSMACCs.cubeTriLinToFun (T, R, L)"}
{"name":"MSSMCharges.toSMSpecies","declaration":"/-- For a given `i ∈ Fin 6` the projection of `MSSMCharges.charges` down to the\ncorresponding SM species of charges. -/\ndef MSSMCharges.toSMSpecies (i : Fin 6) : ACCSystemCharges.Charges MSSMCharges →ₗ[ℚ] ACCSystemCharges.Charges MSSMSpecies"}
{"name":"MSSMCharges.toSMPlusH_symm_apply","declaration":"theorem MSSMCharges.toSMPlusH_symm_apply  : ∀ (a : Fin 18 ⊕ Fin 2 → ℚ) (a_1 : Fin (18 + 2)), MSSMCharges.toSMPlusH.symm a a_1 = a (finSumFinEquiv.symm a_1)"}
