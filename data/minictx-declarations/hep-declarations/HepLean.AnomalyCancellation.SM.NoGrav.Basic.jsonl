{"name":"SM.SMNoGrav_linearACCs","declaration":"theorem SM.SMNoGrav_linearACCs (n : ℕ) (i : Fin 2) : (SM.SMNoGrav n).linearACCs i =\n  match i with\n  | 0 =>\n    {\n      toAddHom :=\n        { toFun := fun S => Finset.sum Finset.univ fun i => 3 * S (finProdFinEquiv (0, i)) + S (finProdFinEquiv (3, i)),\n          map_add' := ⋯ },\n      map_smul' := ⋯ }\n  | 1 =>\n    {\n      toAddHom :=\n        {\n          toFun := fun S =>\n            Finset.sum Finset.univ fun i =>\n              2 * S (finProdFinEquiv (0, i)) + S (finProdFinEquiv (1, i)) + S (finProdFinEquiv (2, i)),\n          map_add' := ⋯ },\n      map_smul' := ⋯ }"}
{"name":"SM.SMNoGrav_numberQuadratic","declaration":"theorem SM.SMNoGrav_numberQuadratic (n : ℕ) : (SM.SMNoGrav n).numberQuadratic = 0"}
{"name":"SM.SMNoGrav.SU3Sol","declaration":"theorem SM.SMNoGrav.SU3Sol {n : ℕ} (S : ACCSystemLinear.LinSols (SM.SMNoGrav n).toACCSystemLinear) : SMACCs.accSU3 S.val = 0"}
{"name":"SM.SMNoGrav.linearToAF","declaration":"/-- An element of `AnomalyFreeLinear` which satisfies the quadratic and cubic ACCs\ngives us a element of `AnomalyFree`. -/\ndef SM.SMNoGrav.linearToAF {n : ℕ} (S : ACCSystemLinear.LinSols (SM.SMNoGrav n).toACCSystemLinear) (hc : SMACCs.accCube S.val = 0) : ACCSystem.Sols (SM.SMNoGrav n)"}
{"name":"SM.SMNoGrav_quadraticACCs","declaration":"theorem SM.SMNoGrav_quadraticACCs (n : ℕ) (i : Fin 0) : (SM.SMNoGrav n).quadraticACCs i = Fin.elim0 i"}
{"name":"SM.SMNoGrav.chargeToLinear","declaration":"/-- An element of `charges` which satisfies the linear ACCs\ngives us a element of `AnomalyFreeLinear`. -/\ndef SM.SMNoGrav.chargeToLinear {n : ℕ} (S : ACCSystemCharges.Charges (SM.SMNoGrav n).toACCSystemCharges) (hSU2 : SMACCs.accSU2 S = 0) (hSU3 : SMACCs.accSU3 S = 0) : ACCSystemLinear.LinSols (SM.SMNoGrav n).toACCSystemLinear"}
{"name":"SM.SMNoGrav_numberLinear","declaration":"theorem SM.SMNoGrav_numberLinear (n : ℕ) : (SM.SMNoGrav n).numberLinear = 2"}
{"name":"SM.SMNoGrav.linearToQuad","declaration":"/-- An element of `AnomalyFreeLinear` which satisfies the quadratic ACCs\ngives us a element of `AnomalyFreeQuad`. -/\ndef SM.SMNoGrav.linearToQuad {n : ℕ} (S : ACCSystemLinear.LinSols (SM.SMNoGrav n).toACCSystemLinear) : ACCSystemQuad.QuadSols (SM.SMNoGrav n).toACCSystemQuad"}
{"name":"SM.SMNoGrav.chargeToQuad","declaration":"/-- An element of `charges` which satisfies the linear and quadratic ACCs\ngives us a element of `AnomalyFreeQuad`. -/\ndef SM.SMNoGrav.chargeToQuad {n : ℕ} (S : ACCSystemCharges.Charges (SM.SMNoGrav n).toACCSystemCharges) (hSU2 : SMACCs.accSU2 S = 0) (hSU3 : SMACCs.accSU3 S = 0) : ACCSystemQuad.QuadSols (SM.SMNoGrav n).toACCSystemQuad"}
{"name":"SM.SMNoGrav.SU2Sol","declaration":"theorem SM.SMNoGrav.SU2Sol {n : ℕ} (S : ACCSystemLinear.LinSols (SM.SMNoGrav n).toACCSystemLinear) : SMACCs.accSU2 S.val = 0"}
{"name":"SM.SMNoGrav.chargeToAF","declaration":"/-- An element of `charges` which satisfies the linear, quadratic and cubic ACCs\ngives us a element of `AnomalyFree`. -/\ndef SM.SMNoGrav.chargeToAF {n : ℕ} (S : ACCSystemCharges.Charges (SM.SMNoGrav n).toACCSystemCharges) (hSU2 : SMACCs.accSU2 S = 0) (hSU3 : SMACCs.accSU3 S = 0) (hc : SMACCs.accCube S = 0) : ACCSystem.Sols (SM.SMNoGrav n)"}
{"name":"SM.SMNoGrav_numberCharges","declaration":"theorem SM.SMNoGrav_numberCharges (n : ℕ) : (SM.SMNoGrav n).numberCharges = 5 * n"}
{"name":"SM.SMNoGrav.quadToAF","declaration":"/-- An element of `AnomalyFreeQuad` which satisfies the quadratic ACCs\ngives us a element of `AnomalyFree`. -/\ndef SM.SMNoGrav.quadToAF {n : ℕ} (S : ACCSystemQuad.QuadSols (SM.SMNoGrav n).toACCSystemQuad) (hc : SMACCs.accCube S.val = 0) : ACCSystem.Sols (SM.SMNoGrav n)"}
{"name":"SM.SMNoGrav","declaration":"/-- The ACC system for the standard model without RHN and without the gravitational ACC. -/\ndef SM.SMNoGrav (n : ℕ) : ACCSystem"}
{"name":"SM.SMNoGrav.cubeSol","declaration":"theorem SM.SMNoGrav.cubeSol {n : ℕ} (S : ACCSystem.Sols (SM.SMNoGrav n)) : SMACCs.accCube S.val = 0"}
{"name":"SM.SMNoGrav_cubicACC_toFun","declaration":"theorem SM.SMNoGrav_cubicACC_toFun (n : ℕ) (S : ACCSystemCharges.Charges (SMCharges n)) : (SM.SMNoGrav n).cubicACC.toFun S =\n  Finset.sum Finset.univ fun i =>\n    6 * (S (finProdFinEquiv (0, i)) * S (finProdFinEquiv (0, i)) * S (finProdFinEquiv (0, i))) +\n            3 * (S (finProdFinEquiv (1, i)) * S (finProdFinEquiv (1, i)) * S (finProdFinEquiv (1, i))) +\n          3 * (S (finProdFinEquiv (2, i)) * S (finProdFinEquiv (2, i)) * S (finProdFinEquiv (2, i))) +\n        2 * (S (finProdFinEquiv (3, i)) * S (finProdFinEquiv (3, i)) * S (finProdFinEquiv (3, i))) +\n      S (finProdFinEquiv (4, i)) * S (finProdFinEquiv (4, i)) * S (finProdFinEquiv (4, i))"}
