{"name":"IndexNotation.ColorIndexList.contrEquiv_inl_inl_isSome","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_inl_inl_isSome {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (i : { x // x ∈ IndexNotation.IndexList.withUniqueDualLT l.toIndexList }) : Option.isSome\n    (IndexNotation.IndexList.getDual? l.toIndexList\n      ((IndexNotation.ColorIndexList.contrEquiv l) (Sum.inl (Sum.inl i)))) =\n  true"}
{"name":"IndexNotation.ColorIndexList.contr_contr","declaration":"theorem IndexNotation.ColorIndexList.contr_contr {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) : IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l) = IndexNotation.ColorIndexList.contr l"}
{"name":"IndexNotation.ColorIndexList.contr_countId_eq_zero_of_countId_zero","declaration":"theorem IndexNotation.ColorIndexList.contr_countId_eq_zero_of_countId_zero {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (I : IndexNotation.Index 𝓒.Color) (h : IndexNotation.IndexList.countId l.toIndexList I = 0) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I = 0"}
{"name":"IndexNotation.ColorIndexList.contr_contr_colorMap","declaration":"theorem IndexNotation.ColorIndexList.contr_contr_colorMap {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (i : Fin\n  (IndexNotation.IndexList.length\n    (IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l)).toIndexList)) : IndexNotation.IndexList.colorMap (IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l)).toIndexList\n    i =\n  IndexNotation.IndexList.colorMap (IndexNotation.ColorIndexList.contr l).toIndexList (Fin.cast ⋯ i)"}
{"name":"IndexNotation.ColorIndexList.contr_of_withDual_empty","declaration":"theorem IndexNotation.ColorIndexList.contr_of_withDual_empty {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (h : IndexNotation.IndexList.withDual l.toIndexList = ∅) : IndexNotation.ColorIndexList.contr l = l"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_inl_inr_eq","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_inl_inr_eq {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (i : { x // x ∈ IndexNotation.IndexList.withUniqueDualLT l.toIndexList }) : (IndexNotation.ColorIndexList.contrEquiv l) (Sum.inl (Sum.inr i)) =\n  Option.get (IndexNotation.IndexList.getDual? l.toIndexList ↑i) ⋯"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_inl_inl_eq","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_inl_inl_eq {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (i : { x // x ∈ IndexNotation.IndexList.withUniqueDualLT l.toIndexList }) : (IndexNotation.ColorIndexList.contrEquiv l) (Sum.inl (Sum.inl i)) = ↑i"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_contrCond","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_contrCond {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) : TensorColor.ColorMap.ContrCond (IndexNotation.ColorIndexList.contrEquiv l)\n  (IndexNotation.IndexList.colorMap l.toIndexList)"}
{"name":"IndexNotation.ColorIndexList.countId_contr_eq_zero_iff","declaration":"theorem IndexNotation.ColorIndexList.countId_contr_eq_zero_iff {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) [DecidableEq 𝓒.Color] (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I = 0 ↔\n  IndexNotation.IndexList.countId l.toIndexList I = 0 ∨ IndexNotation.IndexList.countId l.toIndexList I = 2"}
{"name":"IndexNotation.ColorIndexList.contr_getDual?_eq_none","declaration":"theorem IndexNotation.ColorIndexList.contr_getDual?_eq_none {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) : IndexNotation.IndexList.getDual? (IndexNotation.ColorIndexList.contr l).toIndexList i = none"}
{"name":"IndexNotation.ColorIndexList.contr_areDualInSelf","declaration":"theorem IndexNotation.ColorIndexList.contr_areDualInSelf {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) (j : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) : IndexNotation.IndexList.AreDualInSelf (IndexNotation.ColorIndexList.contr l).toIndexList i j ↔ False"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_colorMapIso","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_colorMapIso {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) : TensorColor.ColorMap.MapIso\n  (Equiv.refl (Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)))\n  (TensorColor.ColorMap.contr (IndexNotation.ColorIndexList.contrEquiv l)\n    (IndexNotation.IndexList.colorMap l.toIndexList))\n  (IndexNotation.IndexList.colorMap (IndexNotation.ColorIndexList.contr l).toIndexList)"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_on_withDual_empty","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_on_withDual_empty {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) (h : IndexNotation.IndexList.withDual l.toIndexList = ∅) : (IndexNotation.ColorIndexList.contrEquiv l) (Sum.inr i) = Fin.cast ⋯ i"}
{"name":"IndexNotation.ColorIndexList.contr_contr_idMap","declaration":"theorem IndexNotation.ColorIndexList.contr_contr_idMap {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (i : Fin\n  (IndexNotation.IndexList.length\n    (IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l)).toIndexList)) : IndexNotation.IndexList.idMap (IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l)).toIndexList\n    i =\n  IndexNotation.IndexList.idMap (IndexNotation.ColorIndexList.contr l).toIndexList (Fin.cast ⋯ i)"}
{"name":"IndexNotation.ColorIndexList.contrEquiv","declaration":"/-- An equivalence splitting the indices of `l` into\na sum type of those indices and their duals (with choice determined by the ordering on `Fin`),\nand those indices without duals.\n\nThis equivalence is used to contract the indices of tensors. -/\ndef IndexNotation.ColorIndexList.contrEquiv {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) : ({ x // x ∈ IndexNotation.IndexList.withUniqueDualLT l.toIndexList } ⊕\n      { x // x ∈ IndexNotation.IndexList.withUniqueDualLT l.toIndexList }) ⊕\n    Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList) ≃\n  Fin (IndexNotation.IndexList.length l.toIndexList)"}
{"name":"IndexNotation.ColorIndexList.countId_contr_le_one","declaration":"theorem IndexNotation.ColorIndexList.countId_contr_le_one {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I ≤ 1"}
{"name":"IndexNotation.ColorIndexList.contr","declaration":"/-- The contraction of a `ColorIndexList`, `l`.\nThat is, the `ColorIndexList` obtained by taking only those indices in `l` which do not\nhave a dual. This can be thought of as contracting all of those indices with a dual. -/\ndef IndexNotation.ColorIndexList.contr {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) : IndexNotation.ColorIndexList 𝓒"}
{"name":"IndexNotation.ColorIndexList.contr_countId_eq_filter","declaration":"theorem IndexNotation.ColorIndexList.contr_countId_eq_filter {𝓒 : TensorColor} [IndexNotation 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (I : IndexNotation.Index 𝓒.Color) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I =\n  List.countP\n    (fun i => decide (List.countP (fun j => decide (IndexNotation.Index.id i = IndexNotation.Index.id j)) l.val = 1))\n    (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
