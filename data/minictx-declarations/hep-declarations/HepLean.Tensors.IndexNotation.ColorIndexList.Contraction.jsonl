{"name":"IndexNotation.ColorIndexList.contrEquiv_inl_inl_isSome","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_inl_inl_isSome {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (i : { x // x âˆˆ IndexNotation.IndexList.withUniqueDualLT l.toIndexList }) : Option.isSome\n    (IndexNotation.IndexList.getDual? l.toIndexList\n      ((IndexNotation.ColorIndexList.contrEquiv l) (Sum.inl (Sum.inl i)))) =\n  true"}
{"name":"IndexNotation.ColorIndexList.contr_contr","declaration":"theorem IndexNotation.ColorIndexList.contr_contr {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) : IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l) = IndexNotation.ColorIndexList.contr l"}
{"name":"IndexNotation.ColorIndexList.contr_countId_eq_zero_of_countId_zero","declaration":"theorem IndexNotation.ColorIndexList.contr_countId_eq_zero_of_countId_zero {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (I : IndexNotation.Index ð“’.Color) (h : IndexNotation.IndexList.countId l.toIndexList I = 0) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I = 0"}
{"name":"IndexNotation.ColorIndexList.contr_contr_colorMap","declaration":"theorem IndexNotation.ColorIndexList.contr_contr_colorMap {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (i : Fin\n  (IndexNotation.IndexList.length\n    (IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l)).toIndexList)) : IndexNotation.IndexList.colorMap (IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l)).toIndexList\n    i =\n  IndexNotation.IndexList.colorMap (IndexNotation.ColorIndexList.contr l).toIndexList (Fin.cast â‹¯ i)"}
{"name":"IndexNotation.ColorIndexList.contr_of_withDual_empty","declaration":"theorem IndexNotation.ColorIndexList.contr_of_withDual_empty {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (h : IndexNotation.IndexList.withDual l.toIndexList = âˆ…) : IndexNotation.ColorIndexList.contr l = l"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_inl_inr_eq","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_inl_inr_eq {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (i : { x // x âˆˆ IndexNotation.IndexList.withUniqueDualLT l.toIndexList }) : (IndexNotation.ColorIndexList.contrEquiv l) (Sum.inl (Sum.inr i)) =\n  Option.get (IndexNotation.IndexList.getDual? l.toIndexList â†‘i) â‹¯"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_inl_inl_eq","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_inl_inl_eq {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (i : { x // x âˆˆ IndexNotation.IndexList.withUniqueDualLT l.toIndexList }) : (IndexNotation.ColorIndexList.contrEquiv l) (Sum.inl (Sum.inl i)) = â†‘i"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_contrCond","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_contrCond {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) : TensorColor.ColorMap.ContrCond (IndexNotation.ColorIndexList.contrEquiv l)\n  (IndexNotation.IndexList.colorMap l.toIndexList)"}
{"name":"IndexNotation.ColorIndexList.countId_contr_eq_zero_iff","declaration":"theorem IndexNotation.ColorIndexList.countId_contr_eq_zero_iff {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) [DecidableEq ð“’.Color] (I : IndexNotation.Index ð“’.Color) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I = 0 â†”\n  IndexNotation.IndexList.countId l.toIndexList I = 0 âˆ¨ IndexNotation.IndexList.countId l.toIndexList I = 2"}
{"name":"IndexNotation.ColorIndexList.contr_getDual?_eq_none","declaration":"theorem IndexNotation.ColorIndexList.contr_getDual?_eq_none {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) : IndexNotation.IndexList.getDual? (IndexNotation.ColorIndexList.contr l).toIndexList i = none"}
{"name":"IndexNotation.ColorIndexList.contr_areDualInSelf","declaration":"theorem IndexNotation.ColorIndexList.contr_areDualInSelf {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) (j : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) : IndexNotation.IndexList.AreDualInSelf (IndexNotation.ColorIndexList.contr l).toIndexList i j â†” False"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_colorMapIso","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_colorMapIso {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) : TensorColor.ColorMap.MapIso\n  (Equiv.refl (Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)))\n  (TensorColor.ColorMap.contr (IndexNotation.ColorIndexList.contrEquiv l)\n    (IndexNotation.IndexList.colorMap l.toIndexList))\n  (IndexNotation.IndexList.colorMap (IndexNotation.ColorIndexList.contr l).toIndexList)"}
{"name":"IndexNotation.ColorIndexList.contrEquiv_on_withDual_empty","declaration":"theorem IndexNotation.ColorIndexList.contrEquiv_on_withDual_empty {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) (h : IndexNotation.IndexList.withDual l.toIndexList = âˆ…) : (IndexNotation.ColorIndexList.contrEquiv l) (Sum.inr i) = Fin.cast â‹¯ i"}
{"name":"IndexNotation.ColorIndexList.contr_contr_idMap","declaration":"theorem IndexNotation.ColorIndexList.contr_contr_idMap {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (i : Fin\n  (IndexNotation.IndexList.length\n    (IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l)).toIndexList)) : IndexNotation.IndexList.idMap (IndexNotation.ColorIndexList.contr (IndexNotation.ColorIndexList.contr l)).toIndexList\n    i =\n  IndexNotation.IndexList.idMap (IndexNotation.ColorIndexList.contr l).toIndexList (Fin.cast â‹¯ i)"}
{"name":"IndexNotation.ColorIndexList.contrEquiv","declaration":"/-- An equivalence splitting the indices of `l` into\na sum type of those indices and their duals (with choice determined by the ordering on `Fin`),\nand those indices without duals.\n\nThis equivalence is used to contract the indices of tensors. -/\ndef IndexNotation.ColorIndexList.contrEquiv {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) : ({ x // x âˆˆ IndexNotation.IndexList.withUniqueDualLT l.toIndexList } âŠ•\n      { x // x âˆˆ IndexNotation.IndexList.withUniqueDualLT l.toIndexList }) âŠ•\n    Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList) â‰ƒ\n  Fin (IndexNotation.IndexList.length l.toIndexList)"}
{"name":"IndexNotation.ColorIndexList.countId_contr_le_one","declaration":"theorem IndexNotation.ColorIndexList.countId_contr_le_one {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (I : IndexNotation.Index ð“’.Color) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I â‰¤ 1"}
{"name":"IndexNotation.ColorIndexList.contr","declaration":"/-- The contraction of a `ColorIndexList`, `l`.\nThat is, the `ColorIndexList` obtained by taking only those indices in `l` which do not\nhave a dual. This can be thought of as contracting all of those indices with a dual. -/\ndef IndexNotation.ColorIndexList.contr {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) : IndexNotation.ColorIndexList ð“’"}
{"name":"IndexNotation.ColorIndexList.contr_countId_eq_filter","declaration":"theorem IndexNotation.ColorIndexList.contr_countId_eq_filter {ð“’ : TensorColor} [IndexNotation ð“’.Color] (l : IndexNotation.ColorIndexList ð“’) (I : IndexNotation.Index ð“’.Color) : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l).toIndexList I =\n  List.countP\n    (fun i => decide (List.countP (fun j => decide (IndexNotation.Index.id i = IndexNotation.Index.id j)) l.val = 1))\n    (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
