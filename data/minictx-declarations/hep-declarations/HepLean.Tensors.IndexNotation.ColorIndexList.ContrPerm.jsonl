{"name":"IndexNotation.ColorIndexList.ContrPerm.symm","declaration":"/-- The relation `ContrPerm` is symmetric. -/\ntheorem IndexNotation.ColorIndexList.ContrPerm.symm {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') : IndexNotation.ColorIndexList.ContrPerm l' l"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.contr_perm","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.contr_perm {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l2) : List.Perm (IndexNotation.ColorIndexList.contr l).val (IndexNotation.ColorIndexList.contr l2).val"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.trans","declaration":"/-- The relation `ContrPerm` is transitive. -/\ntheorem IndexNotation.ColorIndexList.ContrPerm.trans {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} {l3 : IndexNotation.ColorIndexList 𝓒} (h1 : IndexNotation.ColorIndexList.ContrPerm l l2) (h2 : IndexNotation.ColorIndexList.ContrPerm l2 l3) : IndexNotation.ColorIndexList.ContrPerm l l3"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.colorMap_eq_of_countSelf","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.colorMap_eq_of_countSelf {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} (hn : IndexNotation.IndexList.Subperm (IndexNotation.ColorIndexList.contr l).toIndexList\n  (IndexNotation.ColorIndexList.contr l2).toIndexList) (h2 : ∀ (i : Fin (List.length (IndexNotation.ColorIndexList.contr l).val)),\n  IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList\n        (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n      1 →\n    IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList\n        (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n      1) : IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l2) ∘\n    Subtype.val ∘\n      ⇑(IndexNotation.IndexList.getDualInOtherEquiv (IndexNotation.ColorIndexList.contr l).toIndexList\n          (IndexNotation.ColorIndexList.contr l2).toIndexList) =\n  IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l) ∘ Subtype.val"}
{"name":"IndexNotation.ColorIndexList.ContrPerm","declaration":"/-- Two `ColorIndexList`s are said to be related by contracted permutations, `ContrPerm`,\nif and only if:\n\n  1) Their contractions are the same length.\n  2) Every index in the contracted list of one has a unqiue dual in the contracted\n    list of the other and that dual has a the same color.\n-/\ndef IndexNotation.ColorIndexList.ContrPerm {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) (l' : IndexNotation.ColorIndexList 𝓒) : Prop"}
{"name":"IndexNotation.ColorIndexList.permEquiv_colorMap_iso","declaration":"theorem IndexNotation.ColorIndexList.permEquiv_colorMap_iso {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') (h1 : IndexNotation.IndexList.withDual l.toIndexList = ∅) (h2 : IndexNotation.IndexList.withDual l'.toIndexList = ∅) : TensorColor.ColorMap.MapIso (IndexNotation.ColorIndexList.permEquiv h h1 h2).symm\n  (IndexNotation.ColorIndexList.colorMap' l') (IndexNotation.ColorIndexList.colorMap' l)"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.self_contr","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.self_contr {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} : IndexNotation.ColorIndexList.ContrPerm (IndexNotation.ColorIndexList.contr l) l"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.equivalence","declaration":"/-- `ContrPerm` forms an equivalence relation. -/\ntheorem IndexNotation.ColorIndexList.ContrPerm.equivalence {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] : Equivalence IndexNotation.ColorIndexList.ContrPerm"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.iff_countSelf","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.iff_countSelf {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} : IndexNotation.ColorIndexList.ContrPerm l l2 ↔\n  ∀ (I : IndexNotation.Index 𝓒.Color),\n    IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList I =\n      IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList I"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.getDualInOtherEquiv_eq","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.getDualInOtherEquiv_eq {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l2) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) : List.get (IndexNotation.ColorIndexList.contr l2).val\n    ↑((IndexNotation.IndexList.getDualInOtherEquiv (IndexNotation.ColorIndexList.contr l).toIndexList\n          (IndexNotation.ColorIndexList.contr l2).toIndexList)\n        { val := i, property := ⋯ }) =\n  List.get (IndexNotation.ColorIndexList.contr l).val i"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.iff_count'","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.iff_count' {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} : IndexNotation.ColorIndexList.ContrPerm l l2 ↔\n  IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList =\n      IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l2).toIndexList ∧\n    IndexNotation.IndexList.Subperm (IndexNotation.ColorIndexList.contr l).toIndexList\n        (IndexNotation.ColorIndexList.contr l2).toIndexList ∧\n      ∀ (I : IndexNotation.Index 𝓒.Color),\n        IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList I = 1 →\n          IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList I = 1"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.symm_trans","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.symm_trans {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} {l3 : IndexNotation.ColorIndexList 𝓒} (h1 : IndexNotation.ColorIndexList.ContrPerm l l2) (h2 : IndexNotation.ColorIndexList.ContrPerm l2 l3) : ⋯ = ⋯"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.iff_count","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.iff_count {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} : IndexNotation.ColorIndexList.ContrPerm l l2 ↔\n  IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList =\n      IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l2).toIndexList ∧\n    ∀ (I : IndexNotation.Index 𝓒.Color),\n      IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList I = 1 →\n        IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList I = 1"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_symm","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_symm {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') : (IndexNotation.ColorIndexList.contrPermEquiv h).symm = IndexNotation.ColorIndexList.contrPermEquiv ⋯"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_colorMap_iso","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_colorMap_iso {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') : TensorColor.ColorMap.MapIso (IndexNotation.ColorIndexList.contrPermEquiv h).symm\n  (IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l'))\n  (IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l))"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.mem_withUniqueDualInOther_of_no_contr","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.mem_withUniqueDualInOther_of_no_contr {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') (h1 : IndexNotation.IndexList.withDual l.toIndexList = ∅) (h2 : IndexNotation.IndexList.withDual l'.toIndexList = ∅) (x : Fin (IndexNotation.IndexList.length l.toIndexList)) : x ∈ IndexNotation.IndexList.withUniqueDualInOther l.toIndexList l'.toIndexList"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_contr_self","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_contr_self {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} : IndexNotation.ColorIndexList.contrPermEquiv ⋯ = (Fin.castIso ⋯).toEquiv"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.mem_snd_of_mem_snd","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.mem_snd_of_mem_snd {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l2) {I : IndexNotation.Index 𝓒.Color} (hI : I ∈ (IndexNotation.ColorIndexList.contr l).val) : I ∈ (IndexNotation.ColorIndexList.contr l2).val"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_refl","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_refl {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) : IndexNotation.ColorIndexList.contrPermEquiv ⋯ =\n  Equiv.refl (Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList))"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.contr_self","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.contr_self {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} : IndexNotation.ColorIndexList.ContrPerm l (IndexNotation.ColorIndexList.contr l)"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.iff_count_fin","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.iff_count_fin {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} : IndexNotation.ColorIndexList.ContrPerm l l2 ↔\n  IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList =\n      IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l2).toIndexList ∧\n    IndexNotation.IndexList.Subperm (IndexNotation.ColorIndexList.contr l).toIndexList\n        (IndexNotation.ColorIndexList.contr l2).toIndexList ∧\n      ∀ (i : Fin (List.length (IndexNotation.ColorIndexList.contr l).val)),\n        IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList\n              (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n            1 →\n          IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList\n              (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n            1"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_colorMap_iso'","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_colorMap_iso' {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') : TensorColor.ColorMap.MapIso (IndexNotation.ColorIndexList.contrPermEquiv h)\n  (IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l))\n  (IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l'))"}
{"name":"IndexNotation.ColorIndexList.permEquiv","declaration":"/-- Given two `ColorIndexList` related by permutations and without duals, the equivalence between\nthe indices of the corresponding index lists. This equivalence is the\npermutation between the indices. -/\ndef IndexNotation.ColorIndexList.permEquiv {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') (h1 : IndexNotation.IndexList.withDual l.toIndexList = ∅) (h2 : IndexNotation.IndexList.withDual l'.toIndexList = ∅) : Fin (IndexNotation.IndexList.length l.toIndexList) ≃ Fin (IndexNotation.IndexList.length l'.toIndexList)"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_self_contr","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_self_contr {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} : IndexNotation.ColorIndexList.contrPermEquiv ⋯ = (Fin.castIso ⋯).toEquiv"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.countSelf_eq_one_snd_of_countSelf_eq_one_fst","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.countSelf_eq_one_snd_of_countSelf_eq_one_fst {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l2) {I : IndexNotation.Index 𝓒.Color} (h1 : IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList I = 1) : IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList I = 1"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_trans","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_trans {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} {l3 : IndexNotation.ColorIndexList 𝓒} (h1 : IndexNotation.ColorIndexList.ContrPerm l l2) (h2 : IndexNotation.ColorIndexList.ContrPerm l2 l3) : (IndexNotation.ColorIndexList.contrPermEquiv h1).trans (IndexNotation.ColorIndexList.contrPermEquiv h2) =\n  IndexNotation.ColorIndexList.contrPermEquiv ⋯"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.length_of_no_contr","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.length_of_no_contr {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') (h1 : IndexNotation.IndexList.withDual l.toIndexList = ∅) (h2 : IndexNotation.IndexList.withDual l'.toIndexList = ∅) : IndexNotation.IndexList.length l.toIndexList = IndexNotation.IndexList.length l'.toIndexList"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv","declaration":"/-- Given two `ColorIndexList` related by contracted permutations, the equivalence between\nthe indices of the corresponding contracted index lists. This equivalence is the\npermutation between the contracted indices. -/\ndef IndexNotation.ColorIndexList.contrPermEquiv {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l' : IndexNotation.ColorIndexList 𝓒} (h : IndexNotation.ColorIndexList.ContrPerm l l') : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList) ≃\n  Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l').toIndexList)"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.getDualInOtherEquiv_eq_of_countSelf","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.getDualInOtherEquiv_eq_of_countSelf {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] {l : IndexNotation.ColorIndexList 𝓒} {l2 : IndexNotation.ColorIndexList 𝓒} (hn : IndexNotation.IndexList.Subperm (IndexNotation.ColorIndexList.contr l).toIndexList\n  (IndexNotation.ColorIndexList.contr l2).toIndexList) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) (h1 : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l2).toIndexList\n    (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n  1) (h2 : IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList\n    (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n  1) : List.get (IndexNotation.ColorIndexList.contr l2).val\n    ↑((IndexNotation.IndexList.getDualInOtherEquiv (IndexNotation.ColorIndexList.contr l).toIndexList\n          (IndexNotation.ColorIndexList.contr l2).toIndexList)\n        { val := i, property := ⋯ }) =\n  List.get (IndexNotation.ColorIndexList.contr l).val i"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.refl","declaration":"/-- The relation `ContrPerm` is reflexive. -/\ntheorem IndexNotation.ColorIndexList.ContrPerm.refl {𝓒 : TensorColor} [IndexNotation 𝓒.Color] [DecidableEq 𝓒.Color] (l : IndexNotation.ColorIndexList 𝓒) : IndexNotation.ColorIndexList.ContrPerm l l"}
