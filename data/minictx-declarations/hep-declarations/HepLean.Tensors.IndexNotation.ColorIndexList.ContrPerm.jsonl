{"name":"IndexNotation.ColorIndexList.ContrPerm.symm","declaration":"/-- The relation `ContrPerm` is symmetric. -/\ntheorem IndexNotation.ColorIndexList.ContrPerm.symm {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') : IndexNotation.ColorIndexList.ContrPerm l' l"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.contr_perm","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.contr_perm {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l2) : List.Perm (IndexNotation.ColorIndexList.contr l).val (IndexNotation.ColorIndexList.contr l2).val"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.trans","declaration":"/-- The relation `ContrPerm` is transitive. -/\ntheorem IndexNotation.ColorIndexList.ContrPerm.trans {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} {l3 : IndexNotation.ColorIndexList ğ“’} (h1 : IndexNotation.ColorIndexList.ContrPerm l l2) (h2 : IndexNotation.ColorIndexList.ContrPerm l2 l3) : IndexNotation.ColorIndexList.ContrPerm l l3"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.colorMap_eq_of_countSelf","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.colorMap_eq_of_countSelf {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (hn : IndexNotation.IndexList.Subperm (IndexNotation.ColorIndexList.contr l).toIndexList\n  (IndexNotation.ColorIndexList.contr l2).toIndexList) (h2 : âˆ€ (i : Fin (List.length (IndexNotation.ColorIndexList.contr l).val)),\n  IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList\n        (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n      1 â†’\n    IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList\n        (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n      1) : IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l2) âˆ˜\n    Subtype.val âˆ˜\n      â‡‘(IndexNotation.IndexList.getDualInOtherEquiv (IndexNotation.ColorIndexList.contr l).toIndexList\n          (IndexNotation.ColorIndexList.contr l2).toIndexList) =\n  IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l) âˆ˜ Subtype.val"}
{"name":"IndexNotation.ColorIndexList.ContrPerm","declaration":"/-- Two `ColorIndexList`s are said to be related by contracted permutations, `ContrPerm`,\nif and only if:\n\n  1) Their contractions are the same length.\n  2) Every index in the contracted list of one has a unqiue dual in the contracted\n    list of the other and that dual has a the same color.\n-/\ndef IndexNotation.ColorIndexList.ContrPerm {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (l' : IndexNotation.ColorIndexList ğ“’) : Prop"}
{"name":"IndexNotation.ColorIndexList.permEquiv_colorMap_iso","declaration":"theorem IndexNotation.ColorIndexList.permEquiv_colorMap_iso {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') (h1 : IndexNotation.IndexList.withDual l.toIndexList = âˆ…) (h2 : IndexNotation.IndexList.withDual l'.toIndexList = âˆ…) : TensorColor.ColorMap.MapIso (IndexNotation.ColorIndexList.permEquiv h h1 h2).symm\n  (IndexNotation.ColorIndexList.colorMap' l') (IndexNotation.ColorIndexList.colorMap' l)"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.self_contr","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.self_contr {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} : IndexNotation.ColorIndexList.ContrPerm (IndexNotation.ColorIndexList.contr l) l"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.equivalence","declaration":"/-- `ContrPerm` forms an equivalence relation. -/\ntheorem IndexNotation.ColorIndexList.ContrPerm.equivalence {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] : Equivalence IndexNotation.ColorIndexList.ContrPerm"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.iff_countSelf","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.iff_countSelf {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} : IndexNotation.ColorIndexList.ContrPerm l l2 â†”\n  âˆ€ (I : IndexNotation.Index ğ“’.Color),\n    IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList I =\n      IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList I"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.getDualInOtherEquiv_eq","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.getDualInOtherEquiv_eq {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l2) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) : List.get (IndexNotation.ColorIndexList.contr l2).val\n    â†‘((IndexNotation.IndexList.getDualInOtherEquiv (IndexNotation.ColorIndexList.contr l).toIndexList\n          (IndexNotation.ColorIndexList.contr l2).toIndexList)\n        { val := i, property := â‹¯ }) =\n  List.get (IndexNotation.ColorIndexList.contr l).val i"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.iff_count'","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.iff_count' {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} : IndexNotation.ColorIndexList.ContrPerm l l2 â†”\n  IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList =\n      IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l2).toIndexList âˆ§\n    IndexNotation.IndexList.Subperm (IndexNotation.ColorIndexList.contr l).toIndexList\n        (IndexNotation.ColorIndexList.contr l2).toIndexList âˆ§\n      âˆ€ (I : IndexNotation.Index ğ“’.Color),\n        IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList I = 1 â†’\n          IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList I = 1"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.symm_trans","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.symm_trans {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} {l3 : IndexNotation.ColorIndexList ğ“’} (h1 : IndexNotation.ColorIndexList.ContrPerm l l2) (h2 : IndexNotation.ColorIndexList.ContrPerm l2 l3) : â‹¯ = â‹¯"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.iff_count","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.iff_count {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} : IndexNotation.ColorIndexList.ContrPerm l l2 â†”\n  IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList =\n      IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l2).toIndexList âˆ§\n    âˆ€ (I : IndexNotation.Index ğ“’.Color),\n      IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList I = 1 â†’\n        IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList I = 1"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_symm","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_symm {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') : (IndexNotation.ColorIndexList.contrPermEquiv h).symm = IndexNotation.ColorIndexList.contrPermEquiv â‹¯"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_colorMap_iso","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_colorMap_iso {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') : TensorColor.ColorMap.MapIso (IndexNotation.ColorIndexList.contrPermEquiv h).symm\n  (IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l'))\n  (IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l))"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.mem_withUniqueDualInOther_of_no_contr","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.mem_withUniqueDualInOther_of_no_contr {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') (h1 : IndexNotation.IndexList.withDual l.toIndexList = âˆ…) (h2 : IndexNotation.IndexList.withDual l'.toIndexList = âˆ…) (x : Fin (IndexNotation.IndexList.length l.toIndexList)) : x âˆˆ IndexNotation.IndexList.withUniqueDualInOther l.toIndexList l'.toIndexList"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_contr_self","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_contr_self {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} : IndexNotation.ColorIndexList.contrPermEquiv â‹¯ = (Fin.castIso â‹¯).toEquiv"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.mem_snd_of_mem_snd","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.mem_snd_of_mem_snd {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l2) {I : IndexNotation.Index ğ“’.Color} (hI : I âˆˆ (IndexNotation.ColorIndexList.contr l).val) : I âˆˆ (IndexNotation.ColorIndexList.contr l2).val"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_refl","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_refl {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) : IndexNotation.ColorIndexList.contrPermEquiv â‹¯ =\n  Equiv.refl (Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList))"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.contr_self","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.contr_self {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} : IndexNotation.ColorIndexList.ContrPerm l (IndexNotation.ColorIndexList.contr l)"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.iff_count_fin","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.iff_count_fin {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} : IndexNotation.ColorIndexList.ContrPerm l l2 â†”\n  IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList =\n      IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l2).toIndexList âˆ§\n    IndexNotation.IndexList.Subperm (IndexNotation.ColorIndexList.contr l).toIndexList\n        (IndexNotation.ColorIndexList.contr l2).toIndexList âˆ§\n      âˆ€ (i : Fin (List.length (IndexNotation.ColorIndexList.contr l).val)),\n        IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList\n              (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n            1 â†’\n          IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList\n              (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n            1"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_colorMap_iso'","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_colorMap_iso' {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') : TensorColor.ColorMap.MapIso (IndexNotation.ColorIndexList.contrPermEquiv h)\n  (IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l))\n  (IndexNotation.ColorIndexList.colorMap' (IndexNotation.ColorIndexList.contr l'))"}
{"name":"IndexNotation.ColorIndexList.permEquiv","declaration":"/-- Given two `ColorIndexList` related by permutations and without duals, the equivalence between\nthe indices of the corresponding index lists. This equivalence is the\npermutation between the indices. -/\ndef IndexNotation.ColorIndexList.permEquiv {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') (h1 : IndexNotation.IndexList.withDual l.toIndexList = âˆ…) (h2 : IndexNotation.IndexList.withDual l'.toIndexList = âˆ…) : Fin (IndexNotation.IndexList.length l.toIndexList) â‰ƒ Fin (IndexNotation.IndexList.length l'.toIndexList)"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_self_contr","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_self_contr {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} : IndexNotation.ColorIndexList.contrPermEquiv â‹¯ = (Fin.castIso â‹¯).toEquiv"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.countSelf_eq_one_snd_of_countSelf_eq_one_fst","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.countSelf_eq_one_snd_of_countSelf_eq_one_fst {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l2) {I : IndexNotation.Index ğ“’.Color} (h1 : IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l).toIndexList I = 1) : IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList I = 1"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv_trans","declaration":"theorem IndexNotation.ColorIndexList.contrPermEquiv_trans {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} {l3 : IndexNotation.ColorIndexList ğ“’} (h1 : IndexNotation.ColorIndexList.ContrPerm l l2) (h2 : IndexNotation.ColorIndexList.ContrPerm l2 l3) : (IndexNotation.ColorIndexList.contrPermEquiv h1).trans (IndexNotation.ColorIndexList.contrPermEquiv h2) =\n  IndexNotation.ColorIndexList.contrPermEquiv â‹¯"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.length_of_no_contr","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.length_of_no_contr {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') (h1 : IndexNotation.IndexList.withDual l.toIndexList = âˆ…) (h2 : IndexNotation.IndexList.withDual l'.toIndexList = âˆ…) : IndexNotation.IndexList.length l.toIndexList = IndexNotation.IndexList.length l'.toIndexList"}
{"name":"IndexNotation.ColorIndexList.contrPermEquiv","declaration":"/-- Given two `ColorIndexList` related by contracted permutations, the equivalence between\nthe indices of the corresponding contracted index lists. This equivalence is the\npermutation between the contracted indices. -/\ndef IndexNotation.ColorIndexList.contrPermEquiv {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : IndexNotation.ColorIndexList.ContrPerm l l') : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList) â‰ƒ\n  Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l').toIndexList)"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.getDualInOtherEquiv_eq_of_countSelf","declaration":"theorem IndexNotation.ColorIndexList.ContrPerm.getDualInOtherEquiv_eq_of_countSelf {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l2 : IndexNotation.ColorIndexList ğ“’} (hn : IndexNotation.IndexList.Subperm (IndexNotation.ColorIndexList.contr l).toIndexList\n  (IndexNotation.ColorIndexList.contr l2).toIndexList) (i : Fin (IndexNotation.IndexList.length (IndexNotation.ColorIndexList.contr l).toIndexList)) (h1 : IndexNotation.IndexList.countId (IndexNotation.ColorIndexList.contr l2).toIndexList\n    (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n  1) (h2 : IndexNotation.IndexList.countSelf (IndexNotation.ColorIndexList.contr l2).toIndexList\n    (List.get (IndexNotation.ColorIndexList.contr l).val i) =\n  1) : List.get (IndexNotation.ColorIndexList.contr l2).val\n    â†‘((IndexNotation.IndexList.getDualInOtherEquiv (IndexNotation.ColorIndexList.contr l).toIndexList\n          (IndexNotation.ColorIndexList.contr l2).toIndexList)\n        { val := i, property := â‹¯ }) =\n  List.get (IndexNotation.ColorIndexList.contr l).val i"}
{"name":"IndexNotation.ColorIndexList.ContrPerm.refl","declaration":"/-- The relation `ContrPerm` is reflexive. -/\ntheorem IndexNotation.ColorIndexList.ContrPerm.refl {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) : IndexNotation.ColorIndexList.ContrPerm l l"}
