{"name":"PureU1.pairSwap_snd","declaration":"theorem PureU1.pairSwap_snd {n : ℕ} (i : Fin n) (j : Fin n) : (PureU1.pairSwap i j).toFun j = i"}
{"name":"PureU1.permOfInjection","declaration":"/-- A permutation of fermions which takes one ordered subset into another. -/\ndef PureU1.permOfInjection {m : ℕ} {n : ℕ} (f : Fin m ↪ Fin n) (g : Fin m ↪ Fin n) : (PureU1.FamilyPermutations n).group"}
{"name":"PureU1.pairSwap_inv_snd","declaration":"theorem PureU1.pairSwap_inv_snd {n : ℕ} (i : Fin n) (j : Fin n) : (PureU1.pairSwap i j).invFun j = i"}
{"name":"PureU1.FamilyPermutations","declaration":"/-- The permutations acting on the ACC system. -/\ndef PureU1.FamilyPermutations (n : ℕ) : ACCSystemGroupAction (PureU1 n)"}
{"name":"PureU1.permCharges","declaration":"/-- The representation of `permGroup` acting on the vector space of charges. -/\ndef PureU1.permCharges {n : ℕ} : Representation ℚ (PureU1.PermGroup n) (ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges)"}
{"name":"PureU1.permTwoInj_fst_apply","declaration":"theorem PureU1.permTwoInj_fst_apply {n : ℕ} {i : Fin n} {j : Fin n} (hij : i ≠ j) : (Function.Embedding.toEquivRange (PureU1.permTwoInj hij)).symm { val := i, property := ⋯ } = 0"}
{"name":"PureU1.FamilyPermutations_anomalyFreeLinear_apply","declaration":"theorem PureU1.FamilyPermutations_anomalyFreeLinear_apply {n : ℕ} (S : ACCSystemLinear.LinSols (PureU1 n).toACCSystemLinear) (i : Fin n) (f : (PureU1.FamilyPermutations n).group) : (((ACCSystemGroupAction.linSolRep (PureU1.FamilyPermutations n)) f) S).val i = S.val (f.invFun i)"}
{"name":"PureU1.permTwoInj_snd_apply","declaration":"theorem PureU1.permTwoInj_snd_apply {n : ℕ} {i : Fin n} {j : Fin n} (hij : i ≠ j) : (Function.Embedding.toEquivRange (PureU1.permTwoInj hij)).symm { val := j, property := ⋯ } = 1"}
{"name":"PureU1.instGroupPermGroup","declaration":"instance PureU1.instGroupPermGroup {n : ℕ} : Group (PureU1.PermGroup n)"}
{"name":"PureU1.pairSwap_inv_other","declaration":"theorem PureU1.pairSwap_inv_other {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} (hik : i ≠ k) (hjk : j ≠ k) : (PureU1.pairSwap i j).invFun k = k"}
{"name":"PureU1.permTwo_fst","declaration":"theorem PureU1.permTwo_fst {n : ℕ} {i : Fin n} {j : Fin n} {i' : Fin n} {j' : Fin n} (hij : i ≠ j) (hij' : i' ≠ j') : (PureU1.permTwo hij hij').toFun i' = i"}
{"name":"PureU1.permThreeInj_fst","declaration":"theorem PureU1.permThreeInj_fst {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) : i ∈ Set.range ⇑(PureU1.permThreeInj hij hjk hik)"}
{"name":"PureU1.FamilyPermutations_charges_apply","declaration":"theorem PureU1.FamilyPermutations_charges_apply {n : ℕ} (S : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges) (i : Fin n) (f : (PureU1.FamilyPermutations n).group) : ((PureU1.FamilyPermutations n).rep f) S i = S (f.invFun i)"}
{"name":"PureU1.permTwo_snd","declaration":"theorem PureU1.permTwo_snd {n : ℕ} {i : Fin n} {j : Fin n} {i' : Fin n} {j' : Fin n} (hij : i ≠ j) (hij' : i' ≠ j') : (PureU1.permTwo hij hij').toFun j' = j"}
{"name":"PureU1.permThree_snd","declaration":"theorem PureU1.permThree_snd {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} {i' : Fin n} {j' : Fin n} {k' : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) (hij' : i' ≠ j') (hjk' : j' ≠ k') (hik' : i' ≠ k') : (PureU1.permThree hij hjk hik hij' hjk' hik').toFun j' = j"}
{"name":"PureU1.permThree_fst","declaration":"theorem PureU1.permThree_fst {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} {i' : Fin n} {j' : Fin n} {k' : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) (hij' : i' ≠ j') (hjk' : j' ≠ k') (hik' : i' ≠ k') : (PureU1.permThree hij hjk hik hij' hjk' hik').toFun i' = i"}
{"name":"PureU1.permThreeInj_snd_apply","declaration":"theorem PureU1.permThreeInj_snd_apply {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) : (Function.Embedding.toEquivRange (PureU1.permThreeInj hij hjk hik)).symm { val := j, property := ⋯ } = 1"}
{"name":"PureU1.permThree_thd","declaration":"theorem PureU1.permThree_thd {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} {i' : Fin n} {j' : Fin n} {k' : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) (hij' : i' ≠ j') (hjk' : j' ≠ k') (hik' : i' ≠ k') : (PureU1.permThree hij hjk hik hij' hjk' hik').toFun k' = k"}
{"name":"PureU1.pairSwap_self_inv","declaration":"theorem PureU1.pairSwap_self_inv {n : ℕ} (i : Fin n) (j : Fin n) : (PureU1.pairSwap i j)⁻¹ = PureU1.pairSwap i j"}
{"name":"PureU1.Prop_two","declaration":"theorem PureU1.Prop_two {n : ℕ} (P : ℚ × ℚ → Prop) {S : ACCSystemLinear.LinSols (PureU1 n).toACCSystemLinear} {a : Fin n} {b : Fin n} (hab : a ≠ b) (h : ∀ (f : (PureU1.FamilyPermutations n).group),\n  P\n    ((((ACCSystemGroupAction.linSolRep (PureU1.FamilyPermutations n)) f) S).val a,\n      (((ACCSystemGroupAction.linSolRep (PureU1.FamilyPermutations n)) f) S).val b)) (i : Fin n) (j : Fin n) : i ≠ j → P (S.val i, S.val j)"}
{"name":"PureU1.permThreeInj_thd_apply","declaration":"theorem PureU1.permThreeInj_thd_apply {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) : (Function.Embedding.toEquivRange (PureU1.permThreeInj hij hjk hik)).symm { val := k, property := ⋯ } = 2"}
{"name":"PureU1.Prop_three","declaration":"theorem PureU1.Prop_three {n : ℕ} (P : ℚ × ℚ × ℚ → Prop) {S : ACCSystemLinear.LinSols (PureU1 n).toACCSystemLinear} {a : Fin n} {b : Fin n} {c : Fin n} (hab : a ≠ b) (hac : a ≠ c) (hbc : b ≠ c) (h : ∀ (f : (PureU1.FamilyPermutations n).group),\n  P\n    ((((ACCSystemGroupAction.linSolRep (PureU1.FamilyPermutations n)) f) S).val a,\n      (((ACCSystemGroupAction.linSolRep (PureU1.FamilyPermutations n)) f) S).val b,\n      (((ACCSystemGroupAction.linSolRep (PureU1.FamilyPermutations n)) f) S).val c)) (i : Fin n) (j : Fin n) (k : Fin n) : i ≠ j → j ≠ k → i ≠ k → P (S.val i, S.val j, S.val k)"}
{"name":"PureU1.pairSwap_other","declaration":"theorem PureU1.pairSwap_other {n : ℕ} (i : Fin n) (j : Fin n) (k : Fin n) (hik : i ≠ k) (hjk : j ≠ k) : (PureU1.pairSwap i j).toFun k = k"}
{"name":"PureU1.PermGroup","declaration":"/-- The permutation group of the n-fermions. -/\ndef PureU1.PermGroup (n : ℕ) : Type"}
{"name":"PureU1.accCube_invariant","declaration":"theorem PureU1.accCube_invariant {n : ℕ} (f : PureU1.PermGroup n) (S : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges) : (PureU1.accCube n) ((PureU1.permCharges f) S) = (PureU1.accCube n) S"}
{"name":"PureU1.permThreeInj_thd","declaration":"theorem PureU1.permThreeInj_thd {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) : k ∈ Set.range ⇑(PureU1.permThreeInj hij hjk hik)"}
{"name":"PureU1.accGrav_invariant","declaration":"theorem PureU1.accGrav_invariant {n : ℕ} (f : PureU1.PermGroup n) (S : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges) : (PureU1.accGrav n) ((PureU1.permCharges f) S) = (PureU1.accGrav n) S"}
{"name":"PureU1.chargeMap_apply","declaration":"theorem PureU1.chargeMap_apply {n : ℕ} (f : PureU1.PermGroup n) (S : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges) : ∀ (a : Fin (PureU1 n).numberCharges), (PureU1.chargeMap f) S a = S (f a)"}
{"name":"PureU1.permTwoInj_fst","declaration":"theorem PureU1.permTwoInj_fst {n : ℕ} {i : Fin n} {j : Fin n} (hij : i ≠ j) : i ∈ Set.range ⇑(PureU1.permTwoInj hij)"}
{"name":"PureU1.permTwoInj","declaration":"/-- Given two distinct elements, an embedding of `Fin 2` into `Fin n`. -/\ndef PureU1.permTwoInj {n : ℕ} {i : Fin n} {j : Fin n} (hij : i ≠ j) : Fin 2 ↪ Fin n"}
{"name":"PureU1.permTwo","declaration":"/-- A permutation which swaps `i` with `i'` and `j` with `j'`. -/\ndef PureU1.permTwo {n : ℕ} {i : Fin n} {j : Fin n} {i' : Fin n} {j' : Fin n} (hij : i ≠ j) (hij' : i' ≠ j') : (PureU1.FamilyPermutations n).group"}
{"name":"PureU1.permThree","declaration":"/-- A permutation which swaps three distinct elements with another three. -/\ndef PureU1.permThree {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} {i' : Fin n} {j' : Fin n} {k' : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) (hij' : i' ≠ j') (hjk' : j' ≠ k') (hik' : i' ≠ k') : (PureU1.FamilyPermutations n).group"}
{"name":"PureU1.pairSwap_fst","declaration":"theorem PureU1.pairSwap_fst {n : ℕ} (i : Fin n) (j : Fin n) : (PureU1.pairSwap i j).toFun i = j"}
{"name":"PureU1.permTwoInj_snd","declaration":"theorem PureU1.permTwoInj_snd {n : ℕ} {i : Fin n} {j : Fin n} (hij : i ≠ j) : j ∈ Set.range ⇑(PureU1.permTwoInj hij)"}
{"name":"PureU1.pairSwap","declaration":"/-- The permutation which swaps i and j. -/\ndef PureU1.pairSwap {n : ℕ} (i : Fin n) (j : Fin n) : (PureU1.FamilyPermutations n).group"}
{"name":"PureU1.permThreeInj","declaration":"/-- Given three distinct elements an embedding of `Fin 3` into `Fin n`. -/\ndef PureU1.permThreeInj {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) : Fin 3 ↪ Fin n"}
{"name":"PureU1.chargeMap","declaration":"/-- The image of an element of `permGroup` under the representation on charges. -/\ndef PureU1.chargeMap {n : ℕ} (f : PureU1.PermGroup n) : ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges →ₗ[ℚ] ACCSystemCharges.Charges (PureU1 n).toACCSystemCharges"}
{"name":"PureU1.pairSwap_inv_fst","declaration":"theorem PureU1.pairSwap_inv_fst {n : ℕ} (i : Fin n) (j : Fin n) : (PureU1.pairSwap i j).invFun i = j"}
{"name":"PureU1.permThreeInj_fst_apply","declaration":"theorem PureU1.permThreeInj_fst_apply {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) : (Function.Embedding.toEquivRange (PureU1.permThreeInj hij hjk hik)).symm { val := i, property := ⋯ } = 0"}
{"name":"PureU1.permThreeInj_snd","declaration":"theorem PureU1.permThreeInj_snd {n : ℕ} {i : Fin n} {j : Fin n} {k : Fin n} (hij : i ≠ j) (hjk : j ≠ k) (hik : i ≠ k) : j ∈ Set.range ⇑(PureU1.permThreeInj hij hjk hik)"}
