{"name":"IndexNotation.ColorIndexList.orderEmbOfFin_univ","declaration":"theorem IndexNotation.ColorIndexList.orderEmbOfFin_univ (n : â„•) (m : â„•) (h : n = m) : Finset.orderEmbOfFin Finset.univ â‹¯ = OrderIso.toOrderEmbedding (Fin.castIso â‹¯)"}
{"name":"IndexNotation.ColorIndexList.mk","declaration":"ctor IndexNotation.ColorIndexList.mk {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] (toIndexList : IndexNotation.IndexList ğ“’.Color) (unique_duals : IndexNotation.IndexList.OnlyUniqueDuals toIndexList) (dual_color : IndexNotation.IndexList.ColorCond toIndexList) : IndexNotation.ColorIndexList ğ“’"}
{"name":"IndexNotation.ColorIndexList.ext","declaration":"theorem IndexNotation.ColorIndexList.ext {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : l.val = l'.val) : l = l'"}
{"name":"IndexNotation.ColorIndexList.countId_le_two","declaration":"theorem IndexNotation.ColorIndexList.countId_le_two {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] [DecidableEq ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) (I : IndexNotation.Index ğ“’.Color) : IndexNotation.IndexList.countId l.toIndexList I â‰¤ 2"}
{"name":"IndexNotation.ColorIndexList.instCoeColorIndexListIndexListColor","declaration":"instance IndexNotation.ColorIndexList.instCoeColorIndexListIndexListColor {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] : Coe (IndexNotation.ColorIndexList ğ“’) (IndexNotation.IndexList ğ“’.Color)"}
{"name":"IndexNotation.ColorIndexList.empty","declaration":"/-- The `ColorIndexList` whose underlying list of indices is empty. -/\ndef IndexNotation.ColorIndexList.empty {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] : IndexNotation.ColorIndexList ğ“’"}
{"name":"IndexNotation.ColorIndexList","declaration":"/-- A list of indices with the additional constraint that if a index has a dual,\nthat dual is unique, and the dual of an index has dual color to that index.\n\nThis is the permissible type of indices which can be used for a tensor. For example,\nthe index list `['áµ˜Â¹', 'áµ¤â‚']` can be extended to a `ColorIndexList` but the index list\n`['áµ˜Â¹', 'áµ¤â‚', 'áµ¤â‚']` cannot. -/\nstructure IndexNotation.ColorIndexList (ğ“’ : TensorColor) [IndexNotation ğ“’.Color] : Type"}
{"name":"IndexNotation.ColorIndexList.colorMap'","declaration":"/-- The colorMap of a `ColorIndexList` as a `ğ“’.ColorMap`.\nThis is to be compared with `colorMap` which is a map `Fin l.length â†’ ğ“’.Color`. -/\ndef IndexNotation.ColorIndexList.colorMap' {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] (l : IndexNotation.ColorIndexList ğ“’) : TensorColor.ColorMap ğ“’ (Fin (IndexNotation.IndexList.length l.toIndexList))"}
{"name":"IndexNotation.ColorIndexList.dual_color","declaration":"/-- The condition that for an index with a dual, that dual has dual color to the index. -/\ndef IndexNotation.ColorIndexList.dual_color {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] (self : IndexNotation.ColorIndexList ğ“’) : IndexNotation.IndexList.ColorCond self.toIndexList"}
{"name":"IndexNotation.ColorIndexList.ext'","declaration":"theorem IndexNotation.ColorIndexList.ext' {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] {l : IndexNotation.ColorIndexList ğ“’} {l' : IndexNotation.ColorIndexList ğ“’} (h : l.toIndexList = l'.toIndexList) : l = l'"}
{"name":"IndexNotation.ColorIndexList.unique_duals","declaration":"/-- The condition that for index with a dual, that dual is the unique other index with\nan identical `id`. -/\ndef IndexNotation.ColorIndexList.unique_duals {ğ“’ : TensorColor} [IndexNotation ğ“’.Color] (self : IndexNotation.ColorIndexList ğ“’) : IndexNotation.IndexList.OnlyUniqueDuals self.toIndexList"}
