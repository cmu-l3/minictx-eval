{"name":"IndexNotation.IndexList.toPosSet_is_finite","declaration":"theorem IndexNotation.IndexList.toPosSet_is_finite {X : Type} (l : IndexNotation.IndexList X) : Set.Finite (IndexNotation.IndexList.toPosSet l)"}
{"name":"IndexNotation.IndexList.colorMap_append_inl'","declaration":"theorem IndexNotation.IndexList.colorMap_append_inl' {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : IndexNotation.IndexList.colorMap (l ++ l2) ∘ ⇑IndexNotation.IndexList.appendEquiv ∘ Sum.inl =\n  IndexNotation.IndexList.colorMap l"}
{"name":"List.filter_map","declaration":"theorem List.filter_map {β : Type u_1} {α : Type u_2} {p : α → Bool} (f : β → α) (l : List β) : List.filter p (List.map f l) = List.map f (List.filter (p ∘ f) l)"}
{"name":"IndexNotation.IndexList.colorMap_sumELim","declaration":"theorem IndexNotation.IndexList.colorMap_sumELim {X : Type} (l1 : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Sum.elim (IndexNotation.IndexList.colorMap l1) (IndexNotation.IndexList.colorMap l2) =\n  IndexNotation.IndexList.colorMap (l1 ++ l2) ∘ ⇑IndexNotation.IndexList.appendEquiv"}
{"name":"IndexNotation.IndexList.colorMap","declaration":"/-- The map of from `Fin s.numIndices` into colors associated to an index list. -/\ndef IndexNotation.IndexList.colorMap {X : Type} (l : IndexNotation.IndexList X) : Fin (IndexNotation.IndexList.length l) → X"}
{"name":"IndexNotation.IndexList.idMap_append_inr","declaration":"theorem IndexNotation.IndexList.idMap_append_inr {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l2)) : IndexNotation.IndexList.idMap (l ++ l2) (IndexNotation.IndexList.appendEquiv (Sum.inr i)) =\n  IndexNotation.IndexList.idMap l2 i"}
{"name":"IndexNotation.IndexList.instHAppendIndexList","declaration":"instance IndexNotation.IndexList.instHAppendIndexList {X : Type} : HAppend (IndexNotation.IndexList X) (IndexNotation.IndexList X) (IndexNotation.IndexList X)"}
{"name":"List.get_eq_getElem","declaration":"theorem List.get_eq_getElem {α : Type u_1} (l : List α) (i : Fin (List.length l)) : List.get l i = l[↑i]"}
{"name":"IndexNotation.IndexList.idMap_cast","declaration":"theorem IndexNotation.IndexList.idMap_cast {X : Type} {l1 : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : l1 = l2) (i : Fin (IndexNotation.IndexList.length l1)) : IndexNotation.IndexList.idMap l1 i = IndexNotation.IndexList.idMap l2 (Fin.cast ⋯ i)"}
{"name":"IndexNotation.IndexList.instFintypeElemProdFinLengthIndexToPosSet","declaration":"instance IndexNotation.IndexList.instFintypeElemProdFinLengthIndexToPosSet {X : Type} (l : IndexNotation.IndexList X) : Fintype ↑(IndexNotation.IndexList.toPosSet l)"}
{"name":"IndexNotation.IndexList.toPosSetEquiv","declaration":"/-- Equivalence between `toPosSet` and `Fin l.numIndices`. -/\ndef IndexNotation.IndexList.toPosSetEquiv {X : Type} (l : IndexNotation.IndexList X) : ↑(IndexNotation.IndexList.toPosSet l) ≃ Fin (IndexNotation.IndexList.length l)"}
{"name":"IndexNotation.IndexList.filter_id_eq_sort","declaration":"theorem IndexNotation.IndexList.filter_id_eq_sort {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : List.filter (fun J => decide (IndexNotation.Index.id (List.get l.val i) = IndexNotation.Index.id J)) l.val =\n  List.map (List.get l.val)\n    (Finset.sort (fun i j => i ≤ j)\n      (Finset.filter (fun j => IndexNotation.IndexList.idMap l i = IndexNotation.IndexList.idMap l j) Finset.univ))"}
{"name":"IndexNotation.IndexList.appendInr","declaration":"/-- The inclusion of the indices of `l2` into the indices of `l ++ l2`. -/\ndef IndexNotation.IndexList.appendInr {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Fin (IndexNotation.IndexList.length l2) ↪ Fin (IndexNotation.IndexList.length (l ++ l2))"}
{"name":"IndexNotation.IndexList","declaration":"/-- The type of lists of indices. -/\nstructure IndexNotation.IndexList (X : Type) : Type"}
{"name":"IndexNotation.IndexList.colorMap_append_inl","declaration":"theorem IndexNotation.IndexList.colorMap_append_inl {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.colorMap (l ++ l2) (IndexNotation.IndexList.appendEquiv (Sum.inl i)) =\n  IndexNotation.IndexList.colorMap l i"}
{"name":"IndexNotation.IndexList.append_length","declaration":"theorem IndexNotation.IndexList.append_length {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : IndexNotation.IndexList.length (l ++ l2) = IndexNotation.IndexList.length l + IndexNotation.IndexList.length l2"}
{"name":"IndexNotation.IndexList.idMap","declaration":"/-- The map of from `Fin s.numIndices` into the natural numbers associated to an index list. -/\ndef IndexNotation.IndexList.idMap {X : Type} (l : IndexNotation.IndexList X) : Fin (IndexNotation.IndexList.length l) → ℕ"}
{"name":"IndexNotation.IndexList.appendEquiv","declaration":"/-- An equivalence between the sum of the types of indices of `l` an `l2` and the type\nof indices of the joined index list `l ++ l2`. -/\ndef IndexNotation.IndexList.appendEquiv {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} : Fin (IndexNotation.IndexList.length l) ⊕ Fin (IndexNotation.IndexList.length l2) ≃\n  Fin (IndexNotation.IndexList.length (l ++ l2))"}
{"name":"IndexNotation.IndexList.fromFinMap","declaration":"/-- The construction of a list of indices from a map\nfrom `Fin n` to `Index X`. -/\ndef IndexNotation.IndexList.fromFinMap {X : Type} {n : ℕ} (f : Fin n → IndexNotation.Index X) : IndexNotation.IndexList X"}
{"name":"IndexNotation.IndexList.length","declaration":"/-- The number of indices in an index list. -/\ndef IndexNotation.IndexList.length {X : Type} (l : IndexNotation.IndexList X) : ℕ"}
{"name":"List.getElem_append_left","declaration":"theorem List.getElem_append_left {α : Type u_1} {i : ℕ} (as : List α) (bs : List α) (h : i < List.length as) {h' : i < List.length (as ++ bs)} : (as ++ bs)[i] = as[i]"}
{"name":"IndexNotation.IndexList.colorMap_append_inr","declaration":"theorem IndexNotation.IndexList.colorMap_append_inr {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l2)) : IndexNotation.IndexList.colorMap (l ++ l2) (IndexNotation.IndexList.appendEquiv (Sum.inr i)) =\n  IndexNotation.IndexList.colorMap l2 i"}
{"name":"IndexNotation.IndexList.colorMap_cast","declaration":"theorem IndexNotation.IndexList.colorMap_cast {X : Type} {l1 : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (h : l1 = l2) : IndexNotation.IndexList.colorMap l1 = IndexNotation.IndexList.colorMap l2 ∘ Fin.cast ⋯"}
{"name":"IndexNotation.IndexList.appendInl_appendEquiv","declaration":"theorem IndexNotation.IndexList.appendInl_appendEquiv {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Function.Embedding.trans (IndexNotation.IndexList.appendInl l l2)\n    (Equiv.toEmbedding IndexNotation.IndexList.appendEquiv.symm) =\n  { toFun := Sum.inl, inj' := ⋯ }"}
{"name":"IndexNotation.IndexList.colorMap_append_inr'","declaration":"theorem IndexNotation.IndexList.colorMap_append_inr' {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : IndexNotation.IndexList.colorMap (l ++ l2) ∘ ⇑IndexNotation.IndexList.appendEquiv ∘ Sum.inr =\n  IndexNotation.IndexList.colorMap l2"}
{"name":"IndexNotation.IndexList.tail_val","declaration":"theorem IndexNotation.IndexList.tail_val {X : Type} (l : IndexNotation.IndexList X) : (IndexNotation.IndexList.tail l).val = List.tail l.val"}
{"name":"IndexNotation.IndexList.idMap_append_inl","declaration":"theorem IndexNotation.IndexList.idMap_append_inl {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.idMap (l ++ l2) (IndexNotation.IndexList.appendEquiv (Sum.inl i)) =\n  IndexNotation.IndexList.idMap l i"}
{"name":"IndexNotation.IndexList.fromFinMap_numIndices","declaration":"theorem IndexNotation.IndexList.fromFinMap_numIndices {X : Type} {n : ℕ} (f : Fin n → IndexNotation.Index X) : IndexNotation.IndexList.length (IndexNotation.IndexList.fromFinMap f) = n"}
{"name":"IndexNotation.IndexList.cons_append","declaration":"theorem IndexNotation.IndexList.cons_append {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : IndexNotation.Index X) : IndexNotation.IndexList.cons l i ++ l2 = IndexNotation.IndexList.cons (l ++ l2) i"}
{"name":"IndexNotation.IndexList.cons_val","declaration":"theorem IndexNotation.IndexList.cons_val {X : Type} (l : IndexNotation.IndexList X) (i : IndexNotation.Index X) : (IndexNotation.IndexList.cons l i).val = i :: l.val"}
{"name":"IndexNotation.IndexList.induction","declaration":"theorem IndexNotation.IndexList.induction {X : Type} {P : IndexNotation.IndexList X → Prop} (h_nil : P { val := ∅ }) (h_cons : ∀ (x : IndexNotation.Index X) (xs : IndexNotation.IndexList X), P xs → P (IndexNotation.IndexList.cons xs x)) (l : IndexNotation.IndexList X) : P l"}
{"name":"IndexNotation.IndexList.appendInr_appendEquiv","declaration":"theorem IndexNotation.IndexList.appendInr_appendEquiv {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Function.Embedding.trans (IndexNotation.IndexList.appendInr l l2)\n    (Equiv.toEmbedding IndexNotation.IndexList.appendEquiv.symm) =\n  { toFun := Sum.inr, inj' := ⋯ }"}
{"name":"IndexNotation.IndexList.toPosSet","declaration":"/-- Given a list of indices a subset of `Fin l.numIndices × Index X`\nof pairs of positions in `l` and the corresponding item in `l`. -/\ndef IndexNotation.IndexList.toPosSet {X : Type} (l : IndexNotation.IndexList X) : Set (Fin (IndexNotation.IndexList.length l) × IndexNotation.Index X)"}
{"name":"IndexNotation.IndexList.appendInl","declaration":"/-- The inclusion of the indices of `l` into the indices of `l ++ l2`. -/\ndef IndexNotation.IndexList.appendInl {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Fin (IndexNotation.IndexList.length l) ↪ Fin (IndexNotation.IndexList.length (l ++ l2))"}
{"name":"IndexNotation.IndexList.append_val","declaration":"theorem IndexNotation.IndexList.append_val {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} : (l ++ l2).val = l.val ++ l2.val"}
{"name":"IndexNotation.IndexList.append_assoc","declaration":"theorem IndexNotation.IndexList.append_assoc {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (l3 : IndexNotation.IndexList X) : l ++ l2 ++ l3 = l ++ (l2 ++ l3)"}
{"name":"IndexNotation.IndexList.ext","declaration":"theorem IndexNotation.IndexList.ext {X : Type} (l : IndexNotation.IndexList X) {l2 : IndexNotation.IndexList X} (h : l.val = l2.val) : l = l2"}
{"name":"IndexNotation.IndexList.val","declaration":"/-- The list of index values. For example `['ᵘ¹','ᵘ²','ᵤ₁']`. -/\ndef IndexNotation.IndexList.val {X : Type} (self : IndexNotation.IndexList X) : List (IndexNotation.Index X)"}
{"name":"IndexNotation.IndexList.ext_colorMap_idMap","declaration":"theorem IndexNotation.IndexList.ext_colorMap_idMap {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (hl : IndexNotation.IndexList.length l = IndexNotation.IndexList.length l2) (hi : IndexNotation.IndexList.idMap l = IndexNotation.IndexList.idMap l2 ∘ Fin.cast hl) (hc : IndexNotation.IndexList.colorMap l = IndexNotation.IndexList.colorMap l2 ∘ Fin.cast hl) : l = l2"}
{"name":"List.filter_congr","declaration":"theorem List.filter_congr {α : Type u_1} {p : α → Bool} {q : α → Bool} {l : List α} : (∀ x ∈ l, p x = q x) → List.filter p l = List.filter q l"}
{"name":"IndexNotation.IndexList.head","declaration":"/-- The first index in a non-empty index list. -/\ndef IndexNotation.IndexList.head {X : Type} (l : IndexNotation.IndexList X) (h : l ≠ { val := ∅ }) : IndexNotation.Index X"}
{"name":"IndexNotation.IndexList.toPosFinset","declaration":"/-- Given a list of indices a finite set of `Fin l.length × Index X`\nof pairs of positions in `l` and the corresponding item in `l`. -/\ndef IndexNotation.IndexList.toPosFinset {X : Type} (l : IndexNotation.IndexList X) : Finset (Fin (IndexNotation.IndexList.length l) × IndexNotation.Index X)"}
{"name":"IndexNotation.IndexList.cons","declaration":"/-- The index list constructed by prepending an index to the list. -/\ndef IndexNotation.IndexList.cons {X : Type} (l : IndexNotation.IndexList X) (i : IndexNotation.Index X) : IndexNotation.IndexList X"}
{"name":"IndexNotation.IndexList.tail","declaration":"/-- The tail of an index list. That is, the index list with the first index dropped. -/\ndef IndexNotation.IndexList.tail {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList X"}
{"name":"IndexNotation.IndexList.cons_length","declaration":"theorem IndexNotation.IndexList.cons_length {X : Type} (l : IndexNotation.IndexList X) (i : IndexNotation.Index X) : IndexNotation.IndexList.length (IndexNotation.IndexList.cons l i) = IndexNotation.IndexList.length l + 1"}
{"name":"List.getElem_append_right","declaration":"theorem List.getElem_append_right {α : Type u_1} {i : ℕ} (as : List α) (bs : List α) (h : ¬i < List.length as) {h' : i < List.length (as ++ bs)} {h'' : i - List.length as < List.length bs} : (as ++ bs)[i] = bs[i - List.length as]"}
{"name":"List.head_cons_tail","declaration":"theorem List.head_cons_tail {α : Type u_1} (x : List α) (h : x ≠ []) : List.head x h :: List.tail x = x"}
{"name":"IndexNotation.IndexList.mk","declaration":"ctor IndexNotation.IndexList.mk {X : Type} (val : List (IndexNotation.Index X)) : IndexNotation.IndexList X"}
{"name":"IndexNotation.IndexList.head_cons_tail","declaration":"theorem IndexNotation.IndexList.head_cons_tail {X : Type} (l : IndexNotation.IndexList X) (h : l ≠ { val := ∅ }) : l = IndexNotation.IndexList.cons (IndexNotation.IndexList.tail l) (IndexNotation.IndexList.head l h)"}
{"name":"IndexNotation.IndexList.filter_sort_comm","declaration":"theorem IndexNotation.IndexList.filter_sort_comm {n : ℕ} (s : Finset (Fin n)) (p : Fin n → Prop) [DecidablePred p] : List.filter (fun b => decide (p b)) (Finset.sort (fun i j => i ≤ j) s) =\n  Finset.sort (fun i j => i ≤ j) (Finset.filter p s)"}
