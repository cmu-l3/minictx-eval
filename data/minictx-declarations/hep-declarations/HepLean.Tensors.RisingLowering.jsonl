{"name":"TensorStructure.dualize_equivariant_apply","declaration":"/-- Dualizing indices is equivariant with respect to the group action. This is the\napplied version of this statement. -/\ntheorem TensorStructure.dualize_equivariant_apply {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {G : Type} [Group G] [MulActionTensor G ğ“£] (e : C âŠ• P â‰ƒ X) (g : G) (x : TensorStructure.Tensor ğ“£ cX) : (TensorStructure.dualize ğ“£ e) (((TensorStructure.rep ğ“£) g) x) =\n  ((TensorStructure.rep ğ“£) g) ((TensorStructure.dualize ğ“£ e) x)"}
{"name":"TensorStructure.dualizeSymm","declaration":"/-- Takes a vector with index with dual color to a vector with index the underlying color.\nObtained by contraction with the metric. -/\ndef TensorStructure.dualizeSymm {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) (Î¼ : ğ“£.Color) : ğ“£.ColorModule (ğ“£.Ï„ Î¼) â†’â‚—[R] ğ“£.ColorModule Î¼"}
{"name":"TensorColor.ColorMap.DualMap.boolFin_DualMap","declaration":"theorem TensorColor.ColorMap.DualMap.boolFin_DualMap {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {n : â„•} {câ‚ : TensorColor.ColorMap ğ“’ (Fin n)} {câ‚‚ : TensorColor.ColorMap ğ“’ (Fin n)} (h : TensorColor.ColorMap.DualMap.boolFin câ‚ câ‚‚ = true) : TensorColor.ColorMap.DualMap câ‚ câ‚‚"}
{"name":"TensorStructure.dualize_cond","declaration":"theorem TensorStructure.dualize_cond {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} (e : C âŠ• P â‰ƒ X) : cX = Sum.elim (cX âˆ˜ â‡‘e âˆ˜ Sum.inl) (cX âˆ˜ â‡‘e âˆ˜ Sum.inr) âˆ˜ â‡‘e.symm"}
{"name":"TensorColor.ColorMap.DualMap.split_dual","declaration":"theorem TensorColor.ColorMap.DualMap.split_dual {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {X : Type} {câ‚ : TensorColor.ColorMap ğ“’ X} {câ‚‚ : TensorColor.ColorMap ğ“’ X} (h : TensorColor.ColorMap.DualMap câ‚ câ‚‚) : TensorColor.ColorMap.partDual câ‚ (TensorColor.ColorMap.DualMap.split câ‚ câ‚‚) = câ‚‚"}
{"name":"TensorColor.ColorMap.DualMap.symm","declaration":"theorem TensorColor.ColorMap.DualMap.symm {ğ“’ : TensorColor} {X : Type} {câ‚ : TensorColor.ColorMap ğ“’ X} {câ‚‚ : TensorColor.ColorMap ğ“’ X} (h : TensorColor.ColorMap.DualMap câ‚ câ‚‚) : TensorColor.ColorMap.DualMap câ‚‚ câ‚"}
{"name":"TensorStructure.dualizeAll_equivariant","declaration":"theorem TensorStructure.dualizeAll_equivariant {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {G : Type} [Group G] [MulActionTensor G ğ“£] (g : G) : â†‘(TensorStructure.dualizeAll ğ“£) âˆ˜â‚— (TensorStructure.rep ğ“£) g =\n  (TensorStructure.rep ğ“£) g âˆ˜â‚— â†‘(TensorStructure.dualizeAll ğ“£)"}
{"name":"TensorStructure.metric_cast","declaration":"theorem TensorStructure.metric_cast {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {Î½ : ğ“£.Color} (h : Î¼ = Î½) : (TensorProduct.congr (TensorStructure.colorModuleCast ğ“£ h) (TensorStructure.colorModuleCast ğ“£ h)) (ğ“£.metric Î¼) =\n  ğ“£.metric Î½"}
{"name":"TensorProduct.congr_refl_refl","declaration":"theorem TensorProduct.congr_refl_refl {M : Type u_1} {N : Type u_2} {R : Type} [CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] : TensorProduct.congr (LinearEquiv.refl R M) (LinearEquiv.refl R N) = LinearEquiv.refl R (TensorProduct R M N)"}
{"name":"TensorStructure.dualizeModule","declaration":"/-- Equivalence between the module with a color `Î¼` and the module with color\n`ğ“£.Ï„ Î¼` obtained by contraction with the metric. -/\ndef TensorStructure.dualizeModule {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) (Î¼ : ğ“£.Color) : ğ“£.ColorModule Î¼ â‰ƒâ‚—[R] ğ“£.ColorModule (ğ“£.Ï„ Î¼)"}
{"name":"TensorColor.ColorMap.DualMap.split","declaration":"/-- The splitting of `X` given two color maps based on the equality of the color. -/\ndef TensorColor.ColorMap.DualMap.split {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {X : Type} (câ‚ : TensorColor.ColorMap ğ“’ X) (câ‚‚ : TensorColor.ColorMap ğ“’ X) : { x // câ‚ x â‰  câ‚‚ x } âŠ• { x // câ‚ x = câ‚‚ x } â‰ƒ X"}
{"name":"TensorColor.ColorMap.DualMap.boolFin'","declaration":"/-- The bool which is ture if `ğ“’.colorQuot (câ‚ i) = ğ“’.colorQuot (câ‚‚ i)` is true for all `i`. -/\ndef TensorColor.ColorMap.DualMap.boolFin' {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {n : â„•} (câ‚ : TensorColor.ColorMap ğ“’ (Fin n)) (câ‚‚ : TensorColor.ColorMap ğ“’ (Fin n)) : Bool"}
{"name":"TensorColor.ColorMap.DualMap.split_dual'","declaration":"theorem TensorColor.ColorMap.DualMap.split_dual' {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {X : Type} {câ‚ : TensorColor.ColorMap ğ“’ X} {câ‚‚ : TensorColor.ColorMap ğ“’ X} (h : TensorColor.ColorMap.DualMap câ‚ câ‚‚) : TensorColor.ColorMap.partDual câ‚‚ (TensorColor.ColorMap.DualMap.split câ‚ câ‚‚) = câ‚"}
{"name":"TensorColor.ColorMap.DualMap.refl","declaration":"theorem TensorColor.ColorMap.DualMap.refl {ğ“’ : TensorColor} {X : Type} {câ‚ : TensorColor.ColorMap ğ“’ X} : TensorColor.ColorMap.DualMap câ‚ câ‚"}
{"name":"TensorColor.ColorMap.DualMap","declaration":"/-- Two color maps are said to be dual if their quotents are dual. -/\ndef TensorColor.ColorMap.DualMap {ğ“’ : TensorColor} {X : Type} (câ‚ : TensorColor.ColorMap ğ“’ X) (câ‚‚ : TensorColor.ColorMap ğ“’ X) : Prop"}
{"name":"TensorColor.ColorMap.DualMap.trans","declaration":"theorem TensorColor.ColorMap.DualMap.trans {ğ“’ : TensorColor} {X : Type} {câ‚ : TensorColor.ColorMap ğ“’ X} {câ‚‚ : TensorColor.ColorMap ğ“’ X} {câ‚ƒ : TensorColor.ColorMap ğ“’ X} (h : TensorColor.ColorMap.DualMap câ‚ câ‚‚) (h' : TensorColor.ColorMap.DualMap câ‚‚ câ‚ƒ) : TensorColor.ColorMap.DualMap câ‚ câ‚ƒ"}
{"name":"TensorStructure.metric_contrRight_unit","declaration":"theorem TensorStructure.metric_contrRight_unit {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) (Î¼ : ğ“£.Color) (x : ğ“£.ColorModule Î¼) : (TensorStructure.contrRightAux (ğ“£.contrDual Î¼))\n    (ğ“£.metric Î¼ âŠ—â‚œ[R]\n      (TensorStructure.contrRightAux (ğ“£.contrDual (ğ“£.Ï„ Î¼)))\n        (ğ“£.metric (ğ“£.Ï„ Î¼) âŠ—â‚œ[R] (TensorStructure.colorModuleCast ğ“£ â‹¯) x)) =\n  x"}
{"name":"TensorStructure.dualizeModule_equivariant_apply","declaration":"theorem TensorStructure.dualizeModule_equivariant_apply {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {G : Type} [Group G] [MulActionTensor G ğ“£] (g : G) (x : ğ“£.ColorModule Î¼) : (TensorStructure.dualizeModule ğ“£ Î¼) (((MulActionTensor.repColorModule Î¼) g) x) =\n  ((MulActionTensor.repColorModule (ğ“£.Ï„ Î¼)) g) ((TensorStructure.dualizeModule ğ“£ Î¼) x)"}
{"name":"TensorStructure.dualize","declaration":"/-- Given an equivalence `C âŠ• P â‰ƒ X` dualizes those indices of a tensor which correspond to\n`C` whilst leaving the indices `P` invariant. -/\ndef TensorStructure.dualize {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} (e : C âŠ• P â‰ƒ X) : TensorStructure.Tensor ğ“£ cX â‰ƒâ‚—[R] TensorStructure.Tensor ğ“£ (TensorColor.ColorMap.partDual cX e)"}
{"name":"TensorStructure.unit_lid","declaration":"theorem TensorStructure.unit_lid {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {x : ğ“£.ColorModule Î¼} : (TensorStructure.contrRightAux (ğ“£.contrDual (ğ“£.Ï„ Î¼)))\n    ((TensorProduct.comm R (ğ“£.ColorModule (ğ“£.Ï„ Î¼)) (ğ“£.ColorModule Î¼)) (ğ“£.unit Î¼) âŠ—â‚œ[R]\n      (TensorStructure.colorModuleCast ğ“£ â‹¯) x) =\n  x"}
{"name":"TensorStructure.unit_lhs_eq","declaration":"theorem TensorStructure.unit_lhs_eq {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} (x : ğ“£.ColorModule Î¼) (y : TensorProduct R (ğ“£.ColorModule (ğ“£.Ï„ Î¼)) (ğ“£.ColorModule Î¼)) : (TensorStructure.contrLeftAux (ğ“£.contrDual Î¼)) (x âŠ—â‚œ[R] y) =\n  (TensorStructure.contrRightAux (ğ“£.contrDual (ğ“£.Ï„ Î¼)))\n    ((TensorProduct.comm R (ğ“£.ColorModule (ğ“£.Ï„ Î¼)) (ğ“£.ColorModule Î¼)) y âŠ—â‚œ[R] (TensorStructure.colorModuleCast ğ“£ â‹¯) x)"}
{"name":"TensorColor.ColorMap.DualMap.boolFin","declaration":"/-- The bool which if `ğ“’.colorQuot (câ‚ i) = ğ“’.colorQuot (câ‚‚ i)` is true for all `i`. -/\ndef TensorColor.ColorMap.DualMap.boolFin {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {n : â„•} (câ‚ : TensorColor.ColorMap ğ“’ (Fin n)) (câ‚‚ : TensorColor.ColorMap ğ“’ (Fin n)) : Bool"}
{"name":"TensorStructure.dualizeModule_equivariant","declaration":"theorem TensorStructure.dualizeModule_equivariant {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {G : Type} [Group G] [MulActionTensor G ğ“£] (g : G) : â†‘(TensorStructure.dualizeModule ğ“£ Î¼) âˆ˜â‚— (MulActionTensor.repColorModule Î¼) g =\n  (MulActionTensor.repColorModule (ğ“£.Ï„ Î¼)) g âˆ˜â‚— â†‘(TensorStructure.dualizeModule ğ“£ Î¼)"}
{"name":"LinearEquiv.ofLinear_toLinearMap","declaration":"theorem LinearEquiv.ofLinear_toLinearMap {Râ‚‚ : Type u_2} {M : Type u_3} {Mâ‚‚ : Type u_1} {R : Type} [Semiring R] [Semiring Râ‚‚] [AddCommMonoid M] [AddCommMonoid Mâ‚‚] {module_M : Module R M} {module_Mâ‚‚ : Module Râ‚‚ Mâ‚‚} {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} {reâ‚â‚‚ : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚} {reâ‚‚â‚ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚} (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (g : Mâ‚‚ â†’â‚›â‚—[Ïƒâ‚‚â‚] M) {hâ‚ : LinearMap.comp f g = LinearMap.id} {hâ‚‚ : LinearMap.comp g f = LinearMap.id} : â†‘(LinearEquiv.ofLinear f g hâ‚ hâ‚‚) = f"}
{"name":"TensorStructure.dualizeAll","declaration":"/-- Dualizes the color of all indicies of a tensor by contraction with the metric. -/\ndef TensorStructure.dualizeAll {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} : TensorStructure.Tensor ğ“£ cX â‰ƒâ‚—[R] TensorStructure.Tensor ğ“£ (ğ“£.Ï„ âˆ˜ cX)"}
{"name":"TensorColor.ColorMap.partDual","declaration":"/-- Given an equivalence `C âŠ• P â‰ƒ X` the color map obtained by `cX` by dualising\nall indices in `C`. -/\ndef TensorColor.ColorMap.partDual {ğ“’ : TensorColor} {X : Type} {C : Type} {P : Type} (cX : TensorColor.ColorMap ğ“’ X) (e : C âŠ• P â‰ƒ X) : TensorColor.ColorMap ğ“’ X"}
{"name":"TensorColor.ColorMap.DualMap.dual_eq_of_neq","declaration":"theorem TensorColor.ColorMap.DualMap.dual_eq_of_neq {ğ“’ : TensorColor} {X : Type} {câ‚ : TensorColor.ColorMap ğ“’ X} {câ‚‚ : TensorColor.ColorMap ğ“’ X} (h : TensorColor.ColorMap.DualMap câ‚ câ‚‚) {x : X} (h' : câ‚ x â‰  câ‚‚ x) : ğ“’.Ï„ (câ‚ x) = câ‚‚ x"}
{"name":"TensorStructure.dualizeFun","declaration":"/-- Takes a vector to a vector with the dual color index.\nObtained by contraction with the metric. -/\ndef TensorStructure.dualizeFun {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) (Î¼ : ğ“£.Color) : ğ“£.ColorModule Î¼ â†’â‚—[R] ğ“£.ColorModule (ğ“£.Ï„ Î¼)"}
{"name":"TensorColor.ColorMap.DualMap.boolFin'_DualMap","declaration":"theorem TensorColor.ColorMap.DualMap.boolFin'_DualMap {ğ“’ : TensorColor} [DecidableEq ğ“’.Color] {n : â„•} {câ‚ : TensorColor.ColorMap ğ“’ (Fin n)} {câ‚‚ : TensorColor.ColorMap ğ“’ (Fin n)} (h : TensorColor.ColorMap.DualMap.boolFin' câ‚ câ‚‚ = true) : TensorColor.ColorMap.DualMap câ‚ câ‚‚"}
{"name":"TensorStructure.dualize_cond'","declaration":"theorem TensorStructure.dualize_cond' {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {C : Type} {P : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} (e : C âŠ• P â‰ƒ X) : Sum.elim (ğ“£.Ï„ âˆ˜ cX âˆ˜ â‡‘e âˆ˜ Sum.inl) (cX âˆ˜ â‡‘e âˆ˜ Sum.inr) =\n  (Sum.elim (ğ“£.Ï„ âˆ˜ cX âˆ˜ â‡‘e âˆ˜ Sum.inl) (cX âˆ˜ â‡‘e âˆ˜ Sum.inr) âˆ˜ â‡‘e.symm) âˆ˜ â‡‘e"}
