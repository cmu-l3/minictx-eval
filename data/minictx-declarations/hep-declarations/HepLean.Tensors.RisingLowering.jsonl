{"name":"TensorStructure.dualize_equivariant_apply","declaration":"/-- Dualizing indices is equivariant with respect to the group action. This is the\napplied version of this statement. -/\ntheorem TensorStructure.dualize_equivariant_apply {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {C : Type} {P : Type} [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {G : Type} [Group G] [MulActionTensor G 𝓣] (e : C ⊕ P ≃ X) (g : G) (x : TensorStructure.Tensor 𝓣 cX) : (TensorStructure.dualize 𝓣 e) (((TensorStructure.rep 𝓣) g) x) =\n  ((TensorStructure.rep 𝓣) g) ((TensorStructure.dualize 𝓣 e) x)"}
{"name":"TensorStructure.dualizeSymm","declaration":"/-- Takes a vector with index with dual color to a vector with index the underlying color.\nObtained by contraction with the metric. -/\ndef TensorStructure.dualizeSymm {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) (μ : 𝓣.Color) : 𝓣.ColorModule (𝓣.τ μ) →ₗ[R] 𝓣.ColorModule μ"}
{"name":"TensorColor.ColorMap.DualMap.boolFin_DualMap","declaration":"theorem TensorColor.ColorMap.DualMap.boolFin_DualMap {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {n : ℕ} {c₁ : TensorColor.ColorMap 𝓒 (Fin n)} {c₂ : TensorColor.ColorMap 𝓒 (Fin n)} (h : TensorColor.ColorMap.DualMap.boolFin c₁ c₂ = true) : TensorColor.ColorMap.DualMap c₁ c₂"}
{"name":"TensorStructure.dualize_cond","declaration":"theorem TensorStructure.dualize_cond {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {C : Type} {P : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} (e : C ⊕ P ≃ X) : cX = Sum.elim (cX ∘ ⇑e ∘ Sum.inl) (cX ∘ ⇑e ∘ Sum.inr) ∘ ⇑e.symm"}
{"name":"TensorColor.ColorMap.DualMap.split_dual","declaration":"theorem TensorColor.ColorMap.DualMap.split_dual {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {X : Type} {c₁ : TensorColor.ColorMap 𝓒 X} {c₂ : TensorColor.ColorMap 𝓒 X} (h : TensorColor.ColorMap.DualMap c₁ c₂) : TensorColor.ColorMap.partDual c₁ (TensorColor.ColorMap.DualMap.split c₁ c₂) = c₂"}
{"name":"TensorColor.ColorMap.DualMap.symm","declaration":"theorem TensorColor.ColorMap.DualMap.symm {𝓒 : TensorColor} {X : Type} {c₁ : TensorColor.ColorMap 𝓒 X} {c₂ : TensorColor.ColorMap 𝓒 X} (h : TensorColor.ColorMap.DualMap c₁ c₂) : TensorColor.ColorMap.DualMap c₂ c₁"}
{"name":"TensorStructure.dualizeAll_equivariant","declaration":"theorem TensorStructure.dualizeAll_equivariant {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {G : Type} [Group G] [MulActionTensor G 𝓣] (g : G) : ↑(TensorStructure.dualizeAll 𝓣) ∘ₗ (TensorStructure.rep 𝓣) g =\n  (TensorStructure.rep 𝓣) g ∘ₗ ↑(TensorStructure.dualizeAll 𝓣)"}
{"name":"TensorStructure.metric_cast","declaration":"theorem TensorStructure.metric_cast {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} {ν : 𝓣.Color} (h : μ = ν) : (TensorProduct.congr (TensorStructure.colorModuleCast 𝓣 h) (TensorStructure.colorModuleCast 𝓣 h)) (𝓣.metric μ) =\n  𝓣.metric ν"}
{"name":"TensorProduct.congr_refl_refl","declaration":"theorem TensorProduct.congr_refl_refl {M : Type u_1} {N : Type u_2} {R : Type} [CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] : TensorProduct.congr (LinearEquiv.refl R M) (LinearEquiv.refl R N) = LinearEquiv.refl R (TensorProduct R M N)"}
{"name":"TensorStructure.dualizeModule","declaration":"/-- Equivalence between the module with a color `μ` and the module with color\n`𝓣.τ μ` obtained by contraction with the metric. -/\ndef TensorStructure.dualizeModule {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) (μ : 𝓣.Color) : 𝓣.ColorModule μ ≃ₗ[R] 𝓣.ColorModule (𝓣.τ μ)"}
{"name":"TensorColor.ColorMap.DualMap.split","declaration":"/-- The splitting of `X` given two color maps based on the equality of the color. -/\ndef TensorColor.ColorMap.DualMap.split {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {X : Type} (c₁ : TensorColor.ColorMap 𝓒 X) (c₂ : TensorColor.ColorMap 𝓒 X) : { x // c₁ x ≠ c₂ x } ⊕ { x // c₁ x = c₂ x } ≃ X"}
{"name":"TensorColor.ColorMap.DualMap.boolFin'","declaration":"/-- The bool which is ture if `𝓒.colorQuot (c₁ i) = 𝓒.colorQuot (c₂ i)` is true for all `i`. -/\ndef TensorColor.ColorMap.DualMap.boolFin' {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {n : ℕ} (c₁ : TensorColor.ColorMap 𝓒 (Fin n)) (c₂ : TensorColor.ColorMap 𝓒 (Fin n)) : Bool"}
{"name":"TensorColor.ColorMap.DualMap.split_dual'","declaration":"theorem TensorColor.ColorMap.DualMap.split_dual' {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {X : Type} {c₁ : TensorColor.ColorMap 𝓒 X} {c₂ : TensorColor.ColorMap 𝓒 X} (h : TensorColor.ColorMap.DualMap c₁ c₂) : TensorColor.ColorMap.partDual c₂ (TensorColor.ColorMap.DualMap.split c₁ c₂) = c₁"}
{"name":"TensorColor.ColorMap.DualMap.refl","declaration":"theorem TensorColor.ColorMap.DualMap.refl {𝓒 : TensorColor} {X : Type} {c₁ : TensorColor.ColorMap 𝓒 X} : TensorColor.ColorMap.DualMap c₁ c₁"}
{"name":"TensorColor.ColorMap.DualMap","declaration":"/-- Two color maps are said to be dual if their quotents are dual. -/\ndef TensorColor.ColorMap.DualMap {𝓒 : TensorColor} {X : Type} (c₁ : TensorColor.ColorMap 𝓒 X) (c₂ : TensorColor.ColorMap 𝓒 X) : Prop"}
{"name":"TensorColor.ColorMap.DualMap.trans","declaration":"theorem TensorColor.ColorMap.DualMap.trans {𝓒 : TensorColor} {X : Type} {c₁ : TensorColor.ColorMap 𝓒 X} {c₂ : TensorColor.ColorMap 𝓒 X} {c₃ : TensorColor.ColorMap 𝓒 X} (h : TensorColor.ColorMap.DualMap c₁ c₂) (h' : TensorColor.ColorMap.DualMap c₂ c₃) : TensorColor.ColorMap.DualMap c₁ c₃"}
{"name":"TensorStructure.metric_contrRight_unit","declaration":"theorem TensorStructure.metric_contrRight_unit {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) (μ : 𝓣.Color) (x : 𝓣.ColorModule μ) : (TensorStructure.contrRightAux (𝓣.contrDual μ))\n    (𝓣.metric μ ⊗ₜ[R]\n      (TensorStructure.contrRightAux (𝓣.contrDual (𝓣.τ μ)))\n        (𝓣.metric (𝓣.τ μ) ⊗ₜ[R] (TensorStructure.colorModuleCast 𝓣 ⋯) x)) =\n  x"}
{"name":"TensorStructure.dualizeModule_equivariant_apply","declaration":"theorem TensorStructure.dualizeModule_equivariant_apply {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} {G : Type} [Group G] [MulActionTensor G 𝓣] (g : G) (x : 𝓣.ColorModule μ) : (TensorStructure.dualizeModule 𝓣 μ) (((MulActionTensor.repColorModule μ) g) x) =\n  ((MulActionTensor.repColorModule (𝓣.τ μ)) g) ((TensorStructure.dualizeModule 𝓣 μ) x)"}
{"name":"TensorStructure.dualize","declaration":"/-- Given an equivalence `C ⊕ P ≃ X` dualizes those indices of a tensor which correspond to\n`C` whilst leaving the indices `P` invariant. -/\ndef TensorStructure.dualize {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {C : Type} {P : Type} [DecidableEq C] [DecidableEq P] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} (e : C ⊕ P ≃ X) : TensorStructure.Tensor 𝓣 cX ≃ₗ[R] TensorStructure.Tensor 𝓣 (TensorColor.ColorMap.partDual cX e)"}
{"name":"TensorStructure.unit_lid","declaration":"theorem TensorStructure.unit_lid {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} {x : 𝓣.ColorModule μ} : (TensorStructure.contrRightAux (𝓣.contrDual (𝓣.τ μ)))\n    ((TensorProduct.comm R (𝓣.ColorModule (𝓣.τ μ)) (𝓣.ColorModule μ)) (𝓣.unit μ) ⊗ₜ[R]\n      (TensorStructure.colorModuleCast 𝓣 ⋯) x) =\n  x"}
{"name":"TensorStructure.unit_lhs_eq","declaration":"theorem TensorStructure.unit_lhs_eq {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} (x : 𝓣.ColorModule μ) (y : TensorProduct R (𝓣.ColorModule (𝓣.τ μ)) (𝓣.ColorModule μ)) : (TensorStructure.contrLeftAux (𝓣.contrDual μ)) (x ⊗ₜ[R] y) =\n  (TensorStructure.contrRightAux (𝓣.contrDual (𝓣.τ μ)))\n    ((TensorProduct.comm R (𝓣.ColorModule (𝓣.τ μ)) (𝓣.ColorModule μ)) y ⊗ₜ[R] (TensorStructure.colorModuleCast 𝓣 ⋯) x)"}
{"name":"TensorColor.ColorMap.DualMap.boolFin","declaration":"/-- The bool which if `𝓒.colorQuot (c₁ i) = 𝓒.colorQuot (c₂ i)` is true for all `i`. -/\ndef TensorColor.ColorMap.DualMap.boolFin {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {n : ℕ} (c₁ : TensorColor.ColorMap 𝓒 (Fin n)) (c₂ : TensorColor.ColorMap 𝓒 (Fin n)) : Bool"}
{"name":"TensorStructure.dualizeModule_equivariant","declaration":"theorem TensorStructure.dualizeModule_equivariant {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} {G : Type} [Group G] [MulActionTensor G 𝓣] (g : G) : ↑(TensorStructure.dualizeModule 𝓣 μ) ∘ₗ (MulActionTensor.repColorModule μ) g =\n  (MulActionTensor.repColorModule (𝓣.τ μ)) g ∘ₗ ↑(TensorStructure.dualizeModule 𝓣 μ)"}
{"name":"LinearEquiv.ofLinear_toLinearMap","declaration":"theorem LinearEquiv.ofLinear_toLinearMap {R₂ : Type u_2} {M : Type u_3} {M₂ : Type u_1} {R : Type} [Semiring R] [Semiring R₂] [AddCommMonoid M] [AddCommMonoid M₂] {module_M : Module R M} {module_M₂ : Module R₂ M₂} {σ₁₂ : R →+* R₂} {σ₂₁ : R₂ →+* R} {re₁₂ : RingHomInvPair σ₁₂ σ₂₁} {re₂₁ : RingHomInvPair σ₂₁ σ₁₂} (f : M →ₛₗ[σ₁₂] M₂) (g : M₂ →ₛₗ[σ₂₁] M) {h₁ : LinearMap.comp f g = LinearMap.id} {h₂ : LinearMap.comp g f = LinearMap.id} : ↑(LinearEquiv.ofLinear f g h₁ h₂) = f"}
{"name":"TensorStructure.dualizeAll","declaration":"/-- Dualizes the color of all indicies of a tensor by contraction with the metric. -/\ndef TensorStructure.dualizeAll {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} : TensorStructure.Tensor 𝓣 cX ≃ₗ[R] TensorStructure.Tensor 𝓣 (𝓣.τ ∘ cX)"}
{"name":"TensorColor.ColorMap.partDual","declaration":"/-- Given an equivalence `C ⊕ P ≃ X` the color map obtained by `cX` by dualising\nall indices in `C`. -/\ndef TensorColor.ColorMap.partDual {𝓒 : TensorColor} {X : Type} {C : Type} {P : Type} (cX : TensorColor.ColorMap 𝓒 X) (e : C ⊕ P ≃ X) : TensorColor.ColorMap 𝓒 X"}
{"name":"TensorColor.ColorMap.DualMap.dual_eq_of_neq","declaration":"theorem TensorColor.ColorMap.DualMap.dual_eq_of_neq {𝓒 : TensorColor} {X : Type} {c₁ : TensorColor.ColorMap 𝓒 X} {c₂ : TensorColor.ColorMap 𝓒 X} (h : TensorColor.ColorMap.DualMap c₁ c₂) {x : X} (h' : c₁ x ≠ c₂ x) : 𝓒.τ (c₁ x) = c₂ x"}
{"name":"TensorStructure.dualizeFun","declaration":"/-- Takes a vector to a vector with the dual color index.\nObtained by contraction with the metric. -/\ndef TensorStructure.dualizeFun {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) (μ : 𝓣.Color) : 𝓣.ColorModule μ →ₗ[R] 𝓣.ColorModule (𝓣.τ μ)"}
{"name":"TensorColor.ColorMap.DualMap.boolFin'_DualMap","declaration":"theorem TensorColor.ColorMap.DualMap.boolFin'_DualMap {𝓒 : TensorColor} [DecidableEq 𝓒.Color] {n : ℕ} {c₁ : TensorColor.ColorMap 𝓒 (Fin n)} {c₂ : TensorColor.ColorMap 𝓒 (Fin n)} (h : TensorColor.ColorMap.DualMap.boolFin' c₁ c₂ = true) : TensorColor.ColorMap.DualMap c₁ c₂"}
{"name":"TensorStructure.dualize_cond'","declaration":"theorem TensorStructure.dualize_cond' {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {C : Type} {P : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} (e : C ⊕ P ≃ X) : Sum.elim (𝓣.τ ∘ cX ∘ ⇑e ∘ Sum.inl) (cX ∘ ⇑e ∘ Sum.inr) =\n  (Sum.elim (𝓣.τ ∘ cX ∘ ⇑e ∘ Sum.inl) (cX ∘ ⇑e ∘ Sum.inr) ∘ ⇑e.symm) ∘ ⇑e"}
