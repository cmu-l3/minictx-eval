{"name":"IndexNotation.IndexList.getDualInOther?_areDualInOther_get","declaration":"theorem IndexNotation.IndexList.getDualInOther?_areDualInOther_get {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true) : IndexNotation.IndexList.AreDualInOther l l2 i (Option.get (IndexNotation.IndexList.getDualInOther? l l2 i) h)"}
{"name":"IndexNotation.IndexList.mem_withInDualOther_iff_exists","declaration":"theorem IndexNotation.IndexList.mem_withInDualOther_iff_exists {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) {i : Fin (IndexNotation.IndexList.length l)} : i ∈ IndexNotation.IndexList.withDualInOther l l2 ↔ ∃ j, IndexNotation.IndexList.AreDualInOther l l2 i j"}
{"name":"IndexNotation.IndexList.AreDualInSelf.symm","declaration":"theorem IndexNotation.IndexList.AreDualInSelf.symm {X : Type} {l : IndexNotation.IndexList X} {i : Fin (IndexNotation.IndexList.length l)} {j : Fin (IndexNotation.IndexList.length l)} (h : IndexNotation.IndexList.AreDualInSelf l i j) : IndexNotation.IndexList.AreDualInSelf l j i"}
{"name":"IndexNotation.IndexList.mem_withDual_iff_isSome","declaration":"theorem IndexNotation.IndexList.mem_withDual_iff_isSome {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : i ∈ IndexNotation.IndexList.withDual l ↔ Option.isSome (IndexNotation.IndexList.getDual? l i) = true"}
{"name":"IndexNotation.IndexList.AreDualInSelf.append_inl_inr","declaration":"theorem IndexNotation.IndexList.AreDualInSelf.append_inl_inr {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l2)) : IndexNotation.IndexList.AreDualInSelf (l ++ l2) (IndexNotation.IndexList.appendEquiv (Sum.inl i))\n    (IndexNotation.IndexList.appendEquiv (Sum.inr j)) =\n  IndexNotation.IndexList.AreDualInOther l l2 i j"}
{"name":"IndexNotation.IndexList.mem_withDualInOther_of_withUniqueDualInOther","declaration":"theorem IndexNotation.IndexList.mem_withDualInOther_of_withUniqueDualInOther {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l l2 }) : ↑i ∈ IndexNotation.IndexList.withDualInOther l l2"}
{"name":"IndexNotation.IndexList.not_mem_withDual_of_mem_withoutDual","declaration":"theorem IndexNotation.IndexList.not_mem_withDual_of_mem_withoutDual {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withoutDual l) : i ∉ IndexNotation.IndexList.withDual l"}
{"name":"IndexNotation.IndexList.AreDualInOther.append_of_inl","declaration":"theorem IndexNotation.IndexList.AreDualInOther.append_of_inl {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l3 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l3)) : IndexNotation.IndexList.AreDualInOther (l ++ l2) l3 (IndexNotation.IndexList.appendEquiv (Sum.inl i)) j ↔\n  IndexNotation.IndexList.AreDualInOther l l3 i j"}
{"name":"IndexNotation.IndexList.getDualInOther?_self_isSome","declaration":"theorem IndexNotation.IndexList.getDualInOther?_self_isSome {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : Option.isSome (IndexNotation.IndexList.getDualInOther? l l i) = true"}
{"name":"IndexNotation.IndexList.withUniqueDualLT_disjoint_withUniqueDualGT","declaration":"theorem IndexNotation.IndexList.withUniqueDualLT_disjoint_withUniqueDualGT {X : Type} (l : IndexNotation.IndexList X) : Disjoint (IndexNotation.IndexList.withUniqueDualLT l) (IndexNotation.IndexList.withUniqueDualGT l)"}
{"name":"IndexNotation.IndexList.getDual?_get_areDualInSelf","declaration":"theorem IndexNotation.IndexList.getDual?_get_areDualInSelf {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : IndexNotation.IndexList.AreDualInSelf l (Option.get (IndexNotation.IndexList.getDual? l i) h) i"}
{"name":"IndexNotation.IndexList.AreDualInOther.append_of_inr","declaration":"theorem IndexNotation.IndexList.AreDualInOther.append_of_inr {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l3 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l2)) (j : Fin (IndexNotation.IndexList.length l3)) : IndexNotation.IndexList.AreDualInOther (l ++ l2) l3 (IndexNotation.IndexList.appendEquiv (Sum.inr i)) j ↔\n  IndexNotation.IndexList.AreDualInOther l2 l3 i j"}
{"name":"IndexNotation.IndexList.getDualInOther?_get_areDualInOther","declaration":"theorem IndexNotation.IndexList.getDualInOther?_get_areDualInOther {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true) : IndexNotation.IndexList.AreDualInOther l2 l (Option.get (IndexNotation.IndexList.getDualInOther? l l2 i) h) i"}
{"name":"IndexNotation.IndexList.AreDualInOther.instDecidableAreDualInOther","declaration":"instance IndexNotation.IndexList.AreDualInOther.instDecidableAreDualInOther {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l2)) : Decidable (IndexNotation.IndexList.AreDualInOther l l2 i j)"}
{"name":"IndexNotation.IndexList.getDual?_areDualInSelf_get","declaration":"theorem IndexNotation.IndexList.getDual?_areDualInSelf_get {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : IndexNotation.IndexList.AreDualInSelf l i (Option.get (IndexNotation.IndexList.getDual? l i) h)"}
{"name":"IndexNotation.IndexList.mem_withDual_of_mem_withUniqueDual","declaration":"theorem IndexNotation.IndexList.mem_withDual_of_mem_withUniqueDual {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withUniqueDual l) : i ∈ IndexNotation.IndexList.withDual l"}
{"name":"IndexNotation.IndexList.withDual_union_withoutDual","declaration":"theorem IndexNotation.IndexList.withDual_union_withoutDual {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.withDual l ∪ IndexNotation.IndexList.withoutDual l = Finset.univ"}
{"name":"IndexNotation.IndexList.withDual_isSome","declaration":"theorem IndexNotation.IndexList.withDual_isSome {X : Type} (l : IndexNotation.IndexList X) (i : { x // x ∈ IndexNotation.IndexList.withDual l }) : Option.isSome (IndexNotation.IndexList.getDual? l ↑i) = true"}
{"name":"IndexNotation.IndexList.withDual","declaration":"/-- The finite set of indices of an index list which have a dual in that index list. -/\ndef IndexNotation.IndexList.withDual {X : Type} (l : IndexNotation.IndexList X) : Finset (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.Fin.ge_of_eq","declaration":"theorem IndexNotation.IndexList.Fin.ge_of_eq {n : ℕ} {a : Fin n} {b : Fin n} (hab : a = b) : b ≤ a"}
{"name":"IndexNotation.IndexList.withUniqueDualLT","declaration":"/-- The finite set of those indices of `l` which have a unique dual, and for which\nthat dual is greater-then (determined by the ordering on `Fin`) then the index itself. -/\ndef IndexNotation.IndexList.withUniqueDualLT {X : Type} (l : IndexNotation.IndexList X) : Finset (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.AreDualInOther.of_append_inr","declaration":"theorem IndexNotation.IndexList.AreDualInOther.of_append_inr {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l3 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l3)) : IndexNotation.IndexList.AreDualInOther l (l2 ++ l3) i (IndexNotation.IndexList.appendEquiv (Sum.inr j)) ↔\n  IndexNotation.IndexList.AreDualInOther l l3 i j"}
{"name":"IndexNotation.IndexList.getDual?_neq_self","declaration":"theorem IndexNotation.IndexList.getDual?_neq_self {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : ¬IndexNotation.IndexList.getDual? l i = some i"}
{"name":"IndexNotation.IndexList.getDual?_isSome_iff_exists","declaration":"theorem IndexNotation.IndexList.getDual?_isSome_iff_exists {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : Option.isSome (IndexNotation.IndexList.getDual? l i) = true ↔ ∃ j, IndexNotation.IndexList.AreDualInSelf l i j"}
{"name":"IndexNotation.IndexList.getDual?","declaration":"/-- Given an `i`, if a dual exists in the same list,\noutputs the first such dual, otherwise outputs `none`. -/\ndef IndexNotation.IndexList.getDual? {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : Option (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.getDualInOther?_id","declaration":"theorem IndexNotation.IndexList.getDualInOther?_id {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true) : IndexNotation.IndexList.idMap l2 (Option.get (IndexNotation.IndexList.getDualInOther? l l2 i) h) =\n  IndexNotation.IndexList.idMap l i"}
{"name":"IndexNotation.IndexList.getDual?_get_neq_self","declaration":"theorem IndexNotation.IndexList.getDual?_get_neq_self {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : ¬Option.get (IndexNotation.IndexList.getDual? l i) h = i"}
{"name":"IndexNotation.IndexList.withDualInOther","declaration":"/-- The finite set of indices of an index list which have a dual in another provided index list. -/\ndef IndexNotation.IndexList.withDualInOther {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Finset (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.withUniqueDualGT","declaration":"/-- The finite set of those indices of `l` which have a unique dual, and for which\nthat dual is less-then (determined by the ordering on `Fin`) then the index itself. -/\ndef IndexNotation.IndexList.withUniqueDualGT {X : Type} (l : IndexNotation.IndexList X) : Finset (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.mem_withDual_of_withUniqueDual","declaration":"theorem IndexNotation.IndexList.mem_withDual_of_withUniqueDual {X : Type} (l : IndexNotation.IndexList X) (i : { x // x ∈ IndexNotation.IndexList.withUniqueDual l }) : ↑i ∈ IndexNotation.IndexList.withDual l"}
{"name":"IndexNotation.IndexList.mem_withUniqueDualInOther_isSome","declaration":"theorem IndexNotation.IndexList.mem_withUniqueDualInOther_isSome {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (hi : i ∈ IndexNotation.IndexList.withUniqueDualInOther l l2) : Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true"}
{"name":"IndexNotation.IndexList.AreDualInSelf.append_inr_inr","declaration":"theorem IndexNotation.IndexList.AreDualInSelf.append_inr_inr {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l2)) (j : Fin (IndexNotation.IndexList.length l2)) : IndexNotation.IndexList.AreDualInSelf (l ++ l2) (IndexNotation.IndexList.appendEquiv (Sum.inr i))\n    (IndexNotation.IndexList.appendEquiv (Sum.inr j)) ↔\n  IndexNotation.IndexList.AreDualInSelf l2 i j"}
{"name":"IndexNotation.IndexList.getDualInOther?_getDualInOther?_get_isSome","declaration":"theorem IndexNotation.IndexList.getDualInOther?_getDualInOther?_get_isSome {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true) : Option.isSome\n    (IndexNotation.IndexList.getDualInOther? l2 l (Option.get (IndexNotation.IndexList.getDualInOther? l l2 i) h)) =\n  true"}
{"name":"IndexNotation.IndexList.AreDualInSelf.instDecidableAreDualInSelf","declaration":"instance IndexNotation.IndexList.AreDualInSelf.instDecidableAreDualInSelf {X : Type} {l : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l)) : Decidable (IndexNotation.IndexList.AreDualInSelf l i j)"}
{"name":"IndexNotation.IndexList.getDual?_of_areDualInSelf","declaration":"theorem IndexNotation.IndexList.getDual?_of_areDualInSelf {X : Type} (l : IndexNotation.IndexList X) {i : Fin (IndexNotation.IndexList.length l)} {j : Fin (IndexNotation.IndexList.length l)} (h : IndexNotation.IndexList.AreDualInSelf l i j) : IndexNotation.IndexList.getDual? l j = some i ∨\n  IndexNotation.IndexList.getDual? l i = some j ∨\n    IndexNotation.IndexList.getDual? l j = IndexNotation.IndexList.getDual? l i"}
{"name":"IndexNotation.IndexList.getDualInOther?","declaration":"/-- Given an `i`, if a dual exists in the other list,\noutputs the first such dual, otherwise outputs `none`. -/\ndef IndexNotation.IndexList.getDualInOther? {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : Option (Fin (IndexNotation.IndexList.length l2))"}
{"name":"IndexNotation.IndexList.not_mem_withDual_of_withUniqueDualInOther","declaration":"theorem IndexNotation.IndexList.not_mem_withDual_of_withUniqueDualInOther {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : { x // x ∈ IndexNotation.IndexList.withUniqueDualInOther l l2 }) : ↑i ∉ IndexNotation.IndexList.withDual l"}
{"name":"IndexNotation.IndexList.AreDualInSelf.append_inl_inl","declaration":"theorem IndexNotation.IndexList.AreDualInSelf.append_inl_inl {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {i : Fin (IndexNotation.IndexList.length l)} {j : Fin (IndexNotation.IndexList.length l)} : IndexNotation.IndexList.AreDualInSelf (l ++ l2) (IndexNotation.IndexList.appendEquiv (Sum.inl i))\n    (IndexNotation.IndexList.appendEquiv (Sum.inl j)) ↔\n  IndexNotation.IndexList.AreDualInSelf l i j"}
{"name":"IndexNotation.IndexList.withUniqueDualInOther","declaration":"/-- The finite set of indices of an index list which have a unique dual in another, provided, index\nlist. -/\ndef IndexNotation.IndexList.withUniqueDualInOther {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) : Finset (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.AreDualInOther.symm","declaration":"theorem IndexNotation.IndexList.AreDualInOther.symm {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {i : Fin (IndexNotation.IndexList.length l)} {j : Fin (IndexNotation.IndexList.length l2)} (h : IndexNotation.IndexList.AreDualInOther l l2 i j) : IndexNotation.IndexList.AreDualInOther l2 l j i"}
{"name":"IndexNotation.IndexList.instDecidableAreDualInSelf","declaration":"instance IndexNotation.IndexList.instDecidableAreDualInSelf {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l)) : Decidable (IndexNotation.IndexList.AreDualInSelf l i j)"}
{"name":"IndexNotation.IndexList.withUniqueDualLT_union_withUniqueDualGT","declaration":"theorem IndexNotation.IndexList.withUniqueDualLT_union_withUniqueDualGT {X : Type} (l : IndexNotation.IndexList X) : IndexNotation.IndexList.withUniqueDualLT l ∪ IndexNotation.IndexList.withUniqueDualGT l =\n  IndexNotation.IndexList.withUniqueDual l"}
{"name":"IndexNotation.IndexList.AreDualInSelf.self_false","declaration":"theorem IndexNotation.IndexList.AreDualInSelf.self_false {X : Type} {l : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) : ¬IndexNotation.IndexList.AreDualInSelf l i i"}
{"name":"IndexNotation.IndexList.withUniqueDual","declaration":"/-- The finite set of indices of an index list which have a unique dual in that index list. -/\ndef IndexNotation.IndexList.withUniqueDual {X : Type} (l : IndexNotation.IndexList X) : Finset (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.not_mem_withDual_iff_isNone","declaration":"theorem IndexNotation.IndexList.not_mem_withDual_iff_isNone {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : i ∉ IndexNotation.IndexList.withDual l ↔ Option.isNone (IndexNotation.IndexList.getDual? l i) = true"}
{"name":"IndexNotation.IndexList.instDecidableAreDualInOther","declaration":"instance IndexNotation.IndexList.instDecidableAreDualInOther {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l2)) : Decidable (IndexNotation.IndexList.AreDualInOther l l2 i j)"}
{"name":"IndexNotation.IndexList.getDual?_getDual?_get_isSome","declaration":"theorem IndexNotation.IndexList.getDual?_getDual?_get_isSome {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : Option.isSome (IndexNotation.IndexList.getDual? l (Option.get (IndexNotation.IndexList.getDual? l i) h)) = true"}
{"name":"IndexNotation.IndexList.mem_withUniqueDual_of_mem_withUniqueDualLt","declaration":"theorem IndexNotation.IndexList.mem_withUniqueDual_of_mem_withUniqueDualLt {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withUniqueDualLT l) : i ∈ IndexNotation.IndexList.withUniqueDual l"}
{"name":"IndexNotation.IndexList.AreDualInSelf.append_inr_inl","declaration":"theorem IndexNotation.IndexList.AreDualInSelf.append_inr_inl {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l2)) (j : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.AreDualInSelf (l ++ l2) (IndexNotation.IndexList.appendEquiv (Sum.inr i))\n    (IndexNotation.IndexList.appendEquiv (Sum.inl j)) =\n  IndexNotation.IndexList.AreDualInOther l2 l i j"}
{"name":"IndexNotation.IndexList.withoutDual","declaration":"/-- The finite set of indices of an index list which do not have a dual. -/\ndef IndexNotation.IndexList.withoutDual {X : Type} (l : IndexNotation.IndexList X) : Finset (Fin (IndexNotation.IndexList.length l))"}
{"name":"IndexNotation.IndexList.mem_withDual_iff_exists","declaration":"theorem IndexNotation.IndexList.mem_withDual_iff_exists {X : Type} (l : IndexNotation.IndexList X) {i : Fin (IndexNotation.IndexList.length l)} : i ∈ IndexNotation.IndexList.withDual l ↔ ∃ j, IndexNotation.IndexList.AreDualInSelf l i j"}
{"name":"IndexNotation.IndexList.getDualInOther?_getDualInOther?_get_self","declaration":"theorem IndexNotation.IndexList.getDualInOther?_getDualInOther?_get_self {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.getDualInOther? l l (Option.get (IndexNotation.IndexList.getDualInOther? l l i) ⋯) =\n  some (Option.get (IndexNotation.IndexList.getDualInOther? l l i) ⋯)"}
{"name":"IndexNotation.IndexList.mem_withUniqueDual_of_mem_withUniqueDualGt","declaration":"theorem IndexNotation.IndexList.mem_withUniqueDual_of_mem_withUniqueDualGt {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withUniqueDualGT l) : i ∈ IndexNotation.IndexList.withUniqueDual l"}
{"name":"IndexNotation.IndexList.mem_withUniqueDual_isSome","declaration":"theorem IndexNotation.IndexList.mem_withUniqueDual_isSome {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withUniqueDual l) : Option.isSome (IndexNotation.IndexList.getDual? l i) = true"}
{"name":"IndexNotation.IndexList.instDecidableLtOptionFinLengthInstLTOptionInstLTFin","declaration":"instance IndexNotation.IndexList.instDecidableLtOptionFinLengthInstLTOptionInstLTFin {X : Type} (l : IndexNotation.IndexList X) (i : Option (Fin (IndexNotation.IndexList.length l))) (j : Option (Fin (IndexNotation.IndexList.length l))) : Decidable (i < j)"}
{"name":"IndexNotation.IndexList.AreDualInOther.of_append_inl","declaration":"theorem IndexNotation.IndexList.AreDualInOther.of_append_inl {X : Type} {l : IndexNotation.IndexList X} {l2 : IndexNotation.IndexList X} {l3 : IndexNotation.IndexList X} (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l2)) : IndexNotation.IndexList.AreDualInOther l (l2 ++ l3) i (IndexNotation.IndexList.appendEquiv (Sum.inl j)) ↔\n  IndexNotation.IndexList.AreDualInOther l l2 i j"}
{"name":"IndexNotation.IndexList.withDual_disjoint_withoutDual","declaration":"theorem IndexNotation.IndexList.withDual_disjoint_withoutDual {X : Type} (l : IndexNotation.IndexList X) : Disjoint (IndexNotation.IndexList.withDual l) (IndexNotation.IndexList.withoutDual l)"}
{"name":"IndexNotation.IndexList.AreDualInOther","declaration":"/-- Two indices in different `IndexLists` are dual to one another if they have the same `id`. -/\ndef IndexNotation.IndexList.AreDualInOther {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l2)) : Prop"}
{"name":"IndexNotation.IndexList.AreDualInSelf","declaration":"/-- Two indices are dual if they are not equivalent, but have the same id. -/\ndef IndexNotation.IndexList.AreDualInSelf {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (j : Fin (IndexNotation.IndexList.length l)) : Prop"}
{"name":"IndexNotation.IndexList.mem_withInDualOther_iff_isSome","declaration":"theorem IndexNotation.IndexList.mem_withInDualOther_iff_isSome {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : i ∈ IndexNotation.IndexList.withDualInOther l l2 ↔ Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true"}
{"name":"IndexNotation.IndexList.getDual?_get_id","declaration":"theorem IndexNotation.IndexList.getDual?_get_id {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : IndexNotation.IndexList.idMap l (Option.get (IndexNotation.IndexList.getDual? l i) h) =\n  IndexNotation.IndexList.idMap l i"}
{"name":"IndexNotation.IndexList.getDualInOther?_isSome_iff_exists","declaration":"theorem IndexNotation.IndexList.getDualInOther?_isSome_iff_exists {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true ↔\n  ∃ j, IndexNotation.IndexList.AreDualInOther l l2 i j"}
