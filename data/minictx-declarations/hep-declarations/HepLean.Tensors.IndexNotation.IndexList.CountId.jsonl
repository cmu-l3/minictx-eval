{"name":"IndexNotation.IndexList.getDualInOther?_countId_right","declaration":"theorem IndexNotation.IndexList.getDualInOther?_countId_right {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true) : IndexNotation.IndexList.countId l2 l2.val[↑(Option.get (IndexNotation.IndexList.getDualInOther? l l2 i) h)] =\n  IndexNotation.IndexList.countId l2 (List.get l.val i)"}
{"name":"IndexNotation.IndexList.filter_id_of_countId_eq_two","declaration":"theorem IndexNotation.IndexList.filter_id_of_countId_eq_two {X : Type} (l : IndexNotation.IndexList X) {i : Fin (IndexNotation.IndexList.length l)} (h : IndexNotation.IndexList.countId l (List.get l.val i) = 2) : List.filter (fun J => decide (IndexNotation.Index.id (List.get l.val i) = IndexNotation.Index.id J)) l.val =\n    [List.get l.val i, List.get l.val (Option.get (IndexNotation.IndexList.getDual? l i) ⋯)] ∨\n  List.filter (fun J => decide (IndexNotation.Index.id (List.get l.val i) = IndexNotation.Index.id J)) l.val =\n    [List.get l.val (Option.get (IndexNotation.IndexList.getDual? l i) ⋯), List.get l.val i]"}
{"name":"IndexNotation.IndexList.countId_append","declaration":"theorem IndexNotation.IndexList.countId_append {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (I : IndexNotation.Index X) : IndexNotation.IndexList.countId (l ++ l2) I = IndexNotation.IndexList.countId l I + IndexNotation.IndexList.countId l2 I"}
{"name":"IndexNotation.IndexList.getDual?_countId","declaration":"theorem IndexNotation.IndexList.getDual?_countId {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDual? l i) = true) : IndexNotation.IndexList.countId l l.val[↑(Option.get (IndexNotation.IndexList.getDual? l i) h)] =\n  IndexNotation.IndexList.countId l (List.get l.val i)"}
{"name":"IndexNotation.IndexList.filter_finRange","declaration":"theorem IndexNotation.IndexList.filter_finRange {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : List.filter (fun j => decide (i = j)) (List.finRange (IndexNotation.IndexList.length l)) = [i]"}
{"name":"IndexNotation.IndexList.countId_append_symm","declaration":"theorem IndexNotation.IndexList.countId_append_symm {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (I : IndexNotation.Index X) : IndexNotation.IndexList.countId (l ++ l2) I = IndexNotation.IndexList.countId (l2 ++ l) I"}
{"name":"IndexNotation.IndexList.mem_withUniqueDual_of_countId_eq_two","declaration":"theorem IndexNotation.IndexList.mem_withUniqueDual_of_countId_eq_two {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : IndexNotation.IndexList.countId l (List.get l.val i) = 2) : i ∈ IndexNotation.IndexList.withUniqueDual l"}
{"name":"IndexNotation.IndexList.mem_withUniqueDual_iff_countId_eq_two","declaration":"theorem IndexNotation.IndexList.mem_withUniqueDual_iff_countId_eq_two {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : i ∈ IndexNotation.IndexList.withUniqueDual l ↔ IndexNotation.IndexList.countId l (List.get l.val i) = 2"}
{"name":"IndexNotation.IndexList.countId_get_other","declaration":"theorem IndexNotation.IndexList.countId_get_other {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.countId l2 (List.get l.val i) =\n  List.countP (fun j => decide (IndexNotation.IndexList.AreDualInOther l l2 i j))\n    (List.finRange (IndexNotation.IndexList.length l2))"}
{"name":"IndexNotation.IndexList.countId_eq_length_filter","declaration":"theorem IndexNotation.IndexList.countId_eq_length_filter {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) : IndexNotation.IndexList.countId l I =\n  List.length (List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val)"}
{"name":"IndexNotation.IndexList.getDualInOther?_countId_left","declaration":"theorem IndexNotation.IndexList.getDualInOther?_countId_left {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : Option.isSome (IndexNotation.IndexList.getDualInOther? l l2 i) = true) : IndexNotation.IndexList.countId l l2.val[↑(Option.get (IndexNotation.IndexList.getDualInOther? l l2 i) h)] =\n  IndexNotation.IndexList.countId l (List.get l.val i)"}
{"name":"IndexNotation.IndexList.filter_id_of_countId_eq_zero'","declaration":"theorem IndexNotation.IndexList.filter_id_of_countId_eq_zero' {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} (h1 : IndexNotation.IndexList.countId l I = 0) : List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val = []"}
{"name":"IndexNotation.IndexList.mem_withoutDual_iff_countId_eq_one","declaration":"theorem IndexNotation.IndexList.mem_withoutDual_iff_countId_eq_one {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : i ∈ IndexNotation.IndexList.withoutDual l ↔ IndexNotation.IndexList.countId l (List.get l.val i) = 1"}
{"name":"List.isEmpty_iff_length_eq_zero","declaration":"theorem List.isEmpty_iff_length_eq_zero {α : Type u_1} {l : List α} : List.isEmpty l = true ↔ List.length l = 0"}
{"name":"IndexNotation.IndexList.countId_eq_two_of_mem_withUniqueDual","declaration":"theorem IndexNotation.IndexList.countId_eq_two_of_mem_withUniqueDual {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withUniqueDual l) : IndexNotation.IndexList.countId l (List.get l.val i) = 2"}
{"name":"List.getElem_indexOf","declaration":"theorem List.getElem_indexOf {α : Type u_1} [DecidableEq α] {a : α} {l : List α} (h : List.indexOf a l < List.length l) : l[List.indexOf a l] = a"}
{"name":"IndexNotation.IndexList.countId","declaration":"/-- The number of times the id of an index `I` appears in a list of indices `l`. -/\ndef IndexNotation.IndexList.countId {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) : ℕ"}
{"name":"IndexNotation.IndexList.mem_withDual_iff_countId_gt_one","declaration":"theorem IndexNotation.IndexList.mem_withDual_iff_countId_gt_one {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : i ∈ IndexNotation.IndexList.withDual l ↔ 1 < IndexNotation.IndexList.countId l (List.get l.val i)"}
{"name":"IndexNotation.IndexList.mem_withDualInOther_iff_countId_neq_zero","declaration":"theorem IndexNotation.IndexList.mem_withDualInOther_iff_countId_neq_zero {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : i ∈ IndexNotation.IndexList.withDualInOther l l2 ↔ IndexNotation.IndexList.countId l2 (List.get l.val i) ≠ 0"}
{"name":"IndexNotation.IndexList.countId_eq_one_of_mem_withUniqueDualInOther","declaration":"theorem IndexNotation.IndexList.countId_eq_one_of_mem_withUniqueDualInOther {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withUniqueDualInOther l l2) : IndexNotation.IndexList.countId l (List.get l.val i) = 1 ∧ IndexNotation.IndexList.countId l2 (List.get l.val i) = 1"}
{"name":"IndexNotation.IndexList.countId_congr","declaration":"theorem IndexNotation.IndexList.countId_congr {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} {J : IndexNotation.Index X} (h : IndexNotation.Index.id I = IndexNotation.Index.id J) : IndexNotation.IndexList.countId l I = IndexNotation.IndexList.countId l J"}
{"name":"IndexNotation.IndexList.countId_of_not_mem_withDual","declaration":"theorem IndexNotation.IndexList.countId_of_not_mem_withDual {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∉ IndexNotation.IndexList.withDual l) : IndexNotation.IndexList.countId l (List.get l.val i) = 1"}
{"name":"IndexNotation.IndexList.countId_of_not_mem_withDualInOther","declaration":"theorem IndexNotation.IndexList.countId_of_not_mem_withDualInOther {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∉ IndexNotation.IndexList.withDualInOther l l2) : IndexNotation.IndexList.countId l2 (List.get l.val i) = 0"}
{"name":"IndexNotation.IndexList.countId_index_neq_zero","declaration":"theorem IndexNotation.IndexList.countId_index_neq_zero {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.countId l (List.get l.val i) ≠ 0"}
{"name":"IndexNotation.IndexList.getDual?_isSome_of_countId_eq_two","declaration":"theorem IndexNotation.IndexList.getDual?_isSome_of_countId_eq_two {X : Type} (l : IndexNotation.IndexList X) {i : Fin (IndexNotation.IndexList.length l)} (h : IndexNotation.IndexList.countId l (List.get l.val i) = 2) : Option.isSome (IndexNotation.IndexList.getDual? l i) = true"}
{"name":"List.getElem_mem","declaration":"theorem List.getElem_mem {α : Type u_1} (l : List α) (n : ℕ) (h : n < List.length l) : l[n] ∈ l"}
{"name":"List.isEmpty_iff","declaration":"theorem List.isEmpty_iff {α : Type u_1} {l : List α} : List.isEmpty l = true ↔ l = []"}
{"name":"IndexNotation.IndexList.filter_id_of_countId_eq_one","declaration":"theorem IndexNotation.IndexList.filter_id_of_countId_eq_one {X : Type} (l : IndexNotation.IndexList X) {i : Fin (IndexNotation.IndexList.length l)} (h1 : IndexNotation.IndexList.countId l (List.get l.val i) = 1) : List.filter (fun J => decide (IndexNotation.Index.id (List.get l.val i) = IndexNotation.Index.id J)) l.val =\n  [List.get l.val i]"}
{"name":"IndexNotation.IndexList.countId_neq_zero_of_mem_withDualInOther","declaration":"theorem IndexNotation.IndexList.countId_neq_zero_of_mem_withDualInOther {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withDualInOther l l2) : IndexNotation.IndexList.countId l2 (List.get l.val i) ≠ 0"}
{"name":"List.isEmpty_false_iff_exists_mem","declaration":"theorem List.isEmpty_false_iff_exists_mem {α : Type u_1} (xs : List α) : List.isEmpty xs = false ↔ ∃ x, x ∈ xs"}
{"name":"IndexNotation.IndexList.countId_cons_eq_two","declaration":"theorem IndexNotation.IndexList.countId_cons_eq_two {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} : IndexNotation.IndexList.countId (IndexNotation.IndexList.cons l I) I = 2 ↔ IndexNotation.IndexList.countId l I = 1"}
{"name":"IndexNotation.IndexList.filter_id_of_countId_eq_one_mem","declaration":"theorem IndexNotation.IndexList.filter_id_of_countId_eq_one_mem {X : Type} (l : IndexNotation.IndexList X) {I : IndexNotation.Index X} (hI : I ∈ l.val) (h : IndexNotation.IndexList.countId l I = 1) : List.filter (fun J => decide (IndexNotation.Index.id I = IndexNotation.Index.id J)) l.val = [I]"}
{"name":"IndexNotation.IndexList.countId_get","declaration":"theorem IndexNotation.IndexList.countId_get {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : IndexNotation.IndexList.countId l (List.get l.val i) =\n  List.countP (fun j => decide (IndexNotation.IndexList.AreDualInSelf l i j))\n      (List.finRange (IndexNotation.IndexList.length l)) +\n    1"}
{"name":"IndexNotation.IndexList.countId_eq_one_append_mem_right_other_eq_zero","declaration":"theorem IndexNotation.IndexList.countId_eq_one_append_mem_right_other_eq_zero {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) {I : IndexNotation.Index X} (hI : I ∈ l2.val) (h : IndexNotation.IndexList.countId (l ++ l2) I = 1) : IndexNotation.IndexList.countId l I = 0"}
{"name":"IndexNotation.IndexList.filter_id_of_countId_eq_zero","declaration":"theorem IndexNotation.IndexList.filter_id_of_countId_eq_zero {X : Type} (l : IndexNotation.IndexList X) {i : Fin (IndexNotation.IndexList.length l)} (h1 : IndexNotation.IndexList.countId l (List.get l.val i) = 0) : List.filter (fun J => decide (IndexNotation.Index.id (List.get l.val i) = IndexNotation.Index.id J)) l.val = []"}
{"name":"IndexNotation.IndexList.mem_withUniqueDualInOther_of_countId_eq_one","declaration":"theorem IndexNotation.IndexList.mem_withUniqueDualInOther_of_countId_eq_one {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : IndexNotation.IndexList.countId l (List.get l.val i) = 1 ∧ IndexNotation.IndexList.countId l2 (List.get l.val i) = 1) : i ∈ IndexNotation.IndexList.withUniqueDualInOther l l2"}
{"name":"IndexNotation.IndexList.mem_withUniqueDualInOther_iff_countId_eq_one","declaration":"theorem IndexNotation.IndexList.mem_withUniqueDualInOther_iff_countId_eq_one {X : Type} [DecidableEq X] (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) : i ∈ IndexNotation.IndexList.withUniqueDualInOther l l2 ↔\n  IndexNotation.IndexList.countId l (List.get l.val i) = 1 ∧ IndexNotation.IndexList.countId l2 (List.get l.val i) = 1"}
{"name":"IndexNotation.IndexList.countId_neq_zero_mem","declaration":"theorem IndexNotation.IndexList.countId_neq_zero_mem {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) (h : IndexNotation.IndexList.countId l I ≠ 0) : ∃ I' ∈ l.val, IndexNotation.Index.id I = IndexNotation.Index.id I'"}
{"name":"Bool.and_iff_right_iff_imp","declaration":"theorem Bool.and_iff_right_iff_imp (a : Bool) (b : Bool) : (a && b) = b ↔ b = true → a = true"}
{"name":"IndexNotation.IndexList.countId_eq_one_append_mem_right_self_eq_one","declaration":"theorem IndexNotation.IndexList.countId_eq_one_append_mem_right_self_eq_one {X : Type} (l : IndexNotation.IndexList X) (l2 : IndexNotation.IndexList X) {I : IndexNotation.Index X} (hI : I ∈ l2.val) (h : IndexNotation.IndexList.countId (l ++ l2) I = 1) : IndexNotation.IndexList.countId l2 I = 1"}
{"name":"IndexNotation.IndexList.countId_mem","declaration":"theorem IndexNotation.IndexList.countId_mem {X : Type} (l : IndexNotation.IndexList X) (I : IndexNotation.Index X) (hI : I ∈ l.val) : IndexNotation.IndexList.countId l I ≠ 0"}
{"name":"List.isEmpty_eq_true","declaration":"theorem List.isEmpty_eq_true {α : Type u_1} {l : List α} : List.isEmpty l = true ↔ l = []"}
{"name":"IndexNotation.IndexList.countId_gt_zero_of_mem_withDual","declaration":"theorem IndexNotation.IndexList.countId_gt_zero_of_mem_withDual {X : Type} (l : IndexNotation.IndexList X) (i : Fin (IndexNotation.IndexList.length l)) (h : i ∈ IndexNotation.IndexList.withDual l) : 1 < IndexNotation.IndexList.countId l (List.get l.val i)"}
