{"name":"TensorStructure.instModuleTensorToSemiringInstAddCommMonoidTensor","declaration":"instance TensorStructure.instModuleTensorToSemiringInstAddCommMonoidTensor {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} : Module R (TensorStructure.Tensor ğ“£ cX)"}
{"name":"TensorColor.colorSetoid","declaration":"/-- The structure of a setoid on colors, two colors are related if they are equal,\nor dual. -/\ninstance TensorColor.colorSetoid (ğ“’ : TensorColor) : Setoid ğ“’.Color"}
{"name":"TensorStructure.decompEmbed","declaration":"/-- Decomposes a tensor into a tensor product of two tensors\none which has indices in the image of the given embedding, and the other has indices in\nthe complement of that image. -/\ndef TensorStructure.decompEmbed {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} (f : Y â†ª X) : TensorStructure.Tensor ğ“£ cX â‰ƒâ‚—[R]\n  TensorProduct R (TensorStructure.Tensor ğ“£ (TensorStructure.decompEmbedColorLeft ğ“£ cX f))\n    (TensorStructure.Tensor ğ“£ (cX âˆ˜ â‡‘f))"}
{"name":"TensorColor.colorQuot","declaration":"/-- A map taking a color to its equivalence class in `colorSetoid`. -/\ndef TensorColor.colorQuot (ğ“’ : TensorColor) (Î¼ : ğ“’.Color) : Quotient (TensorColor.colorSetoid ğ“’)"}
{"name":"TensorStructure.elimPureTensor_update_right","declaration":"theorem TensorStructure.elimPureTensor_update_right {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (p : TensorStructure.PureTensor ğ“£ cX) (q : TensorStructure.PureTensor ğ“£ cY) (y : Y) (r : ğ“£.ColorModule (cY y)) : TensorStructure.elimPureTensor ğ“£ p (Function.update q y r) =\n  Function.update (TensorStructure.elimPureTensor ğ“£ p q) (Sum.inr y) r"}
{"name":"TensorStructure.mapIso_trans","declaration":"theorem TensorStructure.mapIso_trans {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} (e : X â‰ƒ Y) (e' : Y â‰ƒ Z) (h : TensorColor.ColorMap.MapIso e cX cY) (h' : TensorColor.ColorMap.MapIso e' cY cZ) : TensorStructure.mapIso ğ“£ e h â‰ªâ‰«â‚— TensorStructure.mapIso ğ“£ e' h' = TensorStructure.mapIso ğ“£ (e.trans e') â‹¯"}
{"name":"TensorStructure.PureTensor","declaration":"/-- The type of pure tensors, i.e. of the form `v1 âŠ— v2 âŠ— v3 âŠ— ...`. -/\ndef TensorStructure.PureTensor {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} (c : X â†’ ğ“£.Color) : Type"}
{"name":"TensorStructure.tensoratorEquiv","declaration":"/-- An equivalence formed by taking the tensor product of tensors. -/\ndef TensorStructure.tensoratorEquiv {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] (c : X â†’ ğ“£.Color) (d : Y â†’ ğ“£.Color) : TensorProduct R (TensorStructure.Tensor ğ“£ c) (TensorStructure.Tensor ğ“£ d) â‰ƒâ‚—[R] TensorStructure.Tensor ğ“£ (Sum.elim c d)"}
{"name":"TensorStructure.mapIso_tprod","declaration":"theorem TensorStructure.mapIso_tprod {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {c : TensorColor.ColorMap ğ“£.toTensorColor X} {d : TensorColor.ColorMap ğ“£.toTensorColor Y} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.MapIso e c d) (f : (i : X) â†’ ğ“£.ColorModule (c i)) : (TensorStructure.mapIso ğ“£ e h) ((PiTensorProduct.tprod R) f) =\n  (PiTensorProduct.tprod R) fun i => (TensorStructure.colorModuleCast ğ“£ â‹¯) (f (e.symm i))"}
{"name":"TensorStructure.mk","declaration":"ctor TensorStructure.mk {R : Type} [CommSemiring R] (toTensorColor : TensorColor) (ColorModule : toTensorColor.Color â†’ Type) (colorModule_addCommMonoid : (Î¼ : toTensorColor.Color) â†’ AddCommMonoid (ColorModule Î¼)) (colorModule_module : (Î¼ : toTensorColor.Color) â†’ Module R (ColorModule Î¼)) (contrDual : (Î¼ : toTensorColor.Color) â†’ TensorProduct R (ColorModule Î¼) (ColorModule (toTensorColor.Ï„ Î¼)) â†’â‚—[R] R) (contrDual_symm : âˆ€ (Î¼ : toTensorColor.Color) (x : ColorModule Î¼) (y : ColorModule (toTensorColor.Ï„ Î¼)),\n  (contrDual Î¼) (x âŠ—â‚œ[R] y) = (contrDual (toTensorColor.Ï„ Î¼)) (y âŠ—â‚œ[R] (Equiv.cast â‹¯) x)) (unit : (Î¼ : toTensorColor.Color) â†’ TensorProduct R (ColorModule (toTensorColor.Ï„ Î¼)) (ColorModule Î¼)) (unit_rid : âˆ€ (Î¼ : toTensorColor.Color) (x : ColorModule Î¼), (TensorStructure.contrLeftAux (contrDual Î¼)) (x âŠ—â‚œ[R] unit Î¼) = x) (metric : (Î¼ : toTensorColor.Color) â†’ TensorProduct R (ColorModule Î¼) (ColorModule Î¼)) (metric_dual : âˆ€ (Î¼ : toTensorColor.Color),\n  (TensorStructure.contrMidAux (contrDual Î¼)) (metric Î¼ âŠ—â‚œ[R] metric (toTensorColor.Ï„ Î¼)) =\n    (TensorProduct.comm R (ColorModule (toTensorColor.Ï„ Î¼)) (ColorModule Î¼)) (unit Î¼)) : TensorStructure R"}
{"name":"TensorColor.ColorMap.MapIso.dual","declaration":"theorem TensorColor.ColorMap.MapIso.dual {X : Type} {Y : Type} {ğ“’ : TensorColor} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} {e : X â‰ƒ Y} (h : TensorColor.ColorMap.MapIso e cX cY) : TensorColor.ColorMap.MapIso e (TensorColor.ColorMap.dual cX) (TensorColor.ColorMap.dual cY)"}
{"name":"TensorStructure.metric_dual","declaration":"/-- The metric contracted with its dual is the unit. -/\ndef TensorStructure.metric_dual {R : Type} [CommSemiring R] (self : TensorStructure R) (Î¼ : self.Color) : (TensorStructure.contrMidAux (self.contrDual Î¼)) (self.metric Î¼ âŠ—â‚œ[R] self.metric (self.Ï„ Î¼)) =\n  (TensorProduct.comm R (self.ColorModule (self.Ï„ Î¼)) (self.ColorModule Î¼)) (self.unit Î¼)"}
{"name":"TensorStructure.decompEmbedColorLeft","declaration":"/-- The restriction of a map from an indexing set to the space to the complement of the image\nof an embedding. -/\ndef TensorStructure.decompEmbedColorLeft {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] (c : X â†’ ğ“£.Color) (f : Y â†ª X) : { x // x âˆˆ (Finset.image (â‡‘f) Finset.univ)á¶œ } â†’ ğ“£.Color"}
{"name":"TensorStructure.inlPureTensor_update_right","declaration":"theorem TensorStructure.inlPureTensor_update_right {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} [DecidableEq (X âŠ• Y)] (f : TensorStructure.PureTensor ğ“£ (Sum.elim cX cY)) (y : Y) (v1 : ğ“£.ColorModule (Sum.elim cX cY (Sum.inr y))) : TensorStructure.inlPureTensor ğ“£ (Function.update f (Sum.inr y) v1) = TensorStructure.inlPureTensor ğ“£ f"}
{"name":"TensorStructure.contrDual_cast","declaration":"theorem TensorStructure.contrDual_cast {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {Î½ : ğ“£.Color} (h : Î¼ = Î½) (x : ğ“£.ColorModule Î¼) (y : ğ“£.ColorModule (ğ“£.Ï„ Î¼)) : (ğ“£.contrDual Î¼) (x âŠ—â‚œ[R] y) =\n  (ğ“£.contrDual Î½) ((TensorStructure.colorModuleCast ğ“£ h) x âŠ—â‚œ[R] (TensorStructure.colorModuleCast ğ“£ â‹¯) y)"}
{"name":"TensorStructure.domCoprod","declaration":"/-- The multi-linear map taking a pure tensor in `ğ“£.PureTensor (Sum.elim cX cY)` and constructing\na vector in `ğ“£.Tensor cX âŠ—[R] ğ“£.Tensor cY`. -/\ndef TensorStructure.domCoprod {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} : MultilinearMap R (fun x => ğ“£.ColorModule (Sum.elim cX cY x))\n  (TensorProduct R (TensorStructure.Tensor ğ“£ cX) (TensorStructure.Tensor ğ“£ cY))"}
{"name":"TensorStructure.mapIso","declaration":"/-- An linear equivalence of tensor spaces given a color-preserving equivalence of indexing sets. -/\ndef TensorStructure.mapIso {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {c : TensorColor.ColorMap ğ“£.toTensorColor X} {d : TensorColor.ColorMap ğ“£.toTensorColor Y} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.MapIso e c d) : TensorStructure.Tensor ğ“£ c â‰ƒâ‚—[R] TensorStructure.Tensor ğ“£ d"}
{"name":"TensorStructure.contrDual_symm_contrRightAux","declaration":"theorem TensorStructure.contrDual_symm_contrRightAux {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {Î½ : ğ“£.Color} {Î· : ğ“£.Color} (h : Î½ = Î·) : â†‘(TensorStructure.colorModuleCast ğ“£ h) âˆ˜â‚— TensorStructure.contrRightAux (ğ“£.contrDual Î¼) =\n  TensorStructure.contrRightAux (ğ“£.contrDual (ğ“£.Ï„ (ğ“£.Ï„ Î¼))) âˆ˜â‚—\n    â†‘(TensorProduct.congr\n        (TensorProduct.congr (TensorStructure.colorModuleCast ğ“£ h) (TensorStructure.colorModuleCast ğ“£ â‹¯))\n        (TensorStructure.colorModuleCast ğ“£ â‹¯))"}
{"name":"TensorStructure.isEmptyEquiv_tprod","declaration":"theorem TensorStructure.isEmptyEquiv_tprod {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} [IsEmpty X] (f : TensorStructure.PureTensor ğ“£ cX) : (TensorStructure.isEmptyEquiv ğ“£) ((PiTensorProduct.tprod R) f) = 1"}
{"name":"TensorStructure.contrRightAux_comp","declaration":"theorem TensorStructure.contrRightAux_comp {R : Type} [CommSemiring R] {V1 : Type} {V2 : Type} {V3 : Type} {V4 : Type} {V5 : Type} [AddCommMonoid V1] [AddCommMonoid V2] [AddCommMonoid V3] [AddCommMonoid V4] [AddCommMonoid V5] [Module R V1] [Module R V3] [Module R V2] [Module R V4] [Module R V5] (f : TensorProduct R V2 V3 â†’â‚—[R] R) (g : TensorProduct R V4 V5 â†’â‚—[R] R) : TensorStructure.contrRightAux f âˆ˜â‚— TensorProduct.map LinearMap.id (TensorStructure.contrRightAux g) =\n  TensorStructure.contrRightAux g âˆ˜â‚—\n    TensorProduct.map (TensorStructure.contrMidAux f) LinearMap.id âˆ˜â‚—\n      â†‘(LinearEquiv.symm (TensorProduct.assoc R (TensorProduct R V1 V2) (TensorProduct R V3 V4) V5))"}
{"name":"TensorColor.Ï„","declaration":"/-- A map taking every color to its dual color. -/\ndef TensorColor.Ï„ (self : TensorColor) : self.Color â†’ self.Color"}
{"name":"TensorStructure.decompEmbedSet","declaration":"/-- The decomposition of a set into a direct sum based on the image of an injection. -/\ndef TensorStructure.decompEmbedSet {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] (f : Y â†ª X) : X â‰ƒ { x // x âˆˆ (Finset.image (â‡‘f) Finset.univ)á¶œ } âŠ• Y"}
{"name":"TensorStructure.metric","declaration":"/-- The metric for a given color. -/\ndef TensorStructure.metric {R : Type} [CommSemiring R] (self : TensorStructure R) (Î¼ : self.Color) : TensorProduct R (self.ColorModule Î¼) (self.ColorModule Î¼)"}
{"name":"TensorStructure.ColorModule","declaration":"/-- To each color we associate a module. -/\ndef TensorStructure.ColorModule {R : Type} [CommSemiring R] (self : TensorStructure R) : self.Color â†’ Type"}
{"name":"TensorStructure.contrLeftAux","declaration":"/-- An auxillary function to contract the vector space `V1` and `V2` in `V1 âŠ—[R] V2 âŠ—[R] V3`. -/\ndef TensorStructure.contrLeftAux {R : Type} [CommSemiring R] {V1 : Type} {V2 : Type} {V3 : Type} [AddCommMonoid V1] [AddCommMonoid V2] [AddCommMonoid V3] [Module R V1] [Module R V2] [Module R V3] (f : TensorProduct R V1 V2 â†’â‚—[R] R) : TensorProduct R V1 (TensorProduct R V2 V3) â†’â‚—[R] V3"}
{"name":"TensorColor.instDecidableEqQuotientColorColorSetoid","declaration":"instance TensorColor.instDecidableEqQuotientColorColorSetoid (ğ“’ : TensorColor) [DecidableEq ğ“’.Color] : DecidableEq (Quotient (TensorColor.colorSetoid ğ“’))"}
{"name":"TensorColor.ColorMap.MapIso.sum","declaration":"theorem TensorColor.ColorMap.MapIso.sum {X : Type} {X' : Type} {Y : Type} {Y' : Type} {ğ“’ : TensorColor} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} {cX' : TensorColor.ColorMap ğ“’ X'} {cY' : TensorColor.ColorMap ğ“’ Y'} {eX : X â‰ƒ X'} {eY : Y â‰ƒ Y'} (hX : TensorColor.ColorMap.MapIso eX cX cX') (hY : TensorColor.ColorMap.MapIso eY cY cY') : TensorColor.ColorMap.MapIso (Equiv.sumCongr eX eY) (TensorColor.ColorMap.sum cX cY) (TensorColor.ColorMap.sum cX' cY')"}
{"name":"TensorStructure.instAddCommMonoidTensor","declaration":"instance TensorStructure.instAddCommMonoidTensor {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} : AddCommMonoid (TensorStructure.Tensor ğ“£ cX)"}
{"name":"TensorColor.ColorMap.MapIso","declaration":"/-- A relation, given an equivalence of types, between ColorMap which is true\nif related by composition of the equivalence. -/\ndef TensorColor.ColorMap.MapIso {X : Type} {Y : Type} {ğ“’ : TensorColor} (e : X â‰ƒ Y) (cX : TensorColor.ColorMap ğ“’ X) (cY : TensorColor.ColorMap ğ“’ Y) : Prop"}
{"name":"TensorStructure.colorModule_module","declaration":"/-- Each `ColorModule` has the structure of a module over `R`. -/\ndef TensorStructure.colorModule_module {R : Type} [CommSemiring R] (self : TensorStructure R) (Î¼ : self.Color) : Module R (self.ColorModule Î¼)"}
{"name":"TensorStructure.contrDual","declaration":"/-- The contraction of a vector with a vector with dual color. -/\ndef TensorStructure.contrDual {R : Type} [CommSemiring R] (self : TensorStructure R) (Î¼ : self.Color) : TensorProduct R (self.ColorModule Î¼) (self.ColorModule (self.Ï„ Î¼)) â†’â‚—[R] R"}
{"name":"TensorColor.colorRel","declaration":"/-- A relation on colors which is true if the two colors are equal or are duals. -/\ndef TensorColor.colorRel (ğ“’ : TensorColor) (Î¼ : ğ“’.Color) (Î½ : ğ“’.Color) : Prop"}
{"name":"TensorColor.instDecidableEquivColorInstHasEquivColorSetoid","declaration":"instance TensorColor.instDecidableEquivColorInstHasEquivColorSetoid (ğ“’ : TensorColor) [DecidableEq ğ“’.Color] (Î¼ : ğ“’.Color) (Î½ : ğ“’.Color) : Decidable (Î¼ â‰ˆ Î½)"}
{"name":"TensorStructure.mapIso_mapIso","declaration":"theorem TensorStructure.mapIso_mapIso {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} (e : X â‰ƒ Y) (e' : Y â‰ƒ Z) (h : TensorColor.ColorMap.MapIso e cX cY) (h' : TensorColor.ColorMap.MapIso e' cY cZ) (T : TensorStructure.Tensor ğ“£ cX) : (TensorStructure.mapIso ğ“£ e' h') ((TensorStructure.mapIso ğ“£ e h) T) = (TensorStructure.mapIso ğ“£ (e.trans e') â‹¯) T"}
{"name":"TensorStructure.unit_rid","declaration":"/-- The unit is a right identity. -/\ndef TensorStructure.unit_rid {R : Type} [CommSemiring R] (self : TensorStructure R) (Î¼ : self.Color) (x : self.ColorModule Î¼) : (TensorStructure.contrLeftAux (self.contrDual Î¼)) (x âŠ—â‚œ[R] self.unit Î¼) = x"}
{"name":"TensorStructure.isEmptyEquiv","declaration":"/-- The equivalence between `ğ“£.Tensor cX` and `R` when the indexing set `X` is empty. -/\ndef TensorStructure.isEmptyEquiv {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} [IsEmpty X] : TensorStructure.Tensor ğ“£ cX â‰ƒâ‚—[R] R"}
{"name":"TensorStructure.tensoratorEquiv_symm_tprod","declaration":"theorem TensorStructure.tensoratorEquiv_symm_tprod {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (f : TensorStructure.PureTensor ğ“£ (Sum.elim cX cY)) : (LinearEquiv.symm (TensorStructure.tensoratorEquiv ğ“£ cX cY)) ((PiTensorProduct.tprod R) f) =\n  (PiTensorProduct.tprod R) (TensorStructure.inlPureTensor ğ“£ f) âŠ—â‚œ[R]\n    (PiTensorProduct.tprod R) (TensorStructure.inrPureTensor ğ“£ f)"}
{"name":"TensorStructure.elimPureTensor_update_left","declaration":"theorem TensorStructure.elimPureTensor_update_left {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (p : TensorStructure.PureTensor ğ“£ cX) (q : TensorStructure.PureTensor ğ“£ cY) (x : X) (r : ğ“£.ColorModule (cX x)) : TensorStructure.elimPureTensor ğ“£ (Function.update p x r) q =\n  Function.update (TensorStructure.elimPureTensor ğ“£ p q) (Sum.inl x) r"}
{"name":"TensorStructure.tensoratorEquiv_mapIso_apply","declaration":"theorem TensorStructure.tensoratorEquiv_mapIso_apply {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [DecidableEq X] [DecidableEq Y] [DecidableEq Z] [DecidableEq W] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {cW : TensorColor.ColorMap ğ“£.toTensorColor W} (e' : Z â‰ƒ Y) (e'' : W â‰ƒ X) (h' : TensorColor.ColorMap.MapIso e' cZ cY) (h'' : TensorColor.ColorMap.MapIso e'' cW cX) (x : TensorProduct R (TensorStructure.Tensor ğ“£ cW) (TensorStructure.Tensor ğ“£ cZ)) : (TensorStructure.tensoratorEquiv ğ“£ cX cY)\n    ((TensorProduct.congr (TensorStructure.mapIso ğ“£ e'' h'') (TensorStructure.mapIso ğ“£ e' h')) x) =\n  (TensorStructure.mapIso ğ“£ (Equiv.sumCongr e'' e') â‹¯) ((TensorStructure.tensoratorEquiv ğ“£ cW cZ) x)"}
{"name":"TensorColor.Color","declaration":"/-- The allowed colors of indices.\nFor example for a real Lorentz tensor these are `{up, down}`. -/\ndef TensorColor.Color (self : TensorColor) : Type"}
{"name":"TensorStructure.tensoratorEquiv_tmul_tprod","declaration":"theorem TensorStructure.tensoratorEquiv_tmul_tprod {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (p : TensorStructure.PureTensor ğ“£ cX) (q : TensorStructure.PureTensor ğ“£ cY) : (TensorStructure.tensoratorEquiv ğ“£ cX cY) ((PiTensorProduct.tprod R) p âŠ—â‚œ[R] (PiTensorProduct.tprod R) q) =\n  (PiTensorProduct.tprod R) (TensorStructure.elimPureTensor ğ“£ p q)"}
{"name":"TensorStructure.inrPureTensor_update_left","declaration":"theorem TensorStructure.inrPureTensor_update_left {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} [DecidableEq (X âŠ• Y)] (f : TensorStructure.PureTensor ğ“£ (Sum.elim cX cY)) (x : X) (v1 : ğ“£.ColorModule (Sum.elim cX cY (Sum.inl x))) : TensorStructure.inrPureTensor ğ“£ (Function.update f (Sum.inl x) v1) = TensorStructure.inrPureTensor ğ“£ f"}
{"name":"TensorStructure.mapIso_symm","declaration":"theorem TensorStructure.mapIso_symm {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (e : X â‰ƒ Y) (h : TensorColor.ColorMap.MapIso e cX cY) : LinearEquiv.symm (TensorStructure.mapIso ğ“£ e h) = TensorStructure.mapIso ğ“£ e.symm â‹¯"}
{"name":"TensorColor.ColorMap","declaration":"/-- The types of maps from an `X` to `ğ“’.Color`. -/\ndef TensorColor.ColorMap (ğ“’ : TensorColor) (X : Type) : Type"}
{"name":"TensorStructure.tensorProd_piTensorProd_ext","declaration":"theorem TensorStructure.tensorProd_piTensorProd_ext {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {M : Type} [AddCommMonoid M] [Module R M] {f : TensorProduct R (TensorStructure.Tensor ğ“£ cX) (TensorStructure.Tensor ğ“£ cY) â†’â‚—[R] M} {g : TensorProduct R (TensorStructure.Tensor ğ“£ cX) (TensorStructure.Tensor ğ“£ cY) â†’â‚—[R] M} (h : âˆ€ (p : (i : X) â†’ ğ“£.ColorModule (cX i)) (q : (i : Y) â†’ ğ“£.ColorModule (cY i)),\n  f ((PiTensorProduct.tprod R) p âŠ—â‚œ[R] (PiTensorProduct.tprod R) q) =\n    g ((PiTensorProduct.tprod R) p âŠ—â‚œ[R] (PiTensorProduct.tprod R) q)) : f = g"}
{"name":"TensorStructure.decompEmbedColorRight","declaration":"/-- The restriction of a map from an indexing set to the space to the image\nof an embedding. -/\ndef TensorStructure.decompEmbedColorRight {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] (c : X â†’ ğ“£.Color) (f : Y â†ª X) : Y â†’ ğ“£.Color"}
{"name":"TensorStructure.instAddCommMonoidColorModule","declaration":"instance TensorStructure.instAddCommMonoidColorModule {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} : AddCommMonoid (ğ“£.ColorModule Î¼)"}
{"name":"TensorStructure.unit","declaration":"/-- The unit of the contraction. -/\ndef TensorStructure.unit {R : Type} [CommSemiring R] (self : TensorStructure R) (Î¼ : self.Color) : TensorProduct R (self.ColorModule (self.Ï„ Î¼)) (self.ColorModule Î¼)"}
{"name":"TensorColor.ColorMap.sum","declaration":"/-- The sum of two color maps, formed by `Sum.elim`. -/\ndef TensorColor.ColorMap.sum {X : Type} {Y : Type} {ğ“’ : TensorColor} (cX : TensorColor.ColorMap ğ“’ X) (cY : TensorColor.ColorMap ğ“’ Y) : TensorColor.ColorMap ğ“’ (X âŠ• Y)"}
{"name":"TensorColor.ColorMap.dual","declaration":"/-- The dual of a color map, formed by composition with `ğ“’.Ï„`. -/\ndef TensorColor.ColorMap.dual {X : Type} {ğ“’ : TensorColor} (cX : TensorColor.ColorMap ğ“’ X) : TensorColor.ColorMap ğ“’ X"}
{"name":"TensorStructure.contrRightAux","declaration":"/-- An auxillary function to contract the vector space `V1` and `V2` in `(V3 âŠ—[R] V1) âŠ—[R] V2`. -/\ndef TensorStructure.contrRightAux {R : Type} [CommSemiring R] {V1 : Type} {V2 : Type} {V3 : Type} [AddCommMonoid V1] [AddCommMonoid V2] [AddCommMonoid V3] [Module R V1] [Module R V2] [Module R V3] (f : TensorProduct R V1 V2 â†’â‚—[R] R) : TensorProduct R (TensorProduct R V3 V1) V2 â†’â‚—[R] V3"}
{"name":"TensorStructure.mapIso_ext","declaration":"theorem TensorStructure.mapIso_ext {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {c : TensorColor.ColorMap ğ“£.toTensorColor X} {d : TensorColor.ColorMap ğ“£.toTensorColor Y} (e : X â‰ƒ Y) (e' : X â‰ƒ Y) (h : TensorColor.ColorMap.MapIso e c d) (h' : TensorColor.ColorMap.MapIso e' c d) (he : e = e') : TensorStructure.mapIso ğ“£ e h = TensorStructure.mapIso ğ“£ e' h'"}
{"name":"TensorStructure.inrPureTensor_update_right","declaration":"theorem TensorStructure.inrPureTensor_update_right {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} [DecidableEq (X âŠ• Y)] (f : TensorStructure.PureTensor ğ“£ (Sum.elim cX cY)) (y : Y) (v1 : ğ“£.ColorModule (Sum.elim cX cY (Sum.inr y))) : TensorStructure.inrPureTensor ğ“£ (Function.update f (Sum.inr y) v1) =\n  Function.update (TensorStructure.inrPureTensor ğ“£ f) y v1"}
{"name":"TensorStructure.tensoratorEquiv_mapIso","declaration":"theorem TensorStructure.tensoratorEquiv_mapIso {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [DecidableEq X] [DecidableEq Y] [DecidableEq Z] [DecidableEq W] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {cW : TensorColor.ColorMap ğ“£.toTensorColor W} (e' : Z â‰ƒ Y) (e'' : W â‰ƒ X) (h' : TensorColor.ColorMap.MapIso e' cZ cY) (h'' : TensorColor.ColorMap.MapIso e'' cW cX) : TensorProduct.congr (TensorStructure.mapIso ğ“£ e'' h'') (TensorStructure.mapIso ğ“£ e' h') â‰ªâ‰«â‚—\n    TensorStructure.tensoratorEquiv ğ“£ cX cY =\n  TensorStructure.tensoratorEquiv ğ“£ cW cZ â‰ªâ‰«â‚— TensorStructure.mapIso ğ“£ (Equiv.sumCongr e'' e') â‹¯"}
{"name":"TensorStructure.contrDual_symm","declaration":"/-- The contraction is symmetric. -/\ndef TensorStructure.contrDual_symm {R : Type} [CommSemiring R] (self : TensorStructure R) (Î¼ : self.Color) (x : self.ColorModule Î¼) (y : self.ColorModule (self.Ï„ Î¼)) : (self.contrDual Î¼) (x âŠ—â‚œ[R] y) = (self.contrDual (self.Ï„ Î¼)) (y âŠ—â‚œ[R] (Equiv.cast â‹¯) x)"}
{"name":"TensorColor.mk","declaration":"ctor TensorColor.mk (Color : Type) (Ï„ : Color â†’ Color) (Ï„_involutive : Function.Involutive Ï„) : TensorColor"}
{"name":"TensorStructure.tensoratorSymm","declaration":"/-- The linear map combining two tensors into a single tensor\nvia the tensor product i.e. `v1 v2 â†¦ v1 âŠ— v2`. -/\ndef TensorStructure.tensoratorSymm {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} : TensorProduct R (TensorStructure.Tensor ğ“£ cX) (TensorStructure.Tensor ğ“£ cY) â†’â‚—[R]\n  TensorStructure.Tensor ğ“£ (Sum.elim cX cY)"}
{"name":"TensorStructure.Tensor","declaration":"/-- The type of tensors given a map from an indexing set `X` to the type of colors,\nspecifying the color of that index. -/\ndef TensorStructure.Tensor {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} (c : TensorColor.ColorMap ğ“£.toTensorColor X) : Type"}
{"name":"TensorStructure.decompEmbed_cond","declaration":"theorem TensorStructure.decompEmbed_cond {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] (c : X â†’ ğ“£.Color) (f : Y â†ª X) : c =\n  Sum.elim (TensorStructure.decompEmbedColorLeft ğ“£ c f) (TensorStructure.decompEmbedColorRight ğ“£ c f) âˆ˜\n    â‡‘(TensorStructure.decompEmbedSet f)"}
{"name":"TensorColor","declaration":"/-- The index color data associated with a tensor structure.\nThis corresponds to a type with an involution. -/\nstructure TensorColor  : Type 1"}
{"name":"TensorStructure","declaration":"/-- An initial structure specifying a tensor system (e.g. a system in which you can\ndefine real Lorentz tensors or Einstein notation convention). -/\nstructure TensorStructure (R : Type) [CommSemiring R] : Type 1"}
{"name":"TensorColor.instDecidableColorRel","declaration":"instance TensorColor.instDecidableColorRel (ğ“’ : TensorColor) [DecidableEq ğ“’.Color] {Î¼ : ğ“’.Color} {Î½ : ğ“’.Color} : Decidable (TensorColor.colorRel ğ“’ Î¼ Î½)"}
{"name":"TensorColor.colorRel_equivalence","declaration":"/-- An equivalence relation on colors which is true if the two colors are equal or are duals. -/\ntheorem TensorColor.colorRel_equivalence (ğ“’ : TensorColor) : Equivalence (TensorColor.colorRel ğ“’)"}
{"name":"TensorStructure.elimPureTensorMulLin","declaration":"/-- The multilinear map taking pure tensors a `ğ“£.PureTensor cX` and a pure tensor in\n`ğ“£.PureTensor cY`, and constructing a tensor in `ğ“£.Tensor (Sum.elim cX cY))`. -/\ndef TensorStructure.elimPureTensorMulLin {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} : MultilinearMap R (fun i => ğ“£.ColorModule (cX i))\n  (MultilinearMap R (fun x => ğ“£.ColorModule (cY x)) (TensorStructure.Tensor ğ“£ (Sum.elim cX cY)))"}
{"name":"TensorStructure.tensoratorEquiv_mapIso_tmul","declaration":"theorem TensorStructure.tensoratorEquiv_mapIso_tmul {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [DecidableEq X] [DecidableEq Y] [DecidableEq Z] [DecidableEq W] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} {cZ : TensorColor.ColorMap ğ“£.toTensorColor Z} {cW : TensorColor.ColorMap ğ“£.toTensorColor W} (e' : Z â‰ƒ Y) (e'' : W â‰ƒ X) (h' : TensorColor.ColorMap.MapIso e' cZ cY) (h'' : TensorColor.ColorMap.MapIso e'' cW cX) (x : TensorStructure.Tensor ğ“£ cW) (y : TensorStructure.Tensor ğ“£ cZ) : (TensorStructure.tensoratorEquiv ğ“£ cX cY)\n    ((TensorStructure.mapIso ğ“£ e'' h'') x âŠ—â‚œ[R] (TensorStructure.mapIso ğ“£ e' h') y) =\n  (TensorStructure.mapIso ğ“£ (Equiv.sumCongr e'' e') â‹¯) ((TensorStructure.tensoratorEquiv ğ“£ cW cZ) (x âŠ—â‚œ[R] y))"}
{"name":"TensorColor.ColorMap.MapIso.symm'","declaration":"theorem TensorColor.ColorMap.MapIso.symm' {X : Type} {Y : Type} {ğ“’ : TensorColor} {e : X â‰ƒ Y} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} : TensorColor.ColorMap.MapIso e cX cY â†” TensorColor.ColorMap.MapIso e.symm cY cX"}
{"name":"TensorStructure.inlPureTensor_update_left","declaration":"theorem TensorStructure.inlPureTensor_update_left {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} [DecidableEq (X âŠ• Y)] (f : TensorStructure.PureTensor ğ“£ (Sum.elim cX cY)) (x : X) (v1 : ğ“£.ColorModule (Sum.elim cX cY (Sum.inl x))) : TensorStructure.inlPureTensor ğ“£ (Function.update f (Sum.inl x) v1) =\n  Function.update (TensorStructure.inlPureTensor ğ“£ f) x v1"}
{"name":"TensorStructure.mapIso_refl","declaration":"theorem TensorStructure.mapIso_refl {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} : TensorStructure.mapIso ğ“£ (Equiv.refl X) â‹¯ = LinearEquiv.refl R (TensorStructure.Tensor ğ“£ cX)"}
{"name":"TensorStructure.colorModule_addCommMonoid","declaration":"/-- Each `ColorModule` has the structure of an additive commutative monoid. -/\ndef TensorStructure.colorModule_addCommMonoid {R : Type} [CommSemiring R] (self : TensorStructure R) (Î¼ : self.Color) : AddCommMonoid (self.ColorModule Î¼)"}
{"name":"TensorStructure.tensorator","declaration":"/-- Splitting a tensor in `ğ“£.Tensor (Sum.elim cX cY)` into the tensor product of two tensors. -/\ndef TensorStructure.tensorator {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} : TensorStructure.Tensor ğ“£ (Sum.elim cX cY) â†’â‚—[R]\n  TensorProduct R (TensorStructure.Tensor ğ“£ cX) (TensorStructure.Tensor ğ“£ cY)"}
{"name":"TensorStructure.instModuleColorModuleToSemiringInstAddCommMonoidColorModule","declaration":"instance TensorStructure.instModuleColorModuleToSemiringInstAddCommMonoidColorModule {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} : Module R (ğ“£.ColorModule Î¼)"}
{"name":"TensorColor.Ï„_involutive","declaration":"/-- The map `Ï„` is an involution. -/\ndef TensorColor.Ï„_involutive (self : TensorColor) : Function.Involutive self.Ï„"}
{"name":"TensorStructure.elimPureTensor","declaration":"/-- A pure tensor in `ğ“£.PureTensor (Sum.elim cX cY)` constructed from a pure tensor\nin `ğ“£.PureTensor cX` and a pure tensor in `ğ“£.PureTensor cY`. -/\ndef TensorStructure.elimPureTensor {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (p : TensorStructure.PureTensor ğ“£ cX) (q : TensorStructure.PureTensor ğ“£ cY) : TensorStructure.PureTensor ğ“£ (Sum.elim cX cY)"}
{"name":"TensorStructure.inlPureTensor","declaration":"/-- The projection of a pure tensor in `ğ“£.PureTensor (Sum.elim cX cY)` onto a pure tensor in\n`ğ“£.PureTensor cX`. -/\ndef TensorStructure.inlPureTensor {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (p : TensorStructure.PureTensor ğ“£ (Sum.elim cX cY)) : TensorStructure.PureTensor ğ“£ cX"}
{"name":"TensorStructure.colorModuleCast","declaration":"/-- Equivalence of `ColorModule` given an equality of colors. -/\ndef TensorStructure.colorModuleCast {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {Î½ : ğ“£.Color} (h : Î¼ = Î½) : ğ“£.ColorModule Î¼ â‰ƒâ‚—[R] ğ“£.ColorModule Î½"}
{"name":"TensorStructure.inrPureTensor","declaration":"/-- The projection of a pure tensor in `ğ“£.PureTensor (Sum.elim cX cY)` onto a pure tensor in\n`ğ“£.PureTensor cY`. -/\ndef TensorStructure.inrPureTensor {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap ğ“£.toTensorColor X} {cY : TensorColor.ColorMap ğ“£.toTensorColor Y} (p : TensorStructure.PureTensor ğ“£ (Sum.elim cX cY)) : TensorStructure.PureTensor ğ“£ cY"}
{"name":"TensorStructure.contrMidAux","declaration":"/-- An auxillary function to contract the vector space `V1` and `V2` in\n`V4 âŠ—[R] V1 âŠ—[R] V2 âŠ—[R] V3`. -/\ndef TensorStructure.contrMidAux {R : Type} [CommSemiring R] {V1 : Type} {V2 : Type} {V3 : Type} {V4 : Type} [AddCommMonoid V1] [AddCommMonoid V2] [AddCommMonoid V3] [AddCommMonoid V4] [Module R V1] [Module R V2] [Module R V3] [Module R V4] (f : TensorProduct R V1 V2 â†’â‚—[R] R) : TensorProduct R (TensorProduct R V4 V1) (TensorProduct R V2 V3) â†’â‚—[R] TensorProduct R V4 V3"}
{"name":"TensorStructure.contrDual_symm_contrRightAux_apply_tmul","declaration":"theorem TensorStructure.contrDual_symm_contrRightAux_apply_tmul {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) {Î¼ : ğ“£.Color} {Î½ : ğ“£.Color} {Î· : ğ“£.Color} (h : Î½ = Î·) (m : TensorProduct R (ğ“£.ColorModule Î½) (ğ“£.ColorModule Î¼)) (x : ğ“£.ColorModule (ğ“£.Ï„ Î¼)) : (TensorStructure.colorModuleCast ğ“£ h) ((TensorStructure.contrRightAux (ğ“£.contrDual Î¼)) (m âŠ—â‚œ[R] x)) =\n  (TensorStructure.contrRightAux (ğ“£.contrDual (ğ“£.Ï„ (ğ“£.Ï„ Î¼))))\n    ((TensorProduct.congr (TensorStructure.colorModuleCast ğ“£ h) (TensorStructure.colorModuleCast ğ“£ â‹¯)) m âŠ—â‚œ[R]\n      (TensorStructure.colorModuleCast ğ“£ â‹¯) x)"}
{"name":"TensorStructure.contrDual_symm'","declaration":"/-- `ğ“£.contrDual (ğ“£.Ï„ Î¼)` in terms of `ğ“£.contrDual Î¼`. -/\ntheorem TensorStructure.contrDual_symm' {R : Type} [CommSemiring R] (ğ“£ : TensorStructure R) (Î¼ : ğ“£.Color) (x : ğ“£.ColorModule (ğ“£.Ï„ Î¼)) (y : ğ“£.ColorModule (ğ“£.Ï„ (ğ“£.Ï„ Î¼))) : (ğ“£.contrDual (ğ“£.Ï„ Î¼)) (x âŠ—â‚œ[R] y) = (ğ“£.contrDual Î¼) ((TensorStructure.colorModuleCast ğ“£ â‹¯) y âŠ—â‚œ[R] x)"}
{"name":"TensorColor.ColorMap.MapIso.trans","declaration":"theorem TensorColor.ColorMap.MapIso.trans {X : Type} {Y : Type} {Z : Type} {ğ“’ : TensorColor} {e : X â‰ƒ Y} {e' : Y â‰ƒ Z} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} {cZ : TensorColor.ColorMap ğ“’ Z} (h : TensorColor.ColorMap.MapIso e cX cY) (h' : TensorColor.ColorMap.MapIso e' cY cZ) : TensorColor.ColorMap.MapIso (e.trans e') cX cZ"}
{"name":"TensorColor.ColorMap.MapIso.symm","declaration":"theorem TensorColor.ColorMap.MapIso.symm {X : Type} {Y : Type} {ğ“’ : TensorColor} {e : X â‰ƒ Y} {cX : TensorColor.ColorMap ğ“’ X} {cY : TensorColor.ColorMap ğ“’ Y} (h : TensorColor.ColorMap.MapIso e cX cY) : TensorColor.ColorMap.MapIso e.symm cY cX"}
