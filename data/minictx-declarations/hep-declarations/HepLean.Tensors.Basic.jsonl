{"name":"TensorStructure.instModuleTensorToSemiringInstAddCommMonoidTensor","declaration":"instance TensorStructure.instModuleTensorToSemiringInstAddCommMonoidTensor {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} : Module R (TensorStructure.Tensor 𝓣 cX)"}
{"name":"TensorColor.colorSetoid","declaration":"/-- The structure of a setoid on colors, two colors are related if they are equal,\nor dual. -/\ninstance TensorColor.colorSetoid (𝓒 : TensorColor) : Setoid 𝓒.Color"}
{"name":"TensorStructure.decompEmbed","declaration":"/-- Decomposes a tensor into a tensor product of two tensors\none which has indices in the image of the given embedding, and the other has indices in\nthe complement of that image. -/\ndef TensorStructure.decompEmbed {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} (f : Y ↪ X) : TensorStructure.Tensor 𝓣 cX ≃ₗ[R]\n  TensorProduct R (TensorStructure.Tensor 𝓣 (TensorStructure.decompEmbedColorLeft 𝓣 cX f))\n    (TensorStructure.Tensor 𝓣 (cX ∘ ⇑f))"}
{"name":"TensorColor.colorQuot","declaration":"/-- A map taking a color to its equivalence class in `colorSetoid`. -/\ndef TensorColor.colorQuot (𝓒 : TensorColor) (μ : 𝓒.Color) : Quotient (TensorColor.colorSetoid 𝓒)"}
{"name":"TensorStructure.elimPureTensor_update_right","declaration":"theorem TensorStructure.elimPureTensor_update_right {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} (p : TensorStructure.PureTensor 𝓣 cX) (q : TensorStructure.PureTensor 𝓣 cY) (y : Y) (r : 𝓣.ColorModule (cY y)) : TensorStructure.elimPureTensor 𝓣 p (Function.update q y r) =\n  Function.update (TensorStructure.elimPureTensor 𝓣 p q) (Sum.inr y) r"}
{"name":"TensorStructure.mapIso_trans","declaration":"theorem TensorStructure.mapIso_trans {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} {cZ : TensorColor.ColorMap 𝓣.toTensorColor Z} (e : X ≃ Y) (e' : Y ≃ Z) (h : TensorColor.ColorMap.MapIso e cX cY) (h' : TensorColor.ColorMap.MapIso e' cY cZ) : TensorStructure.mapIso 𝓣 e h ≪≫ₗ TensorStructure.mapIso 𝓣 e' h' = TensorStructure.mapIso 𝓣 (e.trans e') ⋯"}
{"name":"TensorStructure.PureTensor","declaration":"/-- The type of pure tensors, i.e. of the form `v1 ⊗ v2 ⊗ v3 ⊗ ...`. -/\ndef TensorStructure.PureTensor {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} (c : X → 𝓣.Color) : Type"}
{"name":"TensorStructure.tensoratorEquiv","declaration":"/-- An equivalence formed by taking the tensor product of tensors. -/\ndef TensorStructure.tensoratorEquiv {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] (c : X → 𝓣.Color) (d : Y → 𝓣.Color) : TensorProduct R (TensorStructure.Tensor 𝓣 c) (TensorStructure.Tensor 𝓣 d) ≃ₗ[R] TensorStructure.Tensor 𝓣 (Sum.elim c d)"}
{"name":"TensorStructure.mapIso_tprod","declaration":"theorem TensorStructure.mapIso_tprod {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {c : TensorColor.ColorMap 𝓣.toTensorColor X} {d : TensorColor.ColorMap 𝓣.toTensorColor Y} (e : X ≃ Y) (h : TensorColor.ColorMap.MapIso e c d) (f : (i : X) → 𝓣.ColorModule (c i)) : (TensorStructure.mapIso 𝓣 e h) ((PiTensorProduct.tprod R) f) =\n  (PiTensorProduct.tprod R) fun i => (TensorStructure.colorModuleCast 𝓣 ⋯) (f (e.symm i))"}
{"name":"TensorStructure.mk","declaration":"ctor TensorStructure.mk {R : Type} [CommSemiring R] (toTensorColor : TensorColor) (ColorModule : toTensorColor.Color → Type) (colorModule_addCommMonoid : (μ : toTensorColor.Color) → AddCommMonoid (ColorModule μ)) (colorModule_module : (μ : toTensorColor.Color) → Module R (ColorModule μ)) (contrDual : (μ : toTensorColor.Color) → TensorProduct R (ColorModule μ) (ColorModule (toTensorColor.τ μ)) →ₗ[R] R) (contrDual_symm : ∀ (μ : toTensorColor.Color) (x : ColorModule μ) (y : ColorModule (toTensorColor.τ μ)),\n  (contrDual μ) (x ⊗ₜ[R] y) = (contrDual (toTensorColor.τ μ)) (y ⊗ₜ[R] (Equiv.cast ⋯) x)) (unit : (μ : toTensorColor.Color) → TensorProduct R (ColorModule (toTensorColor.τ μ)) (ColorModule μ)) (unit_rid : ∀ (μ : toTensorColor.Color) (x : ColorModule μ), (TensorStructure.contrLeftAux (contrDual μ)) (x ⊗ₜ[R] unit μ) = x) (metric : (μ : toTensorColor.Color) → TensorProduct R (ColorModule μ) (ColorModule μ)) (metric_dual : ∀ (μ : toTensorColor.Color),\n  (TensorStructure.contrMidAux (contrDual μ)) (metric μ ⊗ₜ[R] metric (toTensorColor.τ μ)) =\n    (TensorProduct.comm R (ColorModule (toTensorColor.τ μ)) (ColorModule μ)) (unit μ)) : TensorStructure R"}
{"name":"TensorColor.ColorMap.MapIso.dual","declaration":"theorem TensorColor.ColorMap.MapIso.dual {X : Type} {Y : Type} {𝓒 : TensorColor} {cX : TensorColor.ColorMap 𝓒 X} {cY : TensorColor.ColorMap 𝓒 Y} {e : X ≃ Y} (h : TensorColor.ColorMap.MapIso e cX cY) : TensorColor.ColorMap.MapIso e (TensorColor.ColorMap.dual cX) (TensorColor.ColorMap.dual cY)"}
{"name":"TensorStructure.metric_dual","declaration":"/-- The metric contracted with its dual is the unit. -/\ndef TensorStructure.metric_dual {R : Type} [CommSemiring R] (self : TensorStructure R) (μ : self.Color) : (TensorStructure.contrMidAux (self.contrDual μ)) (self.metric μ ⊗ₜ[R] self.metric (self.τ μ)) =\n  (TensorProduct.comm R (self.ColorModule (self.τ μ)) (self.ColorModule μ)) (self.unit μ)"}
{"name":"TensorStructure.decompEmbedColorLeft","declaration":"/-- The restriction of a map from an indexing set to the space to the complement of the image\nof an embedding. -/\ndef TensorStructure.decompEmbedColorLeft {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] (c : X → 𝓣.Color) (f : Y ↪ X) : { x // x ∈ (Finset.image (⇑f) Finset.univ)ᶜ } → 𝓣.Color"}
{"name":"TensorStructure.inlPureTensor_update_right","declaration":"theorem TensorStructure.inlPureTensor_update_right {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} [DecidableEq (X ⊕ Y)] (f : TensorStructure.PureTensor 𝓣 (Sum.elim cX cY)) (y : Y) (v1 : 𝓣.ColorModule (Sum.elim cX cY (Sum.inr y))) : TensorStructure.inlPureTensor 𝓣 (Function.update f (Sum.inr y) v1) = TensorStructure.inlPureTensor 𝓣 f"}
{"name":"TensorStructure.contrDual_cast","declaration":"theorem TensorStructure.contrDual_cast {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} {ν : 𝓣.Color} (h : μ = ν) (x : 𝓣.ColorModule μ) (y : 𝓣.ColorModule (𝓣.τ μ)) : (𝓣.contrDual μ) (x ⊗ₜ[R] y) =\n  (𝓣.contrDual ν) ((TensorStructure.colorModuleCast 𝓣 h) x ⊗ₜ[R] (TensorStructure.colorModuleCast 𝓣 ⋯) y)"}
{"name":"TensorStructure.domCoprod","declaration":"/-- The multi-linear map taking a pure tensor in `𝓣.PureTensor (Sum.elim cX cY)` and constructing\na vector in `𝓣.Tensor cX ⊗[R] 𝓣.Tensor cY`. -/\ndef TensorStructure.domCoprod {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} : MultilinearMap R (fun x => 𝓣.ColorModule (Sum.elim cX cY x))\n  (TensorProduct R (TensorStructure.Tensor 𝓣 cX) (TensorStructure.Tensor 𝓣 cY))"}
{"name":"TensorStructure.mapIso","declaration":"/-- An linear equivalence of tensor spaces given a color-preserving equivalence of indexing sets. -/\ndef TensorStructure.mapIso {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {c : TensorColor.ColorMap 𝓣.toTensorColor X} {d : TensorColor.ColorMap 𝓣.toTensorColor Y} (e : X ≃ Y) (h : TensorColor.ColorMap.MapIso e c d) : TensorStructure.Tensor 𝓣 c ≃ₗ[R] TensorStructure.Tensor 𝓣 d"}
{"name":"TensorStructure.contrDual_symm_contrRightAux","declaration":"theorem TensorStructure.contrDual_symm_contrRightAux {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} {ν : 𝓣.Color} {η : 𝓣.Color} (h : ν = η) : ↑(TensorStructure.colorModuleCast 𝓣 h) ∘ₗ TensorStructure.contrRightAux (𝓣.contrDual μ) =\n  TensorStructure.contrRightAux (𝓣.contrDual (𝓣.τ (𝓣.τ μ))) ∘ₗ\n    ↑(TensorProduct.congr\n        (TensorProduct.congr (TensorStructure.colorModuleCast 𝓣 h) (TensorStructure.colorModuleCast 𝓣 ⋯))\n        (TensorStructure.colorModuleCast 𝓣 ⋯))"}
{"name":"TensorStructure.isEmptyEquiv_tprod","declaration":"theorem TensorStructure.isEmptyEquiv_tprod {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} [IsEmpty X] (f : TensorStructure.PureTensor 𝓣 cX) : (TensorStructure.isEmptyEquiv 𝓣) ((PiTensorProduct.tprod R) f) = 1"}
{"name":"TensorStructure.contrRightAux_comp","declaration":"theorem TensorStructure.contrRightAux_comp {R : Type} [CommSemiring R] {V1 : Type} {V2 : Type} {V3 : Type} {V4 : Type} {V5 : Type} [AddCommMonoid V1] [AddCommMonoid V2] [AddCommMonoid V3] [AddCommMonoid V4] [AddCommMonoid V5] [Module R V1] [Module R V3] [Module R V2] [Module R V4] [Module R V5] (f : TensorProduct R V2 V3 →ₗ[R] R) (g : TensorProduct R V4 V5 →ₗ[R] R) : TensorStructure.contrRightAux f ∘ₗ TensorProduct.map LinearMap.id (TensorStructure.contrRightAux g) =\n  TensorStructure.contrRightAux g ∘ₗ\n    TensorProduct.map (TensorStructure.contrMidAux f) LinearMap.id ∘ₗ\n      ↑(LinearEquiv.symm (TensorProduct.assoc R (TensorProduct R V1 V2) (TensorProduct R V3 V4) V5))"}
{"name":"TensorColor.τ","declaration":"/-- A map taking every color to its dual color. -/\ndef TensorColor.τ (self : TensorColor) : self.Color → self.Color"}
{"name":"TensorStructure.decompEmbedSet","declaration":"/-- The decomposition of a set into a direct sum based on the image of an injection. -/\ndef TensorStructure.decompEmbedSet {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] (f : Y ↪ X) : X ≃ { x // x ∈ (Finset.image (⇑f) Finset.univ)ᶜ } ⊕ Y"}
{"name":"TensorStructure.metric","declaration":"/-- The metric for a given color. -/\ndef TensorStructure.metric {R : Type} [CommSemiring R] (self : TensorStructure R) (μ : self.Color) : TensorProduct R (self.ColorModule μ) (self.ColorModule μ)"}
{"name":"TensorStructure.ColorModule","declaration":"/-- To each color we associate a module. -/\ndef TensorStructure.ColorModule {R : Type} [CommSemiring R] (self : TensorStructure R) : self.Color → Type"}
{"name":"TensorStructure.contrLeftAux","declaration":"/-- An auxillary function to contract the vector space `V1` and `V2` in `V1 ⊗[R] V2 ⊗[R] V3`. -/\ndef TensorStructure.contrLeftAux {R : Type} [CommSemiring R] {V1 : Type} {V2 : Type} {V3 : Type} [AddCommMonoid V1] [AddCommMonoid V2] [AddCommMonoid V3] [Module R V1] [Module R V2] [Module R V3] (f : TensorProduct R V1 V2 →ₗ[R] R) : TensorProduct R V1 (TensorProduct R V2 V3) →ₗ[R] V3"}
{"name":"TensorColor.instDecidableEqQuotientColorColorSetoid","declaration":"instance TensorColor.instDecidableEqQuotientColorColorSetoid (𝓒 : TensorColor) [DecidableEq 𝓒.Color] : DecidableEq (Quotient (TensorColor.colorSetoid 𝓒))"}
{"name":"TensorColor.ColorMap.MapIso.sum","declaration":"theorem TensorColor.ColorMap.MapIso.sum {X : Type} {X' : Type} {Y : Type} {Y' : Type} {𝓒 : TensorColor} {cX : TensorColor.ColorMap 𝓒 X} {cY : TensorColor.ColorMap 𝓒 Y} {cX' : TensorColor.ColorMap 𝓒 X'} {cY' : TensorColor.ColorMap 𝓒 Y'} {eX : X ≃ X'} {eY : Y ≃ Y'} (hX : TensorColor.ColorMap.MapIso eX cX cX') (hY : TensorColor.ColorMap.MapIso eY cY cY') : TensorColor.ColorMap.MapIso (Equiv.sumCongr eX eY) (TensorColor.ColorMap.sum cX cY) (TensorColor.ColorMap.sum cX' cY')"}
{"name":"TensorStructure.instAddCommMonoidTensor","declaration":"instance TensorStructure.instAddCommMonoidTensor {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} : AddCommMonoid (TensorStructure.Tensor 𝓣 cX)"}
{"name":"TensorColor.ColorMap.MapIso","declaration":"/-- A relation, given an equivalence of types, between ColorMap which is true\nif related by composition of the equivalence. -/\ndef TensorColor.ColorMap.MapIso {X : Type} {Y : Type} {𝓒 : TensorColor} (e : X ≃ Y) (cX : TensorColor.ColorMap 𝓒 X) (cY : TensorColor.ColorMap 𝓒 Y) : Prop"}
{"name":"TensorStructure.colorModule_module","declaration":"/-- Each `ColorModule` has the structure of a module over `R`. -/\ndef TensorStructure.colorModule_module {R : Type} [CommSemiring R] (self : TensorStructure R) (μ : self.Color) : Module R (self.ColorModule μ)"}
{"name":"TensorStructure.contrDual","declaration":"/-- The contraction of a vector with a vector with dual color. -/\ndef TensorStructure.contrDual {R : Type} [CommSemiring R] (self : TensorStructure R) (μ : self.Color) : TensorProduct R (self.ColorModule μ) (self.ColorModule (self.τ μ)) →ₗ[R] R"}
{"name":"TensorColor.colorRel","declaration":"/-- A relation on colors which is true if the two colors are equal or are duals. -/\ndef TensorColor.colorRel (𝓒 : TensorColor) (μ : 𝓒.Color) (ν : 𝓒.Color) : Prop"}
{"name":"TensorColor.instDecidableEquivColorInstHasEquivColorSetoid","declaration":"instance TensorColor.instDecidableEquivColorInstHasEquivColorSetoid (𝓒 : TensorColor) [DecidableEq 𝓒.Color] (μ : 𝓒.Color) (ν : 𝓒.Color) : Decidable (μ ≈ ν)"}
{"name":"TensorStructure.mapIso_mapIso","declaration":"theorem TensorStructure.mapIso_mapIso {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} {cZ : TensorColor.ColorMap 𝓣.toTensorColor Z} (e : X ≃ Y) (e' : Y ≃ Z) (h : TensorColor.ColorMap.MapIso e cX cY) (h' : TensorColor.ColorMap.MapIso e' cY cZ) (T : TensorStructure.Tensor 𝓣 cX) : (TensorStructure.mapIso 𝓣 e' h') ((TensorStructure.mapIso 𝓣 e h) T) = (TensorStructure.mapIso 𝓣 (e.trans e') ⋯) T"}
{"name":"TensorStructure.unit_rid","declaration":"/-- The unit is a right identity. -/\ndef TensorStructure.unit_rid {R : Type} [CommSemiring R] (self : TensorStructure R) (μ : self.Color) (x : self.ColorModule μ) : (TensorStructure.contrLeftAux (self.contrDual μ)) (x ⊗ₜ[R] self.unit μ) = x"}
{"name":"TensorStructure.isEmptyEquiv","declaration":"/-- The equivalence between `𝓣.Tensor cX` and `R` when the indexing set `X` is empty. -/\ndef TensorStructure.isEmptyEquiv {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} [IsEmpty X] : TensorStructure.Tensor 𝓣 cX ≃ₗ[R] R"}
{"name":"TensorStructure.tensoratorEquiv_symm_tprod","declaration":"theorem TensorStructure.tensoratorEquiv_symm_tprod {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} (f : TensorStructure.PureTensor 𝓣 (Sum.elim cX cY)) : (LinearEquiv.symm (TensorStructure.tensoratorEquiv 𝓣 cX cY)) ((PiTensorProduct.tprod R) f) =\n  (PiTensorProduct.tprod R) (TensorStructure.inlPureTensor 𝓣 f) ⊗ₜ[R]\n    (PiTensorProduct.tprod R) (TensorStructure.inrPureTensor 𝓣 f)"}
{"name":"TensorStructure.elimPureTensor_update_left","declaration":"theorem TensorStructure.elimPureTensor_update_left {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} (p : TensorStructure.PureTensor 𝓣 cX) (q : TensorStructure.PureTensor 𝓣 cY) (x : X) (r : 𝓣.ColorModule (cX x)) : TensorStructure.elimPureTensor 𝓣 (Function.update p x r) q =\n  Function.update (TensorStructure.elimPureTensor 𝓣 p q) (Sum.inl x) r"}
{"name":"TensorStructure.tensoratorEquiv_mapIso_apply","declaration":"theorem TensorStructure.tensoratorEquiv_mapIso_apply {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [DecidableEq X] [DecidableEq Y] [DecidableEq Z] [DecidableEq W] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} {cZ : TensorColor.ColorMap 𝓣.toTensorColor Z} {cW : TensorColor.ColorMap 𝓣.toTensorColor W} (e' : Z ≃ Y) (e'' : W ≃ X) (h' : TensorColor.ColorMap.MapIso e' cZ cY) (h'' : TensorColor.ColorMap.MapIso e'' cW cX) (x : TensorProduct R (TensorStructure.Tensor 𝓣 cW) (TensorStructure.Tensor 𝓣 cZ)) : (TensorStructure.tensoratorEquiv 𝓣 cX cY)\n    ((TensorProduct.congr (TensorStructure.mapIso 𝓣 e'' h'') (TensorStructure.mapIso 𝓣 e' h')) x) =\n  (TensorStructure.mapIso 𝓣 (Equiv.sumCongr e'' e') ⋯) ((TensorStructure.tensoratorEquiv 𝓣 cW cZ) x)"}
{"name":"TensorColor.Color","declaration":"/-- The allowed colors of indices.\nFor example for a real Lorentz tensor these are `{up, down}`. -/\ndef TensorColor.Color (self : TensorColor) : Type"}
{"name":"TensorStructure.tensoratorEquiv_tmul_tprod","declaration":"theorem TensorStructure.tensoratorEquiv_tmul_tprod {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} (p : TensorStructure.PureTensor 𝓣 cX) (q : TensorStructure.PureTensor 𝓣 cY) : (TensorStructure.tensoratorEquiv 𝓣 cX cY) ((PiTensorProduct.tprod R) p ⊗ₜ[R] (PiTensorProduct.tprod R) q) =\n  (PiTensorProduct.tprod R) (TensorStructure.elimPureTensor 𝓣 p q)"}
{"name":"TensorStructure.inrPureTensor_update_left","declaration":"theorem TensorStructure.inrPureTensor_update_left {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} [DecidableEq (X ⊕ Y)] (f : TensorStructure.PureTensor 𝓣 (Sum.elim cX cY)) (x : X) (v1 : 𝓣.ColorModule (Sum.elim cX cY (Sum.inl x))) : TensorStructure.inrPureTensor 𝓣 (Function.update f (Sum.inl x) v1) = TensorStructure.inrPureTensor 𝓣 f"}
{"name":"TensorStructure.mapIso_symm","declaration":"theorem TensorStructure.mapIso_symm {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} (e : X ≃ Y) (h : TensorColor.ColorMap.MapIso e cX cY) : LinearEquiv.symm (TensorStructure.mapIso 𝓣 e h) = TensorStructure.mapIso 𝓣 e.symm ⋯"}
{"name":"TensorColor.ColorMap","declaration":"/-- The types of maps from an `X` to `𝓒.Color`. -/\ndef TensorColor.ColorMap (𝓒 : TensorColor) (X : Type) : Type"}
{"name":"TensorStructure.tensorProd_piTensorProd_ext","declaration":"theorem TensorStructure.tensorProd_piTensorProd_ext {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} {M : Type} [AddCommMonoid M] [Module R M] {f : TensorProduct R (TensorStructure.Tensor 𝓣 cX) (TensorStructure.Tensor 𝓣 cY) →ₗ[R] M} {g : TensorProduct R (TensorStructure.Tensor 𝓣 cX) (TensorStructure.Tensor 𝓣 cY) →ₗ[R] M} (h : ∀ (p : (i : X) → 𝓣.ColorModule (cX i)) (q : (i : Y) → 𝓣.ColorModule (cY i)),\n  f ((PiTensorProduct.tprod R) p ⊗ₜ[R] (PiTensorProduct.tprod R) q) =\n    g ((PiTensorProduct.tprod R) p ⊗ₜ[R] (PiTensorProduct.tprod R) q)) : f = g"}
{"name":"TensorStructure.decompEmbedColorRight","declaration":"/-- The restriction of a map from an indexing set to the space to the image\nof an embedding. -/\ndef TensorStructure.decompEmbedColorRight {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] (c : X → 𝓣.Color) (f : Y ↪ X) : Y → 𝓣.Color"}
{"name":"TensorStructure.instAddCommMonoidColorModule","declaration":"instance TensorStructure.instAddCommMonoidColorModule {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} : AddCommMonoid (𝓣.ColorModule μ)"}
{"name":"TensorStructure.unit","declaration":"/-- The unit of the contraction. -/\ndef TensorStructure.unit {R : Type} [CommSemiring R] (self : TensorStructure R) (μ : self.Color) : TensorProduct R (self.ColorModule (self.τ μ)) (self.ColorModule μ)"}
{"name":"TensorColor.ColorMap.sum","declaration":"/-- The sum of two color maps, formed by `Sum.elim`. -/\ndef TensorColor.ColorMap.sum {X : Type} {Y : Type} {𝓒 : TensorColor} (cX : TensorColor.ColorMap 𝓒 X) (cY : TensorColor.ColorMap 𝓒 Y) : TensorColor.ColorMap 𝓒 (X ⊕ Y)"}
{"name":"TensorColor.ColorMap.dual","declaration":"/-- The dual of a color map, formed by composition with `𝓒.τ`. -/\ndef TensorColor.ColorMap.dual {X : Type} {𝓒 : TensorColor} (cX : TensorColor.ColorMap 𝓒 X) : TensorColor.ColorMap 𝓒 X"}
{"name":"TensorStructure.contrRightAux","declaration":"/-- An auxillary function to contract the vector space `V1` and `V2` in `(V3 ⊗[R] V1) ⊗[R] V2`. -/\ndef TensorStructure.contrRightAux {R : Type} [CommSemiring R] {V1 : Type} {V2 : Type} {V3 : Type} [AddCommMonoid V1] [AddCommMonoid V2] [AddCommMonoid V3] [Module R V1] [Module R V2] [Module R V3] (f : TensorProduct R V1 V2 →ₗ[R] R) : TensorProduct R (TensorProduct R V3 V1) V2 →ₗ[R] V3"}
{"name":"TensorStructure.mapIso_ext","declaration":"theorem TensorStructure.mapIso_ext {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {c : TensorColor.ColorMap 𝓣.toTensorColor X} {d : TensorColor.ColorMap 𝓣.toTensorColor Y} (e : X ≃ Y) (e' : X ≃ Y) (h : TensorColor.ColorMap.MapIso e c d) (h' : TensorColor.ColorMap.MapIso e' c d) (he : e = e') : TensorStructure.mapIso 𝓣 e h = TensorStructure.mapIso 𝓣 e' h'"}
{"name":"TensorStructure.inrPureTensor_update_right","declaration":"theorem TensorStructure.inrPureTensor_update_right {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} [DecidableEq (X ⊕ Y)] (f : TensorStructure.PureTensor 𝓣 (Sum.elim cX cY)) (y : Y) (v1 : 𝓣.ColorModule (Sum.elim cX cY (Sum.inr y))) : TensorStructure.inrPureTensor 𝓣 (Function.update f (Sum.inr y) v1) =\n  Function.update (TensorStructure.inrPureTensor 𝓣 f) y v1"}
{"name":"TensorStructure.tensoratorEquiv_mapIso","declaration":"theorem TensorStructure.tensoratorEquiv_mapIso {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [DecidableEq X] [DecidableEq Y] [DecidableEq Z] [DecidableEq W] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} {cZ : TensorColor.ColorMap 𝓣.toTensorColor Z} {cW : TensorColor.ColorMap 𝓣.toTensorColor W} (e' : Z ≃ Y) (e'' : W ≃ X) (h' : TensorColor.ColorMap.MapIso e' cZ cY) (h'' : TensorColor.ColorMap.MapIso e'' cW cX) : TensorProduct.congr (TensorStructure.mapIso 𝓣 e'' h'') (TensorStructure.mapIso 𝓣 e' h') ≪≫ₗ\n    TensorStructure.tensoratorEquiv 𝓣 cX cY =\n  TensorStructure.tensoratorEquiv 𝓣 cW cZ ≪≫ₗ TensorStructure.mapIso 𝓣 (Equiv.sumCongr e'' e') ⋯"}
{"name":"TensorStructure.contrDual_symm","declaration":"/-- The contraction is symmetric. -/\ndef TensorStructure.contrDual_symm {R : Type} [CommSemiring R] (self : TensorStructure R) (μ : self.Color) (x : self.ColorModule μ) (y : self.ColorModule (self.τ μ)) : (self.contrDual μ) (x ⊗ₜ[R] y) = (self.contrDual (self.τ μ)) (y ⊗ₜ[R] (Equiv.cast ⋯) x)"}
{"name":"TensorColor.mk","declaration":"ctor TensorColor.mk (Color : Type) (τ : Color → Color) (τ_involutive : Function.Involutive τ) : TensorColor"}
{"name":"TensorStructure.tensoratorSymm","declaration":"/-- The linear map combining two tensors into a single tensor\nvia the tensor product i.e. `v1 v2 ↦ v1 ⊗ v2`. -/\ndef TensorStructure.tensoratorSymm {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} : TensorProduct R (TensorStructure.Tensor 𝓣 cX) (TensorStructure.Tensor 𝓣 cY) →ₗ[R]\n  TensorStructure.Tensor 𝓣 (Sum.elim cX cY)"}
{"name":"TensorStructure.Tensor","declaration":"/-- The type of tensors given a map from an indexing set `X` to the type of colors,\nspecifying the color of that index. -/\ndef TensorStructure.Tensor {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} (c : TensorColor.ColorMap 𝓣.toTensorColor X) : Type"}
{"name":"TensorStructure.decompEmbed_cond","declaration":"theorem TensorStructure.decompEmbed_cond {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [Fintype X] [DecidableEq X] [Fintype Y] (c : X → 𝓣.Color) (f : Y ↪ X) : c =\n  Sum.elim (TensorStructure.decompEmbedColorLeft 𝓣 c f) (TensorStructure.decompEmbedColorRight 𝓣 c f) ∘\n    ⇑(TensorStructure.decompEmbedSet f)"}
{"name":"TensorColor","declaration":"/-- The index color data associated with a tensor structure.\nThis corresponds to a type with an involution. -/\nstructure TensorColor  : Type 1"}
{"name":"TensorStructure","declaration":"/-- An initial structure specifying a tensor system (e.g. a system in which you can\ndefine real Lorentz tensors or Einstein notation convention). -/\nstructure TensorStructure (R : Type) [CommSemiring R] : Type 1"}
{"name":"TensorColor.instDecidableColorRel","declaration":"instance TensorColor.instDecidableColorRel (𝓒 : TensorColor) [DecidableEq 𝓒.Color] {μ : 𝓒.Color} {ν : 𝓒.Color} : Decidable (TensorColor.colorRel 𝓒 μ ν)"}
{"name":"TensorColor.colorRel_equivalence","declaration":"/-- An equivalence relation on colors which is true if the two colors are equal or are duals. -/\ntheorem TensorColor.colorRel_equivalence (𝓒 : TensorColor) : Equivalence (TensorColor.colorRel 𝓒)"}
{"name":"TensorStructure.elimPureTensorMulLin","declaration":"/-- The multilinear map taking pure tensors a `𝓣.PureTensor cX` and a pure tensor in\n`𝓣.PureTensor cY`, and constructing a tensor in `𝓣.Tensor (Sum.elim cX cY))`. -/\ndef TensorStructure.elimPureTensorMulLin {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} : MultilinearMap R (fun i => 𝓣.ColorModule (cX i))\n  (MultilinearMap R (fun x => 𝓣.ColorModule (cY x)) (TensorStructure.Tensor 𝓣 (Sum.elim cX cY)))"}
{"name":"TensorStructure.tensoratorEquiv_mapIso_tmul","declaration":"theorem TensorStructure.tensoratorEquiv_mapIso_tmul {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {Z : Type} {W : Type} [DecidableEq X] [DecidableEq Y] [DecidableEq Z] [DecidableEq W] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} {cZ : TensorColor.ColorMap 𝓣.toTensorColor Z} {cW : TensorColor.ColorMap 𝓣.toTensorColor W} (e' : Z ≃ Y) (e'' : W ≃ X) (h' : TensorColor.ColorMap.MapIso e' cZ cY) (h'' : TensorColor.ColorMap.MapIso e'' cW cX) (x : TensorStructure.Tensor 𝓣 cW) (y : TensorStructure.Tensor 𝓣 cZ) : (TensorStructure.tensoratorEquiv 𝓣 cX cY)\n    ((TensorStructure.mapIso 𝓣 e'' h'') x ⊗ₜ[R] (TensorStructure.mapIso 𝓣 e' h') y) =\n  (TensorStructure.mapIso 𝓣 (Equiv.sumCongr e'' e') ⋯) ((TensorStructure.tensoratorEquiv 𝓣 cW cZ) (x ⊗ₜ[R] y))"}
{"name":"TensorColor.ColorMap.MapIso.symm'","declaration":"theorem TensorColor.ColorMap.MapIso.symm' {X : Type} {Y : Type} {𝓒 : TensorColor} {e : X ≃ Y} {cX : TensorColor.ColorMap 𝓒 X} {cY : TensorColor.ColorMap 𝓒 Y} : TensorColor.ColorMap.MapIso e cX cY ↔ TensorColor.ColorMap.MapIso e.symm cY cX"}
{"name":"TensorStructure.inlPureTensor_update_left","declaration":"theorem TensorStructure.inlPureTensor_update_left {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} [DecidableEq (X ⊕ Y)] (f : TensorStructure.PureTensor 𝓣 (Sum.elim cX cY)) (x : X) (v1 : 𝓣.ColorModule (Sum.elim cX cY (Sum.inl x))) : TensorStructure.inlPureTensor 𝓣 (Function.update f (Sum.inl x) v1) =\n  Function.update (TensorStructure.inlPureTensor 𝓣 f) x v1"}
{"name":"TensorStructure.mapIso_refl","declaration":"theorem TensorStructure.mapIso_refl {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} : TensorStructure.mapIso 𝓣 (Equiv.refl X) ⋯ = LinearEquiv.refl R (TensorStructure.Tensor 𝓣 cX)"}
{"name":"TensorStructure.colorModule_addCommMonoid","declaration":"/-- Each `ColorModule` has the structure of an additive commutative monoid. -/\ndef TensorStructure.colorModule_addCommMonoid {R : Type} [CommSemiring R] (self : TensorStructure R) (μ : self.Color) : AddCommMonoid (self.ColorModule μ)"}
{"name":"TensorStructure.tensorator","declaration":"/-- Splitting a tensor in `𝓣.Tensor (Sum.elim cX cY)` into the tensor product of two tensors. -/\ndef TensorStructure.tensorator {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} [DecidableEq X] [DecidableEq Y] {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} : TensorStructure.Tensor 𝓣 (Sum.elim cX cY) →ₗ[R]\n  TensorProduct R (TensorStructure.Tensor 𝓣 cX) (TensorStructure.Tensor 𝓣 cY)"}
{"name":"TensorStructure.instModuleColorModuleToSemiringInstAddCommMonoidColorModule","declaration":"instance TensorStructure.instModuleColorModuleToSemiringInstAddCommMonoidColorModule {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} : Module R (𝓣.ColorModule μ)"}
{"name":"TensorColor.τ_involutive","declaration":"/-- The map `τ` is an involution. -/\ndef TensorColor.τ_involutive (self : TensorColor) : Function.Involutive self.τ"}
{"name":"TensorStructure.elimPureTensor","declaration":"/-- A pure tensor in `𝓣.PureTensor (Sum.elim cX cY)` constructed from a pure tensor\nin `𝓣.PureTensor cX` and a pure tensor in `𝓣.PureTensor cY`. -/\ndef TensorStructure.elimPureTensor {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} (p : TensorStructure.PureTensor 𝓣 cX) (q : TensorStructure.PureTensor 𝓣 cY) : TensorStructure.PureTensor 𝓣 (Sum.elim cX cY)"}
{"name":"TensorStructure.inlPureTensor","declaration":"/-- The projection of a pure tensor in `𝓣.PureTensor (Sum.elim cX cY)` onto a pure tensor in\n`𝓣.PureTensor cX`. -/\ndef TensorStructure.inlPureTensor {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} (p : TensorStructure.PureTensor 𝓣 (Sum.elim cX cY)) : TensorStructure.PureTensor 𝓣 cX"}
{"name":"TensorStructure.colorModuleCast","declaration":"/-- Equivalence of `ColorModule` given an equality of colors. -/\ndef TensorStructure.colorModuleCast {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} {ν : 𝓣.Color} (h : μ = ν) : 𝓣.ColorModule μ ≃ₗ[R] 𝓣.ColorModule ν"}
{"name":"TensorStructure.inrPureTensor","declaration":"/-- The projection of a pure tensor in `𝓣.PureTensor (Sum.elim cX cY)` onto a pure tensor in\n`𝓣.PureTensor cY`. -/\ndef TensorStructure.inrPureTensor {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {X : Type} {Y : Type} {cX : TensorColor.ColorMap 𝓣.toTensorColor X} {cY : TensorColor.ColorMap 𝓣.toTensorColor Y} (p : TensorStructure.PureTensor 𝓣 (Sum.elim cX cY)) : TensorStructure.PureTensor 𝓣 cY"}
{"name":"TensorStructure.contrMidAux","declaration":"/-- An auxillary function to contract the vector space `V1` and `V2` in\n`V4 ⊗[R] V1 ⊗[R] V2 ⊗[R] V3`. -/\ndef TensorStructure.contrMidAux {R : Type} [CommSemiring R] {V1 : Type} {V2 : Type} {V3 : Type} {V4 : Type} [AddCommMonoid V1] [AddCommMonoid V2] [AddCommMonoid V3] [AddCommMonoid V4] [Module R V1] [Module R V2] [Module R V3] [Module R V4] (f : TensorProduct R V1 V2 →ₗ[R] R) : TensorProduct R (TensorProduct R V4 V1) (TensorProduct R V2 V3) →ₗ[R] TensorProduct R V4 V3"}
{"name":"TensorStructure.contrDual_symm_contrRightAux_apply_tmul","declaration":"theorem TensorStructure.contrDual_symm_contrRightAux_apply_tmul {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) {μ : 𝓣.Color} {ν : 𝓣.Color} {η : 𝓣.Color} (h : ν = η) (m : TensorProduct R (𝓣.ColorModule ν) (𝓣.ColorModule μ)) (x : 𝓣.ColorModule (𝓣.τ μ)) : (TensorStructure.colorModuleCast 𝓣 h) ((TensorStructure.contrRightAux (𝓣.contrDual μ)) (m ⊗ₜ[R] x)) =\n  (TensorStructure.contrRightAux (𝓣.contrDual (𝓣.τ (𝓣.τ μ))))\n    ((TensorProduct.congr (TensorStructure.colorModuleCast 𝓣 h) (TensorStructure.colorModuleCast 𝓣 ⋯)) m ⊗ₜ[R]\n      (TensorStructure.colorModuleCast 𝓣 ⋯) x)"}
{"name":"TensorStructure.contrDual_symm'","declaration":"/-- `𝓣.contrDual (𝓣.τ μ)` in terms of `𝓣.contrDual μ`. -/\ntheorem TensorStructure.contrDual_symm' {R : Type} [CommSemiring R] (𝓣 : TensorStructure R) (μ : 𝓣.Color) (x : 𝓣.ColorModule (𝓣.τ μ)) (y : 𝓣.ColorModule (𝓣.τ (𝓣.τ μ))) : (𝓣.contrDual (𝓣.τ μ)) (x ⊗ₜ[R] y) = (𝓣.contrDual μ) ((TensorStructure.colorModuleCast 𝓣 ⋯) y ⊗ₜ[R] x)"}
{"name":"TensorColor.ColorMap.MapIso.trans","declaration":"theorem TensorColor.ColorMap.MapIso.trans {X : Type} {Y : Type} {Z : Type} {𝓒 : TensorColor} {e : X ≃ Y} {e' : Y ≃ Z} {cX : TensorColor.ColorMap 𝓒 X} {cY : TensorColor.ColorMap 𝓒 Y} {cZ : TensorColor.ColorMap 𝓒 Z} (h : TensorColor.ColorMap.MapIso e cX cY) (h' : TensorColor.ColorMap.MapIso e' cY cZ) : TensorColor.ColorMap.MapIso (e.trans e') cX cZ"}
{"name":"TensorColor.ColorMap.MapIso.symm","declaration":"theorem TensorColor.ColorMap.MapIso.symm {X : Type} {Y : Type} {𝓒 : TensorColor} {e : X ≃ Y} {cX : TensorColor.ColorMap 𝓒 X} {cY : TensorColor.ColorMap 𝓒 Y} (h : TensorColor.ColorMap.MapIso e cX cY) : TensorColor.ColorMap.MapIso e.symm cY cX"}
