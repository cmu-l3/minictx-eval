{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\n", "theoremStatement": "lemma symm : Rectangle z w = Rectangle w z", "fileCreated": "f36a520 20240122", "theoremCreated": "1909a40 20240209", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 24, "tokenPositionInFile": 511, "theoremPositionInFile": 1}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp [Rectangle, uIcc_comm]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 32}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\n", "theoremStatement": "lemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w", "fileCreated": "f36a520 20240122", "theoremCreated": "a926b33 20240218", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 27, "tokenPositionInFile": 591, "theoremPositionInFile": 2}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp [Rectangle, uIcc_comm]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 32}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\n", "theoremStatement": "lemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im)", "fileCreated": "f36a520 20240122", "theoremCreated": "9b8e7fa 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1256, "theoremPositionInFile": 5}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 98}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\n", "theoremStatement": "lemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t", "fileCreated": "f36a520 20240122", "theoremCreated": "f887328 20240215", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 50, "tokenPositionInFile": 1561, "theoremPositionInFile": 6}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "rfl", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 3}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n", "theoremStatement": "@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t", "fileCreated": "f36a520 20240122", "theoremCreated": "f1c959f 20240220", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 52, "tokenPositionInFile": 1655, "theoremPositionInFile": 7}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "rfl", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 3}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n", "theoremStatement": "@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm", "fileCreated": "f36a520 20240122", "theoremCreated": "f1c959f 20240220", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 57, "tokenPositionInFile": 1780, "theoremPositionInFile": 8}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "rfl", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 3}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\n", "theoremStatement": "lemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081", "fileCreated": "f36a520 20240122", "theoremCreated": "f887328 20240215", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 67, "tokenPositionInFile": 2268, "theoremPositionInFile": 9}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 75}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\n", "theoremStatement": "lemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205", "fileCreated": "f36a520 20240122", "theoremCreated": "f887328 20240215", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 72, "tokenPositionInFile": 2523, "theoremPositionInFile": 10}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "reProdIm_subset_iff.trans prod_subset_prod_iff", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 46}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\n", "theoremStatement": "lemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w}", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 78, "tokenPositionInFile": 2875, "theoremPositionInFile": 11}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 159}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\n", "theoremStatement": "lemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U", "fileCreated": "f36a520 20240122", "theoremCreated": "f887328 20240215", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 85, "tokenPositionInFile": 3324, "theoremPositionInFile": 12}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 125}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\n", "theoremStatement": "lemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im", "fileCreated": "f36a520 20240122", "theoremCreated": "91651fb 20240215", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 91, "tokenPositionInFile": 3640, "theoremPositionInFile": 13}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 83}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\n", "theoremStatement": "lemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c", "fileCreated": "f36a520 20240122", "theoremCreated": "a926b33 20240218", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 96, "tokenPositionInFile": 3895, "theoremPositionInFile": 14}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  simpa [Square] using Rectangle.symm", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 40}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n", "theoremStatement": "@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b", "fileCreated": "f36a520 20240122", "theoremCreated": "a926b33 20240218", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 101, "tokenPositionInFile": 4081, "theoremPositionInFile": 16}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 49}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\n", "theoremStatement": "theorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b", "fileCreated": "f36a520 20240122", "theoremCreated": "2282e1a 20240219", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 105, "tokenPositionInFile": 4233, "theoremPositionInFile": 17}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 4, "proofLengthTokens": 207}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\n", "theoremStatement": "theorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b", "fileCreated": "f36a520 20240122", "theoremCreated": "2282e1a 20240219", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 108, "tokenPositionInFile": 4368, "theoremPositionInFile": 18}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 71}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\n", "theoremStatement": "theorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a", "fileCreated": "f36a520 20240122", "theoremCreated": "2282e1a 20240219", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 111, "tokenPositionInFile": 4506, "theoremPositionInFile": 19}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 38}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\n", "theoremStatement": "theorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b", "fileCreated": "f36a520 20240122", "theoremCreated": "2282e1a 20240219", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 114, "tokenPositionInFile": 4627, "theoremPositionInFile": 20}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 39}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\n", "theoremStatement": "lemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w", "fileCreated": "f36a520 20240122", "theoremCreated": "f70547a 20240216", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 117, "tokenPositionInFile": 4750, "theoremPositionInFile": 21}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "\u27e8left_mem_uIcc, left_mem_uIcc\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 30}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\n", "theoremStatement": "lemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w", "fileCreated": "f36a520 20240122", "theoremCreated": "f70547a 20240216", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 119, "tokenPositionInFile": 4835, "theoremPositionInFile": 22}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "\u27e8right_mem_uIcc, right_mem_uIcc\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 32}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\n", "theoremStatement": "lemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w", "fileCreated": "f36a520 20240122", "theoremCreated": "f70547a 20240216", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 121, "tokenPositionInFile": 4923, "theoremPositionInFile": 23}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 9, "proofLengthTokens": 540}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\n", "theoremStatement": "lemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I)", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 132, "tokenPositionInFile": 5586, "theoremPositionInFile": 24}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 4, "proofLengthTokens": 125}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\n", "theoremStatement": "lemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 139, "tokenPositionInFile": 5978, "theoremPositionInFile": 25}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 146}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\n", "theoremStatement": "lemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 146, "tokenPositionInFile": 6376, "theoremPositionInFile": 26}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 7, "proofLengthTokens": 198}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\n", "theoremStatement": "lemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p}", "fileCreated": "f36a520 20240122", "theoremCreated": "f70547a 20240216", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 155, "tokenPositionInFile": 6708, "theoremPositionInFile": 27}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)", "proofType": "tactic", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 7, "proofLengthTokens": 272}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\n", "theoremStatement": "lemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p}", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 166, "tokenPositionInFile": 7201, "theoremPositionInFile": 28}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 4, "proofLengthTokens": 193}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\n", "theoremStatement": "lemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p}", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 173, "tokenPositionInFile": 7557, "theoremPositionInFile": 29}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 86}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\n", "theoremStatement": "lemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p}", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 181, "tokenPositionInFile": 8008, "theoremPositionInFile": 30}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 148}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\n", "theoremStatement": "lemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) ", "fileCreated": "f36a520 20240122", "theoremCreated": "3727e0f 20240219", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 190, "tokenPositionInFile": 8459, "theoremPositionInFile": 31}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "y\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 106}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\n", "theoremStatement": "lemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b}", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 196, "tokenPositionInFile": 8798, "theoremPositionInFile": 32}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 137}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\n", "theoremStatement": "lemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]]", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 203, "tokenPositionInFile": 9159, "theoremPositionInFile": 33}, "definitionMetadata": {"inFileDefinitions": false, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 137}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n", "theoremStatement": "lemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w)", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 208, "tokenPositionInFile": 9408, "theoremPositionInFile": 34}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 34}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\n", "theoremStatement": "lemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w)", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 212, "tokenPositionInFile": 9566, "theoremPositionInFile": 35}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 34}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\n", "theoremStatement": "lemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w)", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 216, "tokenPositionInFile": 9725, "theoremPositionInFile": 36}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 34}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\n", "theoremStatement": "lemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w)", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 220, "tokenPositionInFile": 9882, "theoremPositionInFile": 37}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9", "proofType": "term", "inFileTheoremsInProof": false, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 34}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\n", "theoremStatement": "lemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w)", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 224, "tokenPositionInFile": 10040, "theoremPositionInFile": 38}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "(Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 96}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\n", "theoremStatement": "lemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) ", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 228, "tokenPositionInFile": 10272, "theoremPositionInFile": 39}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "(Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 96}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\n", "theoremStatement": "lemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w)", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 232, "tokenPositionInFile": 10505, "theoremPositionInFile": 40}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "(Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 98}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\n", "theoremStatement": "lemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w)", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 236, "tokenPositionInFile": 10738, "theoremPositionInFile": 41}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "(Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]", "proofType": "term", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 1, "proofLengthTokens": 98}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\n", "theoremStatement": "lemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p})", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 240, "tokenPositionInFile": 10972, "theoremPositionInFile": 42}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 174}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\n", "theoremStatement": "lemma mapsTo_rectangle_right_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p})", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 245, "tokenPositionInFile": 11327, "theoremPositionInFile": 43}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  refine (mapsTo_rectangleBorder_right_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 175}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\n", "theoremStatement": "lemma mapsTo_rectangle_left_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w \\ {p})", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 250, "tokenPositionInFile": 11684, "theoremPositionInFile": 44}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  refine (mapsTo_rectangleBorder_left_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 174}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_left_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\n", "theoremStatement": "lemma mapsTo_rectangle_right_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w \\ {p})", "fileCreated": "f36a520 20240122", "theoremCreated": "6c9e2b8 20240217", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 255, "tokenPositionInFile": 12038, "theoremPositionInFile": 45}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  refine (mapsTo_rectangleBorder_right_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 3, "proofLengthTokens": 175}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_left_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\n", "theoremStatement": "theorem not_mem_rectangleBorder_of_rectangle_mem_nhds {z w p : \u2102} (hp : Rectangle z w \u2208 \ud835\udcdd p) :\n    p \u2209 RectangleBorder z w", "fileCreated": "f36a520 20240122", "theoremCreated": "2282e1a 20240219", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 260, "tokenPositionInFile": 12394, "theoremPositionInFile": 46}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  refine Set.disjoint_right.mp (rectangleBorder_disjoint_singleton ?_) rfl\n  have h1 := rectangle_mem_nhds_iff.mp hp\n  exact \u27e8Set.ne_left_of_mem_uIoo h1.1, Set.ne_right_of_mem_uIoo h1.1,\n    Set.ne_left_of_mem_uIoo h1.2, Set.ne_right_of_mem_uIoo h1.2\u27e9", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 5, "proofLengthTokens": 254}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_left_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\ntheorem not_mem_rectangleBorder_of_rectangle_mem_nhds {z w p : \u2102} (hp : Rectangle z w \u2208 \ud835\udcdd p) :\n    p \u2209 RectangleBorder z w := by\n  refine Set.disjoint_right.mp (rectangleBorder_disjoint_singleton ?_) rfl\n  have h1 := rectangle_mem_nhds_iff.mp hp\n  exact \u27e8Set.ne_left_of_mem_uIoo h1.1, Set.ne_right_of_mem_uIoo h1.1,\n    Set.ne_left_of_mem_uIoo h1.2, Set.ne_right_of_mem_uIoo h1.2\u27e9\n\n", "theoremStatement": "theorem Complex.nhds_hasBasis_square (p : \u2102) : (\ud835\udcdd p).HasBasis (0 < \u00b7) (Square p \u00b7)", "fileCreated": "f36a520 20240122", "theoremCreated": "f1c959f 20240220", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 267, "tokenPositionInFile": 12776, "theoremPositionInFile": 47}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  suffices (\ud835\udcdd p.re \u00d7\u02e2 \ud835\udcdd p.im).HasBasis (0 < .) (equivRealProdCLM.symm.toHomeomorph \u207b\u00b9' Square p .)\n    by simpa only [\u2190 nhds_prod_eq, Homeomorph.map_nhds_eq, Homeomorph.image_preimage]\n      using this.map equivRealProdCLM.symm.toHomeomorph\n  apply ((nhds_basis_Icc_pos p.re).prod_same_index_mono (nhds_basis_Icc_pos p.im) ?_ ?_).congr\n  \u00b7 intro; rfl\n  \u00b7 intros\n    rw [\u2190 uIcc_of_lt (by linarith), \u2190 uIcc_of_lt (by linarith)]\n    simpa [Square, Rectangle] using by ring_nf\n  all_goals exact (antitone_const_tsub.Icc (monotone_id.const_add _)).monotoneOn _", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 10, "proofLengthTokens": 558}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_left_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\ntheorem not_mem_rectangleBorder_of_rectangle_mem_nhds {z w p : \u2102} (hp : Rectangle z w \u2208 \ud835\udcdd p) :\n    p \u2209 RectangleBorder z w := by\n  refine Set.disjoint_right.mp (rectangleBorder_disjoint_singleton ?_) rfl\n  have h1 := rectangle_mem_nhds_iff.mp hp\n  exact \u27e8Set.ne_left_of_mem_uIoo h1.1, Set.ne_right_of_mem_uIoo h1.1,\n    Set.ne_left_of_mem_uIoo h1.2, Set.ne_right_of_mem_uIoo h1.2\u27e9\n\ntheorem Complex.nhds_hasBasis_square (p : \u2102) : (\ud835\udcdd p).HasBasis (0 < \u00b7) (Square p \u00b7) := by\n  suffices (\ud835\udcdd p.re \u00d7\u02e2 \ud835\udcdd p.im).HasBasis (0 < .) (equivRealProdCLM.symm.toHomeomorph \u207b\u00b9' Square p .)\n    by simpa only [\u2190 nhds_prod_eq, Homeomorph.map_nhds_eq, Homeomorph.image_preimage]\n      using this.map equivRealProdCLM.symm.toHomeomorph\n  apply ((nhds_basis_Icc_pos p.re).prod_same_index_mono (nhds_basis_Icc_pos p.im) ?_ ?_).congr\n  \u00b7 intro; rfl\n  \u00b7 intros\n    rw [\u2190 uIcc_of_lt (by linarith), \u2190 uIcc_of_lt (by linarith)]\n    simpa [Square, Rectangle] using by ring_nf\n  all_goals exact (antitone_const_tsub.Icc (monotone_id.const_add _)).monotoneOn _\n\n", "theoremStatement": "lemma square_mem_nhds (p : \u2102) {c : \u211d} (hc : c \u2260 0) :\n    Square p c \u2208 \ud835\udcdd p", "fileCreated": "f36a520 20240122", "theoremCreated": "1d47e66 20240219", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 278, "tokenPositionInFile": 13422, "theoremPositionInFile": 48}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  wlog hc_pos : 0 < c generalizing c with h\n  \u00b7 rw [\u2190 square_neg]\n    exact h (neg_ne_zero.mpr hc) <| neg_pos.mpr <| hc.lt_of_le <| not_lt.mp hc_pos\n  exact (nhds_hasBasis_square p).mem_of_mem hc_pos", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 5, "proofLengthTokens": 202}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_left_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\ntheorem not_mem_rectangleBorder_of_rectangle_mem_nhds {z w p : \u2102} (hp : Rectangle z w \u2208 \ud835\udcdd p) :\n    p \u2209 RectangleBorder z w := by\n  refine Set.disjoint_right.mp (rectangleBorder_disjoint_singleton ?_) rfl\n  have h1 := rectangle_mem_nhds_iff.mp hp\n  exact \u27e8Set.ne_left_of_mem_uIoo h1.1, Set.ne_right_of_mem_uIoo h1.1,\n    Set.ne_left_of_mem_uIoo h1.2, Set.ne_right_of_mem_uIoo h1.2\u27e9\n\ntheorem Complex.nhds_hasBasis_square (p : \u2102) : (\ud835\udcdd p).HasBasis (0 < \u00b7) (Square p \u00b7) := by\n  suffices (\ud835\udcdd p.re \u00d7\u02e2 \ud835\udcdd p.im).HasBasis (0 < .) (equivRealProdCLM.symm.toHomeomorph \u207b\u00b9' Square p .)\n    by simpa only [\u2190 nhds_prod_eq, Homeomorph.map_nhds_eq, Homeomorph.image_preimage]\n      using this.map equivRealProdCLM.symm.toHomeomorph\n  apply ((nhds_basis_Icc_pos p.re).prod_same_index_mono (nhds_basis_Icc_pos p.im) ?_ ?_).congr\n  \u00b7 intro; rfl\n  \u00b7 intros\n    rw [\u2190 uIcc_of_lt (by linarith), \u2190 uIcc_of_lt (by linarith)]\n    simpa [Square, Rectangle] using by ring_nf\n  all_goals exact (antitone_const_tsub.Icc (monotone_id.const_add _)).monotoneOn _\n\nlemma square_mem_nhds (p : \u2102) {c : \u211d} (hc : c \u2260 0) :\n    Square p c \u2208 \ud835\udcdd p := by\n  wlog hc_pos : 0 < c generalizing c with h\n  \u00b7 rw [\u2190 square_neg]\n    exact h (neg_ne_zero.mpr hc) <| neg_pos.mpr <| hc.lt_of_le <| not_lt.mp hc_pos\n  exact (nhds_hasBasis_square p).mem_of_mem hc_pos\n\n", "theoremStatement": "lemma square_subset_square {p : \u2102} {c\u2081 c\u2082 : \u211d} (hc\u2081 : 0 < c\u2081) (hc : c\u2081 \u2264 c\u2082) :\n    Square p c\u2081 \u2286 Square p c\u2082", "fileCreated": "f36a520 20240122", "theoremCreated": "e9707cc 20240220", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 285, "tokenPositionInFile": 13703, "theoremPositionInFile": 49}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  apply RectSubRect' <;> simpa using by linarith", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 2, "proofLengthTokens": 51}}
{"srcContext": "import Mathlib.Analysis.Complex.CauchyIntegral\nimport Mathlib.Analysis.Complex.Convex\n\nopen Complex Set Topology\n\nopen scoped Interval\n\nvariable {z w : \u2102} {c : \u211d}\n\n/-%%\nThis files gathers definitions and basic properties about rectangles.\n%%-/\n\n/-%%\n\\begin{definition}\\label{Rectangle}\\lean{Rectangle}\\leanok\nA Rectangle has corners $z$ and $w \\in \\C$.\n\\end{definition}\n%%-/\n/- A `Rectangle` has corners `z` and `w`. -/\ndef Rectangle (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]\n\nnamespace Rectangle\n\nlemma symm : Rectangle z w = Rectangle w z := by\n  simp [Rectangle, uIcc_comm]\n\nlemma symm_re : Rectangle (w.re + z.im * I) (z.re + w.im * I) = Rectangle z w := by\n  simp [Rectangle, uIcc_comm]\n\nend Rectangle\n\n/-%%\nThe border of a rectangle is the union of its four sides.\n\\begin{definition}[RectangleBorder]\\label{RectangleBorder}\\lean{RectangleBorder}\\leanok\nA Rectangle's border, given corners $z$ and $w$ is the union of the four sides.\n\\end{definition}\n%%-/\n/- A `RectangleBorder` has corners `z` and `w`. -/\ndef RectangleBorder (z w : \u2102) : Set \u2102 := [[z.re, w.re]] \u00d7\u2102 {z.im} \u222a {z.re} \u00d7\u2102 [[z.im, w.im]] \u222a [[z.re, w.re]] \u00d7\u2102 {w.im} \u222a {w.re} \u00d7\u2102 [[z.im, w.im]]\n\ndef Square (p : \u2102) (c : \u211d) : Set \u2102 := Rectangle (-c - c * I + p) (c + c * I + p)\n\nlemma Square_apply (p : \u2102) (cpos : c > 0) :\n    Square p c = Icc (-c + p.re) (c + p.re) \u00d7\u2102 Icc (-c + p.im) (c + p.im) := by\n  rw [Square, Rectangle, uIcc_of_le (by simp; linarith), uIcc_of_le (by simp; linarith)]\n  simp\n\n-- From PR #9598\n/- The preimage under `equivRealProd` of `s \u00d7\u02e2 t` is `s \u00d7\u2102 t`. -/\nlemma preimage_equivRealProd_prod (s t : Set \u211d) : equivRealProd \u207b\u00b9' (s \u00d7\u02e2 t) = s \u00d7\u2102 t := rfl\n\n@[simp]\ntheorem preimage_equivRealProdCLM_reProdIm (s t : Set \u211d) :\n    equivRealProdCLM.symm \u207b\u00b9' (s \u00d7\u2102 t) = s \u00d7\u02e2 t :=\n  rfl\n\n@[simp]\ntheorem ContinuousLinearEquiv.coe_toLinearEquiv_symm {R : Type*} {S : Type*} [Semiring R] [Semiring S] {\u03c3 : R \u2192+* S}\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] {M\u2082 : Type*} [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] (e : M \u2243SL[\u03c3] M\u2082) :\n    \u21d1e.toLinearEquiv.symm = e.symm :=\n  rfl\n\n-- From PR #9598\n/- The inequality `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` holds in `\u2102` iff it holds in `\u211d \u00d7 \u211d`. -/\nlemma reProdIm_subset_iff {s s\u2081 t t\u2081 : Set \u211d} : s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 := by\n  simp_rw [\u2190 preimage_equivRealProd_prod, equivRealProd.preimage_subset]\n\n-- From PR #9598\n/- If `s \u2286 s\u2081 \u2286 \u211d` and `t \u2286 t\u2081 \u2286 \u211d`, then `s \u00d7 t \u2286 s\u2081 \u00d7 t\u2081` in `\u2102`. -/\nlemma reProdIm_subset_iff' {s s\u2081 t t\u2081 : Set \u211d} :\n    s \u00d7\u2102 t \u2286 s\u2081 \u00d7\u2102 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 :=\n  reProdIm_subset_iff.trans prod_subset_prod_iff\n\n/- The axis-parallel complex rectangle with opposite corners `z` and `w` is complex product\n  of two intervals, which is also the convex hull of the four corners. Golfed from mathlib4\\#9598.-/\nlemma segment_reProdIm_segment_eq_convexHull (z w : \u2102) :\n    [[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]] = convexHull \u211d {z, z.re + w.im * I, w.re + z.im * I, w} := by\n  simp_rw [\u2190 segment_eq_uIcc, \u2190 convexHull_pair, \u2190 convexHull_reProdIm, reProdIm]\n  exact congrArg _ <| Set.ext <| by simpa [Complex.ext_iff] using by tauto\n\n/- If the four corners of a rectangle are contained in a convex set `U`, then the whole\n  rectangle is. Golfed from mathlib4\\#9598.-/\nlemma rectangle_in_convex {U : Set \u2102} (U_convex : Convex \u211d U) {z w : \u2102} (hz : z \u2208 U)\n    (hw : w \u2208 U) (hzw : (z.re + w.im * I) \u2208 U) (hwz : (w.re + z.im * I) \u2208 U) :\n    Rectangle z w \u2286 U := by\n  rw [Rectangle, segment_reProdIm_segment_eq_convexHull]\n  exact convexHull_min (by simp_all [insert_subset_iff]) U_convex\n\nlemma mem_Rect {z w : \u2102} (zRe_lt_wRe : z.re \u2264 w.re) (zIm_lt_wIm : z.im \u2264 w.im) (p : \u2102) :\n    p \u2208 Rectangle z w \u2194 z.re \u2264 p.re \u2227 p.re \u2264 w.re \u2227 z.im \u2264 p.im \u2227 p.im \u2264 w.im := by\n  rw [Rectangle, uIcc_of_le zRe_lt_wRe, uIcc_of_le zIm_lt_wIm]\n  exact and_assoc\n\nlemma square_neg (p : \u2102) (c : \u211d) : Square p (-c) = Square p c := by\n  simpa [Square] using Rectangle.symm\n\ndef Set.uIoo {\u03b1 : Type*} [Lattice \u03b1] (a b : \u03b1) : Set \u03b1 := Ioo (a \u2293 b) (a \u2294 b)\n\n@[simp]\ntheorem uIoo_of_le {\u03b1 : Type*} [Lattice \u03b1] {a b : \u03b1} (h : a \u2264 b) : Set.uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\ntheorem Set.left_not_mem_uIoo {a b : \u211d} : a \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (left_lt_sup.mp h2) (le_of_not_le (inf_lt_left.mp h1))\n\ntheorem Set.right_not_mem_uIoo {a b : \u211d} : b \u2209 Set.uIoo a b :=\n  fun \u27e8h1, h2\u27e9 \u21a6 (right_lt_sup.mp h2) (le_of_not_le (inf_lt_right.mp h1))\n\ntheorem Set.ne_left_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 a :=\n  fun h \u21a6 Set.left_not_mem_uIoo (h \u25b8 hc)\n\ntheorem Set.ne_right_of_mem_uIoo {a b c : \u211d} (hc : c \u2208 Set.uIoo a b) : c \u2260 b :=\n  fun h \u21a6 Set.right_not_mem_uIoo (h \u25b8 hc)\n\nlemma left_mem_rect (z w : \u2102) : z \u2208 Rectangle z w := \u27e8left_mem_uIcc, left_mem_uIcc\u27e9\n\nlemma right_mem_rect (z w : \u2102) : w \u2208 Rectangle z w := \u27e8right_mem_uIcc, right_mem_uIcc\u27e9\n\nlemma rect_subset_iff {z w z' w' : \u2102} :\n    Rectangle z' w' \u2286 Rectangle z w \u2194 z' \u2208 Rectangle z w \u2227 w' \u2208 Rectangle z w := by\n  use fun h \u21a6 \u27e8h (left_mem_rect z' w'), h (right_mem_rect z' w')\u27e9\n  intro \u27e8\u27e8\u27e8hz're_ge, hz're_le\u27e9, \u27e8hz'im_ge, hz'im_le\u27e9\u27e9,\n    \u27e8\u27e8hw're_ge, hw're_le\u27e9, \u27e8hw'im_ge, hw'im_le\u27e9\u27e9\u27e9 x \u27e8\u27e8hxre_ge, hxre_le\u27e9, \u27e8hxim_ge, hxim_le\u27e9\u27e9\n  refine \u27e8\u27e8?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 exact (le_inf hz're_ge hw're_ge).trans hxre_ge\n  \u00b7 exact (le_sup_iff.mp hxre_le).casesOn (fun h \u21a6 h.trans hz're_le) (fun h \u21a6 h.trans hw're_le)\n  \u00b7 exact (le_inf hz'im_ge hw'im_ge).trans hxim_ge\n  \u00b7 exact (le_sup_iff.mp hxim_le).casesOn (fun h \u21a6 h.trans hz'im_le) (fun h \u21a6 h.trans hw'im_le)\n\nlemma RectSubRect {x\u2080 x\u2081 x\u2082 x\u2083 y\u2080 y\u2081 y\u2082 y\u2083 : \u211d} (x\u2080_le_x\u2081 : x\u2080 \u2264 x\u2081) (x\u2081_le_x\u2082 : x\u2081 \u2264 x\u2082)\n    (x\u2082_le_x\u2083 : x\u2082 \u2264 x\u2083) (y\u2080_le_y\u2081 : y\u2080 \u2264 y\u2081) (y\u2081_le_y\u2082 : y\u2081 \u2264 y\u2082) (y\u2082_le_y\u2083 : y\u2082 \u2264 y\u2083) :\n    Rectangle (x\u2081 + y\u2081 * I) (x\u2082 + y\u2082 * I) \u2286 Rectangle (x\u2080 + y\u2080 * I) (x\u2083 + y\u2083 * I) := by\n  rw [rect_subset_iff, mem_Rect, mem_Rect]\n  refine \u27e8\u27e8?_, ?_, ?_, ?_\u27e9, ?_, ?_, ?_, ?_\u27e9\n  all_goals simpa using by linarith\n\nlemma RectSubRect' {z\u2080 z\u2081 z\u2082 z\u2083 : \u2102} (x\u2080_le_x\u2081 : z\u2080.re \u2264 z\u2081.re) (x\u2081_le_x\u2082 : z\u2081.re \u2264 z\u2082.re)\n    (x\u2082_le_x\u2083 : z\u2082.re \u2264 z\u2083.re) (y\u2080_le_y\u2081 : z\u2080.im \u2264 z\u2081.im) (y\u2081_le_y\u2082 : z\u2081.im \u2264 z\u2082.im)\n    (y\u2082_le_y\u2083 : z\u2082.im \u2264 z\u2083.im) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 := by\n  rw [\u2190 re_add_im z\u2080, \u2190 re_add_im z\u2081, \u2190 re_add_im z\u2082, \u2190 re_add_im z\u2083]\n  exact RectSubRect x\u2080_le_x\u2081 x\u2081_le_x\u2082 x\u2082_le_x\u2083 y\u2080_le_y\u2081 y\u2081_le_y\u2082 y\u2082_le_y\u2083\n\nlemma rectangleBorder_subset_rectangle (z w : \u2102) : RectangleBorder z w \u2286 Rectangle z w := by\n  intro x hx\n  obtain \u27e8\u27e8h | h\u27e9 | h\u27e9 | h := hx\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 left_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 left_mem_uIcc, h.2\u27e9\n  \u00b7 exact \u27e8h.1, h.2 \u25b8 right_mem_uIcc\u27e9\n  \u00b7 exact \u27e8h.1 \u25b8 right_mem_uIcc, h.2\u27e9\n\n/- Note: try using `by simp` for `h`. -/\nlemma rectangle_disjoint_singleton {z w p : \u2102}\n    (h : (p.re < z.re \u2227 p.re < w.re) \u2228 (p.im < z.im \u2227 p.im < w.im) \u2228\n      (z.re < p.re \u2227 w.re < p.re) \u2228 (z.im < p.im \u2227 w.im < p.im)) :\n    Disjoint (Rectangle z w) {p} := by\n  refine disjoint_singleton_right.mpr (not_and_or.mpr ?_)\n  obtain h | h | h | h := h\n  \u00b7 exact Or.inl (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_lt h.1 h.2)\n  \u00b7 exact Or.inl (not_mem_uIcc_of_gt h.1 h.2)\n  \u00b7 exact Or.inr (not_mem_uIcc_of_gt h.1 h.2)\n\nlemma rectangleBorder_disjoint_singleton {z w p : \u2102}\n    (h : p.re \u2260 z.re \u2227 p.re \u2260 w.re \u2227 p.im \u2260 z.im \u2227 p.im \u2260 w.im) :\n    Disjoint (RectangleBorder z w) {p} := by\n  refine disjoint_singleton_right.mpr ?_\n  simp_rw [RectangleBorder, Set.mem_union, not_or]\n  exact \u27e8\u27e8\u27e8fun hc \u21a6 h.2.2.1 hc.2, fun hc \u21a6 h.1 hc.1\u27e9, fun hc \u21a6 h.2.2.2 hc.2\u27e9, fun hc \u21a6 h.2.1 hc.1\u27e9\n\nlemma rectangle_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : (p.re < z\u2081.re \u2227 p.re < z\u2082.re) \u2228 (p.im < z\u2081.im \u2227 p.im < z\u2082.im) \u2228\n      (z\u2081.re < p.re \u2227 z\u2082.re < p.re) \u2228 (z\u2081.im < p.im \u2227 z\u2082.im < p.im)) :\n    Rectangle z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8by apply RectSubRect' <;> tauto, rectangle_disjoint_singleton hp\u27e9\n\nlemma rectangleBorder_subset_punctured_rect {z\u2080 z\u2081 z\u2082 z\u2083 p : \u2102}\n    (hz : z\u2080.re \u2264 z\u2081.re \u2227 z\u2081.re \u2264 z\u2082.re \u2227 z\u2082.re \u2264 z\u2083.re \u2227\n      z\u2080.im \u2264 z\u2081.im \u2227 z\u2081.im \u2264 z\u2082.im \u2227 z\u2082.im \u2264 z\u2083.im)\n    (hp : p.re \u2260 z\u2081.re \u2227 p.re \u2260 z\u2082.re \u2227 p.im \u2260 z\u2081.im \u2227 p.im \u2260 z\u2082.im) :\n    RectangleBorder z\u2081 z\u2082 \u2286 Rectangle z\u2080 z\u2083 \\ {p} :=\n  Set.subset_diff.mpr \u27e8\n    (rectangleBorder_subset_rectangle _ _).trans (by apply RectSubRect' <;> tauto),\n    rectangleBorder_disjoint_singleton hp\u27e9\n\nlemma rectangle_mem_nhds_iff {z w p : \u2102} : Rectangle z w \u2208 \ud835\udcdd p \u2194\n    p \u2208 (Set.uIoo z.re w.re) \u00d7\u2102 (Set.uIoo z.im w.im) := by\n  simp_rw [\u2190 mem_interior_iff_mem_nhds, Rectangle, Complex.interior_reProdIm, uIoo, uIcc, interior_Icc]\n\n/- A real segment `[a\u2081, a\u2082]` translated by `b * I` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma horizontalSegment_eq (a\u2081 a\u2082 b : \u211d) :\n    (fun (x : \u211d) \u21a6 x + b * I) '' [[a\u2081, a\u2082]] = [[a\u2081, a\u2082]] \u00d7\u2102 {b} :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\n/- A vertical segment `[b\u2081, b\u2082]` translated by `a` is the complex line segment.\nGolfed from mathlib\\#9598.-/\nlemma verticalSegment_eq (a b\u2081 b\u2082 : \u211d) :\n    (fun (y : \u211d) \u21a6 a + y * I) '' [[b\u2081, b\u2082]] = {a} \u00d7\u2102 [[b\u2081, b\u2082]] :=\n  Set.ext fun _ => \u27e8fun hx \u21a6 hx.casesOn fun _ \u27e8_, hx\u27e9 \u21a6 by simpa [\u2190 hx, reProdIm],\n    fun hx \u21a6 hx.casesOn (by simp_all [Complex.ext_iff])\u27e9\n\nlemma mapsTo_rectangle_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp, by simp [hx]\u27e9\n\nlemma mapsTo_rectangle_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangle_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w) :=\n  fun _ hx \u21a6 \u27e8by simp [hx], by simp\u27e9\n\nlemma mapsTo_rectangleBorder_left_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_re (z w : \u2102) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [verticalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_left_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangleBorder_right_im (z w : \u2102) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (RectangleBorder z w) :=\n  (Set.mapsTo_image _ _).mono subset_rfl fun _ \u21a6 by simp_all [horizontalSegment_eq, RectangleBorder]\n\nlemma mapsTo_rectangle_left_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191z.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_re_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (y : \u211d) => \u2191w.re + \u2191y * I) [[z.im, w.im]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_re z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_left_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + z.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_left_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\nlemma mapsTo_rectangle_right_im_NoP (z w : \u2102) {p : \u2102} (pNotOnBorder : p \u2209 RectangleBorder z w) :\n    MapsTo (fun (x : \u211d) => \u2191x + w.im * I) [[z.re, w.re]] (Rectangle z w \\ {p}) := by\n  refine (mapsTo_rectangleBorder_right_im z w).mono_right (Set.subset_diff.mpr ?_)\n  exact \u27e8rectangleBorder_subset_rectangle z w, disjoint_singleton_right.mpr pNotOnBorder\u27e9\n\ntheorem not_mem_rectangleBorder_of_rectangle_mem_nhds {z w p : \u2102} (hp : Rectangle z w \u2208 \ud835\udcdd p) :\n    p \u2209 RectangleBorder z w := by\n  refine Set.disjoint_right.mp (rectangleBorder_disjoint_singleton ?_) rfl\n  have h1 := rectangle_mem_nhds_iff.mp hp\n  exact \u27e8Set.ne_left_of_mem_uIoo h1.1, Set.ne_right_of_mem_uIoo h1.1,\n    Set.ne_left_of_mem_uIoo h1.2, Set.ne_right_of_mem_uIoo h1.2\u27e9\n\ntheorem Complex.nhds_hasBasis_square (p : \u2102) : (\ud835\udcdd p).HasBasis (0 < \u00b7) (Square p \u00b7) := by\n  suffices (\ud835\udcdd p.re \u00d7\u02e2 \ud835\udcdd p.im).HasBasis (0 < .) (equivRealProdCLM.symm.toHomeomorph \u207b\u00b9' Square p .)\n    by simpa only [\u2190 nhds_prod_eq, Homeomorph.map_nhds_eq, Homeomorph.image_preimage]\n      using this.map equivRealProdCLM.symm.toHomeomorph\n  apply ((nhds_basis_Icc_pos p.re).prod_same_index_mono (nhds_basis_Icc_pos p.im) ?_ ?_).congr\n  \u00b7 intro; rfl\n  \u00b7 intros\n    rw [\u2190 uIcc_of_lt (by linarith), \u2190 uIcc_of_lt (by linarith)]\n    simpa [Square, Rectangle] using by ring_nf\n  all_goals exact (antitone_const_tsub.Icc (monotone_id.const_add _)).monotoneOn _\n\nlemma square_mem_nhds (p : \u2102) {c : \u211d} (hc : c \u2260 0) :\n    Square p c \u2208 \ud835\udcdd p := by\n  wlog hc_pos : 0 < c generalizing c with h\n  \u00b7 rw [\u2190 square_neg]\n    exact h (neg_ne_zero.mpr hc) <| neg_pos.mpr <| hc.lt_of_le <| not_lt.mp hc_pos\n  exact (nhds_hasBasis_square p).mem_of_mem hc_pos\n\nlemma square_subset_square {p : \u2102} {c\u2081 c\u2082 : \u211d} (hc\u2081 : 0 < c\u2081) (hc : c\u2081 \u2264 c\u2082) :\n    Square p c\u2081 \u2286 Square p c\u2082 := by\n  apply RectSubRect' <;> simpa using by linarith\n\n", "theoremStatement": "lemma SmallSquareInRectangle {z w p : \u2102} (pInRectInterior : Rectangle z w \u2208 nhds p) :\n    \u2200\u1da0 (c : \u211d) in \ud835\udcdd[>]0, Square p c \u2286 Rectangle z w", "fileCreated": "f36a520 20240122", "theoremCreated": "f887328 20240215", "file": "PrimeNumberTheoremAnd/Rectangle.lean", "positionMetadata": {"lineInFile": 289, "tokenPositionInFile": 13868, "theoremPositionInFile": 50}, "definitionMetadata": {"inFileDefinitions": true, "libraryDefinitions": true, "repositoryDefinitions": false}, "proofMetadata": {"hasProof": true, "proof": "by\n  obtain \u27e8\u03b5, h\u03b50, h\u03b5\u27e9 := ((Complex.nhds_hasBasis_square p).1 _).mp pInRectInterior\n  filter_upwards [Ioo_mem_nhdsWithin_Ioi' (h\u03b50)] with _ \u27e8h\u03b5'0, h\u03b5'\u27e9\n  exact subset_trans (square_subset_square h\u03b5'0 h\u03b5'.le) h\u03b5", "proofType": "tactic", "inFileTheoremsInProof": true, "repositoryTheoremsInProof": false, "proofLengthLines": 4, "proofLengthTokens": 212}}
